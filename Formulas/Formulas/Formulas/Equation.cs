//=Refer to ERROR123234 for problem.                                                               =
//=For Correct ERROR123234 Refer to ERROR125487.For Localization ERROR123234 Refer To ERROR124576 .=
//=ERROR Permanently removed and problem solved.                                                   =
//=For Correction Detailes refer to CORRECTION157398                                               =
//==================================================================================================
//Refer to ERROR560364 .The Number boolean value dose not set to true when it is true.             =
//The ERROR560364 Correct.Refer To CORRECTION12456                                                 =
//==================================================================================================
//Error of Set Link list Setting Dimension Calculation. Refer To ERROR12769034 For Error Description.
//One Possible Cause is from ERROR560364.So correction of ERROR560364 Correct ERROR12769034.
//ERRORCORRECTION13475:One cuase is to not be Independence on left side.
//There is already error.
//==================================================================================================
//Refer to ERROR760967.The problem is not set correctly in Recursive Method.
//==================================================================================================
//Impossible condition :ERROR28365876234
//ERRORCORRECTION236587 :Conver one of number to independence.
//==================================================================================================
// ERROR45768905 .The condition is not done never.
//==================================================================================================
//ERROR56289087 : The Writiing operation is right to left.it is becuase of Setting Error.
//==================================================================================================
//BackArtiAritArit143
//==================================================================================================
//ERROR2309890 :Error on XAccessLocation.
//ERRORRCORRECTION2409879 :IncreaSing Power return value to 30 and add a first 
//Arithmatic operator.
//==================================================================================================
//ERROR239856 : When The x should be entered it dose not work.
// ERROR43713501 :on Page 78 it illustrate
//==================================================================================================
//ERROR23659008 :Error on XY Calculation .refer to Page 79
//For More information refer to page 80 (next task)
//==================================================================================================
//ERROR12875646 .ERROR IN power node of elements.
//==================================================================================================
//ERROR4586203 : the Second argument was not valid.
//ERRORCORRECTION1287657 :the Second argument correct by proper parameter.
//==================================================================================================
//ERROR75875123 : On Third argument
//ERRORCORRECTION1276548 : The parameters of third argument correct.
//ERROR23746872365 : when the number is and the condition of all is arithmatics the Errorcorrect.
//ERRORCORRECTION987248623: When the current is numbr or independence.
//==================================================================================================                            
//ERROR87096587 :page 84
//ERRORCORECTION87908906 : The XAccessLocation method.
//==================================================================================================                            
//Invisible189264876214
//Visible17264387
//==================================================================================================                            
//ERROR982374893275 :The left side and the right side is not calculated correctly.
//ERRORCORECTION98214 :the left and right side set correctly.
//==================================================================================================                            
//ERROR1254317892 :Refer to page 85
//==================================================================================================                            
//ERROR1234175609 :Error on structure page85
//==================================================================================================                            
//ERROR1826432164 :(error lead)Refer to page 85
//ERRORCORECTION786543679086 : if let side is empty do this else do else. refre to AddToTree namespace
//==================================================================================================                            
//ERROR7809678905 : Error on data structure.
//==================================================================================================                            
//ERRORXT1037 : the parantez is like a number.
//ERRORCORECTION89764567 :The condition of being parantez added
//ERORRCORECTION78JDLK981274 :Editing
//ERRORCORECTION8709218746872 :Adding new statments
//CONDITION7135 :for first Argumnet Sample.
//ERRORCORRCTION789856345676 : changing properly left ad right side arguments
//ERRORCORECTION5687345980 :Th condition was added.
//ERROR73425273 :The RightSiodeLast is null.
//EROROCORRECTION74523274XA :x should stores and when "+" will comes add to tree.
//ERROR345678567MCD98 :The Function Dose not found.
//ERORRCORECTION878919274872 :The number extend to number and variable.
//ERORRCORECTION678901297349814CXS :The above satatment replaced by below statment.refer to page 92.(**)
//LOCATION678976509467 :The page 93 request.
//ERORRCORECTION890758746789 :The Last Sample of Parantez Closeed.
//==================================================================================================                            
//ERROR2734527363 :te argument dose not work.
//==================================================================================================                            
//ERRORCORECTION870957834 :For changing the function Argumnet.refer to page 94.
//==================================================================================================                            
//ERROR73423753 :the function dosnot effect when there is.
//==================================================================================================                            
//ERROR7342517321 :Why the argument isn't drawn? Refer to page 95.
//==================================================================================================                            
//ERRORCORECTION8798689056 : The Right argumnet the (Division) Reduced from Displacement.refer to page 96
//==================================================================================================                            
//ERROR34567957879087124 :When the rightside is a division operator this is not suitable.
//ERRORCORECTION34569856789 :The condition is added.
//==================================================================================================                            
//ERROR7809567845678090 : The parantez location is not correct.
//ERRORCORECTION7719827489273 :The y value is set.
//ERROR45970478905 : the parantez dose not correctly write. The calculation misurement dos not completly doen.
//refer above.
//ERRORCORECTION43760958747 : By reference variable and located the drawing parantez here(signed) the parantez draw corectly.refer to page 96
//==================================================================================================                            
//ERROR456790358754 :ERROR when tow argument are on function (tow function inerr) refer to page 96
//==================================================================================================                            
//ERROR76094896096948 :The value of Cos function dose not calculated. refer to page 97 .
//==================================================================================================                            
//ERROR34095780976 :  When The Opened Parantez Clicked Nothing Oeccued.refer to page 98.
//ERRORCORECTION78290374987234 :The ERROR34095780976 Correction.
//==================================================================================================                            
//ERROR73425362 : The "(" Sample is like a number.
//ERRORCORECTION896709487 : it is like a number ERROR73425362.The problem solved.
//==================================================================================================                            
//ERROR34534253 : Cuase to an infinite loop.
//ERRORCORECTION785606847 :The Error Corect.refer to page 99.
//==================================================================================================                            
//ERROR63729387549 :The quality is not valid.refer to page 100.                                              
//ERROR76293874 :When it recived to this node the calculatingXAndTY... Method X Calculate the child of this node incorectly.
//==================================================================================================                            
//ERRORCORECTION892174982374 :The condition is added.
//==================================================================================================                            
//ERROR928375 :Condition needed.
//ERRORCORECTION98127498234 :The Condition adedd.           
//==================================================================================================                                                   
//ERROR3572425332 :The condition is not allowed.refere to page 101.
//ERROR35724231 :The XAccessLocation Method dose not any effect.
//ERRORCORECTION1982748921374 :Corection  of ERROR35724231 and ERROR3572425332 .refer to page 101.The consdition is function calculated.
//ERROR76982147982347 :value is not calculated corectly.page 101.
//ERRORCORECTION7981248 :The ERROR76982147982347 Corrected.
//==================================================================================================                                                   
//ERROR3453276 :refer to page 101.
//==================================================================================================                                                   
//ERROR31725 :refer to page 102.
//==================================================================================================                                                   
//ERROR35724342 : Dose not any effect.refer to page 102.
//==================================================================================================                                                   
//ERROR92834798234 :The strucure on base node is correctly but on local variable is not true.refer to page 103.
//==================================================================================================                                                   
//ERRORCORECTION0927498 :The Optimizing strucure will be added.
//***==================================================================================================                                                   
//ERROR0921384 :The Value setting is incorectly.The XAccessLocation Method is calculted incorectly.refere to page 104.
//ERRORCORECTION31574213 :Should correct.
//ERROR317241 :The XAccessLocation() Calculate incorrectly.refer to page 104.
//==================================================================================================                                                   
//ERROR35417230 :The Curent pow and the left and right side arithmatics is exist on this method but the 
// The graphically structure of tree has no right side (2) element of "^" current node.refer to page 105.
//ERRORCUASE8967 Of ERROR35417230 :The base strucure has no element of "2" right side of "^" current node.
//==================================================================================================                                                   
//ERRORCORECTION9821748 :The Error is constructed.The value is optimized.refer top page 105.
//==================================================================================================                                                   
//ERROR31724215 :The Right side is incorectly valued.refer to page 105.
//==================================================================================================                                                   
//ERROR31724215 :The Right side of current node (+) is valued incorectly.
//ERRORCORECTION189264 :The value set corectly.
//==================================================================================================                                                   
//ERORR317215 :The right side node of "^" node is set valued incorectly.refer top apge 106.
//ERORRCORECTION1238 :The right side node of "^" node set valued corectly.
//==================================================================================================                                                   
//ERROR41527231 :The lenght of number is not token.and the value of Second Method is Not set correctly.refer to page 106.
//ERRORCORRECTION8237427231 :The lenght of number is set.and the value of Second Method is  set correctly.
//==================================================================================================                                                   
//ERRORCORECTION8756 :The Shift when needed.refer to page 106.                                                             
//==================================================================================================                                                   
//ERROR531724125 :The Value is not valid.
//ERRORCORECTION509238749 :The Value is valid.refer to page 106.
//==================================================================================================                                                   
//ERRORCORECTION98238 :The Power value is constructed.refer to page 107.
//==================================================================================================                                                   
//ERRORCORECTION9098218238 :The Function value is constructed and added.     
//==================================================================================================                                                   
//ERROR3171154210 : Error is the far disTance between strings.refer to page 107.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              
//==================================================================================================                                                   
//ERROR987324 :The Current.ThreadAccess. is null and The null exeption Occeres.
//this.CalculatingXAndYAndWhithAndHeight(Current.LeftSideAccess, Current.ThreadAccess.XAccess + this.XAccessLocation(Current.LeftSideAccess.LeftSideAccess, x) + 15, y, 15, 15, false);
//ERRORCORECTION31724152 :The Error is corected.refer to page 107.
//==================================================================================================                                                                                    
//ERROR41723150 :The structure is invalid.rfer to page 108.
//==================================================================================================                                                                                    
//ERROR928375 :The structre is invalid.refer to page 109.
//ERRORCORCTION0192873 :The Correction of ERROR928375.refre to page 109.
//==================================================================================================                                                                                    
//ERROR31724152 Tan(x+1)23 .The parantez did not reache to end.
//==================================================================================================                                                                                    
//ERROR124270 :The graphically draw has far disTance.
//==================================================================================================                                                                                    
//ERROR41732145 :The graphically draw is incorect.refer to page 111.
//==================================================================================================                                                                                    
//ERROR514230 :The first method call set value changed.
//==================================================================================================                                                                                    
//TESTNEEDED317125 :refer to page 110.
//==================================================================================================                                                                                    
//ERROR2019348 :The below setting value is incorrect.
//==================================================================================================                                                                                    
//ERROR92874 :by refering to page 112 The right side calculate from here if the condition is getright().getleft().
//==================================================================================================                                                                                    
//ERROR311421 :The only ERROR is the far disTance between some strings.
//==================================================================================================                                                                                    
//ERROR41725312 :far disTance netween some string and over lap of Last parantez.
//==================================================================================================                                                                                    
//ERROR415210: It seems will be an error at y value setting.
//==================================================================================================                                                                                    
//ERROR30407513 :The error are far disTance between some strings and the y value setting.
//==================================================================================================                                                                                    
//ERROR17412375 :The error are far disTance between some strings and the y value setting.
//==================================================================================================                                                                                    
//ERROR17492834 :The error are far disTance between some strings and the y value setting.
//==================================================================================================                                                                                    
//ERROR40503017 :The error are far disTance between some strings and the y value setting.
//==================================================================================================                                                                                    
//ERROR30715031 :The error are far disTance between some strings and the y value setting.
//==================================================================================================                                                                                    
//ERROR3078796    :The error are far disTance between some strings and the y value setting.
//==================================================================================================                                                                                    
//ERROR307986    :The error are far disTance between some strings and the y value setting.
//==================================================================================================                                                                                    
//ERROR403107 : And has no effect.refer to page 117.
//==================================================================================================                                                                                    
//ERRORBIG17242357 :The thread of nodes dose not set correctly or not set.refer to page 117.
//==================================================================================================                                                                                    
//ERRORCAUSE3172425 :refer to page 118.
//==================================================================================================                                                                                    
//ERROR137256 :Error on strcture refer to page 118.
//==================================================================================================                                                                             
//ERRORCORECTION219347 :refer to  page 118.( ERROR137256 )
//==================================================================================================                                                                                    
//ERRORCORECTION901839 :refer to page 119.
//==================================================================================================                                                                                    
//ERRORCORECTION190187234 :refer to page 119.
//==================================================================================================                                                                                    
//ERRORCORECTION29834 : refer to page 119.
//==================================================================================================                                                                                    
//ERROR87124 :refer to page 120.
//==================================================================================================                                                                                    
//ERRORCORECTION1092387093 :The condition added.refer top page 120.
//==================================================================================================                                                                                    
//ERROR40507011 :Error is already existed.refer to page 120.
//==================================================================================================                                                                                    
//ERRORCORECTION1872487 :The GetThread was not valid set.
//==================================================================================================                                                                                    
//ERROR30701573 :Wehn function is on right side the function dose not work.refer to page .
//ERRORCORECTION981273 :The Right side if is and left side is null.
//==================================================================================================                                                                                    
//ERROR34721530 :This method is completly is wrong.refer to page 125.
//ERROR41723110 :refer to page 125.application of this method is wrong.
//ERRORCORECTION12197234 :The location of division condition for the lenght of divisio operator.refer to page 125.           
//ERROR31012634 :The Hieght of diviosn is very large. refer to page 125.
//==================================================================================================                                                                                    
//ERROR317125507013 :refer to page 126.
//ERROR7081235783 :Both of BigestCurrentNodeDivisionGetYUp(...) and BigestCurrentNodeDivisionGetYDown(...) are completly wrong.refr to page 126.
//ERRORCORECTION03840912384 :The y Value Set.refer top page 126
//ERRORCORECTION038409176584 :The y Value Set.refer top page 126                                        
//NOTE1982738 :To Set Lenght of Division Operator.refer to page 126.
//ERRORCORECTION317243 :refer to page 126.
//==================================================================================================                                                                                    
//ERROR1243 :The NOTE1982738 has some invalid Concept.refr to page 126.
//==================================================================================================                                                                                    
//ERROR13725150 :when this method returned the "/" ,widt value was not valid.refer to page 127.
//ERRORCORECTION019238709124 :The condition lead to ERROR13725150 deleted.refer to page 127.
//ERROR81723678 :Cuase of ERROR13725150 .The Line Of division is not drawn corectly.refr top page 127.
//ERRORCORECTION736340574 :the Argumnet was set.refer to page 127.
//==================================================================================================                                                                                    
//ERRORCORECTION679847386  :The y Value of a independence variable is atmost 15 .refer to page 127.
//ERROR3070802113 :The y value has not been correct.refer to page 128.
//==================================================================================================                                                                                    
//ERRORCORECTION6345012948 :Correction Of ERROR3070802113.refer to page 127.
//==================================================================================================                                                                                    
//ERROR307021 :TheError is far disTance between line division and right side nodes(below of line division).
//ERRORCORECTION1897234 :The Some code changed to be corrected.
//==================================================================================================                                                                                            
//ERROR6509705095 :The y value of tow method is invalid.refer to page 128.
//==================================================================================================                                                                                            
//ERROR30704350 :The right side is null.error in structure.refer to page 129.
//ERRORCORECTION5698670946 :Wehn at mosst one node is at right side of division the addition should not be down.
//==================================================================================================                                                                                            
//ERRORCORECTION127609 :The condition leads to invalid operation.refer to page 129.
//==================================================================================================                                                                                            
//ERROR30704123 :The error is invalid set.refer to page 129.
//==================================================================================================                                                                                            
//ERRORCORECTION1276097 :deleting condition leads to error 129.(below if condition).
//==================================================================================================                                                                                            
//ERROR30702150 :error is already exist.refer to page 130.
//==================================================================================================                                                                                            
//ERROR77007 :The problem dose not found.refer to page 130.
//ERRORCORECTION70077030 :Cause of ERROR77007 solved.refer to page 131.
//==================================================================================================                                                                                            
//ERRORCORECTION64740948 :The method has been edited.refer to page 130.
//==================================================================================================                                                                                       
//ERRORCORECTIONNEEDED3107 :In BigestCurrentNodeDivisionGetYUp(..) usage mst call Current.GetLeftSide(..).refer to page 130.
//==================================================================================================                                                                                       
//ERRORANDERRORCORECTION307021 :The condition has been incorected.refer to page 131.
//==================================================================================================                                                                                       
//ERRORCUASE560969 :The Error cause of ERROR3070:The Node Selected Is not correctly Selected.refer to page 133.
//ERRORCORECTION7689 :refer to page 133.
//ERROR3456 :it can not be useul.refer to page 135.
//==================================================================================================                                                                                       
//LOCATION8709 :Below.refer to page 133.
//UNREACHED7890 This statment unreached.refer to page 133.
//==================================================================================================                                                                                       
//ERROR7887 :This leads to error.we call back.
//Might to ERRORCuase1298670 :it may on some locations be unsafty.
//==================================================================================================                                                                                       
//ERROR4070 :Thhere is a rellacement between tow ind or num.refer to page 135.
//ERRORCORECTION978213498 :When Holder become null we use of Treeconstructed.refer to page 135.
//==================================================================================================                                                                                       
//ERROR9801294 :this could npot be usseful.refer to page 135.
//==================================================================================================                                                                                       
//ERRORCORECTION7346 :it seems at each time calling the parantez is tow time increazes and decreament.refer to page 135.
//==================================================================================================                                                                                       
//LOCATION73808 :At here the node pop inneeded.refer to page 135.
//LOCATION739734 :At here the node pop needed.refer to page 135.
//==================================================================================================                                                                                       
//ERROR307080 :refer to page 136.
//==================================================================================================                                                                                       
//ERROR30807507  :The whidth of line is not ok.refer to page 137.
//==================================================================================================                                                                                       
//ERROR30702507 :The x Begining is incorected.refer to page 137.
//==================================================================================================                                                                                       
//ERROR18924 :The y upo and down is incorrected.refer to page 137.
//==================================================================================================                                                                                       
//ERROR307050 :The far disTance long width line.refer to page 137.
//==================================================================================================                                                                                       
//ERROR9812734 :The far disTance line.refr to page 137.
//==================================================================================================                                                                                       
//ERROR987123 :The Right side function is incorrectly set value.refer to page 138.
//==================================================================================================                                                                                       
//ERROR982375 :the line drawn is not set correctly.refer to page 138.
//==================================================================================================                                                                                       
//ERROR9730405077 :The function is near the line.refer to page 138.
//==================================================================================================                                                                                       
//ERROR31754230 :The division was not.refer to page 138.
//ERRORCORECTION124754230 :The condition added.refer to page 138.
//==================================================================================================                                                                                       
//ERROR3040506077 :The dowen is near line.refer to page 138.
//==================================================================================================                                                                                       
//LOCATION82174 :The trace movment .
//==================================================================================================                                                                                       
//ERROR30408034 :The movement charackters fall in structure.
//ERRORCORECTION19274 :the correction of ERROR30408034.refer to page 139.
//==================================================================================================                                                                                       
//ERROR192874984 :In Some Addition of node The Node is not added to current Node.refer to page 139.
//ERRORCORECTION239487 :The Correction of ERROR192874984.refr to page 139.
//ERROR307040 :Cause of ERRORCORECTION239487.refer to page 139.
//ERRORCORECTION30171892 :Errorcorrection of ERROR307040.Convert ADDED.RightSideAccess To ADDED.refer to page 139.
//==================================================================================================                                                                                       
//ERROR30490678 :Enterring To Block Without any neede.refer to page 139.
//ERRORCORECTION1624 :Errorcorrection of ERROR30490678.refer to page 139.
//ERRORCORECTION19284 :the Node is not set.refer to page 140.
//==================================================================================================                                                                                       
//ERRORCORECTION6756980 :refer to page 140.
//==================================================================================================                                                                                       
//ERROR12764 :"Invalid Thread settings.refer to page 140.
//ERROCORECTION317428 :error Corect.refer to page140.
//==================================================================================================                                                                                       
//ERROR1982478 :The x value dose not set correctly.refer to page 141.
//ERRORCORECTION9287498 :the ERROR3070401 Correction.
//==================================================================================================                                                                                       
//ERROR20984098 :The Value of whidth is not set correctly.refer to page 141.
//==================================================================================================                                                                                       
//ERROR901204980 :The Thread is set to node.refer to pag 141.
//ERRORCORCION01823098 :The Power error cuase corection..refer to page 142.
//==================================================================================================                                                                                       
//ERROR28373248754 :The Set X and Y value at Set Structure  is not ok.refer to page 142.
//ERRORCUASE23785 :cause of ERROR28373248754.refer to page 142.
//ERRORCORECTION2428734 : Corection of ERRORCUASE23785.refer top pae 143.
//==================================================================================================                                                                                       
//ERRORCORECTION109824 :The y value set to up.refer to page 143.
//==================================================================================================                                                                                       
//ERROR30701121 :some times The equation is set graphically wrong.refer to page 143.
//==================================================================================================                                                                                       
//ERROR912874 :Refer to page 143.
//==================================================================================================                                                                                       
//Might ERROR02198409 :refer to page 145.
//==================================================================================================                                                                                       
//UNACTIVATE1307.refer to page 145.Cause is for unsutiable Object reference.
//ERRORCORECTION0293854  :The towice time showing editor form is coreccted here.refer to page 145.
//ERRORCORECTION921348 :refer to page 145.
//==================================================================================================                                                                                       
//ERROR3070403:refer to page 145.
//ERROR09284 :The box drawing is not occured.refer to page 146.
//==================================================================================================                                                                                       
//ERRORCORECTION120974 :Correction of ERROR09284.refer to page 146.
//==================================================================================================                                                                                       
//ERROR317504 :refer to page 148.
//==================================================================================================                                                                                       
//ERRORCORECTION0923842308 :The Contained varibale of trre nodes.refer to page 148.
//==================================================================================================                                                                                       
//ERRORCORECTION0918248214 :The non null value set to correct error.refer to page 148.
//ERROR029184 : The previuse node is null.refer to page 149.
//ERRORCORECTION9285 :The Null Eception corection.
//ERROR317542.refer to page 149.
//ERRORCORECTION09128409 :The Fining of Proper node.
//==================================================================================================                                                                                       
//ERRORCORECTION30178120 :refer to page 150.
//==================================================================================================                                                                                       
//ERRORCORECTION192874 :The Location of Main Tree is located below.refer to page 150.
//==================================================================================================                                                                                       
//ERROR307019 :The infinite loop location.refer to page 150.
//LOCATION1307:refer to page 150.
//==================================================================================================                                                                                       
//ERROR137415 :refer to page 150.
//ERRORCORECTION137415 :Error Solved.refer to page 150.
//==================================================================================================                                                                                       
//ERROR9128374  :The Holder Should replaced at Nodes.refre to page 152.
//ERRORCORECTION091284 :The ERROR9128374 corection.refer to page 152.
//ERROR3174 :Tow editor is.refer to page 152.
//ERRORCORECTION13704175 :The extra editor Hide.referto page 152.
//==================================================================================================                                                                                       
//LOCATION765765 :refer to page 185.
//LOCATION131705 :Refer to page 185. 
//LOCATION987127973 :Refet to page 185.
//ERRORCORECTION981273 :Refer to page 185 and LOCATION987127973.
//LOCATION87687988 :Refer to page 185.
//==================================================================================================                                                                                       
//CONDITION317450 :refer to page 186.
//LOCATION78264928 :Here by refering to page 185.
//ERRORCORECTION30714123 :Refer to page 185.
//==================================================================================================                                                                                       
//LOCATION31745197  :Refer to page 187.
//==================================================================================================                                                                                       
using System;
using System.Drawing;
using System.Threading;
using System.Windows.Forms;
namespace Formulas
{
    public partial class Equation : Form
    {
        bool AutoTrueManualFalse = true;
        Graphic.Squares Sq = null;
        Graphics g = null;
        static int[] SquredPushed = new int[2];
        int DummyRow = 0, DummyColumn = 0;
        PictureBox Integral = new PictureBox();
        PictureBox Line = new PictureBox();
        PictureBox Trianglic = new PictureBox();
        PictureBox Cerices = new PictureBox();
        PictureBox Root = new PictureBox();
        PictureBox Parantez = new PictureBox();
        PictureBox ToUp = new PictureBox();
        PictureBox ToDown = new PictureBox();
        PictureBox ToLeft = new PictureBox();
        PictureBox ToRight = new PictureBox();
        PictureBox Ln = new PictureBox();
        PictureBox Log = new PictureBox();
        PictureBox No = new PictureBox();
        SenderSample Sender = null;

        public Setting.EquationSettingInsertion EquationSettingInsertionOnEquationForm = null;
        private int INTPressded = -1;
        public Formulas.Sinusad SinusadClassVariable = null;
        public NumberVar.NumberAndVariable NumberAndVariable = null;
        public Formulas.Parantez ParantezVariable = new Parantez();
        public Formulas.EquationTrace EquationTraceVariable = null;
        public Formulas.EquationTrace DummyEquationTraceVariable = null;
        public TraceKind TraceKindVariable = new TraceKind();
        //Formulas.Sinusad SinusadClassVariableResived = null;        
        bool LastInsertionTruePreviouseInsertonFalse = true;//Refet to page 145.
        bool ADDTrueDELETEFalse = true;
        public void InizilzingNullEquationTraceInsertionCallObjetcs()
        {
            Equation THISREF = this;
            if (SinusadClassVariable == null)
                SinusadClassVariable = new Sinusad(ref SinusadClassVariable, ref THISREF);


            if (NumberAndVariable == null)
                NumberAndVariable = new NumberVar.NumberAndVariable(ref NumberAndVariable, ref THISREF);

            if (EquationSettingInsertionOnEquationForm == null)
                EquationSettingInsertionOnEquationForm = new Setting.EquationSettingInsertion();

            if (EquationTraceVariable == null)
                EquationTraceVariable = new EquationTrace(THISREF, new Set());


        }
        public Equation()
        {
            InitializeComponent();

        }
        public Equation(Equation sender)
        {
            sender = this;

        }
        public SenderSample SenderAccess
        {
            get { return Sender; }
            set { Sender = value; }
        }
        public bool AutoTrueManualFalseAccess
        {
            get { return AutoTrueManualFalse; }
            set { AutoTrueManualFalse = value; }
        }
        public Formulas.Parantez ParantezVariableAccess
        {
            get { return ParantezVariable; }
            set { ParantezVariable = value; }
        }
        public NumberVar.NumberAndVariable NumberAndVariableAccess
        {
            get { return NumberAndVariable; }
            set { NumberAndVariable = value; }
        }
        public Setting.EquationSettingInsertion EquationSettingInsertionOnEquationFormAccess
        {
            get { return EquationSettingInsertionOnEquationForm; }
            set { EquationSettingInsertionOnEquationForm = value; }
        }
        public Formulas.Sinusad SinusadClassVariableAccess
        {
            get { return SinusadClassVariable; }
            set { SinusadClassVariable = value; }
        }
        public bool ADDTrueDELETEFalseAccess
        {
            get { return ADDTrueDELETEFalse; }
            set { ADDTrueDELETEFalse = value; }
        }
        public EquationTrace EquationTraceAccess
        {
            get { return EquationTraceVariable; }
            set { EquationTraceVariable = value; }
        }
        public bool LastInsertionTruePreviouseInsertonFalseAccess
        {
            get { return LastInsertionTruePreviouseInsertonFalse; }
            set { LastInsertionTruePreviouseInsertonFalse = value; }
        }

        public SenderSample SenderSampleAccess
        {
            get { return Sender; }
            set { Sender = value; }
        }
        public Formulas.Parantez GetParantezFormVariable()
        {
            return ParantezVariable;
        }
        /*public Graphic.Squares GetSq()
        {
            return Sq;
        }
         */
        public Graphic.Squares SqAccess
        {
            get { return Sq; }
            set { Sq = value; }
        }
        public int INTPressedAccess
        {
            get { return INTPressded; }
            set { INTPressded = value; }
        }
        public String GetString(int INTPressded)
        {
            String Sample = null;
            if (INTPressded == 0)
                Sample = "Sin";
            if (INTPressded == 1)
                Sample = "Cos";
            if (INTPressded == 2)
                Sample = "Tan";
            if (INTPressded == 3)
                Sample = "Cot";
            if (INTPressded == 4)
                Sample = "Sec";
            if (INTPressded == 5)
                Sample = "Csc";
            if (INTPressded == 6)
                Sample = "Ln";
            if (INTPressded == 7)
                Sample = "Log";
            return Sample;
        }
        public void SetIndependenceVariable()
        {
            g = this.CreateGraphics();
            g.DrawString("x", new Font("Times New Roman", 15), new SolidBrush(Color.Black), 250, 8);
        }
        private void Form1_Load(object sender, EventArgs e)
        {
            this.DrawForm();
            Sender = new SenderSample(this);
            Equation E = this;
            SinusadClassVariable = new Sinusad(ref SinusadClassVariable, ref E);
            NumberAndVariable = new NumberVar.NumberAndVariable(ref NumberAndVariable, ref E);
            EquationSettingInsertionOnEquationForm = new Setting.EquationSettingInsertion();
            EquationTraceVariable = new EquationTrace(this, this.Sender.AutoSenderAccess.DrawingAccess.ArrtificialItelligenceForGraphicallyDrawingAccess.NodeSetAcesss);
        }
        public String GetCurrentSampleFromBoard(int StringValue)
        {
            String DummyGetCurrentSample = null;
            if (StringValue == 0)
                DummyGetCurrentSample = "INT";
            if (StringValue == 1)
                DummyGetCurrentSample = "/";
            if (StringValue == 2)
                DummyGetCurrentSample = SinusadClassVariable.GetContained();
            if (StringValue == 3)
                DummyGetCurrentSample = "sic";
            if (StringValue == 4)
                DummyGetCurrentSample = "Root";
            if (StringValue == 5)
                DummyGetCurrentSample = "()";
            if (StringValue == 6)
                DummyGetCurrentSample = "Up";
            if (StringValue == 7)
                DummyGetCurrentSample = "Down";
            if (StringValue == 8)
                DummyGetCurrentSample = "Left";
            if (StringValue == 9)
                DummyGetCurrentSample = "Right";
            if (StringValue == 10)
                DummyGetCurrentSample = "+";
            if (StringValue == 11)
                DummyGetCurrentSample = "-";
            if (StringValue == 12)
                DummyGetCurrentSample = "*";
            if (StringValue == 13)
                DummyGetCurrentSample = "/";
            if (StringValue == 14)
                DummyGetCurrentSample = "x";
            if (StringValue == 15)
                DummyGetCurrentSample = NumberAndVariable.GetContained();
            if (StringValue == 16)
                DummyGetCurrentSample = "^";
            if (StringValue == 17)
                DummyGetCurrentSample = "=";
            return DummyGetCurrentSample;
        }
        private void DrawForm()
        {
            g = this.CreateGraphics();
            g.Clear(Color.White);
            Sq = new Graphic.Squares(this.Width, this.Height);
            for (int i = 0; i < this.Width; i = i + 40)
                for (int j = 0; j < this.Height; j = j + 40)
                {
                    g.DrawRectangle(new Pen(Color.Black, 5), Sq.lwBase[i / 40, j / 40, 0], Sq.lwBase[i / 40, j / 40, 1], 40, 40);
                    g.FillRectangle(new SolidBrush(Color.LightGray), Sq.lwBase[i / 40, j / 40, 0], Sq.lwBase[i / 40, j / 40, 1], 40, 40);
                    g.FillRectangle(new SolidBrush(Color.White), Sq.lwUp[i / 40, j / 40, 0], Sq.lwUp[i / 40, j / 40, 1], 34, 34);
                }
            Integral.BackColor = Color.White;
            Line.BackColor = Color.White;
            Trianglic.BackColor = Color.White;
            Cerices.BackColor = Color.White;
            Root.BackColor = Color.White;
            Parantez.BackColor = Color.White;
            ToUp.BackColor = Color.White;
            ToDown.BackColor = Color.White;
            ToLeft.BackColor = Color.White;
            ToRight.BackColor = Color.White;
        }
        public void SenderOperations()
        {
            if (INTPressded == 18)
                AutoTrueManualFalse = !AutoTrueManualFalse;
            try
            {
                this.Form1_Paint(new object(), new PaintEventArgs(g, new Rectangle()));
            }
            catch (ArgumentNullException t) { ExceptionClass.ExceptionClassMethod(t); this.Form1_Paint(new object(), new PaintEventArgs(this.CreateGraphics(), new Rectangle())); }
            //on every sample should inroduce Three state
            //EquationSettingInsertionOnEquationForm.ShowDialog();
            Equation THIS = this;
            //ERRORCORECTION921348 :refer to page 145.
            //ERROR317504 :refer to page 148.
            if (THIS.LastInsertionTruePreviouseInsertonFalseAccess)
            {
                if (AutoTrueManualFalse)
                {
                    Sender.SenderSampleOperation(ref THIS, true, INTPressded, ref SinusadClassVariable, ref EquationSettingInsertionOnEquationForm, ref NumberAndVariable, ref ParantezVariable, ref EquationTraceVariable, TraceKindVariable);
                    //LOCATION82174
                    //To Trace movement if needed.
                    //ERROR3070403:refer to page 145.
                    //ERROR3298403:refer to page 145.
                    EquationTraceVariable.SetSettingsOnMoveButtons(THIS, this.SenderSampleAccess.AutoSenderAccess.DrawingAccess.ArrtificialItelligenceForGraphicallyDrawingAccess.NodeSetAcesss, this.SenderSampleAccess.AutoSenderAccess.DrawingAccess.GraphicsAccess, this.INTPressded, this.TraceKindVariable);
                }
                else
                    Sender.SenderSampleOperation(ref THIS, false, INTPressded, ref SinusadClassVariable, ref EquationSettingInsertionOnEquationForm, ref NumberAndVariable, ref ParantezVariable, ref EquationTraceVariable, TraceKindVariable);
                /* if (EquationTraceVariable.HolderReadyAccess)
                    {
                        this.SenderSampleAccess.AutoSenderAccess.NodeAccess = EquationTraceVariable.HOLDERAccess.SenderSampleAccess.AutoSenderAccess.NodeAccess;
                        DummyEquationTraceVariable = null;
                    }            
                 */

            }
            else
            {
                if (DummyEquationTraceVariable == null)
                    DummyEquationTraceVariable = new EquationTrace(THIS, THIS.SenderSampleAccess.AutoSenderAccess.DrawingAccess.ArrtificialItelligenceForGraphicallyDrawingAccess.NodeSetAcesss);
                DummyEquationTraceVariable.SetSettingsOnMoveButtons(THIS, THIS.SenderSampleAccess.AutoSenderAccess.DrawingAccess.ArrtificialItelligenceForGraphicallyDrawingAccess.NodeSetAcesss, THIS.SenderSampleAccess.AutoSenderAccess.DrawingAccess.GraphicsAccess, INTPressded, THIS.TraceKindVariable);
            }
        }
        private void Form1_Click(object sender, EventArgs e)
        {
            this.SenderOperations();
        }
        public Setting.EquationSettingInsertion EquationSettingInsertionVariableAccess
        {
            get { return EquationSettingInsertionOnEquationForm; }
            set { EquationSettingInsertionOnEquationForm = value; }
        }
        private void PushedRectangle()
        {
            int Row = 0, Column = 0;
            if (Sq != null)
            {
                for (int i = 0; i < Sq.Row; i++)
                {
                    for (int j = 0; j < Sq.Column; j++)
                    {
                        Row = i;
                        Column = j;
                        if (((SquredPushed[0] > Sq.lwBase[Row, Column, 0]) & (SquredPushed[0] < Sq.lwBase[Row, Column, 2])))
                            if (((SquredPushed[1] > Sq.lwBase[Row, Column, 1]) & (SquredPushed[1] < Sq.lwBase[Row, Column, 3])))
                                break;
                    }
                    if (((SquredPushed[0] > Sq.lwBase[Row, Column, 0]) & (SquredPushed[0] < Sq.lwBase[Row, Column, 2])))
                        if (((SquredPushed[1] > Sq.lwBase[Row, Column, 1]) & (SquredPushed[1] < Sq.lwBase[Row, Column, 3])))
                            break;
                }
                if ((Row != DummyRow) || (Column != DummyColumn))
                    if (((SquredPushed[0] > Sq.lwBase[Row, Column, 0]) & (SquredPushed[0] < Sq.lwBase[Row, Column, 2])))
                        if (((SquredPushed[1] > Sq.lwBase[Row, Column, 1]) & (SquredPushed[1] < Sq.lwBase[Row, Column, 3])))
                        {
                            g.DrawRectangle(new Pen(Color.Black, 5), Sq.lwBase[DummyRow, DummyColumn, 0], Sq.lwBase[DummyRow, DummyColumn, 1], 40, 40);
                            g.FillRectangle(new SolidBrush(Color.LightGray), Sq.lwUp[Row, Column, 0], Sq.lwUp[Row, Column, 1], 34, 34);
                            g.FillRectangle(new SolidBrush(Color.White), Sq.lwUp[DummyRow, DummyColumn, 0], Sq.lwUp[DummyRow, DummyColumn, 1], 34, 34);
                            //Integral
                            if (DummyRow == 0)
                                if (DummyColumn == 0)
                                    Integral.BackColor = Color.White;

                            if (Row == 0)
                                if (Column == 0)
                                {
                                    INTPressded = 0;
                                    Integral.BackColor = Color.LightGray;
                                }
                            //line
                            if (DummyRow == 1)
                                if (DummyColumn == 0)
                                    Line.BackColor = Color.White;


                            if (Row == 1)
                                if (Column == 0)
                                {
                                    INTPressded = 1;
                                    Line.BackColor = Color.LightGray;
                                }
                            //Trianglic
                            if (DummyRow == 2)
                                if (DummyColumn == 0)

                                    Trianglic.BackColor = Color.White;

                            if (Row == 2)
                                if (Column == 0)
                                {
                                    INTPressded = 2;
                                    Trianglic.BackColor = Color.LightGray;
                                }
                            //cerieces
                            if (DummyRow == 3)
                                if (DummyColumn == 0)
                                    Cerices.BackColor = Color.White;

                            if (Row == 3)
                                if (Column == 0)
                                {
                                    Cerices.BackColor = Color.LightGray;
                                    INTPressded = 3;
                                }
                            //Root
                            if (DummyRow == 4)
                                if (DummyColumn == 0)


                                    Root.BackColor = Color.White;

                            if (Row == 4)
                                if (Column == 0)
                                {
                                    INTPressded = 4;
                                    Root.BackColor = Color.LightGray;
                                }
                            //Parantez
                            if (DummyRow == 5)
                                if (DummyColumn == 0)
                                {

                                    Parantez.BackColor = Color.White;
                                }

                            if (Row == 5)
                                if (Column == 0)
                                {

                                    INTPressded = 5;
                                    Parantez.BackColor = Color.LightGray;

                                }
                            //ToUp
                            if (DummyRow == 0)
                                if (DummyColumn == 1)

                                    ToUp.BackColor = Color.White;

                            if (Row == 0)
                                if (Column == 1)
                                {
                                    ToUp.BackColor = Color.LightGray;
                                    INTPressded = 6;
                                }
                            //ToDown
                            if (DummyRow == 1)
                                if (DummyColumn == 1)

                                    ToDown.BackColor = Color.White;

                            if (Row == 1)
                                if (Column == 1)
                                {
                                    INTPressded = 7;
                                    ToDown.BackColor = Color.LightGray;
                                }
                            //ToLeft
                            if (DummyRow == 2)
                                if (DummyColumn == 1)

                                    ToLeft.BackColor = Color.White;

                            if (Row == 2)
                                if (Column == 1)
                                {
                                    INTPressded = 8;
                                    ToLeft.BackColor = Color.LightGray;
                                }
                            //ToRight
                            if (DummyRow == 3)
                                if (DummyColumn == 1)
                                    ToRight.BackColor = Color.White;

                            if (Row == 3)
                                if (Column == 1)
                                {
                                    INTPressded = 9;
                                    ToRight.BackColor = Color.LightGray;
                                }
                            if (Row == 4)
                                if (Column == 1)
                                    INTPressded = 10;
                            if (Row == 5)
                                if (Column == 1)
                                    INTPressded = 11;
                            if (Row == 6)
                                if (Column == 1)
                                    INTPressded = 12;
                            if (Row == 7)
                                if (Column == 1)
                                    INTPressded = 13;
                            if (Row == 8)
                                if (Column == 1)
                                {
                                    EquationSettingInsertionOnEquationForm.ShowDialog();

                                }
                            //Independency variable
                            if (Row == 6)
                                if (Column == 0)
                                    INTPressded = 14;
                            if (Row == 7)
                                if (Column == 0)
                                    INTPressded = 16;
                            //number
                            if (DummyRow == 8)
                                if (DummyColumn == 0)

                                    No.BackColor = Color.White;

                            if (Row == 8)
                                if (Column == 0)
                                {
                                    INTPressded = 15;
                                    No.BackColor = Color.LightGray;
                                }

                            if (Row == 9)
                                if (Column == 0)
                                {
                                    INTPressded = 17;
                                    No.BackColor = Color.LightGray;
                                }
                            if (DummyRow == 9)
                                if (DummyColumn == 0)

                                    No.BackColor = Color.White;
                            if (Row == 10)
                                if (Column == 0)
                                {

                                    INTPressded = 18;
                                }
                            if (Row == 10)
                                if (Column == 1)
                                {
                                    TraceKindVariable.ShowDialog();
                                    INTPressded = 19;
                                    //TraceKindVariable.Close();
                                }
                            if (AutoTrueManualFalse)
                                this.DrawAuto();
                            else
                                this.DrawManual();
                            this.DrawTraceKind();
                            this.FiveBasicOprators();
                            this.SetIndependenceVariable();
                            this.DrawEqual();
                            DummyRow = Row;
                            DummyColumn = Column;
                        }
            }
        }
        private void Form1_Activated(object sender, EventArgs e)
        {
            this.DrawForm();
        }
        private void Form1_AutoValidateChanged(object sender, EventArgs e)
        {
            this.DrawForm();
        }
        private void Form1_Paint(object sender, PaintEventArgs e)
        {
            this.DrawForm();
            this.DrawIntegralOnForm();//0
            this.DrawLineOnForm();//1
            this.DrawTrianglicOnForm();//2
            this.DrawCericesOnForm();//3
            this.DrawRootOnForm();//4
            this.DrawParantezOnForm();//5
            this.DrawToUpOnForm();//6
            this.DrawToDownOnForm();//7
            this.DrawToLeftOnForm();//8
            this.DrawToRightOnForm();//9
            this.FiveBasicOprators();//10
            this.SetIndependenceVariable();//11
            this.DrawNumberAndVaribale();//12
            this.DrawEqual();//13
            if (AutoTrueManualFalse)
                this.DrawAuto();
            else
                this.DrawManual();
            this.DrawTraceKind();
        }
        private void DrawEqual()
        {
            g.DrawString("=", new Font("Times New Roman", 20, FontStyle.Bold), new SolidBrush(Color.Black), 367, 10);
        }
        private void DrawManual()
        {
            g.DrawString("Manual", new Font("Times New Roman", 5, FontStyle.Bold), new SolidBrush(Color.Black), 407, 15);
        }
        private void DrawTraceKind()
        {
            g.DrawString("TR kind", new Font("Times New Roman", 5, FontStyle.Bold), new SolidBrush(Color.Black), 407, 55);
        }
        private void DrawAuto()
        {
            g.DrawString("Auto", new Font("Times New Roman", 5, FontStyle.Bold), new SolidBrush(Color.Black), 407, 15);
        }
        private void DrawIntegralOnForm()
        {

            Integral.Visible = true;
            Integral.Location = new Point(12, 12);
            Integral.Width = 16;
            Integral.Height = 16;
            Integral.SizeMode = PictureBoxSizeMode.StretchImage;
            Integral.Image = Image.FromFile
              (System.IO.Path.GetDirectoryName(Environment.GetCommandLineArgs()[0]) + "\\"

              + "Integral.gif");
            this.Controls.Add(Integral);
        }
        private void DrawLineOnForm()
        {
            Line.Visible = true;
            Line.Location = new Point(52, 12);
            Line.Width = 16;
            Line.Height = 16;
            Line.SizeMode = PictureBoxSizeMode.StretchImage;
            Line.Image = Image.FromFile
              (System.IO.Path.GetDirectoryName(Environment.GetCommandLineArgs()[0]) + "\\"

              + "Line.gif");
            this.Controls.Add(Line);
        }
        private void DrawTrianglicOnForm()
        {
            Trianglic.Visible = true;
            Trianglic.Location = new Point(92, 12);
            Trianglic.Width = 16;
            Trianglic.Height = 16;
            Trianglic.SizeMode = PictureBoxSizeMode.StretchImage;
            Trianglic.Image = Image.FromFile
              (System.IO.Path.GetDirectoryName(Environment.GetCommandLineArgs()[0]) + "\\"

              + "Trianglic.gif");
            this.Controls.Add(Trianglic);
        }
        private void DrawCericesOnForm()
        {
            Cerices.Visible = true;
            Cerices.Location = new Point(132, 12);
            Cerices.Width = 16;
            Cerices.Height = 16;
            Cerices.SizeMode = PictureBoxSizeMode.StretchImage;
            Cerices.Image = Image.FromFile
              (System.IO.Path.GetDirectoryName(Environment.GetCommandLineArgs()[0]) + "\\"

              + "Cerices.gif");
            this.Controls.Add(Cerices);
        }
        private void DrawRootOnForm()
        {

            Root.Visible = true;
            Root.Location = new Point(172, 12);
            Root.Width = 16;
            Root.Height = 16;
            Root.SizeMode = PictureBoxSizeMode.StretchImage;
            Root.Image = Image.FromFile
              (System.IO.Path.GetDirectoryName(Environment.GetCommandLineArgs()[0]) + "\\"

              + "Root.gif");
            this.Controls.Add(Root);
        }
        private void DrawParantezOnForm()
        {

            Parantez.Visible = true;
            Parantez.Location = new Point(212, 12);
            Parantez.Width = 16;
            Parantez.Height = 16;
            Parantez.SizeMode = PictureBoxSizeMode.StretchImage;
            Parantez.Image = Image.FromFile
              (System.IO.Path.GetDirectoryName(Environment.GetCommandLineArgs()[0]) + "\\"

              + "Parantez.gif");
            this.Controls.Add(Parantez);
        }
        private void DrawToUpOnForm()
        {
            ToUp.Visible = true;
            ToUp.Location = new Point(12, 52);
            ToUp.Width = 16;
            ToUp.Height = 16;
            ToUp.SizeMode = PictureBoxSizeMode.StretchImage;
            ToUp.Image = Image.FromFile
              (System.IO.Path.GetDirectoryName(Environment.GetCommandLineArgs()[0]) + "\\"

              + "ToUp.gif");
            this.Controls.Add(ToUp);
        }
        private void DrawToDownOnForm()
        {

            ToDown.Visible = true;
            ToDown.Location = new Point(52, 52);
            ToDown.Width = 16;
            ToDown.Height = 16;
            ToDown.SizeMode = PictureBoxSizeMode.StretchImage;
            ToDown.Image = Image.FromFile
              (System.IO.Path.GetDirectoryName(Environment.GetCommandLineArgs()[0]) + "\\"

              + "ToDown.gif");
            this.Controls.Add(ToDown);
        }

        private void DrawToLeftOnForm()
        {
            ToLeft.Visible = true;
            ToLeft.Location = new Point(92, 52);
            ToLeft.Width = 16;
            ToLeft.Height = 16;
            ToLeft.SizeMode = PictureBoxSizeMode.StretchImage;
            ToLeft.Image = Image.FromFile
              (System.IO.Path.GetDirectoryName(Environment.GetCommandLineArgs()[0]) + "\\"

              + "ToLeft.gif");
            this.Controls.Add(ToLeft);
        }
        private void DrawToRightOnForm()
        {

            ToRight.Visible = true;
            ToRight.Location = new Point(132, 52);
            ToRight.Width = 16;
            ToRight.Height = 16;
            ToRight.SizeMode = PictureBoxSizeMode.StretchImage;
            ToRight.Image = Image.FromFile
              (System.IO.Path.GetDirectoryName(Environment.GetCommandLineArgs()[0]) + "\\"

              + "ToRight.gif");
            this.Controls.Add(ToRight);
        }
        private void FiveBasicOprators()
        {
            g.DrawString("+", new Font("Times New Roman", 20, FontStyle.Bold), new SolidBrush(Color.Black), 168, 45);
            g.DrawString("-", new Font("Times New Roman", 20, FontStyle.Bold), new SolidBrush(Color.Black), 213, 43);
            g.DrawString("*", new Font("Times New Roman", 20, FontStyle.Bold), new SolidBrush(Color.Black), 248, 45);
            g.DrawString("/", new Font("Times New Roman", 20, FontStyle.Bold), new SolidBrush(Color.Black), 287, 45);
            g.DrawString("^", new Font("Times New Roman", 20, FontStyle.Bold), new SolidBrush(Color.Black), 287, 10);
        }
        private void DrawNumberAndVaribale()
        {
            No.Visible = true;
            No.Location = new Point(330, 12);
            No.Width = 16;
            No.Height = 16;
            No.SizeMode = PictureBoxSizeMode.StretchImage;
            No.BackColor = Color.White;
            No.Image = Image.FromFile
              (System.IO.Path.GetDirectoryName(Environment.GetCommandLineArgs()[0]) + "\\"

              + "No.gif");
            this.Controls.Add(No);

        }
        private void Equation_MouseMove(object sender, MouseEventArgs e)
        {
            SquredPushed[0] = this.PointToClient(MousePosition).X;
            SquredPushed[1] = this.PointToClient(MousePosition).Y;
            this.PushedRectangle();
            if (INTPressded != 2)
                SinusadClassVariable.Hide();
        }

        private void Equation_KeyPress(object sender, KeyPressEventArgs e)
        {
            if (e.KeyChar == 27)//Escape
                LastInsertionTruePreviouseInsertonFalse = true;
            if (e.KeyChar == 32)//Insertion
                LastInsertionTruePreviouseInsertonFalse = false;
            if (e.KeyChar == 68)
                ADDTrueDELETEFalse = false;
            else
                ADDTrueDELETEFalse = true;

        }

        private void Equation_Paint(object sender, PaintEventArgs e)
        {
            this.DrawForm();
            Sender = new SenderSample(this);
            Equation E = this;
            SinusadClassVariable = new Sinusad(ref SinusadClassVariable, ref E);
            NumberAndVariable = new NumberVar.NumberAndVariable(ref NumberAndVariable, ref E);
            EquationSettingInsertionOnEquationForm = new Setting.EquationSettingInsertion();
            EquationTraceVariable = new EquationTrace(this, this.Sender.AutoSenderAccess.DrawingAccess.ArrtificialItelligenceForGraphicallyDrawingAccess.NodeSetAcesss);

        }

        private void Equation_Resize(object sender, EventArgs e)
        {
            this.Height = 120;
            this.Width = 400;
        }
    }
    class AddDeleteNode
    {
        EquationTrace EquationTraceVariable = null;
        Equation EquationVariable = null;
        SenderSample DummySenderSample = null;
        public AddDeleteNode(Equation THISE, EquationTrace TR)
        {
            EquationVariable = THISE;
            EquationTraceVariable = TR;
            DummySenderSample = new SenderSample(THISE);
            //ERRORCORECTION0293854  :The towice time showing editor form is coreccted here.refer to page 145.
            //DummySenderSample.AutoSenderAccess.DrawingAccess.GraphicallyInterfaceAccess.EditorAccesss.Hide();
            //ERRORCORECTION030819 :The ERRORCORECTION of Drwaing Nodes.
            THISE.SenderSampleAccess.AutoSenderAccess.DrawingAccess.GraphicallyInterfaceAccess.EditorAccesss.Hide();
            //DummySenderSample.AutoSenderAccess.DrawingAccess.GraphicallyInterfaceAccess.EditorAccesss.Hide();
        }
        public EquationTrace TraceEquationAccessOfAddDeleteNodeClass
        {
            get { return EquationTraceVariable; }
            set { EquationTraceVariable = value; }
        }
        public SenderSample DummySenderSampleAccess
        {
            get { return DummySenderSample; }
            set { DummySenderSample = value; }
        }
        public Equation EquationAccessOfAddDeleteNodeClass
        {
            get { return EquationVariable; }
            set { EquationVariable = value; }
        }
        private AddToTree.Tree FINDTreeWithThreadConsiderationNodeOfPreviouseNodeForBetweenTraceKindDummyAccess(Equation THISE)
        {
            AddToTree.Tree Node = THISE.SenderSampleAccess.AutoSenderAccess.NodeAccess;
            AddToTree.Tree Dummy = Node;
            this.FINDTreeWithThreadConsiderationNode(Node, ref Dummy);
            return Dummy;
        }
        private void FINDTreeWithThreadConsiderationNode(AddToTree.Tree Node, ref AddToTree.Tree Dummy)
        {
            if (Node == null)
                return;
            if (Node.SampleAccess == EquationTraceVariable.PreviouseNodeForBetweenTraceKindDummyAccess.StringSampleAccess)
                if (Node.LeftSideAccess.SampleAccess == EquationTraceVariable.PreviouseNodeForBetweenTraceKindDummyAccess.LeftSideAccess.StringSampleAccess)
                    if (Node.RightSideAccess.SampleAccess == EquationTraceVariable.PreviouseNodeForBetweenTraceKindDummyAccess.RightSideAccess.StringSampleAccess)
                        Dummy = Node;
            this.FINDTreeWithThreadConsiderationNode(Node.LeftSideAccess, ref Dummy);
            this.FINDTreeWithThreadConsiderationNode(Node.RightSideAccess, ref Dummy);
        }
        private Set FindSetNodeOfCurrentNodeAdded(Equation THISE, AddToTree.Tree Added)
        {
            AddToTree.Tree Node = Added;
            Set Dummy = THISE.SenderSampleAccess.AutoSenderAccess.DrawingAccess.ArrtificialItelligenceForGraphicallyDrawingAccess.NodeSetAcesss;
            Dummy = this.FindSetNode(ref Node, Dummy);
            return Dummy;
        }
        private Set FindSetNode(ref AddToTree.Tree Node, Set Dummy)
        {
            if (Dummy == null)
                return Dummy;
            if (Node.SampleAccess == EquationTraceVariable.PreviouseNodeForBetweenTraceKindDummyAccess.StringSampleAccess)
                if (Node.LeftSideAccess.SampleAccess == EquationTraceVariable.PreviouseNodeForBetweenTraceKindDummyAccess.LeftSideAccess.StringSampleAccess)
                    if (Node.RightSideAccess.SampleAccess == EquationTraceVariable.PreviouseNodeForBetweenTraceKindDummyAccess.RightSideAccess.StringSampleAccess)
                        return Dummy;
            Dummy = this.FindSetNode(ref Node, Dummy.LeftSideAccess);
            Dummy = this.FindSetNode(ref Node, Dummy.RightSideAccess);
            return Dummy;
        }
        public void AddDeleteNodeOperation(Equation THISE, EquationTrace TR, bool ADDTrueDELETEFalse, String Sample, bool InCurrentADDDELETETrueOtherWiseFalse)
        {
            if (InCurrentADDDELETETrueOtherWiseFalse)//IN OPERATION
            {
                if (ADDTrueDELETEFalse)//ADDING OPERATION
                {
                    //Might ERROR02198409 :refer to page 145.
                    /*if ((THISE.SenderSampleAccess.AutoSenderAccess.IsParantez(THISE.GetCurrentSampleFromBoard(THISE.INTPressedAccess))))
                        DummySenderSample.AutoSenderAccess.SenderToAddToTree(THISE.GetCurrentSampleFromBoard(THISE.INTPressedAccess), THISE, true);
                    else
                        DummySenderSample.AutoSenderAccess.SenderToAddToTree(THISE.GetCurrentSampleFromBoard(THISE.INTPressedAccess), THISE, false);
                     */
                    if (THISE.AutoTrueManualFalseAccess)
                        DummySenderSample.SenderSampleOperation(ref THISE, true, THISE.INTPressedAccess, ref (THISE.SinusadClassVariable), ref THISE.EquationSettingInsertionOnEquationForm, ref THISE.NumberAndVariable, ref THISE.ParantezVariable, ref THISE.EquationTraceVariable, THISE.TraceKindVariable);
                    else
                        DummySenderSample.SenderSampleOperation(ref THISE, false, THISE.INTPressedAccess, ref THISE.SinusadClassVariable, ref THISE.EquationSettingInsertionOnEquationForm, ref THISE.NumberAndVariable, ref THISE.ParantezVariable, ref THISE.EquationTraceVariable, THISE.TraceKindVariable);

                }
                else//DELETE
                { }
            }
            else//DO CONJUNCT OPERATION IF FINISHSHED FOR ADDING
                if (ADDTrueDELETEFalse)
            {//Refer To page 144.


                DummySenderSample.AutoSenderAccess.NodeAccess.LeftSideAccess = null;
                DummySenderSample.AutoSenderAccess.NodeAccess.RightSideAccess = null;
                DummySenderSample.AutoSenderAccess.NodeAccess = new AddToTree.Tree(null, false);
                //DummySenderSample = new SenderSample(THISE);
            }

            /*
            AddToTree.Tree ADDED  = new AddToTree.Tree(Sample, false);
            //AddToTree.Tree Node = THISE.SenderSampleAccess.AutoSenderAccess.NodeAccess;
            AddToTree.Tree Dummy  = this.FINDTreeWithThreadConsiderationNodeOfPreviouseNodeForBetweenTraceKindDummyAccess(THISE);
            AddToTree.Tree Holder = Dummy;



            if (ADDTrueDELETEFalse)//ADD
            {
                if (THISE.EquationTraceAccess.TraceKindAccess.RadioButtonTowAcess.Checked)//ADD Node
                {
                    if (Dummy.ThreadAccess != null)
                    {
                        if (Holder.ThreadAccess.LeftSideAccess == Holder)
                            Holder.ThreadAccess.SetLefTandRightCommonlySide(ADDED, Holder.ThreadAccess.RightSideAccess);
                        else
                            Holder.ThreadAccess.SetLefTandRightCommonlySide(Holder.ThreadAccess.LeftSideAccess, ADDED);
                        ADDED.ThreadAccess = Dummy.ThreadAccess;
                        Holder.ThreadAccess = ADDED;

                        while (Holder.ThreadAccess != null)
                            Holder = Holder.ThreadAccess;

                        THISE.SenderSampleAccess.AutoSenderAccess.reciverCuntractionTreeAccess.NodeAccess = Holder;

                        THISE.SenderSampleAccess.AutoSenderAccess.DrawingAccess.GraphicsAccess.Clear(Color.White);
                        THISE.SenderSampleAccess.AutoSenderAccess.DrawingAccess.Draw(THISE, THISE.SenderSampleAccess.AutoSenderAccess, 40, 40);

                        EquationTraceVariable.PreviouseNodeForBetweenTraceKindDummyAccess = this.FindSetNodeOfCurrentNodeAdded(THISE, ADDED);
                    }
                    else
                    if (THISE.EquationTraceAccess.TraceKindAccess.RadioButtonOneAcess.Checked)//NodeReplaceMent
                    { }
              
                }
            }
            else//DELETE
            { }
             */
        }
    }
    /*class TraceEquation
    {
      AutoSender AutoSenderVariable = null;
      AddToTree.Tree DummyTree = null;
      int Stage = 0;
      int Side = 0;
      public TraceEquation()
      {
          //AutoSenderVariable = new AutoSender(this);
      }
      public void TraceOnEquation(String Sample)
      {
       DummyTree=AutoSenderVariable.NodeAccess;
       if (Sample.ToString().ToLower() == "up")
       if (Stage>0)
           Stage--;
       else
       if (Sample.ToString().ToLower() == "down")
           Stage++;
       else
       if (Sample.ToString().ToLower() == "left")
       if (Side>0)
           Side--;
       else
       if (Sample.ToString().ToLower() == "right")
           Side++;           
      }
    }
     */
    //This class is high level of drawing.
    public class Drawing
    {
        //ArrtificialItelligenceForGraphicallyDrawing ArrtificialItelligenceForGraphicallyDrawingNext = null;
        static ArrtificialItelligenceForGraphicallyDrawing ArrtificialItelligenceForGraphicallyDrawingNode = null;
        GraphicallyInterface GraphicallyInterfaceVariable = null;
        //Graphics g = null;
        public Drawing(Equation THIS, AutoSender AutoSendervarible, GraphicallyInterface Graphically)
        {
            GraphicallyInterfaceVariable = Graphically;
            ArrtificialItelligenceForGraphicallyDrawingNode = new ArrtificialItelligenceForGraphicallyDrawing(THIS, AutoSendervarible, Graphically);
        }
        public ArrtificialItelligenceForGraphicallyDrawing ArrtificialItelligenceForGraphicallyDrawingAccess
        {
            get { return ArrtificialItelligenceForGraphicallyDrawingNode; }
            set { ArrtificialItelligenceForGraphicallyDrawingNode = value; }
        }
        /*public Graphics GetGraphics()
        {
            return GraphicallyInterfaceVariable.Getg();
        }
         */
        public Graphics GraphicsAccess
        {
            get { return GraphicallyInterfaceVariable.gAccesss; }
            set { GraphicallyInterfaceVariable.gAccesss = value; }
        }
        public GraphicallyInterface GraphicallyInterfaceAccess
        {
            get { return GraphicallyInterfaceVariable; }
            set { GraphicallyInterfaceVariable = value; }
        }
        /*public ArrtificialItelligenceForGraphicallyDrawing GetArrtificialItelligenceForGraphicallyDrawing()
        {
            return ArrtificialItelligenceForGraphicallyDrawingNode;
        }*/
        /*public ArrtificialItelligenceForGraphicallyDrawing ArrtificialItelligenceForGraphicallyDrawingAccess
        {
            get { return ArrtificialItelligenceForGraphicallyDrawingNode; }
            set { eturn ArrtificialItelligenceForGraphicallyDrawingNode; }
        }
         */
        public void Draw(Equation THIS, AutoSender AutoSenderVarible, int xBegin, int yBegin)
        {
            //ERROR7342517321 :why the argument isn't drawn?
            ArrtificialItelligenceForGraphicallyDrawing Dummy = new ArrtificialItelligenceForGraphicallyDrawing(THIS, AutoSenderVarible, GraphicallyInterfaceVariable);
            ArrtificialItelligenceForGraphicallyDrawingNode.InizializingWhenNeede(xBegin, yBegin);
            Dummy = ArrtificialItelligenceForGraphicallyDrawingNode;
            while (Dummy != null)
            {
                Dummy.InizializingWhenNeede(xBegin, yBegin);
                //for every statment draws.
                this.DrawEachNodeOfArrtificialItelligenceForGraphicallyDrawing(Dummy, THIS, AutoSenderVarible);
                Dummy = Dummy.ArrtificialItelligenceForGraphicallyDrawingNextAcess;
            }
        }
        //This Method draw On Form.
        public void DrawEachNodeOfArrtificialItelligenceForGraphicallyDrawing(ArrtificialItelligenceForGraphicallyDrawing A, Equation THIS, AutoSender SEnderSampleVariable)
        {
            //Get Graphic Handled.
            //g = GraphicallyInterfaceVariable.Getg();
            Set Dummy = new Set();
            //To Draw Each Node.(grpe of ArrtificialIntelligence)
            Dummy = ArrtificialItelligenceForGraphicallyDrawingNode.NodeSetAcesss;
            //by recursive on this method all Set Nodes draws
            this.DrawOnForm(Dummy, GraphicallyInterfaceVariable);
        }
        public void DrawOnForm(Set SetVariable, GraphicallyInterface GraphicallyInterfaceVariable)
        {
            if (SetVariable == null)
                return;
            int xBegin = 32000, yBegin = SetVariable.YAccess;
            int xEnd = 0, yEnd = SetVariable.YAccess;
            if (((SetVariable.GetDecoder() >= 2) && (SetVariable.GetDecoder() <= 7))
                || ((SetVariable.GetDecoder() >= 10) && (SetVariable.GetDecoder() <= 11)))
            {
                //ERROR7809567845678090 : The parantez location is not correct.
                //ERRORCORECTION7719827489273 :The y value is set.
                //ERRORCORECTION43760958747 : By reference variable and located the drawing parantez here the parantez draw corectly.
                GraphicallyInterfaceVariable.DrawTowParantezOnForm(SetVariable, ref xBegin, ref yBegin, ref xEnd, ref yEnd, 10);
                GraphicallyInterfaceVariable.DrawTowParantez(xBegin - 5, yBegin, xEnd + 5, yEnd, 10);
            }
            if (SetVariable.GetDecoder() == 0)
                GraphicallyInterfaceVariable.DrawIntegralOnForm(SetVariable.XAccess, SetVariable.YAccess, SetVariable.WidhtAccess, SetVariable.HieghtAcess);
            else
                if (SetVariable.GetDecoder() == 1)
                GraphicallyInterfaceVariable.DrawLineOnForm(SetVariable.XAccess, SetVariable.YAccess, SetVariable.WidhtAccess, SetVariable.HieghtAcess);
            else
                    if (SetVariable.GetDecoder() == 2)
                GraphicallyInterfaceVariable.Sin(SetVariable.XAccess, SetVariable.YAccess, 10);
            else
                        if (SetVariable.GetDecoder() == 3)
                GraphicallyInterfaceVariable.Cos(SetVariable.XAccess, SetVariable.YAccess, 10);
            else
                            if (SetVariable.GetDecoder() == 4)
                GraphicallyInterfaceVariable.Tan(SetVariable.XAccess, SetVariable.YAccess, 10);
            else
                                if (SetVariable.GetDecoder() == 5)
                GraphicallyInterfaceVariable.Cot(SetVariable.XAccess, SetVariable.YAccess, 10);
            else
                                    if (SetVariable.GetDecoder() == 6)
                GraphicallyInterfaceVariable.Sec(SetVariable.XAccess, SetVariable.YAccess, 10);
            else
                                        if (SetVariable.GetDecoder() == 7)
                GraphicallyInterfaceVariable.Csc(SetVariable.XAccess, SetVariable.YAccess, 10);
            else
                                            if (SetVariable.GetDecoder() == 8)
                GraphicallyInterfaceVariable.DrawCericesOnForm(SetVariable.XAccess, SetVariable.YAccess, SetVariable.WidhtAccess, SetVariable.HieghtAcess);
            else
                                                if (SetVariable.GetDecoder() == 9)
                GraphicallyInterfaceVariable.DrawRootOnForm(SetVariable.XAccess, SetVariable.YAccess, SetVariable.WidhtAccess, SetVariable.HieghtAcess);
            else
                                                    if (SetVariable.GetDecoder() == 10)
                GraphicallyInterfaceVariable.DrawLn(SetVariable.XAccess, SetVariable.YAccess, 10);
            else
                                                        if (SetVariable.GetDecoder() == 11)
                GraphicallyInterfaceVariable.DrawLog(SetVariable.XAccess, SetVariable.YAccess, 10);
            else
                                                            if (SetVariable.GetDecoder() == 12)
                GraphicallyInterfaceVariable.DrawNumber(SetVariable, SetVariable.XAccess, SetVariable.YAccess, 10);
            else
                                                                if (SetVariable.GetDecoder() == 13)
                GraphicallyInterfaceVariable.FiveBasicOpratorsPlus(SetVariable.XAccess, SetVariable.YAccess, 10);
            else
                                                                    if (SetVariable.GetDecoder() == 14)
                GraphicallyInterfaceVariable.FiveBasicOpratorsMinuse(SetVariable.XAccess, SetVariable.YAccess, 10);
            else
                                                                        if (SetVariable.GetDecoder() == 15)
                GraphicallyInterfaceVariable.FiveBasicOpratorsMul(SetVariable.XAccess, SetVariable.YAccess, 10);
            else
                                                                            if (SetVariable.GetDecoder() == 16)
                //ERROR81723678 :Cuase of ERROR13725150 .The Line Of division is not drawn corectly.refr top page 127.
                //ERRORCORECTION736340574 :the Argumnet was set.
                GraphicallyInterfaceVariable.FiveBasicOpratorsDiv(SetVariable.XAccess, SetVariable.YAccess, SetVariable.WidhtAccess, SetVariable.HieghtAcess);
            else
                                                                                if (SetVariable.GetDecoder() == 17)
                GraphicallyInterfaceVariable.FiveBasicOpratorsPow(SetVariable.XAccess, SetVariable.YAccess, 10);
            else
                                                                                    if (SetVariable.GetDecoder() == 18)
                GraphicallyInterfaceVariable.DrawIndependence(SetVariable, SetVariable.XAccess, SetVariable.YAccess, 10);

            this.DrawOnForm(SetVariable.LeftSideAccess, GraphicallyInterfaceVariable);
            this.DrawOnForm(SetVariable.RightSideAccess, GraphicallyInterfaceVariable);
        }
    }
    //This class is due to ArrtificialIntelligence drawing.
    //The Stores is a link list data type.
    public class ArrtificialItelligenceForGraphicallyDrawing
    {
        GraphicallyInterface GraphicallyInterfaceVaribale = null;
        ArrtificialItelligenceForGraphicallyDrawing ArrtificialItelligenceForGraphicallyDrawingNext = null;
        Set NodeSet = null;
        AddToTree.Tree NodeTree = null;
        public ArrtificialItelligenceForGraphicallyDrawing(Equation EquationVariable, AutoSender AutoSenderVaribale, GraphicallyInterface Graphically)
        {
            GraphicallyInterfaceVaribale = Graphically;
            //In order to Set Tree;            
            NodeTree = GraphicallyInterfaceVaribale.GetNodeTree();
            NodeSet = new Set();
        }
        public Set NodeSetAcesss
        {
            get { return NodeSet; }
            set { NodeSet = value; }
        }
        public GraphicallyInterface GraphicallyInterfaceAcesss
        {
            get { return GraphicallyInterfaceVaribale; }
            set { GraphicallyInterfaceVaribale = value; }
        }
        public ArrtificialItelligenceForGraphicallyDrawing ArrtificialItelligenceForGraphicallyDrawingNextAcess
        {
            get { return this.ArrtificialItelligenceForGraphicallyDrawingNext; }
            set { this.ArrtificialItelligenceForGraphicallyDrawingNext = value; }
        }
        //This Method Inizialize Set Nodes First time.
        public void InizializingWhenNeede(int xBegin, int yBegin)
        {
            // ERROR123234
            //Inizialize Nodes.
            //This May Help To Correct TreeNode.
            //Unfortunetly this can not be useful.
            //The conection between AutoSender And Here is corrected to Connect.
            //The Problem is from "SenderToAddToTree" Method.
            //The ERROR123234 Solved.
            NodeTree = GraphicallyInterfaceVaribale.GetNodeTree();
            //For Setting Nodes.
            //(Error) On Inizializing.The SetNode is not created.
            //The code was been Changed completely.
            //The code Is not already Created correctly.
            //===*The problem is not this method .the nodetree is not created correctly.===*
            //===*"CreateGraphicallyNodes" method work properly.===*            
            //It may to be corrected Except "No" variable.
            //ERROR560364
            //CORRECTION12456.The Number is set now. 
            NodeSet = this.CreateGraphicallyNodes(NodeTree);
            //Set Dimensions.                        
            //(Error) The dimensions are not set.
            //ERROR12769034 .The Settings too only for one of condition is not Occured .
            //ERRORCORRECTION13475 .The condition added.Is Worked ??No
            //There Is already ERROR .
            //ERROR23659008 :Error on XY Calculation
            //ERROR30807507  :The whidth of line is not ok.
            NodeSet = this.CalculatingXAndYAndWhithAndHeight(NodeSet, xBegin, yBegin, 20, 20, true);
            //ERROR77007 :The problem dose not found.refer to page 130.
            //ERRORCORECTION8756 :The Shift when needed.refer to page 106.
            NodeSet = this.ShiftWhenNeededX(NodeSet);
            NodeSet = this.ShiftWhenNeededY(NodeSet);
            /*
            Set Dummy = new Set();
            this.SetWhidthValueOfNumberNode(NodeSet, ref Dummy);
            NodeSet = Dummy;
            this.SetXValueOfArithmaticsNode(NodeSet, ref Dummy);
            NodeSet = Dummy;
             */
        }
        public void InizializingWhenNeedeForAnswerDrawn(AddToTree.Tree Dummy, int xBegin, int yBegin)
        {
            // ERROR123234
            //Inizialize Nodes.
            //This May Help To Correct TreeNode.
            //Unfortunetly this can not be useful.
            //The conection between AutoSender And Here is corrected to Connect.
            //The Problem is from "SenderToAddToTree" Method.
            //The ERROR123234 Solved.

            NodeTree = Dummy.CopyNewTree(Dummy);

            //   System.Windows.Forms.MessageBox.Show("5-1.the Node assigned.");

            //For Setting Nodes.
            //(Error) On Inizializing.The SetNode is not created.
            //The code was been Changed completely.
            //The code Is not already Created correctly.
            //===*The problem is not this method .the nodetree is not created correctly.===*
            //===*"CreateGraphicallyNodes" method work properly.===*            
            //It may to be corrected Except "No" variable.
            //ERROR560364
            //CORRECTION12456.The Number is set now. 
            NodeSet = this.CreateGraphicallyNodes(NodeTree);

            // System.Windows.Forms.MessageBox.Show("5-2.The Graphically Node creates and assigned.");
            //Set Dimensions.
            //(Error) The dimensions are not set.
            //ERROR12769034 .The Settings too only for one of condition is not Occured.
            //ERRORCORRECTION13475 .The condition added.Is Worked ??No
            //There Is already ERROR.
            //ERROR23659008 :Error on XY Calculation
            //ERROR30807507  :The whidth of line is not ok.
            NodeSet = this.CalculatingXAndYAndWhithAndHeight(NodeSet, xBegin, yBegin, 20, 20, false);

            // System.Windows.Forms.MessageBox.Show("5-3.The Graphically Node calcculated.");

            //ERROR77007 :The problem dose not found.refer to page 130.
            //ERRORCORECTION8756 :The Shift when needed.refer to page 106.
            NodeSet = this.ShiftWhenNeededX(NodeSet);
            NodeSet = this.ShiftWhenNeededY(NodeSet);
            /*
            Set Dummy = new Set();
            this.SetWhidthValueOfNumberNode(NodeSet, ref Dummy);
            NodeSet = Dummy;
            this.SetXValueOfArithmaticsNode(NodeSet, ref Dummy);
            NodeSet = Dummy;
            */

            // System.Windows.Forms.MessageBox.Show("5-4.End Of Inzizilizing.");
        }
        private Set TheSmalestNodeX(Set Node, Set DummySmalest)
        {
            if (Node == null)
                return DummySmalest;
            if (Node.XAccess < DummySmalest.XAccess)
                DummySmalest = Node;
            DummySmalest = this.TheSmalestNodeX(Node.LeftSideAccess, DummySmalest);
            DummySmalest = this.TheSmalestNodeX(Node.RightSideAccess, DummySmalest);
            return DummySmalest;
        }
        private Set TheSmalestNodeY(Set Node, Set DummySmalest)
        {
            if (Node == null)
                return DummySmalest;
            if (Node.YAccess < DummySmalest.YAccess)
                DummySmalest = Node;
            DummySmalest = this.TheSmalestNodeY(Node.LeftSideAccess, DummySmalest);
            DummySmalest = this.TheSmalestNodeY(Node.RightSideAccess, DummySmalest);
            return DummySmalest;
        }
        private Set ShiftActionX(Set Node, int ShiftCount)
        {
            if (Node == null)
                return Node;
            Node.SetDimentions(((Node.XAccess) + ShiftCount), Node.YAccess, Node.WidhtAccess, Node.HieghtAcess);
            this.ShiftActionX(Node.LeftSideAccess, ShiftCount);
            this.ShiftActionX(Node.RightSideAccess, ShiftCount);
            return Node;
        }
        private Set ShiftActionY(Set Node, int ShiftCount)
        {
            if (Node == null)
                return Node;
            Node.SetDimentions(Node.XAccess, Node.YAccess + ShiftCount, Node.WidhtAccess, Node.HieghtAcess);
            this.ShiftActionY(Node.LeftSideAccess, ShiftCount);
            this.ShiftActionY(Node.RightSideAccess, ShiftCount);
            return Node;
        }
        private Set ShiftWhenNeededX(Set Node)
        {
            int x = this.TheSmalestNodeX(Node, Node).XAccess;
            int ShiftCount = 0;
            ShiftCount = 40 - x;
            return this.ShiftActionX(Node, ShiftCount);
        }
        private Set ShiftWhenNeededY(Set Node)
        {
            int y = this.TheSmalestNodeY(Node, Node).YAccess;
            int ShiftCount = 0;
            ShiftCount = 40 - y;
            return this.ShiftActionY(Node, ShiftCount);
        }

        private Set ShiftLeftSideDivisionCurrentNodeYNodesValues(Set CurrentLeftSide, Set Current)
        {
            Set Bigest = new Set();
            //ERRORCORECTION5698670946 :When at mosst one node is at right side of division the addition should not be down.
            if (CurrentLeftSide != null)
                //ERRORCORECTION127609 :The condition leads to invalid operation.refer to page 129.
                //ERRORCORECTION1276097 :deleting condition leads to error 129.(below if condition)
                if (CurrentLeftSide.LeftSideAccess != null)
                {

                    this.ReturnBigestNodeOfLeftSideCurrentDivision(CurrentLeftSide, ref Bigest);
                    int ShiftCount = this.ShiftUpToUpOrDownCount(Bigest, Current);
                    if (ShiftCount != 0)
                        CurrentLeftSide = this.SetActionY(CurrentLeftSide, ShiftCount);
                }
            return CurrentLeftSide;
        }
        private void ReturnBigestNodeOfLeftSideCurrentDivision(Set Current, ref Set Dummy)
        {
            if (Current == null)
                return;
            if (Current != null)
                if (Current.LeftSideAccess != null)
                {
                    if (Current.YAccess <= Current.LeftSideAccess.YAccess)
                        Dummy = Current.LeftSideAccess;
                    this.ReturnBigestNodeOfLeftSideCurrentDivision(Current.LeftSideAccess, ref Dummy);

                }
            if (Current != null)
                if (Current.RightSideAccess != null)
                {   //ERRORCORECTION45038 :refer to page 129.
                    if (Current.YAccess <= Current.RightSideAccess.YAccess)
                        Dummy = Current.RightSideAccess;
                    this.ReturnBigestNodeOfLeftSideCurrentDivision(Current.RightSideAccess, ref Dummy);
                }

            return;
        }
        private int ShiftUpToUpOrDownCount(Set BigestNode, Set DivisionNode)
        {
            int y = 0;
            //The Smallest Vlaue
            if (BigestNode != null)
                if (DivisionNode != null)
                {
                    y = BigestNode.YAccess;
                    y = DivisionNode.YAccess - y - 15;
                }
            return y;
        }

        //Base Node of Y action.
        private Set ShiftRightSideDivisionCurrentNodeYNodesValues(Set CurrentRightSide, Set Current)
        {
            Set Smallest = new Set();
            //ERRORCORECTION5698670946 :When at mosst one node is at right side of division the addition should not be down.
            if (CurrentRightSide != null)
                //ERRORCORECTION127609 :The condition leads to invalid operation.refer to page 129.
                //ERRORCORECTION1276097 :deleting condition leads to error 129.(below if condition)
                if (CurrentRightSide.RightSideAccess != null)
                {
                    this.ReturnSmallestNodeOfRightSideCurrentDivision(CurrentRightSide, ref Smallest);
                    int ShiftCount = this.ShiftDownToUpOrDownCount(Smallest, Current);
                    if (ShiftCount != 0)
                        CurrentRightSide = this.SetActionY(CurrentRightSide, ShiftCount);
                }
            return CurrentRightSide;
        }
        private Set SetActionY(Set Current, int ShiftCount)
        {
            if (Current == null)
                return null;
            Current.SetDimentions(Current.XAccess, Current.YAccess + ShiftCount, Current.WidhtAccess, Current.HieghtAcess);
            Current.SetLefTandRight(this.SetActionY(Current.LeftSideAccess, ShiftCount), this.SetActionY(Current.RightSideAccess, ShiftCount));
            return Current;
        }
        private int ShiftDownToUpOrDownCount(Set SmallestNode, Set DivisionNode)
        {
            int y = 0;
            //The Smallest Vlaue
            if (SmallestNode != null)
                if (DivisionNode != null)
                {
                    y = SmallestNode.YAccess;
                    y = DivisionNode.YAccess - y + 15;
                }
            return y;
        }
        //Gets Smalest y value of rightside node of current division.
        private void ReturnSmallestNodeOfRightSideCurrentDivision(Set Current, ref Set Dummy)
        {
            //Set Dummy = Current.RightSideAccess;
            //Set Dummy = Current.RightSideAccess;
            if (Current == null)
                return;
            if (Current != null)
                if (Current.RightSideAccess != null)
                {
                    //ERRORCORECTION45038 :refer to page 129.
                    if (Current.YAccess >= Current.RightSideAccess.YAccess)
                        Dummy = Current.RightSideAccess;
                    this.ReturnSmallestNodeOfRightSideCurrentDivision(Current.RightSideAccess, ref Dummy);

                }
            if (Current != null)
                if (Current.LeftSideAccess != null)
                {   //ERRORCORECTION45038 :refer to page 129.
                    if (Current.YAccess >= Current.LeftSideAccess.YAccess)
                        Dummy = Current.LeftSideAccess;
                    this.ReturnSmallestNodeOfRightSideCurrentDivision(Current.LeftSideAccess, ref Dummy);
                }

            return;
        }

        public GraphicallyInterface GraphicallyInterfaceAccess
        {
            get { return GraphicallyInterfaceVaribale; }
            set { GraphicallyInterfaceVaribale = value; }
        }
        //this method creats graphically settings
        //for first time both of tow argument is node.on every
        //Call The Node Of Tree And The Node Of Set Should be argument.
        //===**Rememeber befor calling Set Nodes to null;===**
        public Set CreateGraphicallyNodes(AddToTree.Tree Exsit)
        {
            //t
            if (Exsit == null)
                return null;
            Set Current = new Set();
            Current.NodeAccess = Exsit.GetSample();
            Current.SetOneOfThem(Exsit.GetSample());
            Current.SetLefTandRight(this.CreateGraphicallyNodes(Exsit.LeftSideAccess), this.CreateGraphicallyNodes(Exsit.RightSideAccess));
            return Current;
            /*
            //becuase of Exist Not creation correctly The stack overfloaw i encountred            
            //(Error) The Current is not created correctly.
            //The Left Side and right Side Of Current is not created correctlt.
            //===(NO ERROR ON HERE)This Method is work properly.The problem is nodetree cunstruction.===
            Set Current=new Set();
            Current.SetNode(Exsit.GetSample());
            Current.SetOneOfThem(Exsit.GetSample());
            Current.SetLefTandRight(this.CreateGraphicallyNodes(Exsit.LeftSideAccess),this.CreateGraphicallyNodes(Exsit.RightSideAccess));
            return Current;          
             */
        }
        private void SetAttribute(Set Current, AddToTree.Tree Exist)
        {
            if (Exist.GetSample().ToLower() == "no")
                Current.SetOneOfThem("No");
            else
                if (Exist.GetSample().ToLower() == "int")
                Current.SetOneOfThem("Integral");
            else
                    if (Exist.GetSample().ToLower() == "/")
                Current.SetOneOfThem("Line");
            else
                        if (Exist.GetSample().ToLower() == "sin")
                Current.SetOneOfThem("Sin");
            else
                            if (Exist.GetSample().ToLower() == "cos")
                Current.SetOneOfThem("Cos");
            else
                                if (Exist.GetSample().ToLower() == "tan")
                Current.SetOneOfThem("Tan");
            else
                                    if (Exist.GetSample().ToLower() == "sec")
                Current.SetOneOfThem("Sec");
            else
                                        if (Exist.GetSample().ToLower() == "csc")
                Current.SetOneOfThem("Csc");
            else
                                            if (Exist.GetSample().ToLower() == "sic")
                Current.SetOneOfThem("Cerices");
            else
                                                if (Exist.GetSample().ToLower() == "root")
                Current.SetOneOfThem("Root");
            else
                                                    if (Exist.GetSample().ToLower() == "+")
                Current.SetOneOfThem("+");
            else
                                                        if (Exist.GetSample().ToLower() == "-")
                Current.SetOneOfThem("-");
            else
                                                            if (Exist.GetSample().ToLower() == "*")
                Current.SetOneOfThem("*");
            else
                                                                if (Exist.GetSample().ToLower() == "/")
                Current.SetOneOfThem("/");
            else
                                                                    if (Exist.GetSample().ToLower() == "ln")
                Current.SetOneOfThem("Ln");
            else
                                                                        if (Exist.GetSample().ToLower() == "^")
                Current.SetOneOfThem("^");


        }
        private void AddToSetNode(Set C, String t)
        {
            C.NodeAccess = t;
        }
        public void Inizializing()
        {
            NodeTree = GraphicallyInterfaceVaribale.GetNodeTree();
            NodeSet = null;
            NodeSet = new Set();
            //Create Set Node Link List.
            NodeSet = this.CreateGraphicallyNodes(NodeTree);
        }
        private bool IsRoot(int i)
        {
            bool Is = false;
            if (i == 9)
                Is = true;
            return Is;
        }
        private bool IsPower(int i)
        {
            bool Is = false;
            if (i == 17)
                Is = true;
            return Is;
        }
        private bool IsFunction(int t)
        {
            bool Is = false;
            if ((t >= 2) && (t <= 11))
                Is = true;
            //if ((t >= 9) && (t <= 11))
            //  Is = true;
            return Is;
        }
        private bool IsNumber(int i)
        {
            bool Is = false;
            if (i == 12)
                Is = true;
            return Is;
        }
        private bool IsArithmaticsOperator(int t)
        {
            bool Is = false;
            if ((t >= 13) && (t <= 16))
                Is = true;
            if (t == 1)
                Is = true;
            return Is;
        }
        private bool ISindependenceOrNumber(int i)
        {
            bool Is = false;
            if (i == 18)
                Is = true;
            if (i == 12)
                Is = true;
            return Is;
        }
        private bool ISindependence(int i)
        {
            bool Is = false;
            if (i == 18)
                Is = true;
            return Is;
        }
        private bool IsDivision(int i)
        {
            bool Is = false;
            if ((i == 1) || (i == 16))
                Is = true;
            return Is;
        }
        private int BigestCurrentNodeDivisionBigestXAccess(Set Current)
        {
            //ERROR34721530 :This method is completly is wrong.we move this method to end of calXandY.. Method.
            int i = Current.XAccess;
            if (Current.LeftSideAccess == null)
                return i;
            if (i < this.BigestCurrentNodeDivisionBigestXAccess(Current.LeftSideAccess))
                i = this.BigestCurrentNodeDivisionBigestXAccess(Current.LeftSideAccess);
            if (Current.RightSideAccess == null)
                return i;
            if (i < this.BigestCurrentNodeDivisionBigestXAccess(Current.RightSideAccess))
                i = this.BigestCurrentNodeDivisionBigestXAccess(Current.RightSideAccess);
            return i;
        }
        private int BigestCurrentNodeDivisionSmallestXAccess(Set Current)
        {
            //ERROR34721530 :This method is completly is wrong.we move this method to end of calXandY.. Method.
            int i = Current.XAccess;
            if (Current.LeftSideAccess == null)
                return i;
            if (i > this.BigestCurrentNodeDivisionSmallestXAccess(Current.LeftSideAccess))
                i = this.BigestCurrentNodeDivisionSmallestXAccess(Current.LeftSideAccess);
            if (Current.RightSideAccess == null)
                return i;
            if (i > this.BigestCurrentNodeDivisionSmallestXAccess(Current.RightSideAccess))
                i = this.BigestCurrentNodeDivisionSmallestXAccess(Current.RightSideAccess);
            return i;
        }
        private void BigestCurrentNodeDivisionGetYUpEdited(Set Current, ref int y)
        {
            //ERRORCORECTION64740948 :The method has been edited.
            if (Current == null)
                return;
            if (Current != null)
            //if (Current.LeftSideAccess != null)
            {
                if (this.IsDivision(Current.GetDecoder()))
                    y = y - 15;
            }
            this.BigestCurrentNodeDivisionGetYUpEdited(Current.LeftSideAccess, ref y);
            this.BigestCurrentNodeDivisionGetYUpEdited(Current.RightSideAccess, ref y);
            return;
        }

        private int BigestCurrentNodeDivisionGetYUp(Set Current)
        {
            int i = Current.YAccess;
            if (Current.LeftSideAccess == null)
                return i;
            if (i > this.BigestCurrentNodeDivisionGetYUp(Current.LeftSideAccess))
                i = this.BigestCurrentNodeDivisionGetYUp(Current.LeftSideAccess);
            if (Current.RightSideAccess == null)
                return i;
            if (i > this.BigestCurrentNodeDivisionGetYUp(Current.RightSideAccess))
                i = this.BigestCurrentNodeDivisionGetYUp(Current.RightSideAccess);
            return i;
        }

        private int BigestCurrentNodeDivisionGetYDown(Set Current)
        {
            int i = Current.YAccess;
            if (Current.LeftSideAccess == null)
                return i;
            if (i < this.BigestCurrentNodeDivisionGetYDown(Current.LeftSideAccess))
                i = this.BigestCurrentNodeDivisionGetYDown(Current.LeftSideAccess);
            if (Current.RightSideAccess == null)
                return i;
            if (i < this.BigestCurrentNodeDivisionGetYDown(Current.RightSideAccess))
                i = this.BigestCurrentNodeDivisionGetYDown(Current.RightSideAccess);
            return i;
        }
        private int XAccessLocation(Set Current, int x)
        {
            //ERROR3171154210 : Error is the far disTance between strings.
            if (Current == null)
                return 0;
            if (Current != null)
            {

                if (Current.LeftSideAccess != null)
                    if (Current.RightSideAccess != null)
                        if ((this.ISindependenceOrNumber(Current.LeftSideAccess.GetDecoder())) &&
                            (this.ISindependenceOrNumber(Current.RightSideAccess.GetDecoder())))
                        {
                            //ERROR IN power node ERROR12875646
                            if (this.IsPower(Current.GetDecoder()))
                            {
                                //return 5 + (((Current.LeftSideAccess.StringSampleAccess.Length - 1) * 15) + ((Current.RightSideAccess.StringSampleAccess.Length - 1) * 15));
                                //x = 5 + (((Current.LeftSideAccess.StringSampleAccess.Length - 1) * 15) + ((Current.RightSideAccess.StringSampleAccess.Length - 1) * 15));
                                //ERRORCORECTION98238 :The Power value is constructed.
                                x = 5 + (((Current.LeftSideAccess.StringSampleAccess.Length - 1) * 15) + ((Current.RightSideAccess.StringSampleAccess.Length - 1) * 15));
                                goto END;
                            }
                            //ERRORCORECTION87908906
                            if (this.IsArithmaticsOperator(Current.GetDecoder()))
                            {
                                //return 20 + (((Current.LeftSideAccess.StringSampleAccess.Length-1 ) * 15) + ((Current.RightSideAccess.StringSampleAccess.Length-1) * 15));
                                x = 20 + (((Current.LeftSideAccess.StringSampleAccess.Length - 1) * 15) + ((Current.RightSideAccess.StringSampleAccess.Length - 1) * 15));
                                goto END;
                            }
                            if (this.IsDivision(Current.GetDecoder()))
                            {
                                //return 15 + (((Current.LeftSideAccess.StringSampleAccess.Length - 1) * 15) + ((Current.RightSideAccess.StringSampleAccess.Length - 1) * 15));
                                x = 15 + (((Current.LeftSideAccess.StringSampleAccess.Length - 1) * 15) + ((Current.RightSideAccess.StringSampleAccess.Length - 1) * 15));
                                goto END;
                            }
                        }
                //ERRORCORECTION892174982374 :The condition is added.
                if (Current.RightSideAccess == null)
                    if (Current.LeftSideAccess != null)
                        if (this.IsFunction(Current.GetDecoder()))
                        {
                            //ERROR928375 :Condition needed.
                            //ERRORCORECTION98127498234 :The Condition adedd.           
                            if (this.ISindependenceOrNumber(Current.LeftSideAccess.GetDecoder()))
                            {
                                //return ((15 * this.NumberOfFunctionSamplesElements(Current.StringSampleAccess)) + 25);
                                x = ((15 * this.NumberOfFunctionSamplesElements(Current.StringSampleAccess)) + 25);
                                goto END;
                            }
                            else
                            {
                                //return (15 * this.NumberOfFunctionSamplesElements(Current.StringSampleAccess)) + this.XAccessLocation(Current.LeftSideAccess);
                                x = (15 * this.NumberOfFunctionSamplesElements(Current.StringSampleAccess)) + this.XAccessLocation(Current.LeftSideAccess, x);
                                goto END;
                            }
                            //ERRORCORECTION1982748921374 :Corection  of ERROR35724231 and ERROR3572425332 .refer to page 101.condition will be added.
                        }

                //if(Current.LeftSideAccess!=null)
                //    if(Current.RightSideAccess==null)                


                //ERROR23746872365
                //ERRORCORRECTION987248623
                if (Current.LeftSideAccess == null)
                    if (Current.RightSideAccess == null)
                    {

                        //ERRORCORECTION7981248 :The ERROR76982147982347 Corrected.
                        if (this.IsFunction(Current.ThreadAccess.GetDecoder()))
                        {
                            //return (15*this.NumberOfFunctionSamplesElements(Current.ThreadAccess.StringSampleAccess))+5;
                            x = (15 * this.NumberOfFunctionSamplesElements(Current.ThreadAccess.StringSampleAccess)) + 5;
                            goto ENDOFRETURN;
                        }
                        else
                        {
                            //return (15 * Current.StringSampleAccess.Length);
                            //ERROR92874 :by refering to page 112 The right side calculate from here if the condition is getright().getleft().
                            x = 10 + (15 * Current.StringSampleAccess.Length);
                            goto END;
                        }

                    }
            }
            //if(this.IsArithmaticsOperator(Current.RightSideAccess))
            //         return (this.XAccessLocation(Current.LeftSideAccess)+5);
            //ERROR317241 :The XAccessLocation() Calculate incorrectly.refer to page 104.
            //return (this.XAccessLocation(Current.LeftSideAccess) + this.XAccessLocation(Current.RightSideAccess));
            x = x - (this.XAccessLocation(Current.LeftSideAccess, x));
            END:
            //ERRORCORECTION9098218238 :The Function value is constructed and added.     
            if (this.IsFunction(Current.ThreadAccess.GetDecoder()))
                x = x + 15 * this.NumberOfFunctionSamplesElements(Current.ThreadAccess.StringSampleAccess);
            ENDOFRETURN:
            return x;
        }
        private int GetWhidthOfNumber(String Dummy)
        {
            return Dummy.Length * 15;
        }
        private int NumberOfFunctionSamplesElements(String Sample)
        {
            if ((Sample.ToString().ToLower() == "sin")
                || (Sample.ToString().ToLower() == "cos")
                || (Sample.ToString().ToLower() == "tan")
                || (Sample.ToString().ToLower() == "cot")
                || (Sample.ToString().ToLower() == "sec")
                || (Sample.ToString().ToLower() == "csc")
                || (Sample.ToString().ToLower() == "log")
                )
                return 3;
            else
                return 2;
        }
        public void TheSmallestValue(Set SetVariable, ref int xBegin)
        {
            if (SetVariable == null)
                return;
            if (xBegin < (SetVariable.XAccess))
                xBegin = SetVariable.XAccess;
            this.TheSmallestValue(SetVariable.LeftSideAccess, ref xBegin);
            this.TheSmallestValue(SetVariable.RightSideAccess, ref xBegin);
        }
        public void TheBigestValueNodeXForcalculationMethode(Set SetVariable, ref int xBegin)
        {
            if (SetVariable == null)
                return;
            if (xBegin < (SetVariable.XAccess + SetVariable.WidhtAccess))
                xBegin = SetVariable.XAccess + SetVariable.WidhtAccess;
            this.TheBigestValueNodeXForcalculationMethode(SetVariable.LeftSideAccess, ref xBegin);
            this.TheBigestValueNodeXForcalculationMethode(SetVariable.RightSideAccess, ref xBegin);
        }
        private void GetSmallestXOfCurrentNode(Set Current, ref Set Dummy)
        {
            if (Current != null)
            {
                if (Current.LeftSideAccess != null)
                    if (Current.LeftSideAccess.XAccess < Dummy.XAccess)
                    {
                        Dummy = Current.LeftSideAccess;
                        this.GetSmallestXOfCurrentNode(Current.LeftSideAccess, ref Dummy);

                    }
                if (Current.RightSideAccess != null)
                    if (Current.RightSideAccess.XAccess < Dummy.XAccess)
                    {
                        Dummy = Current.RightSideAccess;
                        this.GetSmallestXOfCurrentNode(Current.RightSideAccess, ref Dummy);

                    }
            }
        }
        private void GetBigestXOfCurrentNode(Set Current, ref Set Dummy)
        {
            if (Current != null)
                if (Dummy != null)
                {
                    if (Current.LeftSideAccess != null)
                        if (Current.LeftSideAccess.XAccess > Dummy.XAccess)
                        {
                            Dummy = Current.LeftSideAccess;
                            this.GetBigestXOfCurrentNode(Current.LeftSideAccess, ref Dummy);

                        }
                    if (Current.RightSideAccess != null)
                        if (Current.RightSideAccess.XAccess > Dummy.XAccess)
                        {
                            Dummy = Current.RightSideAccess;
                            this.GetBigestXOfCurrentNode(Current.RightSideAccess, ref Dummy);

                        }
                }
        }
        private int BigestLenghtOfLefTandRightArguments(Set CurrentLeft, Set CurrentRight, ref int LenghtLeft, ref int LenghtRight)
        {
            Set DummySmall = CurrentLeft;
            Set DummyBig = CurrentRight;

            this.GetSmallestXOfCurrentNode(CurrentLeft, ref DummySmall);
            this.GetBigestXOfCurrentNode(CurrentRight, ref DummyBig);

            this.GetSmallestXOfCurrentNode(CurrentRight, ref DummySmall);
            this.GetBigestXOfCurrentNode(CurrentLeft, ref DummyBig);
            int x = 0;
            if (DummyBig != null)
            {
                if (DummySmall != null)
                    x = ((DummyBig.XAccess + DummyBig.StringSampleAccess.Length * 15) - (DummySmall.XAccess));
                else
                    x = (DummyBig.XAccess + DummyBig.StringSampleAccess.Length * 15);
            }
            else
                x = 0;
            return x;


            /*
            while (DummyLeft.LeftSideAccess != null)
            {
                if (LenghtLeft > CurrentLeft.XAccess)
                    LenghtLeft = CurrentLeft.XAccess;
                DummyLeft = DummyLeft.LeftSideAccess;
            }            
            while (DummyRight.RightSideAccess != null)
            {
                int x = CurrentRight.XAccess + CurrentRight.StringSampleAccess.Length * 15;
                if (LenghtRight < x)
                    LenghtRight = x;
                if(this.IsFunction(DummyRight.GetDecoder()))
                    if(DummyRight.LeftSideAccess!=null)
                        DummyRight=DummyRight.LeftSideAccess;
                DummyRight = DummyRight.RightSideAccess;
            }
             */

            //this.BigestLenghtOfLefTandRightArguments(CurrentLeft.LeftSideAccess, CurrentRight.RightSideAccess, ref LenghtLeft, ref LenghtRight);
            //return (LenghtRight-LenghtLeft);

        }
        //For first time the 7th argumnet become true otherwise false
        public Set CalculatingXAndYAndWhithAndHeight(Set Current, int x, int y, int Whidt, int Height, bool InizializingAllowed)
        {
            //   System.Windows.Forms.MessageBox.Show("5.2.1-Entering at calculating method.");
            if (Current == null)
                return Current;
            //     System.Windows.Forms.MessageBox.Show("5.2.2-pass nul condition.");
            //HOLE ERROR : ERROR56289087
            //Inizializing Nodes.
            //ERROR3572425332 :The condition is not allowed.
            //ERROR76982147982347 :value is not calculated corectly.page 101.    
            //ERROR3453276 :refer to page 101.
            //ERROR35417230 :The Curent pow and the left and right side arithmatics is exist on this method but the 
            // The graphically structure of tree has no right side (2) element of "^" current node.refer to page 105.
            //ERRORCUASE8967 Of ERROR35417230 :The base strucure has no element of "2" right side of "^" current node.
            //ERROR311421 :The only ERROR is the far disTance between some strings.
            //ERROR7081235783 :Both of BigestCurrentNodeDivisionGetYUp(...) and BigestCurrentNodeDivisionGetYDown(...) are completly wrong.refr to page 126.
            //ERROR20984098 :The Value of whidth is not set correctly.refer to page 141.
            if (InizializingAllowed)
                this.Inizializing();
            //      System.Windows.Forms.MessageBox.Show("5.2.3-The Inizlizing is act in clacluation.");
            if (Current.LeftSideAccess == null)
                if (Current.RightSideAccess == null)
                {
                    //ERRORCORECTION9287498 :the ERROR3070401 Correction.
                    if (this.IsNumber(Current.GetDecoder()))
                        Current.SetDimentions(x, y, (Current.StringSampleAccess.Length * 15), Height);
                    else
                        Current.SetDimentions(x, y, Whidt, Height);
                    return Current;
                }
            Current.SetDimentions(x, y, Whidt, Height);
            //+-+
            //If current is artith and the left is power
            //and the right side is num or independence.


            //        System.Windows.Forms.MessageBox.Show("5.2.4-Ready for clacluation.");

            if (Current != null)
                if (Current.LeftSideAccess != null)
                    if (Current.RightSideAccess != null)
                        if (this.IsArithmaticsOperator(Current.GetDecoder()))
                            if (this.IsPower(Current.LeftSideAccess.GetDecoder()))
                                if (this.ISindependenceOrNumber(Current.RightSideAccess.GetDecoder()))
                                {
                                    //ERRORCORECTION317243 :refer to page 126.
                                    //ERROR41723110 :refer to page 125.

                                    if (this.IsDivision(Current.GetDecoder()))
                                    {   //t permanently                                        
                                        //ERROR317125507013 :refer to page 126.
                                        //this.CalculatingXAndYAndWhithAndHeight(Current.LeftSideAccess, x + 5,this.BigestCurrentNodeDivisionGetYUp(Current),15, 15, false);
                                        //ERRORCORECTION03840912384 :The y Value Set.refer top page 126
                                        this.CalculatingXAndYAndWhithAndHeight(Current.LeftSideAccess, x + 5, y - 18, 15, 15, false);
                                        //Current.LeftSideAccess.SetDimentions(x + 5, this.BigestCurrentNodeDivisionGetYUp(Current), this.BigestCurrentNodeDivisionBigestXAccess(Current), 15);
                                        //Current.SetDimentions(x, y, Whidt, Height);
                                        //this.CalculatingXAndYAndWhithAndHeight(Current.RightSideAccess, this.XAccessLocation(Current.RightSideAccess,x) + 5, this.BigestCurrentNodeDivisionGetYDown(Current),15, 15, false);
                                        //ERRORCORECTION038409176584 :The y Value Set.refer top page 126
                                        //this.CalculatingXAndYAndWhithAndHeight(Current.RightSideAccess, this.XAccessLocation(Current.RightSideAccess, x) + 5, y + 10, 15, 15, false);
                                        this.CalculatingXAndYAndWhithAndHeight(Current.RightSideAccess, x + 5, y + 18, 15, 15, false);
                                        //Current.LeftSideAccess.SetDimentions(this.XAccessLocation(Current.RightSideAccess) + 5, this.BigestCurrentNodeDivisionGetYDown(Current), this.BigestCurrentNodeDivisionBigestXAccess(Current), 15);
                                        //Current.SetDimentions(x, y, Whidt, Height);
                                    }
                                    else
                                    {
                                        if ((Current.ThreadAccess != null) && IS.IsFunction(Current.ThreadAccess.StringSampleAccess))
                                        {
                                            this.CalculatingXAndYAndWhithAndHeight(Current.LeftSideAccess, Current.ThreadAccess.XAccess + Current.ThreadAccess.StringSampleAccess.Length * 10 + 15, y, 15, 15, false);
                                            //Current.LeftSideAccess.SetDimentions(x-10, y, 15, 15);
                                            //Current.SetDimentions(x, y, Whidt, Height);
                                            Current.XAccess = Current.ThreadAccess.XAccess + Current.ThreadAccess.StringSampleAccess.Length * 10 + 30;
                                            this.CalculatingXAndYAndWhithAndHeight(Current.RightSideAccess, Current.XAccess + 15, y, 15, 15, false);

                                        }
                                        else
                                        {

                                            //t permanently 2
                                            //ERROR239856 : When The x should be entered it dose not work.
                                            //ERROR901204980 :The Thread is set to node.refer to pag 141.
                                            if (Current.ThreadAccess != null)
                                                this.CalculatingXAndYAndWhithAndHeight(Current.LeftSideAccess, Current.ThreadAccess.XAccess + this.XAccessLocation(Current.LeftSideAccess.LeftSideAccess, x), y, 15, 15, false);
                                            else
                                                //ERRORCORECTION98237498 :The Above ERROR (ERROR901204980) set to error.
                                                this.CalculatingXAndYAndWhithAndHeight(Current.LeftSideAccess, this.XAccessLocation(Current.LeftSideAccess.LeftSideAccess, x), y, 15, 15, false);
                                            //Current.SetDimentions(x,y,Whidt,Height);
                                            //Current.LeftSideAccess.SetDimentions(this.XAccessLocation(Current.LeftSideAccess) + Current.ThreadAccess.XAccess + 10, y, 15, 15);
                                            this.CalculatingXAndYAndWhithAndHeight(Current.RightSideAccess, Current.XAccess + Current.WidhtAccess, y, 15, 15, false);
                                            //Current.LeftSideAccess.SetDimentions(x + 10, y, 15, 15);
                                            //Current.SetDimentions(x,y,Whidt, Height);
                                        }
                                    }
                                }
            //If current is artith and the left is independence varibale OR NUMBER
            //and the right side is pow.
            if (Current != null)
                if (Current.LeftSideAccess != null)
                    if (Current.RightSideAccess != null)
                        if (this.IsArithmaticsOperator(Current.GetDecoder()))
                            if (this.ISindependenceOrNumber(Current.LeftSideAccess.GetDecoder()))
                                if (this.IsPower(Current.RightSideAccess.GetDecoder()))
                                {
                                    if (this.IsDivision(Current.GetDecoder()))
                                    {   //t permanently.2
                                        //ERRORCORECTION679847386  :The y Value of a independence variable is atmost 15 .refer to page 127.
                                        //this.CalculatingXAndYAndWhithAndHeight(Current.LeftSideAccess, x + 5, this.BigestCurrentNodeDivisionGetYUp(Current), this.XAccessLocation(Current.LeftSideAccess,x), 15, false);
                                        this.CalculatingXAndYAndWhithAndHeight(Current.LeftSideAccess, x + 5, y - 15, this.XAccessLocation(Current.LeftSideAccess, x), 15, false);
                                        //Current.LeftSideAccess.SetDimentions(x + 5, this.BigestCurrentNodeDivisionGetYUp(Current), this.BigestCurrentNodeDivisionBigestXAccess(Current), 15);
                                        //Current.SetDimentions(x, y, Whidt, Height);
                                        //ERROR3070802113 :The y value has not been correct.
                                        //this.CalculatingXAndYAndWhithAndHeight(Current.RightSideAccess, this.XAccessLocation(Current.RightSideAccess,x) + 5, this.BigestCurrentNodeDivisionGetYDown(Current), this.XAccessLocation(Current.RightSideAccess,x), 15, false);
                                        this.CalculatingXAndYAndWhithAndHeight(Current.RightSideAccess, this.XAccessLocation(Current.RightSideAccess, x) + 5, this.BigestCurrentNodeDivisionGetYDown(Current), this.XAccessLocation(Current.RightSideAccess, x), 15, false);
                                        //Current.LeftSideAccess.SetDimentions(this.XAccessLocation(Current.RightSideAccess) + 5, this.BigestCurrentNodeDivisionGetYDown(Current), this.BigestCurrentNodeDivisionBigestXAccess(Current), 15);
                                        //Current.SetDimentions(x, y, Whidt, Height);
                                    }
                                    else
                                    {
                                        if ((Current.ThreadAccess != null) && IS.IsFunction(Current.ThreadAccess.StringSampleAccess))
                                        {
                                            this.CalculatingXAndYAndWhithAndHeight(Current.LeftSideAccess, Current.ThreadAccess.XAccess + Current.ThreadAccess.StringSampleAccess.Length * 10 + 15, y, 15, 15, false);
                                            //Current.LeftSideAccess.SetDimentions(x-10, y, 15, 15);
                                            //Current.SetDimentions(x, y, Whidt, Height);
                                            Current.XAccess = Current.ThreadAccess.XAccess + Current.ThreadAccess.StringSampleAccess.Length * 10 + 30;
                                            this.CalculatingXAndYAndWhithAndHeight(Current.RightSideAccess, Current.XAccess + 15, y, 15, 15, false);

                                        }
                                        else
                                        {
                                            //ERROR760967 Cuase: The relative Thread is null.another Error cuase is of Value Arguments setting.
                                            //t permanently.2 it is seem to better.
                                            //The error is on current power the left side is independence and the right side is number.
                                            this.CalculatingXAndYAndWhithAndHeight(Current.LeftSideAccess, x - this.XAccessLocation(Current.LeftSideAccess, x) - 10, y, this.XAccessLocation(Current.LeftSideAccess, x) + 15, 15, false);
                                            //Current.SetDimentions(x,y,Whidt,Height);
                                            //Current.LeftSideAccess.SetDimentions(x - 10, y, 15, 15);
                                            this.CalculatingXAndYAndWhithAndHeight(Current.RightSideAccess, x + 15, y, 15, 15, false);
                                            //Current.LeftSideAccess.SetDimentions(x + 10, y, 15, 15);
                                            //Current.SetDimentions(x,y,Whidt, Height);
                                        }
                                    }
                                }
            //==-
            //If current is operator and the left is independence varibale or number
            //and the right side is arrithmatic operator.
            if (Current != null)
                if (Current.LeftSideAccess != null)
                    if (Current.RightSideAccess != null)
                        if (this.IsArithmaticsOperator(Current.GetDecoder()))
                            if (this.ISindependenceOrNumber(Current.LeftSideAccess.GetDecoder()))
                                if (this.IsArithmaticsOperator(Current.RightSideAccess.GetDecoder()))
                                {   //BackArtiAritArit143
                                    if (this.IsDivision(Current.GetDecoder()))
                                    {   //t permanently.2
                                        //ERROR6509705095 :The y value of tow method is invalid.
                                        //this.CalculatingXAndYAndWhithAndHeight(Current.LeftSideAccess, x + 5,this.BigestCurrentNodeDivisionGetYUp(Current),this.XAccessLocation(Current.LeftSideAccess,x), 15, false);
                                        //ERRORCORECTION870989 :Error corection of ERROR6509705095.
                                        this.CalculatingXAndYAndWhithAndHeight(Current.LeftSideAccess, x + 5, y - 15, this.XAccessLocation(Current.LeftSideAccess, x), 15, false);
                                        //Current.LeftSideAccess.SetDimentions(x + 5, this.BigestCurrentNodeDivisionGetYUp(Current), this.BigestCurrentNodeDivisionBigestXAccess(Current), 15);
                                        //Current.SetDimentions(x, y, Whidt, Height);
                                        //ERRORCORECTION8798689056 : The Right argumnet the (Division) Reduced from Displacement.
                                        //this.CalculatingXAndYAndWhithAndHeight(Current.RightSideAccess, x + 5, this.BigestCurrentNodeDivisionGetYDown(Current),15, 15, false);
                                        //ERRORCORECTION870989 :Error corection of ERROR6509705095.
                                        this.CalculatingXAndYAndWhithAndHeight(Current.RightSideAccess, x + 5, y + 15, 15, 15, false);
                                        //Current.LeftSideAccess.SetDimentions(x + 5, this.BigestCurrentNodeDivisionGetYDown(Current), this.BigestCurrentNodeDivisionBigestXAccess(Current), 15);
                                        //Current.SetDimentions(x, y, Whidt, Height);
                                    }
                                    else
                                    {
                                        //ERROR760967 Cuase: The relative Thread is null.another Error cuase is of Value Argumnets setting.
                                        //t permanently.2 it is seem to better.
                                        //The error is on current power the left side is independence and the right side is number.
                                        //ERROR2309890 :Error on XAccessLocation Method.
                                        //ERRORRCORRECTION2409879 : Refer Above.

                                        this.CalculatingXAndYAndWhithAndHeight(Current.LeftSideAccess, x - Current.LeftSideAccess.StringSampleAccess.Length * 10, y, 15, 15, false);
                                        //Current.SetDimentions(x,y,Whidt,Height);
                                        //Current.LeftSideAccess.SetDimentions(x - 10, y, 15, 15);
                                        //ERROR87096587 : The x argument dose not set correctly.Error is form XAccessLocation Method.
                                        //ERROR34567957879087124 :When the rightside is a division operator this is not suitable.
                                        //ERRORCORECTION34569856789 :The condition is added.
                                        if (!(this.IsDivision(Current.RightSideAccess.GetDecoder())))
                                        {
                                            int FunctionNumber = Integral.NumberOfFunctionElementsSet(Current.RightSideAccess.LeftSideAccess);
                                            int ElemenmtNumber = Integral.NumberOfElementsSet(Current.RightSideAccess.LeftSideAccess);
                                            int a = x + ((ElemenmtNumber - FunctionNumber) + FunctionNumber * 3) * 10;
                                            this.CalculatingXAndYAndWhithAndHeight(Current.RightSideAccess, a + 10, y, 15, 15, false);
                                        }
                                        else
                                        {
                                            //int ElementNumber = Integral.NumberOfElementsSet(Current.RightSideAccess.LeftSideAccess);
                                            //int FunctionNumber = Integral.NumberOfFunctionElementsSet(Current.RightSideAccess.LeftSideAccess);
                                            //int a = x + (((ElementNumber - FunctionNumber) + FunctionNumber * 3)) * 10;                             
                                            this.CalculatingXAndYAndWhithAndHeight(Current.RightSideAccess, x + 10, y, 15, 15, false);
                                        }
                                        //Current.LeftSideAccess.SetDimentions(this.XAccessLocation(Current.RightSideAccess.LeftSideAccess) + Current.XAccess, y, 15, 15);
                                        //Current.SetDimentions(x,y,Whidt, Height);
                                    }
                                }
            /*       //This Set Dimentions.
                   //if the node is arithmatics operator 
                   //and right Side is operator and left side is a number.
                        if (Current != null)
                            if (Current.LeftSideAccess != null)
                                if (Current.RightSideAccess != null)
                                    if (this.IsArithmaticsOperator(Current.GetDecoder()))
                                        if (this.IsNumber(Current.LeftSideAccess.GetDecoder()))
                                            if (this.IsArithmaticsOperator(Current.RightSideAccess.GetDecoder()))
                                            {
                                                if (this.IsDivision(Current.GetDecoder()))
                                                {   //t permanently.2 ===
                                                    this.CalculatingXAndYAndWhithAndHeight(Current.LeftSideAccess,x-10, this.BigestCurrentNodeDivisionGetYUp(Current),15, 15, false);
                                                    //Current.LeftSideAccess.SetDimentions(x-10, this.BigestCurrentNodeDivisionGetYUp(Current),15, 15);
                                                    //this.CalculatingXAndYAndWhithAndHeight(Current.RightSideAccess, this.XAccessLocation(Current.RightSideAccess)+10, this.BigestCurrentNodeDivisionGetYDown(Current), 15, 15, false);
                                                    ////Current.LeftSideAccess.SetDimentions(this.XAccessLocation(Current.RightSideAccess)+10, this.BigestCurrentNodeDivisionGetYDown(Current), 15, 15);
                                                    this.CalculatingXAndYAndWhithAndHeight(Current.RightSideAccess, this.XAccessLocation(Current.RightSideAccess) + 10, this.BigestCurrentNodeDivisionGetYDown(Current), 15, 15, false);
                                                    //Current.LeftSideAccess.SetDimentions(this.XAccessLocation(Current.RightSideAccess) + 10, this.BigestCurrentNodeDivisionGetYDown(Current), 15, 15);
                                        
                                                }
                                                else
                                                {  //t permanently.2 ===
                                                    this.CalculatingXAndYAndWhithAndHeight(Current.LeftSideAccess,x-10, y, 15, 15, false);
                                                    //Current.SetDimentions(x, y, Whidt, Height);
                                                    //Current.LeftSideAccess.SetDimentions(x-10, y, 15, 15);
                                                    this.CalculatingXAndYAndWhithAndHeight(Current.RightSideAccess, this.XAccessLocation(Current.RightSideAccess), y, 15, 15, false);
                                                    //Current.LeftSideAccess.SetDimentions(this.XAccessLocation(Current.RightSideAccess), y, 15, 15);
                                                    //Current.SetDimentions(x, y, Whidt, Height);
                                                }
                                            }
                        */
            //if the node is arithmatics operator 
            //and right and left side are arithmatics operator too.
            if (Current != null)
                if (Current.LeftSideAccess != null)
                    if (Current.RightSideAccess != null)
                        if (this.IsArithmaticsOperator(Current.GetDecoder()))
                            if (this.IsArithmaticsOperator(Current.LeftSideAccess.GetDecoder()))
                                if (this.IsArithmaticsOperator(Current.RightSideAccess.GetDecoder()))
                                {
                                    if (this.IsDivision(Current.GetDecoder()))
                                    {
                                        //t permanently.2 ===
                                        int DummyY = 0;
                                        //ERRORANDERRORCORECTION307021 :The condition has been incorected.refer to page 131.
                                        this.BigestCurrentNodeDivisionGetYUpEdited(Current, ref DummyY);
                                        this.CalculatingXAndYAndWhithAndHeight(Current.LeftSideAccess, x + 5, y + DummyY, this.XAccessLocation(Current.LeftSideAccess, x), 15, false);
                                        //Current.LeftSideAccess.SetDimentions(this.XAccessLocation(Current.LeftSideAccess), this.BigestCurrentNodeDivisionGetYUp(Current), 15, 15);
                                        //Current.SetDimentions(x, y, Whidt, Height);

                                        if (Current.LeftSideAccess.LeftSideAccess != null)
                                            this.CalculatingXAndYAndWhithAndHeight(Current.RightSideAccess, x + 5, this.BigestCurrentNodeDivisionGetYDown(Current), 15, 15, false);
                                        //Current.LeftSideAccess.SetDimentions(this.XAccessLocation(Current.RightSideAccess), this.BigestCurrentNodeDivisionGetYDown(Current),15, 15);
                                        //Current.SetDimentions(x, y, Whidt, Height);
                                    }
                                    else if (Current.ThreadAccess != null)
                                    {
                                        //t permanently.2 ===
                                        //ERROR4586203 : the Second argument was not valid.
                                        //ERRORCORRECTION1287657 :the Second argument correct by proper parameter.
                                        //ERROR1254317892 ERROR on Left side.
                                        this.CalculatingXAndYAndWhithAndHeight(Current.LeftSideAccess, Current.ThreadAccess.XAccess + this.XAccessLocation(Current.LeftSideAccess.LeftSideAccess, x) + 15, y, 15, 15, false);
                                        //Current.SetDimentions(x, y, Whidt, Height);
                                        //Current.LeftSideAccess.SetDimentions(Current.LeftSideAccess.XAccess, y, 15, 15);
                                        //ERROR75875123 : On Third argument
                                        //ERRORCORRECTION1276548 : The parameters of third argument correct.
                                        this.CalculatingXAndYAndWhithAndHeight(Current.RightSideAccess, Current.XAccess + this.XAccessLocation(Current.RightSideAccess.LeftSideAccess, x), y, 15, 15, false);
                                        //Current.LeftSideAccess.SetDimentions(this.XAccessLocation(Current.RightSideAccess), y, 15, 15);
                                        //Current.SetDimentions(x, y, Whidt, Height);
                                    }
                                }
            //if the node is arithmatics operator 
            //and rightSide is Function and left side is arithmatics operator.
            if (Current != null)
                if (Current.LeftSideAccess != null)
                    if (Current.RightSideAccess != null)
                        if (this.IsArithmaticsOperator(Current.GetDecoder()))
                            if (this.IsArithmaticsOperator(Current.LeftSideAccess.GetDecoder()))
                                if (this.IsFunction(Current.RightSideAccess.GetDecoder()))
                                {
                                    if (this.IsDivision(Current.GetDecoder()))
                                    {   //t permanently.2
                                        this.CalculatingXAndYAndWhithAndHeight(Current.LeftSideAccess, this.XAccessLocation(Current.LeftSideAccess, x) + 15, this.BigestCurrentNodeDivisionGetYUp(Current), this.BigestCurrentNodeDivisionBigestXAccess(Current), 15, false);

                                        //Current.LeftSideAccess.SetDimentions(this.XAccessLocation(Current.LeftSideAccess), this.BigestCurrentNodeDivisionGetYUp(Current), 15, 15);
                                        //Current.SetDimentions(x, y, Whidt, Height);
                                        this.CalculatingXAndYAndWhithAndHeight(Current.RightSideAccess, x + this.BigestCurrentNodeDivisionBigestXAccess(Current) + 15, this.BigestCurrentNodeDivisionGetYDown(Current), 15, 15, false);
                                        //Current.LeftSideAccess.SetDimentions(x + 10, this.BigestCurrentNodeDivisionGetYDown(Current),15, 15);
                                        //Current.SetDimentions(x, y, Whidt, Height);
                                    }
                                    else
                                    {
                                        //t permanently.2
                                        int ElementNumber = Integral.NumberOfElementsSet(Current.LeftSideAccess.RightSideAccess);
                                        int FunctionNumber = Integral.NumberOfFunctionElementsSet(Current.LeftSideAccess.RightSideAccess);
                                        int a = x - (((ElementNumber - FunctionNumber) + FunctionNumber * 3)) * 10;
                                        this.CalculatingXAndYAndWhithAndHeight(Current.LeftSideAccess, a - 10, y, 15, 15, false);
                                        //Current.LeftSideAccess.SetDimentions(this.XAccessLocation(Current.LeftSideAccess), y, 20, 15);
                                        //Current.SetDimentions(x, y, Whidt, Height);
                                        this.CalculatingXAndYAndWhithAndHeight(Current.RightSideAccess, x + 10, y, 15, 15, false);
                                        //Current.LeftSideAccess.SetDimentions(x+10,y,15,15);
                                        //Current.SetDimentions(x, y, Whidt, Height);
                                    }
                                }

            //if the node is arithmatics operator 
            //and LedtSide is independence and Right side is number.
            //It IS IMPOSSIBLE. ERROR28365876234
            //ERRORCORRECTION236587 :the node is artihmatice and the left side 
            //is independence and the right side is number.
            if (Current != null)
                if (Current.LeftSideAccess != null)
                    if (Current.RightSideAccess != null)
                        if (this.IsArithmaticsOperator(Current.GetDecoder()))
                            if (this.ISindependenceOrNumber(Current.LeftSideAccess.GetDecoder()))
                                if (this.ISindependenceOrNumber(Current.RightSideAccess.GetDecoder()))
                                {
                                    if (this.IsDivision(Current.GetDecoder()))
                                    {   //t permanently 2.
                                        this.CalculatingXAndYAndWhithAndHeight(Current.LeftSideAccess, x + 5, y - 20, this.XAccessLocation(Current.LeftSideAccess, x), 15, false);
                                        //Current.LeftSideAccess.SetDimentions(x+5, y - 20, 15, 15);
                                        //Current.SetDimentions(x, y, Whidt, Height);
                                        this.CalculatingXAndYAndWhithAndHeight(Current.RightSideAccess, x + 5, y + 20, this.XAccessLocation(Current.RightSideAccess, x), 15, false);
                                        //Current.LeftSideAccess.SetDimentions(x+5, y + 20, 15, 15);
                                        //Current.SetDimentions(x, y, Whidt, Height);
                                    }
                                    else
                                    {   //t permanently 2.
                                        //ERROR982374893275 :The left side and the right side is not calculated correctly.
                                        //ERRORCORECTION98214 :the left and right side set correctly.
                                        if ((Current.ThreadAccess != null) && IS.IsFunction(Current.ThreadAccess.StringSampleAccess))
                                        {
                                            this.CalculatingXAndYAndWhithAndHeight(Current.LeftSideAccess, Current.ThreadAccess.XAccess + Current.ThreadAccess.StringSampleAccess.Length * 10 + 15, y, 15, 15, false);
                                            //Current.LeftSideAccess.SetDimentions(x-10, y, 15, 15);
                                            //Current.SetDimentions(x, y, Whidt, Height);
                                            Current.XAccess = Current.ThreadAccess.XAccess + Current.ThreadAccess.StringSampleAccess.Length * 10 + 30;
                                            this.CalculatingXAndYAndWhithAndHeight(Current.RightSideAccess, Current.XAccess + 15, y, 15, 15, false);

                                        }
                                        else
                                        {
                                            this.CalculatingXAndYAndWhithAndHeight(Current.LeftSideAccess, Current.XAccess - Current.LeftSideAccess.StringSampleAccess.Length * 15, y, 15, 15, false);
                                            //Current.LeftSideAccess.SetDimentions(x-10, y, 15, 15);
                                            //Current.SetDimentions(x, y, Whidt, Height);
                                            this.CalculatingXAndYAndWhithAndHeight(Current.RightSideAccess, x + 15, y, 15, 15, false);
                                        }
                                        //Current.LeftSideAccess.SetDimentions(x+10, y, 15, 15);
                                        //Current.SetDimentions(x, y, Whidt, Height);
                                    }
                                }
            if (Current != null)
                if (Current.LeftSideAccess != null)//LOCATINO1872643876786
                    if (Current.RightSideAccess != null)
                        if (this.IsArithmaticsOperator(Current.GetDecoder()))
                            if (this.ISindependenceOrNumber(Current.LeftSideAccess.GetDecoder()))
                                if (this.IsFunction(Current.RightSideAccess.GetDecoder()))
                                {
                                    if (this.IsDivision(Current.GetDecoder()))
                                    {   //t permanently 2.
                                        this.CalculatingXAndYAndWhithAndHeight(Current.LeftSideAccess, x + 5, y - 20, this.XAccessLocation(Current.LeftSideAccess, x), 15, false);
                                        this.CalculatingXAndYAndWhithAndHeight(Current.RightSideAccess, x + 5, y + 20, this.XAccessLocation(Current.RightSideAccess, x), 15, false);
                                    }
                                    else
                                    {   //t permanently 2.
                                        this.CalculatingXAndYAndWhithAndHeight(Current.LeftSideAccess, x - ((Current.LeftSideAccess.StringSampleAccess.Length) * 10) - 10, y, 15, 15, false);
                                        this.CalculatingXAndYAndWhithAndHeight(Current.RightSideAccess, x + 10, y, 15, 15, false);
                                    }
                                }
            if (Current != null)
                if (Current.LeftSideAccess != null)
                    if (Current.RightSideAccess != null)//LOCATINO18726438
                        if (this.IsArithmaticsOperator(Current.GetDecoder()))
                            if (this.IsFunction(Current.LeftSideAccess.GetDecoder()))
                                if (this.ISindependenceOrNumber(Current.RightSideAccess.GetDecoder()))
                                {
                                    if (this.IsDivision(Current.GetDecoder()))
                                    {   //t permanently 2.
                                        this.CalculatingXAndYAndWhithAndHeight(Current.LeftSideAccess, x + 5, y - 20, this.XAccessLocation(Current.LeftSideAccess, x), 15, false);
                                        this.CalculatingXAndYAndWhithAndHeight(Current.RightSideAccess, x + 5, y + 20, this.XAccessLocation(Current.RightSideAccess, x), 15, false);
                                    }
                                    else
                                    {   //t permanently 2.
                                        Set t = new Set();
                                        this.GetBigestXOfCurrentNode(Current.LeftSideAccess, ref t);
                                        this.CalculatingXAndYAndWhithAndHeight(Current.LeftSideAccess, x - t.XAccess - 15, y, 15, 15, false);
                                        this.CalculatingXAndYAndWhithAndHeight(Current.RightSideAccess, x + 25, y, 15, 15, false);
                                    }
                                }

            //if the node is pow operator 
            //and rightSide is number and left side is independence.
            if (Current != null)
                if (Current.LeftSideAccess != null)
                    if (Current.RightSideAccess != null)
                        if (this.IsPower(Current.GetDecoder()))
                            if (this.ISindependenceOrNumber(Current.LeftSideAccess.GetDecoder()))
                                if (this.ISindependenceOrNumber(Current.RightSideAccess.GetDecoder()))
                                {
                                    int Queficient = 1;
                                    if (Current.ThreadAccess != null)
                                        if (this.IsDivision(Current.ThreadAccess.GetDecoder()))
                                            if (Current == (Current.ThreadAccess.RightSideAccess))
                                                Queficient = -1;
                                    if ((Current.ThreadAccess != null) && IS.IsFunction(Current.ThreadAccess.StringSampleAccess))
                                    {
                                        this.CalculatingXAndYAndWhithAndHeight(Current.LeftSideAccess, Current.ThreadAccess.XAccess + Current.ThreadAccess.StringSampleAccess.Length * 10 + 15, y, 15, 15, false);
                                        //Current.LeftSideAccess.SetDimentions(x-10, y, 15, 15);
                                        //Current.SetDimentions(x, y, Whidt, Height);
                                        Current.XAccess = Current.ThreadAccess.XAccess + Current.ThreadAccess.StringSampleAccess.Length * 10 + 30;
                                        this.CalculatingXAndYAndWhithAndHeight(Current.RightSideAccess, Current.XAccess + 5, y - 5, 15, 15, false);

                                    }
                                    else
                                    {
                                        //t permanently.2 It seems to be better.
                                        //ERRORCORECTION9821748 :The Error is constructed.The value is optimized.refer top page 105.
                                        //ERRORCORECTION109824 :The y value set to up.refer to page 143.
                                        //ERROR30701121 :some times The equation is set graphically wrong.refer to page 143.
                                        this.CalculatingXAndYAndWhithAndHeight(Current.LeftSideAccess, x - 10, y - 5 * Queficient, this.XAccessLocation(Current.LeftSideAccess, x) + 5, 15, false);
                                        //Current.LeftSideAccess.SetDimentions(x + 10, y, 15, 15);
                                        //Current.SetDimentions(x, y, Whidt, Height);
                                        //ERORR317215 :The right side node of "^" node is set valued incorectly.
                                        //ERORRCORECTION1238 :The right side node of "^" node set valued corectly.
                                        this.CalculatingXAndYAndWhithAndHeight(Current.RightSideAccess, x + 5, y - 10 * Queficient, this.XAccessLocation(Current.RightSideAccess, x) + 5, 15, false);
                                        //Current.LeftSideAccess.SetDimentions(x + 15, y - 10, 15, 15);
                                        //Current.SetDimentions(x, y, Whidt, Height);
                                    }
                                }
            /*//==+
             //if the node is pow operator 
             //and rightSide is number and left side is independence.
             //and the power thread is arithmatics
             if (Current != null)
                 if (Current.LeftSideAccess != null)
                     if (Current.RightSideAccess != null)
                         if (Current.ThreadAccess != null)
                             if (Current.ThreadAccess.ThreadAccess == null)
                         if (this.IsPower(Current.GetDecoder()))
                             if (this.ISindependence(Current.LeftSideAccess.GetDecoder()))
                                 if (this.IsNumber(Current.RightSideAccess.GetDecoder()))
                                     if (this.IsArithmaticsOperator(Current.ThreadAccess.GetDecoder()))
                                     {   //t permanently.2
                                         // ERROR45768905
                                         //this condition never done.
                                     this.CalculatingXAndYAndWhithAndHeight(Current.LeftSideAccess, Current.ThreadAccess.XAccess + 10, y, 15, 15, false);
                                      //Current.LeftSideAccess.SetDimentions(Current.ThreadAccess.XAccess + 10, y, 15, 15);
                                     //Current.SetDimentions(x, y, Whidt, Height);
                                     this.CalculatingXAndYAndWhithAndHeight(Current.RightSideAccess, x + 12, y - 5, 15, 15, false);
                                     //Current.LeftSideAccess.SetDimentions(x + 12, y - 5, 15, 15);
                                     //Current.SetDimentions(x, y, Whidt, Height);
                                 }
                        */
            //ERROR30701573 :Wehn function is on right side the function dose not work.refer to page .
            //ERROR2734527363 :te argument dose not work. Because  
            //ERROR76293874 :When it recived to this node the calculatingXAndTY... Method X Calculate the child of this node incorectly.
            //if the node is function The Left Side is Argument and the rightside is null.
            if (Current != null)
                if (Current.LeftSideAccess != null)
                    if (Current.RightSideAccess == null)
                        //ERROR73423753 :the function dosnot effect when there is.
                        if (this.IsFunction(Current.GetDecoder()))
                        {   //t permanently 2.
                            //ERROR35724231 :The XAccessLocation Method dose not any effect.
                            this.CalculatingXAndYAndWhithAndHeight(Current.LeftSideAccess, x + Current.StringSampleAccess.Length * 10, y, 15, 15, false);
                            //Current.LeftSideAccess.SetDimentions(x + 10, y, 15, 15);
                            //Current.SetDimentions(x, y, Whidt, Height);
                        }
            //ERRORCORECTION981273 :The Right side if is and left side is null.
            //if the node is function The Left Side is Argument and the rightside is null.
            if (Current != null)
                if (Current.LeftSideAccess == null)
                    if (Current.RightSideAccess != null)
                        if (this.IsFunction(Current.GetDecoder()))
                            this.CalculatingXAndYAndWhithAndHeight(Current.RightSideAccess, x + Current.StringSampleAccess.Length * 10, y, 15, 15, false);


            //if the node is arithmatics operator 
            //and rightSide is arithmatics and left side power.
            //ERROR0921384 :The Value setting is incorectly.The XAccessLocation Method is calculted incorectly.refere to page 104.
            //ERRORCORECTION31574213 :Should correct
            if (Current != null)
                if (Current.LeftSideAccess != null)
                    if (Current.RightSideAccess != null)
                        if (this.IsArithmaticsOperator(Current.GetDecoder()))
                            if (this.IsPower(Current.LeftSideAccess.GetDecoder()))
                                if (this.IsArithmaticsOperator(Current.RightSideAccess.GetDecoder()))
                                {
                                    if (this.IsDivision(Current.GetDecoder()))
                                    {
                                        //t permanently 2. ===
                                        this.CalculatingXAndYAndWhithAndHeight(Current.LeftSideAccess, x + this.XAccessLocation(Current.LeftSideAccess, x), this.BigestCurrentNodeDivisionGetYUp(Current.LeftSideAccess), this.BigestCurrentNodeDivisionBigestXAccess(Current), 15, false);
                                        //Current.LeftSideAccess.SetDimentions(this.XAccessLocation(Current.LeftSideAccess), this.BigestCurrentNodeDivisionBigestXAccess(Current) - 10, 15, 15);
                                        //Current.SetDimentions(x, y, Whidt, Height);
                                        this.CalculatingXAndYAndWhithAndHeight(Current.RightSideAccess, x + this.XAccessLocation(Current.RightSideAccess, x), this.BigestCurrentNodeDivisionGetYDown(Current), this.BigestCurrentNodeDivisionBigestXAccess(Current), 15, false);
                                        //Current.LeftSideAccess.SetDimentions(this.XAccessLocation(Current.RightSideAccess),this.BigestCurrentNodeDivisionBigestXAccess(Current)+10, 15, 15);
                                        //Current.SetDimentions(x, y, Whidt, Height);
                                    }
                                    else
                                    {   //t permanently 2. ===
                                        this.CalculatingXAndYAndWhithAndHeight(Current.LeftSideAccess, x - this.XAccessLocation(Current.LeftSideAccess, x), y, 15, 15, false);
                                        //Current.LeftSideAccess.SetDimentions(this.XAccessLocation(Current.LeftSideAccess), y, 15, 15);
                                        //Current.SetDimentions(x, y, Whidt, Height);
                                        //ERROR31724215 :The Right side is incorectly valued.
                                        int BigestX = 0;
                                        this.TheSmallestValue(Current.LeftSideAccess, ref BigestX);
                                        if (Current.RightSideAccess.LeftSideAccess != null)
                                            //ERROR31724215 :The Right side of current node (+) is valued incorectly.
                                            //ERRORCORECTION189264 :The value set corectly.Error is already exist.
                                            //ERROR41527231 :The lenght of number is not token.and the value of Second Method is Not set correctly.refer to page 106.
                                            //ERRORCORRECTION8237427231 :The lenght of number is set.and the value of Second Method is  set correctly.
                                            this.CalculatingXAndYAndWhithAndHeight(Current.RightSideAccess, x + this.XAccessLocation(Current.RightSideAccess.LeftSideAccess, x) + 10, y, 15, 15, false);
                                        //Current.LeftSideAccess.SetDimentions(this.XAccessLocation(Current.RightSideAccess), y, 15, 15);
                                        //Current.SetDimentions(x, y, Whidt, Height);
                                    }
                                }
            //if the node is function and  
            //and rightSide is null and left side is function too.
            if (Current != null)
                if (Current.LeftSideAccess != null)
                    if (Current.RightSideAccess == null)
                        if (this.IsFunction(Current.GetDecoder()))
                            if (this.IsFunction(Current.LeftSideAccess.GetDecoder()))
                            {
                                //t permanently 2.
                                this.CalculatingXAndYAndWhithAndHeight(Current.LeftSideAccess, x + this.XAccessLocation(Current.LeftSideAccess, x), y, 15, 15, false);
                                //Current.LeftSideAccess.SetDimentions(x - 10, y, 15, 15);
                                //Current.SetDimentions(x, y, Whidt, Height);
                                //this.CalculatingXAndYAndWhithAndHeight(Current.RightSideAccess, x + 10, y, 15, 15, false);
                                //Current.LeftSideAccess.SetDimentions(x + 10, y, 15, 15);
                                //Current.SetDimentions(x, y, Whidt, Height);                                 
                            }
            //if the node is arithmatic and  
            //and rightSide is function and left side is numberorIndependence.
            //ERROR63729387549 :The quality is not valid.
            if (Current != null)
                if (Current.LeftSideAccess != null)
                    if (Current.RightSideAccess != null)
                        if (this.IsArithmaticsOperator(Current.GetDecoder()))
                            if (this.ISindependenceOrNumber(Current.LeftSideAccess.GetDecoder()))
                                if (this.IsFunction(Current.RightSideAccess.GetDecoder()))
                                {
                                    //ERROR31754230 :The division was not.refer to page 138.
                                    //ERRORCORECTION124754230 :The condition added.refer to page 138.
                                    if (this.IsDivision(Current.GetDecoder()))
                                    {   //t permanently 2.

                                        this.CalculatingXAndYAndWhithAndHeight(Current.LeftSideAccess, x + this.XAccessLocation(Current.LeftSideAccess, x) - 5, y - 15, 15, 15, false);
                                        //ERROR3040506077 :The dowen is near line.refer to page 138.
                                        this.CalculatingXAndYAndWhithAndHeight(Current.RightSideAccess, x + this.XAccessLocation(Current.RightSideAccess.LeftSideAccess, x), y + this.BigestCurrentNodeDivisionGetYDown(Current.RightSideAccess), 15, 15, false);

                                    }
                                    else
                                    {
                                        //t permanently 2.
                                        this.CalculatingXAndYAndWhithAndHeight(Current.LeftSideAccess, x - (Current.LeftSideAccess.StringSampleAccess.Length * 15), y, 15, 15, false);
                                        //Current.LeftSideAccess.SetDimentions(x - 10, y, 15, 15);
                                        //Current.SetDimentions(x, y, Whidt, Height);
                                        //ERROR531724125 :The Value is not valid.
                                        //ERRORCORECTION509238749 :The Value is valid.refer to page 106.
                                        this.CalculatingXAndYAndWhithAndHeight(Current.RightSideAccess, x + 10, y, 15, 15, false);
                                        //Current.LeftSideAccess.SetDimentions(x + 10, y, 15, 15);
                                        //Current.SetDimentions(x, y, Whidt, Height);                                 
                                    }
                                }

            /*
          
            //if the node is arithmatics operator 
            //and rightSide is null and left side is independence.
            if (Current != null)
                if (Current.LeftSideAccess != null)
                    if (Current.RightSideAccess == null)
                        if (this.IsArithmaticsOperator(Current.GetDecoder()))
                            if (this.ISindependence(Current.LeftSideAccess.GetDecoder()))                             
                                {
                                    if (this.IsDivision(Current.GetDecoder()))
                                    {   //t permanently 2.
                                        this.CalculatingXAndYAndWhithAndHeight(Current.LeftSideAccess, x + 5, y - 7, 15, 15, false);
                                        //Current.LeftSideAccess.SetDimentions(x + 5, y - 7, 15, 15);
                                        //Current.SetDimentions(x, y, Whidt, Height);
                                        //this.CalculatingXAndYAndWhithAndHeight(Current.RightSideAccess, x + 5, y + 7, 15, 15, false);
                                        ////Current.LeftSideAccess.SetDimentions(x + 5, y + 7, 15, 15);
                                        //Current.SetDimentions(x, y, Whidt, Height);
                                    }
                                    else
                                    {   //t permanently 2.
                                        this.CalculatingXAndYAndWhithAndHeight(Current.LeftSideAccess, x - 10, y, 15, 15, false);
                                        //Current.LeftSideAccess.SetDimentions(x - 10, y, 15, 15);
                                        //Current.SetDimentions(x, y, Whidt, Height);
                                        //this.CalculatingXAndYAndWhithAndHeight(Current.RightSideAccess, x + 10, y, 15, 15, false);
                                        ////Current.LeftSideAccess.SetDimentions(x + 10, y, 15, 15);
                                        //Current.SetDimentions(x, y, Whidt, Height);
                                    }
                                }
 
            */
            //if the node is power 
            //and right and left side are arithmatics operator too.
            if (Current != null)
                if (Current.LeftSideAccess != null)
                    if (Current.RightSideAccess != null)
                        if (this.IsPower(Current.GetDecoder()))
                            if (this.IsArithmaticsOperator(Current.LeftSideAccess.GetDecoder()))
                                if (this.IsArithmaticsOperator(Current.RightSideAccess.GetDecoder()))
                                {
                                    //t permanently.2 === 
                                    //ERROR4586203 : the Second argument was not valid.
                                    //ERRORCORRECTION1287657 :the Second argument correct by proper parameter.
                                    //ERROR1254317892 ERROR on Left side.
                                    //ERROR987324 :The Current.ThreadAccess. is null and The null exeption Occeres.
                                    //this.CalculatingXAndYAndWhithAndHeight(Current.LeftSideAccess, Current.ThreadAccess.XAccess + this.XAccessLocation(Current.LeftSideAccess.LeftSideAccess, x) + 15, y, 15, 15, false);
                                    //ERRORCORECTION31724152 :The Error is corected.
                                    this.CalculatingXAndYAndWhithAndHeight(Current.LeftSideAccess, Current.XAccess - this.XAccessLocation(Current.LeftSideAccess.LeftSideAccess, x) + 5, y, 15, 15, false);
                                    //Current.SetDimentions(x, y, Whidt, Height);
                                    //Current.LeftSideAccess.SetDimentions(Current.LeftSideAccess.XAccess, y, 15, 15);
                                    //ERROR75875123 : On Third argument
                                    //ERRORCORRECTION1276548 : The parameters of third argument correct.
                                    this.CalculatingXAndYAndWhithAndHeight(Current.RightSideAccess, Current.XAccess + this.XAccessLocation(Current.RightSideAccess.LeftSideAccess, x), y - 10, 15, 15, false);
                                    //Current.LeftSideAccess.SetDimentions(this.XAccessLocation(Current.RightSideAccess), y, 15, 15);
                                    //Current.SetDimentions(x, y, Whidt, Height);                             
                                }
            //if the node is arithmatics operator 
            //and rightSide is pow and left side power.
            if (Current != null)
                if (Current.LeftSideAccess != null)
                    if (Current.RightSideAccess != null)
                        if (this.IsArithmaticsOperator(Current.GetDecoder()))
                            if (this.IsPower(Current.LeftSideAccess.GetDecoder()))
                                if (this.IsPower(Current.RightSideAccess.GetDecoder()))
                                {
                                    if (this.IsDivision(Current.GetDecoder()))
                                    {
                                        //t permanently 2. ===
                                        this.CalculatingXAndYAndWhithAndHeight(Current.LeftSideAccess, x + this.XAccessLocation(Current.LeftSideAccess, x), this.BigestCurrentNodeDivisionGetYUp(Current.LeftSideAccess), this.BigestCurrentNodeDivisionBigestXAccess(Current), 15, false);
                                        //Current.LeftSideAccess.SetDimentions(this.XAccessLocation(Current.LeftSideAccess), this.BigestCurrentNodeDivisionBigestXAccess(Current) - 10, 15, 15);
                                        //Current.SetDimentions(x, y, Whidt, Height);
                                        this.CalculatingXAndYAndWhithAndHeight(Current.RightSideAccess, x + this.XAccessLocation(Current.RightSideAccess, x), this.BigestCurrentNodeDivisionGetYDown(Current), this.BigestCurrentNodeDivisionBigestXAccess(Current), 15, false);
                                        //Current.LeftSideAccess.SetDimentions(this.XAccessLocation(Current.RightSideAccess),this.BigestCurrentNodeDivisionBigestXAccess(Current)+10, 15, 15);
                                        //Current.SetDimentions(x, y, Whidt, Height);
                                    }
                                    else
                                    {   //t permanently 2. ===
                                        this.CalculatingXAndYAndWhithAndHeight(Current.LeftSideAccess, x - this.XAccessLocation(Current.LeftSideAccess.LeftSideAccess, x), y, 15, 15, false);
                                        this.CalculatingXAndYAndWhithAndHeight(Current.RightSideAccess, x + this.XAccessLocation(Current.RightSideAccess.LeftSideAccess, x) + 10, y, 15, 15, false);
                                    }

                                }
            //if the node is power and rightSide is pow and left side power.
            if (Current != null)
                if (Current.LeftSideAccess != null)
                    if (Current.RightSideAccess != null)
                        if (this.IsPower(Current.GetDecoder()))
                            if (this.IsPower(Current.LeftSideAccess.GetDecoder()))
                                if (this.IsPower(Current.RightSideAccess.GetDecoder()))
                                {
                                    this.CalculatingXAndYAndWhithAndHeight(Current.LeftSideAccess, x - this.XAccessLocation(Current.LeftSideAccess.LeftSideAccess, x), y + 10, 15, 15, false);

                                    this.CalculatingXAndYAndWhithAndHeight(Current.RightSideAccess, x + this.XAccessLocation(Current.RightSideAccess.LeftSideAccess, x) + 10, y - 10, 15, 15, false);

                                }
            //if the node is power and rightSide is ind and left side is arithmatics.
            if (Current != null)
                if (Current.LeftSideAccess != null)
                    if (Current.RightSideAccess != null)
                        if (this.IsPower(Current.GetDecoder()))
                            if (this.IsArithmaticsOperator(Current.LeftSideAccess.GetDecoder()))
                                if (this.ISindependenceOrNumber(Current.RightSideAccess.GetDecoder()))
                                {
                                    int ElementNumber = Integral.NumberOfElementsSet(Current.LeftSideAccess.RightSideAccess);
                                    int FunctionNumber = Integral.NumberOfFunctionElementsSet(Current.LeftSideAccess.RightSideAccess);
                                    int a = x - (((ElementNumber - FunctionNumber) + FunctionNumber * 3)) * 10;
                                    this.CalculatingXAndYAndWhithAndHeight(Current.LeftSideAccess, a - 10, y, 15, 15, false);
                                    this.CalculatingXAndYAndWhithAndHeight(Current.RightSideAccess, x + 10, y - 10, 15, 15, false);

                                }

            //if the node is power and rightSide is arithmatic and left side is numor var.
            if (Current != null)
                if (Current.LeftSideAccess != null)
                    if (Current.RightSideAccess != null)
                        if (this.IsPower(Current.GetDecoder()))
                            if (this.ISindependenceOrNumber(Current.LeftSideAccess.GetDecoder()))
                                if (this.IsArithmaticsOperator(Current.RightSideAccess.GetDecoder()))
                                {
                                    this.CalculatingXAndYAndWhithAndHeight(Current.LeftSideAccess, x - this.XAccessLocation(Current.LeftSideAccess.LeftSideAccess, x), y, 15, 15, false);
                                    this.CalculatingXAndYAndWhithAndHeight(Current.RightSideAccess, x + this.XAccessLocation(Current.RightSideAccess.LeftSideAccess, x), y - 10, 15, 15, false);

                                }
            //if the node is power and rightSide is in dependence or variable  and left side is function.
            if (Current != null)
                if (Current.LeftSideAccess != null)
                    if (Current.RightSideAccess != null)
                        if (this.IsPower(Current.GetDecoder()))
                            if (this.IsFunction(Current.LeftSideAccess.GetDecoder()))
                                if (this.ISindependenceOrNumber(Current.RightSideAccess.GetDecoder()))
                                {
                                    this.CalculatingXAndYAndWhithAndHeight(Current.LeftSideAccess, x - this.XAccessLocation(Current.LeftSideAccess.LeftSideAccess, x), y, 15, 15, false);
                                    this.CalculatingXAndYAndWhithAndHeight(Current.RightSideAccess, x + this.XAccessLocation(Current.RightSideAccess.LeftSideAccess, x), y - 10, 15, 15, false);

                                }
            //if the node is Artithmatic Operator  and rightSide is in null  and left side of Left is independnce variable.
            if (Current != null)
                if (Current.LeftSideAccess != null)
                    if (Current.RightSideAccess == null)
                        if (this.IsFunction(Current.GetDecoder()))
                            if (this.ISindependence(Current.LeftSideAccess.GetDecoder()))
                            {
                                this.CalculatingXAndYAndWhithAndHeight(Current.LeftSideAccess, x - this.XAccessLocation(Current.LeftSideAccess, x), y, 15, 15, false);

                            }

            //if the node is power and rightSide is function  and left side is ind or var.
            if (Current != null)
                if (Current.LeftSideAccess != null)
                    if (Current.RightSideAccess != null)
                        if (this.IsPower(Current.GetDecoder()))
                            if (this.ISindependenceOrNumber(Current.LeftSideAccess.GetDecoder()))
                                if (this.IsFunction(Current.RightSideAccess.GetDecoder()))
                                {
                                    this.CalculatingXAndYAndWhithAndHeight(Current.LeftSideAccess, x - this.XAccessLocation(Current.LeftSideAccess.LeftSideAccess, x), y, 15, 15, false);
                                    this.CalculatingXAndYAndWhithAndHeight(Current.RightSideAccess, x + 15, y - 10, 15, 15, false);

                                }
            //if the node is arithmatics operator 
            //and rightSide is pow and left side is arithmatics.
            //ERROR41732145 :The graphically draw is incorect.refer to page 111.
            if (Current != null)
                if (Current.LeftSideAccess != null)
                    if (Current.RightSideAccess != null)
                        if (this.IsArithmaticsOperator(Current.GetDecoder()))
                            if (this.IsArithmaticsOperator(Current.LeftSideAccess.GetDecoder()))
                                if (this.IsPower(Current.RightSideAccess.GetDecoder()))
                                {
                                    if (this.IsDivision(Current.GetDecoder()))
                                    {
                                        //ERROR307080 :refer to page 136.
                                        //t permanently 2. ===
                                        this.CalculatingXAndYAndWhithAndHeight(Current.LeftSideAccess, x + this.XAccessLocation(Current.LeftSideAccess, x), this.BigestCurrentNodeDivisionGetYUp(Current.LeftSideAccess), this.BigestCurrentNodeDivisionBigestXAccess(Current), 15, false);
                                        //Current.LeftSideAccess.SetDimentions(this.XAccessLocation(Current.LeftSideAccess), this.BigestCurrentNodeDivisionBigestXAccess(Current) - 10, 15, 15);
                                        //Current.SetDimentions(x, y, Whidt, Height);
                                        this.CalculatingXAndYAndWhithAndHeight(Current.RightSideAccess, x + this.XAccessLocation(Current.RightSideAccess, x), this.BigestCurrentNodeDivisionGetYDown(Current), this.BigestCurrentNodeDivisionBigestXAccess(Current), 15, false);
                                        //Current.LeftSideAccess.SetDimentions(this.XAccessLocation(Current.RightSideAccess),this.BigestCurrentNodeDivisionBigestXAccess(Current)+10, 15, 15);
                                        //Current.SetDimentions(x, y, Whidt, Height);
                                    }
                                    else
                                    {   //t permanently 2. ===
                                        //ERROR514230 :The first method call set value changed.
                                        this.CalculatingXAndYAndWhithAndHeight(Current.LeftSideAccess, x - this.XAccessLocation(Current.LeftSideAccess.RightSideAccess, x), y, 15, 15, false);
                                        this.CalculatingXAndYAndWhithAndHeight(Current.RightSideAccess, x + this.XAccessLocation(Current.RightSideAccess.LeftSideAccess, x) + 10, y, 15, 15, false);
                                    }

                                }
            //if the node is arithmatics operator 
            //and rightSide and left side are function.     
            if (Current != null)
                if (Current.LeftSideAccess != null)
                    if (Current.RightSideAccess != null)
                        if (this.IsArithmaticsOperator(Current.GetDecoder()))
                            if (this.IsFunction(Current.LeftSideAccess.GetDecoder()))
                                if (this.IsFunction(Current.RightSideAccess.GetDecoder()))
                                {
                                    if (this.IsDivision(Current.GetDecoder()))
                                    {
                                        //ERROR30702507 :The x Begining is incorected.refer to page 137.
                                        //ERROR18924 :The y upo and down is incorrected.
                                        //t permanently 2. ===
                                        //this.CalculatingXAndYAndWhithAndHeight(Current.LeftSideAccess, x + this.XAccessLocation(Current.LeftSideAccess, x), this.BigestCurrentNodeDivisionGetYUp(Current.LeftSideAccess), this.BigestCurrentNodeDivisionBigestXAccess(Current), 15, false);
                                        this.CalculatingXAndYAndWhithAndHeight(Current.LeftSideAccess, x - 25, this.BigestCurrentNodeDivisionGetYUp(Current.LeftSideAccess), this.BigestCurrentNodeDivisionBigestXAccess(Current), 15, false);
                                        //Current.LeftSideAccess.SetDimentions(this.XAccessLocation(Current.LeftSideAccess), this.BigestCurrentNodeDivisionBigestXAccess(Current) - 10, 15, 15);
                                        //Current.SetDimentions(x, y, Whidt, Height);
                                        //this.CalculatingXAndYAndWhithAndHeight(Current.RightSideAccess, x + this.XAccessLocation(Current.RightSideAccess, x), this.BigestCurrentNodeDivisionGetYDown(Current), this.BigestCurrentNodeDivisionBigestXAccess(Current), 15, false);
                                        this.CalculatingXAndYAndWhithAndHeight(Current.RightSideAccess, x + (Integral.NumberOfElementsSet(Current.LeftSideAccess) * 15) + 5, this.BigestCurrentNodeDivisionGetYDown(Current), this.BigestCurrentNodeDivisionBigestXAccess(Current), 15, false);
                                        //Current.LeftSideAccess.SetDimentions(this.XAccessLocation(Current.RightSideAccess),this.BigestCurrentNodeDivisionBigestXAccess(Current)+10, 15, 15);
                                        //Current.SetDimentions(x, y, Whidt, Height);
                                    }
                                    else
                                    {   //t permanently 2. ===
                                        //ERROR4172351602 :Far disTance between strings.
                                        int a = 0;
                                        int FunctionNumbner = Integral.NumberOfFunctionElementsSet(Current.LeftSideAccess);
                                        int ElementNumber = Integral.NumberOfElementsSet(Current.LeftSideAccess);
                                        if (Current.ThreadAccess != null)
                                            a = Current.ThreadAccess.XAccess + 10;
                                        else
                                            a = x - (((ElementNumber - FunctionNumbner) + (FunctionNumbner * 3)) * 15) - 10;
                                        this.CalculatingXAndYAndWhithAndHeight(Current.LeftSideAccess, a, y, 15, 15, false); this.TheBigestValueNodeXForcalculationMethode(Current.LeftSideAccess, ref x);
                                        this.CalculatingXAndYAndWhithAndHeight(Current.RightSideAccess, x + 5, y, 15, 15, false);
                                    }

                                }


            //if the node is arithmatics operator 
            //and rightSide is aritmatic and left side is function.     
            if (Current != null)
                if (Current.LeftSideAccess != null)
                    if (Current.RightSideAccess != null)
                        if (this.IsArithmaticsOperator(Current.GetDecoder()))
                            if (this.IsFunction(Current.LeftSideAccess.GetDecoder()))
                                if (this.IsArithmaticsOperator(Current.RightSideAccess.GetDecoder()))
                                {
                                    if (this.IsDivision(Current.GetDecoder()))
                                    {
                                        //ERROR307050 :The far disTance long width line.refer to page 137.
                                        //t permanently 2. ===
                                        this.CalculatingXAndYAndWhithAndHeight(Current.LeftSideAccess, x + this.XAccessLocation(Current.LeftSideAccess, x), this.BigestCurrentNodeDivisionGetYUp(Current.LeftSideAccess), this.BigestCurrentNodeDivisionBigestXAccess(Current), 15, false);
                                        //Current.LeftSideAccess.SetDimentions(this.XAccessLocation(Current.LeftSideAccess), this.BigestCurrentNodeDivisionBigestXAccess(Current) - 10, 15, 15);
                                        //Current.SetDimentions(x, y, Whidt, Height);
                                        this.CalculatingXAndYAndWhithAndHeight(Current.RightSideAccess, x + this.XAccessLocation(Current.RightSideAccess, x), this.BigestCurrentNodeDivisionGetYDown(Current), this.BigestCurrentNodeDivisionBigestXAccess(Current), 15, false);
                                        //Current.LeftSideAccess.SetDimentions(this.XAccessLocation(Current.RightSideAccess),this.BigestCurrentNodeDivisionBigestXAccess(Current)+10, 15, 15);
                                        //Current.SetDimentions(x, y, Whidt, Height);
                                    }
                                    else
                                    {   //t permanently 2. ===                                                                  
                                        this.CalculatingXAndYAndWhithAndHeight(Current.LeftSideAccess, x - this.XAccessLocation(Current.LeftSideAccess, x), y, 15, 15, false);
                                        //ERROR2019348 :The below setting value is incorrect.
                                        //refer to page 112. The leftside() deleted.
                                        this.CalculatingXAndYAndWhithAndHeight(Current.RightSideAccess, x + this.XAccessLocation(Current.RightSideAccess, x), y, 15, 15, false);
                                    }

                                }
            //if the node is arithmatics operator 
            //and rightSide is pow and left side is function.     
            if (Current != null)
                if (Current.LeftSideAccess != null)
                    if (Current.RightSideAccess != null)
                        if (this.IsArithmaticsOperator(Current.GetDecoder()))
                            if (this.IsFunction(Current.LeftSideAccess.GetDecoder()))
                                if (this.IsPower(Current.RightSideAccess.GetDecoder()))
                                {
                                    if (this.IsDivision(Current.GetDecoder()))
                                    {
                                        //ERROR9812734 :The far disTance line.refr to page 137.
                                        //t permanently 2. ===
                                        this.CalculatingXAndYAndWhithAndHeight(Current.LeftSideAccess, x + this.XAccessLocation(Current.LeftSideAccess, x), this.BigestCurrentNodeDivisionGetYUp(Current.LeftSideAccess), this.BigestCurrentNodeDivisionBigestXAccess(Current), 15, false);
                                        //Current.LeftSideAccess.SetDimentions(this.XAccessLocation(Current.LeftSideAccess), this.BigestCurrentNodeDivisionBigestXAccess(Current) - 10, 15, 15);
                                        //Current.SetDimentions(x, y, Whidt, Height);
                                        this.CalculatingXAndYAndWhithAndHeight(Current.RightSideAccess, x + this.XAccessLocation(Current.RightSideAccess, x), this.BigestCurrentNodeDivisionGetYDown(Current), this.BigestCurrentNodeDivisionBigestXAccess(Current), 15, false);
                                        //Current.LeftSideAccess.SetDimentions(this.XAccessLocation(Current.RightSideAccess),this.BigestCurrentNodeDivisionBigestXAccess(Current)+10, 15, 15);
                                        //Current.SetDimentions(x, y, Whidt, Height);
                                    }
                                    else
                                    {   //t permanently 2. ===                                                                  
                                        this.CalculatingXAndYAndWhithAndHeight(Current.LeftSideAccess, x - this.XAccessLocation(Current.LeftSideAccess, x), y, 15, 15, false);
                                        this.CalculatingXAndYAndWhithAndHeight(Current.RightSideAccess, x + this.XAccessLocation(Current.RightSideAccess, x), y, 15, 15, false);
                                    }
                                }
            //if the node is arithmatics operator 
            //and LeftSide is pow and Right side is function.     
            if (Current != null)
                if (Current.LeftSideAccess != null)
                    if (Current.RightSideAccess != null)
                        if (this.IsArithmaticsOperator(Current.GetDecoder()))
                            if (this.IsPower(Current.LeftSideAccess.GetDecoder()))
                                if (this.IsFunction(Current.RightSideAccess.GetDecoder()))
                                {
                                    if (this.IsDivision(Current.GetDecoder()))
                                    {
                                        //ERROR987123 :The Right side function is incorrectly set value.
                                        //t permanently 2. ===
                                        this.CalculatingXAndYAndWhithAndHeight(Current.LeftSideAccess, x + this.XAccessLocation(Current.LeftSideAccess, x), this.BigestCurrentNodeDivisionGetYUp(Current.LeftSideAccess), this.BigestCurrentNodeDivisionBigestXAccess(Current), 15, false);
                                        //Current.LeftSideAccess.SetDimentions(this.XAccessLocation(Current.LeftSideAccess), this.BigestCurrentNodeDivisionBigestXAccess(Current) - 10, 15, 15);
                                        //Current.SetDimentions(x, y, Whidt, Height);
                                        this.CalculatingXAndYAndWhithAndHeight(Current.RightSideAccess, x + this.XAccessLocation(Current.RightSideAccess, x), this.BigestCurrentNodeDivisionGetYDown(Current), this.BigestCurrentNodeDivisionBigestXAccess(Current), 15, false);
                                        //Current.LeftSideAccess.SetDimentions(this.XAccessLocation(Current.RightSideAccess),this.BigestCurrentNodeDivisionBigestXAccess(Current)+10, 15, 15);
                                        //Current.SetDimentions(x, y, Whidt, Height);
                                    }
                                    else
                                    {   //t permanently 2. ===                                                                  
                                        this.CalculatingXAndYAndWhithAndHeight(Current.LeftSideAccess, x - this.XAccessLocation(Current.LeftSideAccess, x), y, 15, 15, false);
                                        this.CalculatingXAndYAndWhithAndHeight(Current.RightSideAccess, x + 5, y, 15, 15, false);
                                    }
                                }
            //if the node is arithmatics operator 
            //and LeftSide is arithmatics and Right side is ind or var.     
            if (Current != null)
                if (Current.LeftSideAccess != null)
                    if (Current.RightSideAccess != null)
                        if (this.IsArithmaticsOperator(Current.GetDecoder()))
                            if (this.IsArithmaticsOperator(Current.LeftSideAccess.GetDecoder()))
                                if (this.ISindependenceOrNumber(Current.RightSideAccess.GetDecoder()))
                                {
                                    if (this.IsDivision(Current.GetDecoder()))
                                    {
                                        //t permanently 2. ===
                                        //ERROR982375 :the line drawn is not set correctly.refer to page 138.
                                        this.CalculatingXAndYAndWhithAndHeight(Current.LeftSideAccess, x + this.XAccessLocation(Current.LeftSideAccess, x), this.BigestCurrentNodeDivisionGetYUp(Current.LeftSideAccess), this.BigestCurrentNodeDivisionBigestXAccess(Current), 15, false);
                                        //Current.LeftSideAccess.SetDimentions(this.XAccessLocation(Current.LeftSideAccess), this.BigestCurrentNodeDivisionBigestXAccess(Current) - 10, 15, 15);
                                        //Current.SetDimentions(x, y, Whidt, Height);
                                        //ERRORCUASE23785 :cause of ERROR28373248754.refer to page 142.
                                        //ERRORCORECTION2428734 : Corection of ERRORCUASE23785.refer top pae 143.
                                        this.CalculatingXAndYAndWhithAndHeight(Current.RightSideAccess, x + this.XAccessLocation(Current.RightSideAccess, x), y + 15, 15, 15, false);
                                        //Current.LeftSideAccess.SetDimentions(this.XAccessLocation(Current.RightSideAccess),this.BigestCurrentNodeDivisionBigestXAccess(Current)+10, 15, 15);
                                        //Current.SetDimentions(x, y, Whidt, Height);
                                    }
                                    else
                                    {   //t permanently 2. ===                                                                  
                                        this.CalculatingXAndYAndWhithAndHeight(Current.LeftSideAccess, x - this.XAccessLocation(Current.LeftSideAccess, x), y, 15, 15, false);
                                        //ERRORCORECTION6756980 :refer to page 140.
                                        if (this.IsDivision(Current.LeftSideAccess.GetDecoder()))
                                        {
                                            x = Current.LeftSideAccess.XAccess + Current.LeftSideAccess.WidhtAccess;
                                            Current.SetDimentions(x, Current.YAccess, Current.WidhtAccess, Current.HieghtAcess);
                                            this.CalculatingXAndYAndWhithAndHeight(Current.RightSideAccess, x + 5, y, 15, 15, false);
                                        }
                                        else
                                        //if (this.IsArithmaticsOperator(Current.LeftSideAccess.GetDecoder()))
                                        {
                                            int p = 0;
                                            this.TheBigestValueNodeXForcalculationMethode(Current.LeftSideAccess.RightSideAccess, ref p);
                                            //x = Current.LeftSideAccess.XAccess + Current.LeftSideAccess.GetWidht();
                                            x = p + 15;
                                            Current.SetDimentions(x, Current.YAccess, Current.WidhtAccess, Current.HieghtAcess);
                                            this.CalculatingXAndYAndWhithAndHeight(Current.RightSideAccess, x + 5, y, 15, 15, false);
                                        }
                                        /*else
                                        {
                                            //ERROR1982478 :The x value dose not set correctly.refer to page 141.
                                            //this.CalculatingXAndYAndWhithAndHeight(Current.RightSideAccess, x + 5, y, 15, 15, false);
                                            int p = 0;
                                           // Set Dummy = Current;
                                            //while (Dummy.ThreadAccess!=null)
                                              //  Dummy = Dummy.ThreadAccess;
                                            this.TheBigestValueNodeXForcalculationMethode(Current.LeftSideAccess, ref p);
                                            p = p - x;
                                            this.CalculatingXAndYAndWhithAndHeight(Current.RightSideAccess, x + 5+p, y, 15, 15, false);
                                        }
                                         */
                                    }
                                }
            //if the node is arithmatics operator 
            //and LeftSide is arithmatics and Right side is function.     
            /*if (Current != null)
                if (Current.LeftSideAccess != null)
                    if (Current.RightSideAccess != null)
                        if (this.IsArithmaticsOperator(Current.GetDecoder()))
                            if (this.IsArithmaticsOperator(Current.LeftSideAccess.GetDecoder()))
                                if (this.IsFunction(Current.RightSideAccess.GetDecoder()))
                                {
                                    if (this.IsDivision(Current.GetDecoder()))
                                    {
                                        //t permanently 2. ===
                                        //ERROR9730405077 :The function is near the line.refer to page 138.
                                        this.CalculatingXAndYAndWhithAndHeight(Current.LeftSideAccess, x + this.XAccessLocation(Current.LeftSideAccess, x), this.BigestCurrentNodeDivisionGetYUp(Current.LeftSideAccess), this.BigestCurrentNodeDivisionBigestXAccess(Current), 15, false);
                                        //Current.LeftSideAccess.SetDimentions(this.XAccessLocation(Current.LeftSideAccess), this.BigestCurrentNodeDivisionBigestXAccess(Current) - 10, 15, 15);
                                        //Current.SetDimentions(x, y, Whidt, Height);
                                        this.CalculatingXAndYAndWhithAndHeight(Current.RightSideAccess, x + this.XAccessLocation(Current.RightSideAccess, x), this.BigestCurrentNodeDivisionGetYDown(Current), this.BigestCurrentNodeDivisionBigestXAccess(Current), 15, false);
                                        //Current.LeftSideAccess.SetDimentions(this.XAccessLocation(Current.RightSideAccess),this.BigestCurrentNodeDivisionBigestXAccess(Current)+10, 15, 15);
                                        //Current.SetDimentions(x, y, Whidt, Height);
                                    }
                                    else
                                    {   //t permanently 2. ===                                                                  
                                        //ERROR41725312 :far disTance netween some string and over lap of Last parantez.
                                        this.CalculatingXAndYAndWhithAndHeight(Current.LeftSideAccess, x - this.XAccessLocation(Current.LeftSideAccess, x), y, 15, 15, false);
                                        this.CalculatingXAndYAndWhithAndHeight(Current.RightSideAccess, x + 10, y, 15, 15, false);
                                    }
                                }
                   */
            //if the node is power operator 
            //and LeftSide is power and Right side is ind or var.     
            if (Current != null)
                if (Current.LeftSideAccess != null)
                    if (Current.RightSideAccess != null)
                        if (this.IsPower(Current.GetDecoder()))
                            if (this.IsPower(Current.LeftSideAccess.GetDecoder()))
                                if (this.ISindependenceOrNumber(Current.RightSideAccess.GetDecoder()))
                                {
                                    this.CalculatingXAndYAndWhithAndHeight(Current.LeftSideAccess, x - this.XAccessLocation(Current.LeftSideAccess, x), y, 15, 15, false);
                                    //ERROR415210: It seems will be an error at y value setting.
                                    this.CalculatingXAndYAndWhithAndHeight(Current.RightSideAccess, x + 5, y - 20, 15, 15, false);
                                }
            //if the node is power and LeftSide is power and Right side is aritmatics operator.     
            if (Current != null)
                if (Current.LeftSideAccess != null)
                    if (Current.RightSideAccess != null)
                        if (this.IsPower(Current.GetDecoder()))
                            if (this.IsPower(Current.LeftSideAccess.GetDecoder()))
                                if (this.IsArithmaticsOperator(Current.RightSideAccess.GetDecoder()))
                                {
                                    //ERROR30407513 :The error are far disTance between some strings and the y value setting.
                                    this.CalculatingXAndYAndWhithAndHeight(Current.LeftSideAccess, x - this.XAccessLocation(Current.LeftSideAccess, x), y, 15, 15, false);
                                    this.CalculatingXAndYAndWhithAndHeight(Current.RightSideAccess, x + this.XAccessLocation(Current.RightSideAccess, x) + 5, y - 20, 15, 15, false);
                                }
            //if the node is power and LeftSide is power and Right side is FUNCTION.     
            if (Current != null)
                if (Current.LeftSideAccess != null)
                    if (Current.RightSideAccess != null)
                        if (this.IsPower(Current.GetDecoder()))
                            if (this.IsPower(Current.LeftSideAccess.GetDecoder()))
                                if (this.IsFunction(Current.RightSideAccess.GetDecoder()))
                                {
                                    //ERROR17412375  :The error are far disTance between some strings and the y value setting.
                                    this.CalculatingXAndYAndWhithAndHeight(Current.LeftSideAccess, x - this.XAccessLocation(Current.LeftSideAccess, x), y, 15, 15, false);
                                    this.CalculatingXAndYAndWhithAndHeight(Current.RightSideAccess, x + 5, y - 20, 15, 15, false);
                                }
            //if the node is power and LeftSide is arithmatics and Right side is power.     
            if (Current != null)
                if (Current.LeftSideAccess != null)
                    if (Current.RightSideAccess != null)
                        if (this.IsPower(Current.GetDecoder()))
                            if (this.IsArithmaticsOperator(Current.LeftSideAccess.GetDecoder()))
                                if (this.IsPower(Current.RightSideAccess.GetDecoder()))
                                {

                                    this.CalculatingXAndYAndWhithAndHeight(Current.LeftSideAccess, x - this.XAccessLocation(Current.LeftSideAccess, x), y, 15, 15, false);
                                    this.CalculatingXAndYAndWhithAndHeight(Current.RightSideAccess, x + this.XAccessLocation(Current.LeftSideAccess, x) + 5, y - 20, 15, 15, false);
                                }

            //if the node is power and LeftSide is function and Right side is power.     
            if (Current != null)
                if (Current.LeftSideAccess != null)
                    if (Current.RightSideAccess != null)
                        if (this.IsPower(Current.GetDecoder()))
                            if (this.IsFunction(Current.LeftSideAccess.GetDecoder()))
                                if (this.IsPower(Current.RightSideAccess.GetDecoder()))
                                {
                                    //ERROR13407035
                                    this.CalculatingXAndYAndWhithAndHeight(Current.LeftSideAccess, x - this.XAccessLocation(Current.LeftSideAccess, x), y, 15, 15, false);
                                    this.CalculatingXAndYAndWhithAndHeight(Current.RightSideAccess, x + this.XAccessLocation(Current.LeftSideAccess, x) + 5, y - 20, 15, 15, false);
                                }

            //if the node is power and LeftSide is arithmatics and Right side is function.     
            if (Current != null)
                if (Current.LeftSideAccess != null)
                    if (Current.RightSideAccess != null)
                        if (this.IsPower(Current.GetDecoder()))
                            if (this.IsArithmaticsOperator(Current.LeftSideAccess.GetDecoder()))
                                if (this.IsFunction(Current.RightSideAccess.GetDecoder()))
                                {
                                    //ERROR17492834 :The error are far disTance between some strings and the y value setting.
                                    this.CalculatingXAndYAndWhithAndHeight(Current.LeftSideAccess, x - this.XAccessLocation(Current.LeftSideAccess, x), y, 15, 15, false);
                                    this.CalculatingXAndYAndWhithAndHeight(Current.RightSideAccess, x + 5, y - 20, 15, 15, false);
                                }

            //if the node is power and LeftSide is ind or var and Right side is power.     
            if (Current != null)
                if (Current.LeftSideAccess != null)
                    if (Current.RightSideAccess != null)
                        if (this.IsPower(Current.GetDecoder()))
                            if (this.ISindependenceOrNumber(Current.LeftSideAccess.GetDecoder()))
                                if (this.IsPower(Current.RightSideAccess.GetDecoder()))
                                {
                                    //ERROR40503017 :The error are far disTance between some strings and the y value setting.
                                    this.CalculatingXAndYAndWhithAndHeight(Current.LeftSideAccess, x - this.XAccessLocation(Current.LeftSideAccess, x), y, 15, 15, false);
                                    this.CalculatingXAndYAndWhithAndHeight(Current.RightSideAccess, x + this.XAccessLocation(Current.RightSideAccess, x) + 5, y - 20, 15, 15, false);
                                }
            //if the node is power and LeftSide is functon and Right side is power.
            if (Current != null)
                if (Current.LeftSideAccess != null)
                    if (Current.RightSideAccess != null)
                        if (this.IsPower(Current.GetDecoder()))
                            if (this.IsFunction(Current.LeftSideAccess.GetDecoder()))
                                if (this.IsPower(Current.RightSideAccess.GetDecoder()))
                                {
                                    //ERROR30715031 :The error are far disTance between some strings and the y value setting.
                                    this.CalculatingXAndYAndWhithAndHeight(Current.LeftSideAccess, x - this.XAccessLocation(Current.LeftSideAccess, x), y, 15, 15, false);
                                    this.CalculatingXAndYAndWhithAndHeight(Current.RightSideAccess, x + this.XAccessLocation(Current.RightSideAccess, x) + 5, y - 10, 15, 15, false);
                                }
            //if the node is power and LeftSide is arithmatics and Right side is function.     
            if (Current != null)
                if (Current.LeftSideAccess != null)
                    if (Current.RightSideAccess != null)
                        if (this.IsPower(Current.GetDecoder()))
                            if (this.IsFunction(Current.LeftSideAccess.GetDecoder()))
                                if (this.IsArithmaticsOperator(Current.RightSideAccess.GetDecoder()))
                                {
                                    //ERROR3078796    :The error are far disTance between some strings and the y value setting.
                                    this.CalculatingXAndYAndWhithAndHeight(Current.LeftSideAccess, x - this.XAccessLocation(Current.LeftSideAccess, x), y, 15, 15, false);
                                    this.CalculatingXAndYAndWhithAndHeight(Current.RightSideAccess, x + this.XAccessLocation(Current.RightSideAccess, x) + 5, y - 10, 15, 15, false);
                                }
            //if the node is power and LeftSide is function and Right side is function.     
            if (Current != null)
                if (Current.LeftSideAccess != null)
                    if (Current.RightSideAccess != null)
                        if (this.IsPower(Current.GetDecoder()))
                            if (this.IsFunction(Current.LeftSideAccess.GetDecoder()))
                                if (this.IsFunction(Current.RightSideAccess.GetDecoder()))
                                {
                                    //ERROR307986    :The error are far disTance between some strings and the y value setting.
                                    this.CalculatingXAndYAndWhithAndHeight(Current.LeftSideAccess, x - this.XAccessLocation(Current.LeftSideAccess, x), y, 15, 15, false);
                                    this.CalculatingXAndYAndWhithAndHeight(Current.RightSideAccess, x + this.XAccessLocation(Current.RightSideAccess, x) + 5, y - 10, 15, 15, false);

                                }

            //if the node is power and rightSide is null and left side power.
            if (Current != null)
                if (Current.LeftSideAccess != null)
                    if (Current.RightSideAccess == null)
                        if (this.IsPower(Current.GetDecoder()))
                            if (this.IsPower(Current.LeftSideAccess.GetDecoder()))
                                this.CalculatingXAndYAndWhithAndHeight(Current.LeftSideAccess, x - this.XAccessLocation(Current.LeftSideAccess.LeftSideAccess, x), y + 10, 15, 15, false);

            //if the node is power and right is null and left side are arithmatics operator too.
            if (Current != null)
                if (Current.LeftSideAccess != null)
                    if (Current.RightSideAccess == null)
                        if (this.IsPower(Current.GetDecoder()))
                            if (this.IsArithmaticsOperator(Current.LeftSideAccess.GetDecoder()))
                                this.CalculatingXAndYAndWhithAndHeight(Current.LeftSideAccess, Current.XAccess - this.XAccessLocation(Current.LeftSideAccess.LeftSideAccess, x) + 5, y, 15, 15, false);
            //if the node is pow operator 
            //and rightSide is null and left side is independence.
            if (Current != null)
                if (Current.LeftSideAccess != null)
                    if (Current.RightSideAccess == null)
                        if (this.IsPower(Current.GetDecoder()))
                            if (this.ISindependenceOrNumber(Current.LeftSideAccess.GetDecoder()))
                                this.CalculatingXAndYAndWhithAndHeight(Current.LeftSideAccess, x - 10, y, this.XAccessLocation(Current.LeftSideAccess, x) + 5, 15, false);

            //if the node is power and rightSide is null  and left side is function.
            if (Current != null)
                if (Current.LeftSideAccess != null)
                    if (Current.RightSideAccess == null)
                        if (this.IsPower(Current.GetDecoder()))
                            if (this.IsFunction(Current.LeftSideAccess.GetDecoder()))
                                this.CalculatingXAndYAndWhithAndHeight(Current.LeftSideAccess, x - this.XAccessLocation(Current.LeftSideAccess.LeftSideAccess, x), y, 15, 15, false);

            //if the node is power and rightSide is pow and left side null.
            if (Current != null)
                if (Current.LeftSideAccess == null)
                    if (Current.RightSideAccess != null)
                        if (this.IsPower(Current.GetDecoder()))
                            if (this.IsPower(Current.RightSideAccess.GetDecoder()))
                                this.CalculatingXAndYAndWhithAndHeight(Current.RightSideAccess, x + this.XAccessLocation(Current.RightSideAccess.LeftSideAccess, x) + 10, y - 10, 15, 15, false);




            //if the node is power and right and left side is null.
            if (Current != null)
                if (Current.LeftSideAccess == null)
                    if (Current.RightSideAccess != null)
                        if (this.IsPower(Current.GetDecoder()))
                            if (this.IsArithmaticsOperator(Current.RightSideAccess.GetDecoder()))
                                this.CalculatingXAndYAndWhithAndHeight(Current.RightSideAccess, Current.XAccess + this.XAccessLocation(Current.RightSideAccess.LeftSideAccess, x), y - 10, 15, 15, false);
            //if the node is pow operator 
            //and rightSide is number and left side is null.
            if (Current != null)
                if (Current.LeftSideAccess == null)
                    if (Current.RightSideAccess != null)
                        if (this.IsPower(Current.GetDecoder()))
                            if (this.ISindependenceOrNumber(Current.RightSideAccess.GetDecoder()))
                                this.CalculatingXAndYAndWhithAndHeight(Current.RightSideAccess, x + 5, y - 10, this.XAccessLocation(Current.RightSideAccess, x) + 5, 15, false);
            //if the node is arithmatics operator 
            //and rightSide is arithmatics null and left side power.
            if (Current != null)
                if (Current.LeftSideAccess != null)
                    if (Current.RightSideAccess == null)
                        if (this.IsArithmaticsOperator(Current.GetDecoder()))
                            if (this.IsPower(Current.LeftSideAccess.GetDecoder()))
                                if (this.IsDivision(Current.GetDecoder()))
                                    this.CalculatingXAndYAndWhithAndHeight(Current.LeftSideAccess, x + this.XAccessLocation(Current.LeftSideAccess, x), this.BigestCurrentNodeDivisionGetYUp(Current.LeftSideAccess), this.BigestCurrentNodeDivisionBigestXAccess(Current), 15, false);
                                else
                                    this.CalculatingXAndYAndWhithAndHeight(Current.LeftSideAccess, x - this.XAccessLocation(Current.LeftSideAccess, x), y, 15, 15, false);

            //if the node is arithmatics operator 
            //and right is null and left side is  arithmatics operator too.
            if (Current != null)
                if (Current.LeftSideAccess != null)
                    if (Current.RightSideAccess == null)
                        if (this.IsArithmaticsOperator(Current.GetDecoder()))
                            if (this.IsArithmaticsOperator(Current.LeftSideAccess.GetDecoder()))
                                if (this.IsDivision(Current.GetDecoder()))
                                    this.CalculatingXAndYAndWhithAndHeight(Current.LeftSideAccess, this.XAccessLocation(Current.LeftSideAccess, x), this.BigestCurrentNodeDivisionGetYUp(Current), this.XAccessLocation(Current.LeftSideAccess, x), 15, false);
                                else
                                    //ERRORCORECTION1872487 :The GetThread was not valid set.
                                    this.CalculatingXAndYAndWhithAndHeight(Current.LeftSideAccess, x - this.XAccessLocation(Current.LeftSideAccess.LeftSideAccess, x) - 5, y, 15, 15, false);

            //If current is artith and the left is independence varibale OR NUMBER
            //and the right side is null.
            if (Current != null)
                if (Current.LeftSideAccess != null)
                    if (Current.RightSideAccess == null)
                        if (this.IsArithmaticsOperator(Current.GetDecoder()))
                            if (this.ISindependenceOrNumber(Current.LeftSideAccess.GetDecoder()))

                                if (this.IsDivision(Current.GetDecoder()))
                                    this.CalculatingXAndYAndWhithAndHeight(Current.LeftSideAccess, x + 5, this.BigestCurrentNodeDivisionGetYUp(Current), this.XAccessLocation(Current.LeftSideAccess, x), 15, false);

                                else
                                    this.CalculatingXAndYAndWhithAndHeight(Current.LeftSideAccess, x - this.XAccessLocation(Current.LeftSideAccess, x) - 10, y, this.XAccessLocation(Current.LeftSideAccess, x) + 15, 15, false);
            //if the node is arithmatics operator 
            //and rightSide is null and left side is function.     
            if (Current != null)
                if (Current.LeftSideAccess != null)
                    if (Current.RightSideAccess == null)
                        if (this.IsArithmaticsOperator(Current.GetDecoder()))
                            if (this.IsFunction(Current.LeftSideAccess.GetDecoder()))
                                if (this.IsDivision(Current.GetDecoder()))
                                    this.CalculatingXAndYAndWhithAndHeight(Current.LeftSideAccess, x + this.XAccessLocation(Current.LeftSideAccess, x), this.BigestCurrentNodeDivisionGetYUp(Current.LeftSideAccess), this.BigestCurrentNodeDivisionBigestXAccess(Current), 15, false);
                                else
                                    this.CalculatingXAndYAndWhithAndHeight(Current.LeftSideAccess, x - this.XAccessLocation(Current.LeftSideAccess, x), y, 15, 15, false);
            //If current is artith and the left is null
            //and the right side is pow.
            if (Current != null)
                if (Current.LeftSideAccess == null)
                    if (Current.RightSideAccess != null)
                        if (this.IsArithmaticsOperator(Current.GetDecoder()))
                            if (this.IsPower(Current.RightSideAccess.GetDecoder()))
                                if (this.IsDivision(Current.GetDecoder()))
                                    this.CalculatingXAndYAndWhithAndHeight(Current.RightSideAccess, this.XAccessLocation(Current.RightSideAccess, x) + 5, this.BigestCurrentNodeDivisionGetYDown(Current), this.XAccessLocation(Current.RightSideAccess, x), 15, false);
                                else
                                    this.CalculatingXAndYAndWhithAndHeight(Current.RightSideAccess, x + 15, y, 15, 15, false);
            //If current is operator and the left is null
            //and the right side is arrithmatic operator.
            if (Current != null)
                if (Current.LeftSideAccess == null)
                    if (Current.RightSideAccess != null)
                        if (this.IsArithmaticsOperator(Current.GetDecoder()))
                            if (this.IsArithmaticsOperator(Current.RightSideAccess.GetDecoder()))
                                if (this.IsDivision(Current.GetDecoder()))
                                    this.CalculatingXAndYAndWhithAndHeight(Current.RightSideAccess, x + 5, this.BigestCurrentNodeDivisionGetYDown(Current), 15, 15, false);
                                else
                                    if (!this.IsDivision(Current.RightSideAccess.GetDecoder()))
                                    this.CalculatingXAndYAndWhithAndHeight(Current.RightSideAccess, this.XAccessLocation(Current.RightSideAccess.LeftSideAccess, x) + Current.XAccess + 25, y, 15, 15, false);
                                else
                                    this.CalculatingXAndYAndWhithAndHeight(Current.RightSideAccess, x + 15, y, 15, 15, false);

            //If current is artith and the left is null
            //and the right side is num or independence.
            if (Current != null)
                if (Current.LeftSideAccess == null)
                    if (Current.RightSideAccess != null)
                        if (this.IsArithmaticsOperator(Current.GetDecoder()))
                            if (this.ISindependenceOrNumber(Current.RightSideAccess.GetDecoder()))
                                if (this.IsDivision(Current.GetDecoder()))
                                    this.CalculatingXAndYAndWhithAndHeight(Current.RightSideAccess, this.XAccessLocation(Current.RightSideAccess, x) + 5, this.BigestCurrentNodeDivisionGetYDown(Current), this.BigestCurrentNodeDivisionBigestXAccess(Current.RightSideAccess), 15, false);
                                else
                                    this.CalculatingXAndYAndWhithAndHeight(Current.RightSideAccess, Current.XAccess + Current.WidhtAccess, y, 15, 15, false);
            //if the node is arithmatics operator 
            //and rightSide is Function and left side is null.
            if (Current != null)
                if (Current.LeftSideAccess == null)
                    if (Current.RightSideAccess != null)
                        if (this.IsArithmaticsOperator(Current.GetDecoder()))
                            if (this.IsFunction(Current.RightSideAccess.GetDecoder()))
                                if (this.IsDivision(Current.GetDecoder()))
                                    this.CalculatingXAndYAndWhithAndHeight(Current.RightSideAccess, x + this.BigestCurrentNodeDivisionBigestXAccess(Current) + 15, this.BigestCurrentNodeDivisionGetYDown(Current), 15, 15, false);
                                else
                                    this.CalculatingXAndYAndWhithAndHeight(Current.RightSideAccess, x + 10, y, 15, 15, false);

            //System.Windows.Forms.MessageBox.Show("5.2.5-The End of Claculation Conditions");

            //ERRORCORECTION12197234 :The location of division condition for the lenght of divisio operator.refer to page 125.           
            //ERROR31012634 :The Hieght of diviosn is very large. refer to page 125.
            //ERRORCORECTION019238709124 :The condition lead to ERROR13725150 deleted.
            if (this.IsDivision(Current.GetDecoder()))
            { //NOTE1982738 :To Set Lenght of Division Operator.refer to page 126.
                int x0 = 1000, x1 = 0;
                //ERROR1243 :The NOTE1982738 has some invalid Concept.refr to page 126.
                //ERROR13725150 :when this method returned the "/" ,widt value was not valid.refer to page 127.
                Current.SetDimentions(x, y, this.BigestLenghtOfLefTandRightArguments(Current.LeftSideAccess, Current.RightSideAccess, ref x0, ref x1), 5);
                //ERRORCORECTION6345012948 :Correction Of ERROR3070802113.refer to page 127.
                //ERROR307021 :TheError is far disTance between line division and right side nodes(below of line division).
                //ERRORCORECTION1897234 :The Some code changed to be corrected.
                //ERROR30704123 :The error is invalid set.refer to page 129.
                Current.SetLefTandRight(Current.LeftSideAccess, this.ShiftRightSideDivisionCurrentNodeYNodesValues(Current.RightSideAccess, Current));
                Current.SetLefTandRight(this.ShiftLeftSideDivisionCurrentNodeYNodesValues(Current.LeftSideAccess, Current), Current.RightSideAccess);
            }
            if (this.IsNumber(Current.GetDecoder()))
                Current.SetDimentions(Current.XAccess, Current.YAccess, this.GetWhidthOfNumber(Current.StringSampleAccess), Current.HieghtAcess);

            // System.Windows.Forms.MessageBox.Show("5.2.4-The end of Clacluation");
            // Current.SetDimentions(x,y,this.BigestCurrentNodeDivisionBigestXAccess(Current)-this.BigestCurrentNodeDivisionSmallestXAccess(Current),2);                   
            return Current;
        }
        private void SetWhidthValueOfNumberNode(Set Node, ref Set Dummy)
        {
            if (Node == null)
                return;
            if (this.IsNumber(Node.GetDecoder()))
            {
                int p = 0;
                p = Node.StringSampleAccess.Length * 15;
                Node.SetDimentions(Node.XAccess, Node.YAccess, p, Node.HieghtAcess);
            }
            this.SetWhidthValueOfNumberNode(Node.LeftSideAccess, ref Dummy);
            this.SetWhidthValueOfNumberNode(Node.RightSideAccess, ref Dummy);
            Dummy = Node;
            return;

        }
        private void SetXValueOfArithmaticsNode(Set Node, ref Set Dummy)
        {
            if (Node == null)
                return;
            this.SetXValueOfArithmaticsNode(Node.LeftSideAccess, ref Dummy);
            this.SetXValueOfArithmaticsNode(Node.RightSideAccess, ref Dummy);
            if (this.IsArithmaticsOperator(Node.GetDecoder()))
            {
                int p = 0;
                if (this.IsArithmaticsOperator(Node.LeftSideAccess.GetDecoder()))
                {
                    p = Node.LeftSideAccess.RightSideAccess.XAccess + Node.LeftSideAccess.RightSideAccess.WidhtAccess + 15;
                    Node.SetDimentions(p, Node.YAccess, Node.WidhtAccess, Node.HieghtAcess);
                }
            }
            Dummy = Node;
            return;

        }

    }
    //This class Create graphically Nodes
    public class Set
    {
        Set LeftSide = null;
        Set RightSide = null;
        Set Thread = null;
        //AddToTree.Tree TreeVariable = null;
        String StringSampel = null;

        //Current Setting Elements.
        int x = 0, y = 0;
        int Width = 0, Height = 0;

        bool Integral = false;//0
        bool Line = false;//1
        bool Sin = false;//2
        bool Cos = false;//3
        bool Tan = false;//4
        bool Cot = false;//5
        bool Sec = false;//6
        bool Csc = false;//7 
        bool Cerices = false;//8
        bool Root = false;//9
        bool Ln = false;//10
        bool Log = false;//11
        bool No = false;//12
        String Number = null;//12
        bool Add = false;//13
        bool Subtract = false;//14
        bool Mul = false;//15
        bool Div = false;//16
        bool Pow = false;//17
        bool Independence = false;//17
        int Decoder = 0;
        public Set()
        {
        }
        public Set CopyNewSet(Set Exsit)
        {
            if (Exsit != null)
            {
                Set Current = new Set();
                Current = Exsit.CopyNewSetAction(Exsit);
                //CASED13171507 :Refer to oage 336.
                //Current.ThreadAccess = Exsit.CopyNewTree(Exsit.ThreadAccess);                
                Current.Add = Exsit.Add;
                Current.Cerices = Exsit.Cerices;
                Current.Cos = Exsit.Cos;
                Current.Cot = Exsit.Cot;
                Current.Csc = Exsit.Csc;
                Current.Decoder = Exsit.Decoder;
                Current.Div = Exsit.Div;
                Current.Height = Exsit.Height;
                Current.Independence = Exsit.Independence;
                Current.Integral = Exsit.Integral;
                Current.LeftSide = Exsit.LeftSide;
                Current.Line = Exsit.Line;
                Current.Ln = Exsit.Ln;
                Current.Log = Exsit.Log;
                Current.Mul = Exsit.Mul;
                Current.No = Exsit.No;
                Current.Number = Exsit.Number;
                Current.Pow = Exsit.Pow;
                Current.RightSide = Exsit.RightSide;
                Current.Root = Exsit.Root;
                Current.Sec = Exsit.Sec;
                Current.Sin = Exsit.Sin;
                Current.StringSampel = Exsit.StringSampel;
                Current.Subtract = Exsit.Subtract;
                Current.Tan = Exsit.Tan;
                Current.Thread = Exsit.Thread;
                Current.Width = Exsit.Width;
                Current.x = Exsit.x;
                Current.y = Exsit.y;

                Current.ThreadAccess = Exsit.ThreadAccess;
                return Current;
            }
            else
                return null;
        }
        public void SetLefTandRightSetCommonlySide(Set L, Set R)
        {
            LeftSide = L;
            RightSide = R;
        }
        public void SetLefTandRightSetReferencelySide(Set L, Set R)
        {
            LeftSide = L;
            RightSide = R;
        }
        public Set CopyNewSetAction(Set Exsit)
        {
            if (Exsit == null)
                return null;
            Set Current = new Set();
            try
            {

                Current.SetLefTandRightSetCommonlySide(Exsit.CopyNewSetAction(Exsit.LeftSideAccess), Exsit.CopyNewSetAction(Exsit.RightSideAccess));
                //ERRORCORECTION091824098.refer to page 177.
                //ERRORCORECTION9812738 :Refet  top age 190.
                Current.Add = Exsit.Add;
                Current.Cerices = Exsit.Cerices;
                Current.Cos = Exsit.Cos;
                Current.Cot = Exsit.Cot;
                Current.Csc = Exsit.Csc;
                Current.Decoder = Exsit.Decoder;
                Current.Div = Exsit.Div;
                Current.Height = Exsit.Height;
                Current.Independence = Exsit.Independence;
                Current.Integral = Exsit.Integral;
                Current.LeftSide = Exsit.LeftSide;
                Current.Line = Exsit.Line;
                Current.Ln = Exsit.Ln;
                Current.Log = Exsit.Log;
                Current.Mul = Exsit.Mul;
                Current.No = Exsit.No;
                Current.Number = Exsit.Number;
                Current.Pow = Exsit.Pow;
                Current.RightSide = Exsit.RightSide;
                Current.Root = Exsit.Root;
                Current.Sec = Exsit.Sec;
                Current.Sin = Exsit.Sin;
                Current.StringSampel = Exsit.StringSampel;
                Current.Subtract = Exsit.Subtract;
                Current.Tan = Exsit.Tan;
                Current.Thread = Exsit.Thread;
                Current.Width = Exsit.Width;
                Current.x = Exsit.x;
                Current.y = Exsit.y;

                Current.LeftSideAccess.ThreadAccess = Current;
                Current.RightSideAccess.ThreadAccess = Current;
            }
            catch (NullReferenceException t)
            { Formulas.ExceptionClass.ExceptionClassMethod(t); }
            return Current;

        }

        public String NumberAcess
        {
            get { return Number; }
            set { Number = value; }
        }
        public String StringSampleAccess
        {
            get { return StringSampel; }
            set { StringSampel = value; }
        }
        public Set ThreadAccess
        {
            get { return Thread; }
            set { Thread = value; }
        }
        public Set LeftSideAccess
        {
            get { return LeftSide; }
            set { LeftSide = value; }
        }
        public int XAccess
        {
            get { return x; }
            set { x = value; }
        }
        public int YAccess
        {
            get { return y; }
            set { y = value; }
        }
        public int WidhtAccess
        {
            get { return Width; }
            set { Width = value; }
        }
        public int HieghtAcess
        {
            get { return Height; }
            set { Height = value; }
        }
        /*public Set RightSideAccess
        {
            return RightSide;
        }
         */
        public Set RightSideAccess
        {
            get { return RightSide; }
            set { RightSide = value; }
        }
        public void SetDimentions(int X0, int y0, int w0, int h0)
        {
            x = X0;
            y = y0;
            Width = w0;
            Height = h0;
        }
        //By every setting cleans before settings.
        public void SetOneOfThem(String t)
        {
            this.ResetAll();
            if (t != null)
                if (t.ToString().ToLower().ToLower() == "integral")
                    Integral = true;
                else
                    if (t.ToString().ToLower() == "line")
                    Line = true;
                else
                        if (t.ToString().ToLower() == "sin")
                    Sin = true;
                else
                            if (t.ToString().ToLower() == "cos")
                    Cos = true;
                else
                                if (t.ToString().ToLower() == "tan")
                    Tan = true;
                else
                                    if (t.ToString().ToLower() == "cot")
                    Cot = true;
                else
                                        if (t.ToString().ToLower() == "sec")
                    Cot = true;
                else
                                            if (t.ToString().ToLower() == "csc")
                    Cot = true;
                else
                                                if (t.ToString().ToLower() == "cerices")
                    Cerices = true;
                else
                                                    if (t.ToString().ToLower() == "root")
                    Root = true;
                else
                                                        if (t.ToString().ToLower() == "ln")
                    Ln = true;
                else
                                                            if (t.ToString().ToLower() == "log")
                    Log = true;
                else
                                                                if (t.ToString().ToLower() == "+")
                    Add = true;
                else
                                                                    if (t.ToString().ToLower() == "-")
                    Subtract = true;
                else
                                                                        if (t.ToString().ToLower() == "/")
                    Div = true;
                else
                                                                            if (t.ToString().ToLower() == "*")
                    Mul = true;
                else
                                                                                if (t.ToString().ToLower() == "^")
                    Pow = true;
                else
                                                                                    if (t.ToString().ToLower() == "x")
                    Independence = true;
                else
                {   //Correctiorn of ERROR560364?
                    //Consider .ERROR is Elready.
                    No = true;
                    Number = t;
                }
        }
        public void ResetAll()
        {
            Integral = false;//0
            Line = false;//1
            Sin = false;//2
            Cos = false;//3
            Tan = false;//4
            Cot = false;//5        
            Sec = false;//6
            Csc = false;//7        
            Cerices = false;//8
            Root = false;//9
            Ln = false;//10
            Log = false;//11
            No = false;//12
            Add = false;//13
            Subtract = false;//14
            Mul = false;//15
            Div = false;//16
            Pow = false;//17
            Independence = false;//18;
        }
        //Insert Left And Right Side
        public void SetLefTandRight(Set L, Set R)
        {
            LeftSide = L;
            RightSide = R;
            //The left side or right side my be null.
            //at this time the null exeption ocures
            if (LeftSide != null)
                LeftSide.Thread = this;
            if (RightSide != null)
                RightSide.Thread = this;
        }
        /*public void SetNode(String t)
        {
             StringSampel =            t;
        }
         */
        public String NodeAccess
        {
            get { return StringSampel; }
            set { StringSampel = value; }
        }
        public int GetDecoder()
        {
            if (Integral)
                Decoder = 0;
            else
                if (Line)
                Decoder = 1;
            else
                    if (Sin)
                Decoder = 2;
            else
                        if (Cos)
                Decoder = 3;
            else
                            if (Tan)
                Decoder = 4;
            else
                                if (Cot)
                Decoder = 5;
            else
                                    if (Sec)
                Decoder = 6;
            else
                                        if (Csc)
                Decoder = 7;
            else
                                            if (Cerices)
                Decoder = 8;
            else
                                                if (Root)
                Decoder = 9;
            else
                                                    if (Ln)
                Decoder = 10;
            else
                                                        if (Log)
                Decoder = 11;
            else
                                                            if (No)
                Decoder = 12;
            else
                                                                if (Add)
                Decoder = 13;
            else
                                                                    if (Subtract)
                Decoder = 14;
            else
                                                                        if (Mul)
                Decoder = 15;
            else
                                                                            if (Div)
                Decoder = 16;
            else
                                                                                if (Pow)
                Decoder = 17;
            else
                                                                                    if (Independence)
                Decoder = 18;

            return Decoder;
        }
        //This Recursive Method Indicate To be A node To Tree.
        public bool IsNodeInTree(AddToTree.Tree Exist)
        {
            Set t = this;
            bool Is = false;
            if (t == null)
                Is = false;
            else
                if (t != null)
            {
                if (t.Equals(Exist))
                    Is = true;
                else
                {
                    if (t.LeftSideAccess != null)
                        if (t.LeftSideAccess.IsNodeInTree(Exist))
                            Is = true;
                    if (t.RightSideAccess != null)
                        if (t.RightSideAccess.IsNodeInTree(Exist))
                            Is = true;
                }
            }
            else
                Is = false;
            return Is;
        }
    }
    //This class stores drawing settings.
    public class EquationTrace
    {
        int MaxX = 0, MaxY = 0, MinX = 100000, MinY = 100000;

        int XTrace = 0, YTrace = 0;
        //static int TraceMovmentCount = 5;
        Set Setvariable = null;
        Set CurrentSetvariable = null;
        Equation Equation = null;
        Graphics g = null;
        AddToTree.reciverContractionTree reciverContractionTreeVaribale = null;
        TraceKind TraceKindVariable = null;
        Set PreviouseNodeForBetweenTraceKindDummy = null;
        AddDeleteNode AddDeleteNodeOperations = null;
        //     Equation HOLDER = null;//new Equation();
        AddToTree.Tree HOLDER = new AddToTree.Tree(null, false);
        bool HolderReady = false;
        bool EquationReady = false;
        EquationTraceInsertion EquationTraceInsertionVariable = null;
        public bool EquationReadyAccess
        {
            get { return EquationReady; }
            set { EquationReady = value; }
        }
        public int XTRACEAccess
        {
            get { return XTrace; }
            set { XTrace = value; }
        }
        public Set CurrentSetAccess
        {
            get { return CurrentSetvariable; }
            set { CurrentSetvariable = value; }
        }
        public EquationTraceInsertion EquationTraceInsertionAccess
        {
            get { return EquationTraceInsertionVariable; }
            set { EquationTraceInsertionVariable = value; }
        }
        public AddToTree.Tree HOLDERAccess
        {
            get { return HOLDER; }
            set { HOLDER = value; }
        }
        public TraceKind TraceKindAccess
        {
            get { return TraceKindVariable; }
            set { TraceKindVariable = value; }

        }
        public bool HolderReadyAccess
        {
            get { return HolderReady; }
            set { HolderReady = value; }

        }
        public int YTRACEAccess
        {
            get { return YTrace; }
            set { YTrace = value; }
        }
        public Set PreviouseNodeForBetweenTraceKindDummyAccess
        {
            get { return PreviouseNodeForBetweenTraceKindDummy; }
            set { PreviouseNodeForBetweenTraceKindDummy = value; }

        }
        private bool IsEqualWithThreadConsiderationCommonlyTS(AddToTree.Tree Node, Set Dummy)
        {
            bool A = false, B = false, C = false;
            bool D = false, E = false, F = false;
            bool G = false, IS = false;
            A = (Node.SampleAccess == Dummy.StringSampleAccess);
            B = (Node.LeftSideAccess == null);
            C = (Dummy.LeftSideAccess == null);
            D = (Node.RightSideAccess == null);
            E = (Dummy.RightSideAccess == null);
            if (!(B || C))
                F = (Node.LeftSideAccess.SampleAccess == Dummy.LeftSideAccess.StringSampleAccess);
            else
                F = true;
            if (!(D || E))
                G = (Node.RightSideAccess.SampleAccess == Dummy.RightSideAccess.StringSampleAccess);
            else
                G = true;
            if (A)
                if (B == C)
                    if (D == E)
                        if (F)
                            if (G)
                                IS = true;
            return IS;
        }
        private AddToTree.Tree GetAddToTreeNode(AddToTree.Tree Node, ref AddToTree.Tree Dummy)
        {
            /*if (Node.LeftSideAccess == null)
                if (Node.RightSideAccess == null)
                    return Dummy;
             */
            //ERRORCORECTION9285 :The Null Eception corection.
            if (Node == null)
                return Dummy;
            //ERROR317542.refer to page 149.
            /*if (Node.LeftSideAccess.SampleAccess == this.PreviouseNodeForBetweenTraceKindDummy.LeftSideAccess.StringSampleAccess) 
            if (Node.SampleAccess == this.PreviouseNodeForBetweenTraceKindDummy.StringSampleAccess)
                if (Node.LeftSideAccess.SampleAccess == this.PreviouseNodeForBetweenTraceKindDummy.LeftSideAccess.StringSampleAccess)
                    if (Node.RightSideAccess.SampleAccess == this.PreviouseNodeForBetweenTraceKindDummy.RightSideAccess.StringSampleAccess)
                        Dummy=Node;
             */
            //ERRORCORECTION09128409 :The Fining of Proper node.
            if (this.IsEqualWithThreadConsiderationCommonlyTS(Node, this.PreviouseNodeForBetweenTraceKindDummy))
                Dummy = Node;
            Dummy = this.GetAddToTreeNode(Node.LeftSideAccess, ref Dummy);
            Dummy = this.GetAddToTreeNode(Node.RightSideAccess, ref Dummy);
            return Dummy;
        }
        //Thread XAndY=new Thread(new ThreadStart(this.TransmiteXAndYTraceAtNodes));
        //Call from Equation.
        //ERROR192874984 :InSome Addition of node The Node is not added to current Node.refer to page 139.
        public EquationTrace(Equation THISE, Set SetS)
        {
            Equation = THISE;
            Setvariable = SetS;
            reciverContractionTreeVaribale = THISE.SenderSampleAccess.AutoSenderAccess.reciverCuntractionTreeAccess;
            EquationTraceInsertionVariable = new EquationTraceInsertion(Equation);
            EquationReady = false;
            //AddDeleteNodeOperations = new AddDeleteNode(THISE, this);
            //AddDeleteNodeOperations.DummySenderSampleAccess.AutoSenderAccess.DrawingAccess.GraphicallyInterfaceAccess.EditorAccesss.Hide();

            //HOLDER = THISE;
            //HOLDER.Hide();
            //HOLDER.SenderSampleAccess.AutoSenderAccess.DrawingAccess.GraphicallyInterfaceAccess.EditorAccesss.Hide();
            //HOLDER.SenderSampleAccess.AutoSenderAccess.DrawingAccess.GraphicallyInterfaceAccess.EditorAccesss.Hide();
            //HOLDER.Hide();
            //THISE.SenderSampleAccess.AutoSenderAccess.DrawingAccess.GraphicallyInterfaceAccess.EditorAccesss.Show();
            //THISE.Show();
            //this.SetNullTree(ref THISE);           

            //XAndY.Start();
        }
        private void SetNullTree(ref Equation THISE)
        {
            THISE.SenderSampleAccess.AutoSenderAccess.reciverCuntractionTreeAccess.NodeAccess.LeftSideAccess = null;
            THISE.SenderSampleAccess.AutoSenderAccess.reciverCuntractionTreeAccess.NodeAccess.RightSideAccess = null;
            THISE.SenderSampleAccess.AutoSenderAccess.reciverCuntractionTreeAccess.NodeAccess.SampleAccess = null;
            THISE.SenderSampleAccess.AutoSenderAccess.reciverCuntractionTreeAccess.NodeAccess.ThreadAccess = null;
        }
        private bool IsFunction(String Sample)
        {
            bool IsFunction = false;
            if (Sample != null)
            {
                if (Sample.ToString().ToLower() == "sin")
                    IsFunction = true;
                else
                    if (Sample.ToString().ToLower() == "cos")
                    IsFunction = true;
                else
                        if (Sample.ToString().ToLower() == "tan")
                    IsFunction = true;
                else
                            if (Sample.ToString().ToLower() == "cot")
                    IsFunction = true;
                else
                                if (Sample.ToString().ToLower() == "sec")
                    IsFunction = true;
                else
                                    if (Sample.ToString().ToLower() == "csc")
                    IsFunction = true;
                else
                                        if (Sample.ToString().ToLower() == "log")
                    IsFunction = true;
                else
                                            if (Sample.ToString().ToLower() == "ln")
                    IsFunction = true;
                if (Sample.ToString().ToLower() == "root")
                    IsFunction = true;
            }
            return IsFunction;
        }
        private bool MovementAlowed(int Preesed)
        {
            bool Is = false;
            if ((Preesed == 6) || (Preesed == 7) || (Preesed == 8) || (Preesed == 9))
                Is = true;

            return Is;
        }

        public void SetSettingsOnMoveButtons(Equation THISE, Set SetS, Graphics GR, int InPressed, TraceKind TRK)
        {
            g = GR;
            Equation = THISE;
            Setvariable = SetS;
            TraceKindVariable = TRK;
            HolderReady = false;
            //UNACTIVATE1307.refer to page 145.
            if (!(this.MovementAlowed(InPressed)))
            {
                //adding operations.
                if (EquationTraceInsertionVariable.EqauationTraceInsertionAccess)
                {
                    this.EquationReady = false;
                    EquationTraceInsertionVariable.SetTraceTreeVariblefunction(THISE);
                    if ((this.EquationReady))
                    {
                        EquationTraceInsertionVariable.EqauationTraceInsertionAccess = false;
                        this.EquationReady = false;
                    }

                }
                /*if (!THISE.LastInsertionTruePreviouseInsertonFalseAccess)
                 {
                     if (AddDeleteNodeOperations == null)
                     {
                         //       THISE.SenderSampleAccess.AutoSenderAccess.DrawingAccess.GraphicallyInterfaceAccess.EditorAccesss.Hide();
                         //     THISE.Hide();
                         //   HOLDER.Show();
                         // HOLDER.SenderSampleAccess.AutoSenderAccess.DrawingAccess.GraphicallyInterfaceAccess.EditorAccesss.Show();
                         //AddDeleteNodeOperations = new AddDeleteNode(THISE, this);
                         //this.HOLDERAccess = THISE;
                         //ERRORCORECTION30178120 :refer to page 150.
                         this.HOLDER = this.HOLDER.CopyNewTree(THISE.SenderAccess.AutoSenderAccess.NodeAccess);
                         //THISE = new Equation(HOLDER);
                         this.SetNullTree(ref THISE);
                         AddDeleteNodeOperations = new AddDeleteNode(THISE, this);
                     }
                     //HOLDER.INTPressedAccess = THISE.INTPressedAccess;
                     //HOLDER.SenderSampleAccess.AutoSenderAccess.DrawingAccess.GraphicsAccess = g;
                     //AddDeleteNodeOperations.DummySenderSampleAccess.AutoSenderAccess.DrawingAccess.GraphicallyInterfaceAccess.EditorAccesss.Hide();
                     //AddDeleteNodeOperations.AddDeleteNodeOperation(HOLDER, this, THISE.ADDTrueDELETEFalseAccess, HOLDER.GetString(InPressed), !THISE.LastInsertionTruePreviouseInsertonFalseAccess);                    
                     AddDeleteNodeOperations.AddDeleteNodeOperation(THISE, this, THISE.ADDTrueDELETEFalseAccess, THISE.GetCurrentSampleFromBoard(InPressed), !THISE.LastInsertionTruePreviouseInsertonFalseAccess);
                     //g = THISE.SenderSampleAccess.AutoSenderAccess.DrawingAccess.GraphicallyInterfaceAccess.EditorAccesss.GraphicsAccess;
                     //ERRORCORECTION120974 :Correction of ERROR09284.
                     g = AddDeleteNodeOperations.DummySenderSampleAccess.AutoSenderAccess.DrawingAccess.GraphicallyInterfaceAccess.EditorAccesss.GraphicsAccess;
                     Setvariable = AddDeleteNodeOperations.DummySenderSampleAccess.AutoSenderAccess.DrawingAccess.ArrtificialItelligenceForGraphicallyDrawingAccess.NodeSetAcesss;
                 }
                 else
                 {
                     //ERRORCORECTION0918248214 :The non null value set to correct error.refer to page 148.
                     //ERROR029184 : The previuse node is null.refer to page 149.
                     if (THISE.DummyEquationTraceVariable != null)
                         AddDeleteNodeOperations = THISE.DummyEquationTraceVariable.AddDeleteNodeOperations;

                     if (AddDeleteNodeOperations != null)
                     {
                            
                         //ERRORCORECTION0923842308 :The Contained varibale of trre nodes.refer to page 148.
                         //AddToTree.Tree TreeVaribale = HOLDER;
                         //ERRORCORECTION192874 :The Location of Main Tree is located below.refer to page 150.
                         AddToTree.Tree TreeVaribale = THISE.DummyEquationTraceVariable.HOLDER;
                         AddToTree.Tree DummyTreeVaribale = THISE.SenderAccess.AutoSenderAccess.NodeAccess;
                         //LOCATION1307:refer to page 150.
                         //AddDeleteNodeOperations.DummySenderSampleAccess.AutoSenderAccess.NodeAccess;
                         AddToTree.Tree TreeVaribalePreviuse = TreeVaribale;
                         TreeVaribalePreviuse = this.GetAddToTreeNode(TreeVaribale, ref TreeVaribalePreviuse);
                         bool LeftTrueRightFalse = false;
                         //ERROR137415 :refer to page 150.
                         if (TreeVaribalePreviuse.ThreadAccess != null)
                             if (TreeVaribalePreviuse.ThreadAccess.LeftSideAccess == TreeVaribalePreviuse)
                                 LeftTrueRightFalse = true;
                             else
                                 LeftTrueRightFalse = false;

                         if (DummyTreeVaribale.LeftSideAccess == null)
                             DummyTreeVaribale.SetLefTandRightCommonlySide(TreeVaribalePreviuse, DummyTreeVaribale.RightSideAccess);
                         else
                             if (DummyTreeVaribale.RightSideAccess == null)
                                 DummyTreeVaribale.SetLefTandRightCommonlySide(DummyTreeVaribale.LeftSideAccess, TreeVaribalePreviuse);



                         if (TreeVaribalePreviuse.ThreadAccess != null)
                         {
                             AddToTree.Tree TH = TreeVaribalePreviuse.ThreadAccess;
                             if (LeftTrueRightFalse)
                             {
                                 TreeVaribalePreviuse.ThreadAccess.SetLefTandRightCommonlySide(DummyTreeVaribale, TreeVaribalePreviuse.ThreadAccess.RightSideAccess);
                                 TH.LeftSideAccess.ThreadAccess = TH;
                             }
                             else
                             {
                                 TreeVaribalePreviuse.ThreadAccess.SetLefTandRightCommonlySide(TreeVaribalePreviuse.ThreadAccess.LeftSideAccess, DummyTreeVaribale);
                                 TH.RightSideAccess.ThreadAccess = TH;
                             }
                         }
                         //ERRORCORECTION137415 :Error Solved.refer to page 150.
                         DummyTreeVaribale.ThreadAccess = TreeVaribalePreviuse.ThreadAccess;


                         DummyTreeVaribale.LeftSideAccess.ThreadAccess = DummyTreeVaribale;
                         DummyTreeVaribale.RightSideAccess.ThreadAccess = DummyTreeVaribale;



                         //AddToTree.Tree Dummy = PreviouseNodeForBetweenTraceKindDummy;
                         //AddToTree.Tree Dummy = TreeVaribalePreviuse;
                         AddToTree.Tree Dummy = TreeVaribalePreviuse;
                         //ERROR307019 :The infinite loop location.refer to page 150.
                         while (Dummy.ThreadAccess != null)
                             Dummy = Dummy.ThreadAccess;
                         //SettingEquation.SenderSampleAccess.AutoSenderAccess.DrawingAccess.ArrtificialItelligenceForGraphicallyDrawingAccess.NodeSetAcesss = Dummy;
                         //HOLDER = THISE;
                         //ERROR9128374  :The Holder Should replaced at Nodes.
                         HOLDER = Dummy;
                         //ERRORCORECTION091284 :The ERROR9128374 corection.
                         THISE.SenderAccess.AutoSenderAccess.NodeAccess = HOLDER;
                         //ERRORCORECTION13704175 :The extra editor Hide.referto page 152.
                         THISE.EquationTraceVariable.AddDeleteNodeOperations.DummySenderSampleAccess.AutoSenderAccess.DrawingAccess.GraphicallyInterfaceAccess.EditorAccesss.Hide();
                         THISE.DummyEquationTraceVariable.AddDeleteNodeOperations = null;
                         THISE.EquationTraceVariable.AddDeleteNodeOperations = null;
                         //AddDeleteNodeOperations = null;
                         HolderReady = true;
                         //HOLDER.Hide();
                         //HOLDER.SenderAccess.AutoSenderAccess.DrawingAccess.GraphicallyInterfaceAccess.EditorAccesss.Hide();
                         //ERROR3174 :Tow editor is.refer to page 152.
                         //(No effect)THISE.SenderAccess.AutoSenderAccess.DrawingAccess.GraphicallyInterfaceAccess.EditorAccesss.Hide();

                         THISE.Show();
                         THISE.SenderAccess.AutoSenderAccess.DrawingAccess.GraphicallyInterfaceAccess.EditorAccesss.Show();
                     }
                 }*/
            }
            else
                EquationTraceInsertionVariable.EqauationTraceInsertionAccess = true;
            //ERROR09284 :The box drawing is not occured.refer to page 146.
            reciverContractionTreeVaribale = THISE.SenderSampleAccess.AutoSenderAccess.reciverCuntractionTreeAccess;
            //To Calculate Border chart.
            MaxX = 0; MaxY = 0; MinX = 100000; MinY = 100000;
            this.CalculateMaxMinXAandY();
            if ((XTrace == 0) && (YTrace == 0))
                this.SetXTraceAndYTrace();
            else
                if (!this.MovementAlowed(InPressed))
                this.CurrentNodeXTraceAndYtrace();
            else
            {
                if (TraceKindVariable.RadioButtonOneAcess.Checked)
                {
                    bool SET = true;
                    this.TransmiteXAndYTraceAtNodes(Setvariable, ref SET);
                    this.DrawBoxAroundDummyAtNodeKind();
                }
                else
                    if (TraceKindVariable.RadioButtonTowAcess.Checked)
                {
                    bool SET = true;
                    this.TransmiteXAndYTraceAtNodes(Setvariable, ref SET);
                    this.DrawBoxAroundDummyAtNodeKind();
                    SET = true;
                    this.TransmiteXAndYTraceBetweenNodes(Setvariable, ref SET);
                    this.DrawBoxAroundDummyAtBetweenNodeKind();
                }
            }
            this.DrawBox();

            if (!this.MovementAlowed(InPressed))
            {
                if ((XTrace == MinX) && (YTrace == MinY))
                    this.DrawTraceSimbolOnTopLeftNode();
                else
                    if ((XTrace == MinX) && (YTrace == MaxY))
                    this.DrawTraceSimbolOnBelowLeftNode();
                else
                        if ((XTrace == MaxX) && (YTrace == MinY))
                    this.DrawTraceSimbolOnTopRightNode();
                else
                            if ((XTrace == MaxX) && (YTrace == MaxY))
                    this.DrawTraceSimbolOnBelowRightNode();
                else
                                if (YTrace == MaxY)
                    this.DrawTraceSimbolOnBloweNode();
                else
                                    if (YTrace == MinY)
                    this.DrawTraceSimbolOnTopNode();
                else
                                        if (XTrace == MinX)
                    this.DrawTraceSimbolOnLeftNode();
                else
                                            if (XTrace == MaxX)
                    this.DrawTraceSimbolOnRightNode();
                else
                    this.DrawTraceSimbolToSelect();

            }

        }
        private void CurrentNodeXTraceAndYtrace()
        {
            Set Dummy = Setvariable;
            while (Dummy.RightSideAccess != null)
            {
                Dummy = Dummy.RightSideAccess;
                if (this.IsFunction(Dummy.StringSampleAccess))
                    if (Dummy.RightSideAccess == null)
                        if (Dummy.LeftSideAccess != null)
                            Dummy = Dummy.LeftSideAccess;
            }
            XTrace = Dummy.XAccess + Dummy.WidhtAccess;
            YTrace = Dummy.YAccess;
        }
        private void SetXTraceAndYTrace()
        {
            XTrace = (MaxX + MinX) / 2;
            YTrace = (MaxY + MinY) / 2;
        }
        private void DrawBox()
        {
            Pen P = new Pen(Color.Red);
            float[] a = new float[2];
            float j = 0;
            for (int i = 0; i < 2; i++)
            {
                a[i] = j;
                j = (float)(j + 0.5);
            }
            P.CompoundArray = a;
            P.DashStyle = System.Drawing.Drawing2D.DashStyle.DashDotDot;
            g.DrawRectangle(P, MinX, MinY, MaxX - MinX, MaxY - MinY);
        }
        private void DrawTraceSimbolToSelect()
        {
            g.DrawLine(new Pen(Color.Blue, 2), XTrace, YTrace - 5, XTrace, YTrace + 5);
            g.DrawLine(new Pen(Color.Blue, 2), XTrace - 5, YTrace, XTrace + 5, YTrace);
        }
        private void DrawTraceSimbolOnTopNode()
        {
            g.DrawLine(new Pen(Color.Blue, 2), XTrace, YTrace, XTrace, YTrace + 5);
            g.DrawLine(new Pen(Color.Blue, 2), XTrace - 5, YTrace, XTrace + 5, YTrace);
        }
        private void DrawTraceSimbolOnLeftNode()
        {
            g.DrawLine(new Pen(Color.Blue, 2), XTrace, YTrace - 5, XTrace, YTrace + 5);
            g.DrawLine(new Pen(Color.Blue, 2), XTrace, YTrace, XTrace + 5, YTrace);
        }
        private void DrawTraceSimbolOnRightNode()
        {
            g.DrawLine(new Pen(Color.Blue, 2), XTrace, YTrace - 5, XTrace, YTrace + 5);
            g.DrawLine(new Pen(Color.Blue, 2), XTrace, YTrace, XTrace - 5, YTrace);
        }
        private void DrawTraceSimbolOnBloweNode()
        {
            g.DrawLine(new Pen(Color.Blue, 2), XTrace, YTrace - 10, XTrace, YTrace);
            g.DrawLine(new Pen(Color.Blue, 2), XTrace - 5, YTrace, XTrace + 5, YTrace);
        }
        private void DrawTraceSimbolOnTopLeftNode()
        {
            g.DrawLine(new Pen(Color.Blue, 2), XTrace, YTrace, XTrace, YTrace + 5);
            g.DrawLine(new Pen(Color.Blue, 2), XTrace, YTrace, XTrace + 5, YTrace);
        }
        private void DrawTraceSimbolOnBelowLeftNode()
        {
            g.DrawLine(new Pen(Color.Blue, 2), XTrace, YTrace, XTrace, YTrace - 5);
            g.DrawLine(new Pen(Color.Blue, 2), XTrace, YTrace, XTrace + 5, YTrace);
        }
        private void DrawTraceSimbolOnTopRightNode()
        {
            g.DrawLine(new Pen(Color.Blue, 2), XTrace, YTrace, XTrace, YTrace + 5);
            g.DrawLine(new Pen(Color.Blue, 2), XTrace - 5, YTrace, XTrace, YTrace);
        }
        private void DrawTraceSimbolOnBelowRightNode()
        {
            g.DrawLine(new Pen(Color.Blue, 2), XTrace, YTrace - 5, XTrace, YTrace);
            g.DrawLine(new Pen(Color.Blue, 2), XTrace - 5, YTrace, XTrace, YTrace);
        }
        private void DrawBoxAroundDummyAtNodeKind()
        {
            Set Dummy = new Set();
            this.GetNodeOfXTraceAndYTrace(Setvariable, ref Dummy);
            CurrentSetvariable = Dummy;
            Pen P = new Pen(Color.Green);
            float[] a = new float[2];
            float j = 0;
            for (int i = 0; i < 2; i++)
            {
                a[i] = j;
                j = (float)(j + 0.5);
            }
            P.CompoundArray = a;
            P.DashStyle = System.Drawing.Drawing2D.DashStyle.DashDotDot;
            g.DrawRectangle(P, Dummy.XAccess, Dummy.YAccess, Dummy.WidhtAccess, Dummy.HieghtAcess);
        }
        private void DrawBoxAroundDummyAtBetweenNodeKind()
        {
            Pen P = new Pen(Color.Brown);
            float[] a = new float[2];
            float j = 0;
            for (int i = 0; i < 2; i++)
            {
                a[i] = j;
                j = (float)(j + 0.5);
            }
            P.CompoundArray = a;
            P.DashStyle = System.Drawing.Drawing2D.DashStyle.DashDotDot;
            g.DrawLine(P, XTrace - 5, YTrace, XTrace + 5, YTrace);
            g.DrawLine(P, XTrace, YTrace - 5, XTrace, YTrace + 5);
        }
        private Set GetNodeOfXTraceAndYTrace(Set Node, ref Set Dummy)
        {
            if (Node == null)
                return Dummy;
            if ((Node.XAccess) == XTrace)
                if ((Node.YAccess) == YTrace)
                    Dummy = Node;
            if (Node.LeftSideAccess == null)
                if (Node.RightSideAccess == null)
                    return Dummy;
            Dummy = this.GetNodeOfXTraceAndYTrace(Node.LeftSideAccess, ref Dummy);
            Dummy = this.GetNodeOfXTraceAndYTrace(Node.RightSideAccess, ref Dummy);
            return Dummy;
        }
        private void TransmiteXAndYTraceAtNodes(Set Dummy, ref bool SetXTraceAndYTrace)
        {
            //ERROR28373248754 :The Set X and Y value at Set Structure  is not ok.refer to page 142.
            if (Dummy == null)
                return;
            if (Equation.INTPressedAccess == 6)//Up
            {
                if ((Dummy.YAccess) < YTrace)
                {
                    if (SetXTraceAndYTrace)
                    {
                        //XTrace = (Dummy.XAccess + Dummy.GetWidht());
                        //YTrace = (Dummy.YAccess + Dummy.GetHieght());
                        XTrace = Dummy.XAccess;
                        YTrace = Dummy.YAccess;
                        CurrentSetvariable = Dummy;
                        SetXTraceAndYTrace = false;
                    }
                }

            }
            else
                if (Equation.INTPressedAccess == 7)//Down
            {
                if ((Dummy.YAccess) > YTrace)
                {
                    if (SetXTraceAndYTrace)
                    {
                        //    XTrace = (Dummy.XAccess + Dummy.GetWidht());
                        //  YTrace = (Dummy.YAccess + Dummy.GetHieght());
                        XTrace = Dummy.XAccess;
                        YTrace = Dummy.YAccess;
                        CurrentSetvariable = Dummy;
                        SetXTraceAndYTrace = false;
                    }
                }
            }
            else
                    if (Equation.INTPressedAccess == 8)//Right
            {
                if ((Dummy.XAccess) > XTrace)
                {
                    if (SetXTraceAndYTrace)
                    {
                        //XTrace = (Dummy.XAccess + Dummy.GetWidht());
                        //YTrace = (Dummy.YAccess + Dummy.GetHieght());
                        XTrace = Dummy.XAccess;
                        YTrace = Dummy.YAccess;
                        CurrentSetvariable = Dummy;
                        SetXTraceAndYTrace = false;
                    }
                }
            }
            else
                        if (Equation.INTPressedAccess == 9)//Left
            {
                if ((Dummy.XAccess) < XTrace)
                {
                    if (SetXTraceAndYTrace)
                    {
                        //XTrace = (Dummy.XAccess + Dummy.GetWidht());
                        //YTrace = (Dummy.YAccess + Dummy.GetHieght());
                        XTrace = Dummy.XAccess;
                        YTrace = Dummy.YAccess;
                        CurrentSetvariable = Dummy;
                        SetXTraceAndYTrace = false;
                    }
                }
            }
            this.TransmiteXAndYTraceAtNodes(Dummy.LeftSideAccess, ref SetXTraceAndYTrace);
            this.TransmiteXAndYTraceAtNodes(Dummy.RightSideAccess, ref SetXTraceAndYTrace);

            /*if (Equation.INTPressedAccess == 6)//Up
                if (YTrace > MinY)
                    YTrace = YTrace - TraceMovmentCount;
                else
                    YTrace = MinY;
            if (Equation.INTPressedAccess == 7)//Down
                if (YTrace < MaxY)
                    YTrace = YTrace + TraceMovmentCount;
                else
                    YTrace = MaxY;

            if (Equation.INTPressedAccess == 8)//Right
                if (XTrace < MaxX)
                    XTrace = XTrace + TraceMovmentCount;
                else
                    XTrace = MaxX;
            if (Equation.INTPressedAccess == 9)//Left
                if (XTrace > MinX)
                    XTrace = XTrace - TraceMovmentCount;
                else
                    XTrace = MinX;
            //In here the x and y trace coordinates changed depend on right left and up and down keyes.            
            //while (true)
            //{             
            //}            
             */

        }
        private void TransmiteXAndYTraceBetweenNodes(Set Dummy, ref bool SetXTraceAndYTrace)
        {
            if (PreviouseNodeForBetweenTraceKindDummy == null)
                PreviouseNodeForBetweenTraceKindDummy = Setvariable;
            XTrace = PreviouseNodeForBetweenTraceKindDummy.XAccess;
            YTrace = PreviouseNodeForBetweenTraceKindDummy.YAccess;
            //ERROR912874 : Refer to page 143.Cause on XTrace And YTrace.
            this.TransmiteXAndYTraceAtNodes(Dummy, ref SetXTraceAndYTrace);
            Set Node = new Set();
            this.GetNodeOfXTraceAndYTrace(Dummy, ref Node);
            if (Node.ThreadAccess != null)
            {
                XTrace = (int)((PreviouseNodeForBetweenTraceKindDummy.XAccess + Node.ThreadAccess.XAccess) / 2);
                YTrace = (int)((PreviouseNodeForBetweenTraceKindDummy.YAccess + Node.ThreadAccess.YAccess) / 2);
            }
            else
            {
                XTrace = (int)(XTrace - 10);
                //YTrace = (int)(YTrace -10);            
            }
            PreviouseNodeForBetweenTraceKindDummy = Node;
        }
        private void CalculateMaxMinXAandY()
        {
            this.GetSmallestNodeX(Setvariable, ref MinX);
            this.GetSmallestNodeY(Setvariable, ref MinY);
            this.GetBigestNodeX(Setvariable, ref MaxX);
            this.GetBigestNodeY(Setvariable, ref MaxY);
        }
        private void GetSmallestNodeX(Set SetS, ref int XMinX)
        {
            if (SetS == null)
                return;
            if (SetS.XAccess < XMinX)
                XMinX = SetS.XAccess;
            this.GetSmallestNodeX(SetS.LeftSideAccess, ref XMinX);
            this.GetSmallestNodeX(SetS.RightSideAccess, ref XMinX);

        }
        private void GetSmallestNodeY(Set SetS, ref int YMinY)
        {
            if (SetS == null)
                return;
            if ((SetS.YAccess - SetS.HieghtAcess) < YMinY)
                YMinY = SetS.YAccess - SetS.HieghtAcess;
            this.GetSmallestNodeY(SetS.LeftSideAccess, ref YMinY);
            this.GetSmallestNodeY(SetS.RightSideAccess, ref YMinY);

        }
        private void GetBigestNodeX(Set SetS, ref int XMaxX)
        {
            if (SetS == null)
                return;
            if ((SetS.XAccess + SetS.WidhtAccess) > XMaxX)
                XMaxX = SetS.XAccess + SetS.WidhtAccess;
            this.GetBigestNodeX(SetS.LeftSideAccess, ref XMaxX);
            this.GetBigestNodeX(SetS.RightSideAccess, ref XMaxX);

        }
        private void GetBigestNodeY(Set SetS, ref int YMaxY)
        {
            if (SetS == null)
                return;
            if ((SetS.YAccess + SetS.HieghtAcess) > YMaxY)
                YMaxY = SetS.YAccess + SetS.HieghtAcess;
            this.GetBigestNodeY(SetS.LeftSideAccess, ref YMaxY);
            this.GetBigestNodeY(SetS.RightSideAccess, ref YMaxY);

        }
    }
    //this class is used to show graphically equation.
    //The editor Show and sets from here.
    public class GraphicallyInterface
    {
        //ERRORCORECTION70077030 :Cause of ERROR77007 solved.
        /*
        PictureBox Integral = new PictureBox();
        PictureBox Line = new PictureBox();
        PictureBox Trianglic = new PictureBox();
        PictureBox Cerices = new PictureBox();
        PictureBox Root = new PictureBox();
        PictureBox Parantez = new PictureBox();
        PictureBox ToUp = new PictureBox();
        PictureBox ToDown = new PictureBox();
        PictureBox ToLeft = new PictureBox();
        PictureBox ToRight = new PictureBox();

        PictureBox Ln = new PictureBox();
        PictureBox Log = new PictureBox();
        PictureBox No = new PictureBox();
        */
        Equation EquationVariable = null;
        Editors.Editor EditorVariable = null;
        AddToTree.Tree TreeVariable = null;
        AutoSender AutoSenderVariable = null;
        Graphics g = null;
        public GraphicallyInterface(Equation THIS, AutoSender AutoSender)
        {
            EquationVariable = THIS;
            EditorVariable = new Editors.Editor();
            EditorVariable.Show();
            g = EditorVariable.GraphicsAccess;
            AutoSenderVariable = AutoSender;
            TreeVariable = AutoSenderVariable.NodeAccess;
        }
        /*public Editors.Editor EditorVariableAccess
        {
            get{return EditorVariable;}
            set { EditorVariable = value; }
        } 
         */
        public Graphics gAccesss
        {
            get { return g; }
            set { g = value; }
        }
        public Editors.Editor EditorAccesss
        {
            get { return EditorVariable; }
            set { EditorVariable = value; }
        }
        public AutoSender GetAutoSenderVaribale()
        {
            return AutoSenderVariable;
        }
        //calls from sender samle method.
        public void GraphicallyRefreshingToOnotherClass(Equation THIS, AutoSender AutoSender)
        {
            EquationVariable = THIS;
            AutoSenderVariable = AutoSender;
            TreeVariable = AutoSenderVariable.NodeAccess;
        }
        public AddToTree.Tree GetNodeTree()
        {
            while (AutoSenderVariable.NodeAccess.ThreadAccess != null)
                AutoSenderVariable.NodeAccess = AutoSenderVariable.NodeAccess.ThreadAccess;
            //ERRORCORECTION0927498 :The Optimizing strucure will be added.
            TreeVariable = AutoSenderVariable.NodeAccess;
            return TreeVariable;
        }
        private bool IsFunction(int t)
        {
            bool Is = false;
            if ((t >= 2) && (t <= 11))
                Is = true;
            //if ((t >= 9) && (t <= 11))
            //  Is = true;
            return Is;
        }
        public void DrawTowParantezOnForm(Set SetVariable, ref int xBegin, ref int yBegin,
        ref int xEnd, ref int yEnd, int Size)
        {
            //ERROR31724152 Tan(x+1)23 .The parantez did not reache to end.
            if (SetVariable == null)
            {
                //ERROR45970478905 : the parantez dose not correctly write. The calculation misurement dos not completly doen.
                //this.DrawTowParantez(xBegin, yBegin, xEnd, yEnd, Size);
                return;
            }
            if (!this.IsFunction(SetVariable.GetDecoder()))
            {
                if (xBegin > (SetVariable.XAccess))
                    xBegin = SetVariable.XAccess;
                if (xEnd < (SetVariable.XAccess))
                    xEnd = SetVariable.XAccess;
            }
            //ERROR76094896096948 :The Value of Cos function dose not calculated.refer to page 97
            else
                if (SetVariable.LeftSideAccess != null)
                if (this.IsFunction(SetVariable.LeftSideAccess.GetDecoder()))
                {
                    xBegin = SetVariable.LeftSideAccess.XAccess - 5;
                    SetVariable = SetVariable.LeftSideAccess;
                }
            this.DrawTowParantezOnForm(SetVariable.LeftSideAccess, ref xBegin, ref yBegin, ref xEnd, ref yEnd, Size);
            this.DrawTowParantezOnForm(SetVariable.RightSideAccess, ref xBegin, ref yBegin, ref xEnd, ref yEnd, Size);
        }
        public void DrawIntegralOnForm(int x, int y, int Whith, int Lenght)
        {
            PictureBox Integral = new PictureBox();
            Integral.Visible = true;
            Integral.Location = new Point(x, y);
            Integral.Width = Whith;
            Integral.Height = Lenght;
            Integral.SizeMode = PictureBoxSizeMode.StretchImage;
            Integral.Image = Image.FromFile
              (System.IO.Path.GetDirectoryName(Environment.GetCommandLineArgs()[0]) + "\\"

              + "Integral.gif");
            EditorVariable.Controls.Add(Integral);
        }
        public void DrawLineOnForm(int x, int y, int Whith, int Height)
        {
            PictureBox Line = new PictureBox();
            Line.Visible = true;
            Line.Location = new Point(x, y);
            Line.Width = Whith;
            Line.Height = Height;
            Line.SizeMode = PictureBoxSizeMode.StretchImage;
            Line.BorderStyle = BorderStyle.Fixed3D;
            Line.Image = Image.FromFile
              (System.IO.Path.GetDirectoryName(Environment.GetCommandLineArgs()[0]) + "\\"

              + "LineOnly.gif");
            EditorVariable.Controls.Add(Line);
        }
        public void DrawTowParantez(int xBegin, int yBegin, int xEnd, int yEnd, int Size)
        {
            g.DrawString("(", new Font("Times New Roman", Size, FontStyle.Bold), new SolidBrush(Color.Black), xBegin, yBegin);
            g.DrawString(")", new Font("Times New Roman", Size, FontStyle.Bold), new SolidBrush(Color.Black), xEnd, yEnd);
        }
        private void DrawTrianglicOnForm()
        {
            PictureBox Trianglic = new PictureBox();
            Trianglic.Visible = true;
            Trianglic.Location = new Point(92, 12);
            Trianglic.Width = 16;
            Trianglic.Height = 16;
            Trianglic.SizeMode = PictureBoxSizeMode.StretchImage;
            Trianglic.Image = Image.FromFile
              (System.IO.Path.GetDirectoryName(Environment.GetCommandLineArgs()[0]) + "\\"

              + "Trianglic.gif");
            EditorVariable.Controls.Add(Trianglic);
        }
        public void DrawCericesOnForm(int x, int y, int Whith, int Lenght)
        {
            PictureBox Cerices = new PictureBox();
            Cerices.Visible = true;
            Cerices.Location = new Point(x, y);
            Cerices.Width = Whith;
            Cerices.Height = Lenght;
            Cerices.SizeMode = PictureBoxSizeMode.StretchImage;
            Cerices.Image = Image.FromFile
              (System.IO.Path.GetDirectoryName(Environment.GetCommandLineArgs()[0]) + "\\"

              + "Cerices.gif");
            EditorVariable.Controls.Add(Cerices);
        }
        public void DrawRootOnForm(int x, int y, int Whith, int Lenght)
        {
            PictureBox Root = new PictureBox();
            Root.Visible = true;
            Root.Location = new Point(x, y);
            Root.Width = Whith;
            Root.Height = Lenght;
            Root.SizeMode = PictureBoxSizeMode.StretchImage;
            Root.Image = Image.FromFile
              (System.IO.Path.GetDirectoryName(Environment.GetCommandLineArgs()[0]) + "\\"

              + "Root.gif");
            EditorVariable.Controls.Add(Root);
        }
        public void DrawParantezOnForm()
        {
            PictureBox Parantez = new PictureBox();
            Parantez.Visible = true;
            Parantez.Location = new Point(212, 12);
            Parantez.Width = 16;
            Parantez.Height = 16;
            Parantez.SizeMode = PictureBoxSizeMode.StretchImage;
            Parantez.Image = Image.FromFile
              (System.IO.Path.GetDirectoryName(Environment.GetCommandLineArgs()[0]) + "\\"

              + "Parantez.gif");
            EditorVariable.Controls.Add(Parantez);
        }

        public void DrawToUpOnForm()
        {
            PictureBox ToUp = new PictureBox();
            ToUp.Visible = true;
            ToUp.Location = new Point(12, 52);
            ToUp.Width = 16;
            ToUp.Height = 16;
            ToUp.SizeMode = PictureBoxSizeMode.StretchImage;
            ToUp.Image = Image.FromFile
              (System.IO.Path.GetDirectoryName(Environment.GetCommandLineArgs()[0]) + "\\"

              + "ToUp.gif");
            EditorVariable.Controls.Add(ToUp);
        }
        public void DrawToDownOnForm()
        {
            PictureBox ToDown = new PictureBox();
            ToDown.Visible = true;
            ToDown.Location = new Point(52, 52);
            ToDown.Width = 16;
            ToDown.Height = 16;
            ToDown.SizeMode = PictureBoxSizeMode.StretchImage;
            ToDown.Image = Image.FromFile
              (System.IO.Path.GetDirectoryName(Environment.GetCommandLineArgs()[0]) + "\\"

              + "ToDown.gif");
            EditorVariable.Controls.Add(ToDown);
        }

        public void DrawToLeftOnForm()
        {
            PictureBox ToLeft = new PictureBox();
            ToLeft.Visible = true;
            ToLeft.Location = new Point(92, 52);
            ToLeft.Width = 16;
            ToLeft.Height = 16;
            ToLeft.SizeMode = PictureBoxSizeMode.StretchImage;
            ToLeft.Image = Image.FromFile
              (System.IO.Path.GetDirectoryName(Environment.GetCommandLineArgs()[0]) + "\\"

              + "ToLeft.gif");
            EditorVariable.Controls.Add(ToLeft);
        }
        public void DrawToRightOnForm()
        {
            PictureBox ToRight = new PictureBox();

            ToRight.Visible = true;
            ToRight.Location = new Point(132, 52);
            ToRight.Width = 16;
            ToRight.Height = 16;
            ToRight.SizeMode = PictureBoxSizeMode.StretchImage;
            ToRight.Image = Image.FromFile
              (System.IO.Path.GetDirectoryName(Environment.GetCommandLineArgs()[0]) + "\\"

              + "ToRight.gif");
            EditorVariable.Controls.Add(ToRight);
        }
        public void FiveBasicOpratorsPlus(int x, int y, int Size)
        {
            g.DrawString("+", new Font("Times New Roman", Size, FontStyle.Bold), new SolidBrush(Color.Black), x, y);
        }
        public void FiveBasicOpratorsMinuse(int x, int y, int Size)
        {
            g.DrawString("-", new Font("Times New Roman", Size, FontStyle.Bold), new SolidBrush(Color.Black), x, y);
        }
        public void FiveBasicOpratorsMul(int x, int y, int Size)
        {
            g.DrawString("*", new Font("Times New Roman", Size, FontStyle.Bold), new SolidBrush(Color.Black), x, y);
        }
        public void Sin(int x, int y, int Size)
        {
            g.DrawString("Sin", new Font("Times New Roman", Size, FontStyle.Bold), new SolidBrush(Color.Black), x, y);

        }
        public void Cos(int x, int y, int Size)
        {
            g.DrawString("Cos", new Font("Times New Roman", Size, FontStyle.Bold), new SolidBrush(Color.Black), x, y);

        }
        public void Tan(int x, int y, int Size)
        {
            g.DrawString("Tan", new Font("Times New Roman", Size, FontStyle.Bold), new SolidBrush(Color.Black), x, y);

        }
        public void Cot(int x, int y, int Size)
        {
            g.DrawString("Cot", new Font("Times New Roman", Size, FontStyle.Bold), new SolidBrush(Color.Black), x, y);

        }
        public void Sec(int x, int y, int Size)
        {
            g.DrawString("Sec", new Font("Times New Roman", Size, FontStyle.Bold), new SolidBrush(Color.Black), x, y);

        }
        public void Csc(int x, int y, int Size)
        {
            g.DrawString("Csc", new Font("Times New Roman", Size, FontStyle.Bold), new SolidBrush(Color.Black), x, y);

        }
        public void DrawLn(int x, int y, int Size)
        {
            g.DrawString("Ln", new Font("Times New Roman", Size, FontStyle.Bold), new SolidBrush(Color.Black), x, y);

        }
        public void DrawLog(int x, int y, int Size)
        {
            g.DrawString("Log", new Font("Times New Roman", Size, FontStyle.Bold), new SolidBrush(Color.Black), x, y);

        }
        public void FiveBasicOpratorsDiv(int x, int y, int Wdth, int Hight)
        {
            PictureBox Line = new PictureBox();

            //g.DrawString("/", new Font("Times New Roman", Size, FontStyle.Bold), new SolidBrush(Color.Black), x, y);
            Line.Visible = true;
            Line.Location = new Point(x, y);
            Line.Width = Wdth;
            Line.Height = Hight;
            Line.SizeMode = PictureBoxSizeMode.StretchImage;
            Line.Image = Image.FromFile
              (System.IO.Path.GetDirectoryName(Environment.GetCommandLineArgs()[0]) + "\\"

              + "LineOnly.gif");
            EditorVariable.Controls.Add(Line);
        }
        public void FiveBasicOpratorsPow(int x, int y, int Size)
        {
            //g.DrawString("^", new Font("Times New Roman", Size, FontStyle.Bold), new SolidBrush(Color.Black), x, y);
        }
        public void DrawNumber(Set SetVarible, int x, int y, int Size)
        {
            g.DrawString(SetVarible.NumberAcess, new Font("Times New Roman", Size, FontStyle.Bold), new SolidBrush(Color.Black), x, y);
        }
        public void DrawIndependence(Set SetVarible, int x, int y, int Size)
        {
            g.DrawString("x", new Font("Times New Roman", Size, FontStyle.Bold), new SolidBrush(Color.Black), x, y);
        }
        /*public void DrawNumberAndVaribale()
        {
            No.Visible = true;
            No.Location = new Point(330, 12);
            No.Width = 16;
            No.Height = 16;
            No.SizeMode = PictureBoxSizeMode.StretchImage;
            No.BackColor = Color.White;
            No.Image = Image.FromFile
              (System.IO.Path.GetDirectoryName(Environment.GetCommandLineArgs()[0]) + "\\"
              
              +"No.gif");
            EditorVariable.Controls.Add(No);


        }
         */

    }
    public class SenderSample
    {
        AutoSender AutoSender = null;
        ManualSenderSample ManualSender = null;
        public SenderSample(Equation THIS)
        {
            AutoSender = new AutoSender(THIS);
            ManualSender = new ManualSenderSample(AutoSender);
        }
        /*
        public AutoSender AutoSenderAccess
        {
            get { return AutoSender; }
            set { AutoSender = value; }
        }
         */
        public void SenderSampleOperation(ref Equation THIS, bool AutoTrueManualFalse, int INTPressded, ref Sinusad SinusadClassVariable, ref Setting.EquationSettingInsertion EquationSettingInsertionOnEquationForm, ref NumberVar.NumberAndVariable NumberAndVariable, ref Formulas.Parantez ParantezVariable, ref Formulas.EquationTrace EquationTraceVariable, TraceKind TRK)
        {
            if (AutoTrueManualFalse)
            {
                AutoSender.SetEquationSettingInsertionVariable(EquationSettingInsertionOnEquationForm);
                if (INTPressded == 2)
                    SinusadClassVariable.ShowDialog();
                else
                    SinusadClassVariable.Hide();
                if (INTPressded == 15)
                    NumberAndVariable.ShowDialog();
                //SinusadClassVariable.ShowDialog();
                else
                    NumberAndVariable.Hide();
                if (INTPressded == 5)
                    ParantezVariable.ShowDialog();
                else
                    ParantezVariable.Hide();
                //ERRORCORECTION7346 :it seems at each time calling the parantez is tow time increazes and decreament.refer to page 135.
                AutoSender.PreventTowTimeAdded = false;
                //SinusadClassVariable.Hide();
                if ((INTPressded != 2) && (INTPressded != 15) && (INTPressded != 5))
                    AutoSender.SenderToAddToTree(THIS.GetCurrentSampleFromBoard(INTPressded), THIS, false);
                else
                    if (INTPressded == 2)
                    AutoSender.SenderToAddToTree(SinusadClassVariable.GetContained(), THIS, false);
                else
                        if (INTPressded == 15)
                    AutoSender.SenderToAddToTree(NumberAndVariable.GetContained(), THIS, false);
                else
                            if (INTPressded == 5)
                    AutoSender.SenderToAddToTree(ParantezVariable.GetContained(), THIS, false);

            }
            else
            {
            }
        }
        private void AddToProperXTraceAndYTrace(Equation THIS)
        {
            Set Dummy = new Set();
            Set ADDED = new Set();

            ADDED.NodeAccess = THIS.GetCurrentSampleFromBoard(THIS.INTPressedAccess);
            Dummy = AutoSender.DrawingAccess.ArrtificialItelligenceForGraphicallyDrawingAccess.NodeSetAcesss;
            Dummy = this.FindPreviouseNode(Dummy, THIS);
            if (Dummy == null)
            {
                MessageBox.Show("The Indicatore has not set to valid location.");
                return;
            }
            else
            {
                if (Dummy.ThreadAccess != null)
                {

                }
            }

        }
        public Set FindPreviouseNode(Set Node, Equation THISE)
        {
            Set Dummy = null;
            if (System.Math.Abs(Dummy.XAccess + Dummy.WidhtAccess - THISE.EquationTraceAccess.XTRACEAccess) < 10)
                if (System.Math.Abs(Dummy.YAccess - THISE.EquationTraceAccess.YTRACEAccess) < 10)
                {
                    Dummy = Node;
                    return Dummy;
                }
            Dummy = this.FindPreviouseNode(Node.LeftSideAccess, THISE);
            Dummy = this.FindPreviouseNode(Node.RightSideAccess, THISE);
            return Dummy;
        }
        public AutoSender AutoSenderAccess
        {
            get { return AutoSender; }
            set { AutoSender = value; }
        }
    }
    class ManualSenderSample
    {
        AddToTree.Tree SetVaribale = null;
        AutoSender AutoSenderVaribale = null;
        public ManualSenderSample(AutoSender THIS)
        {
            AutoSenderVaribale = THIS;
            SetVaribale = THIS.NodeAccess;
        }
        public void SetManualSenderSampleAtChanging(AutoSender THIS)
        {
            AutoSenderVaribale = THIS;
            SetVaribale = THIS.NodeAccess;
        }
    }
    //This Class Indicate Samples
    public class AutoSender
    {
        private AddToTree.reciverContractionTree reciverContractionTreeVaribale = null;
        QueueString QueueStringVariable = new QueueString(100);
        //Formulas.Equation EquationVariable = null;
        AddToTree.Tree TreeConstructed = null;
        static bool IsParantes = false;
        Setting.EquationSettingInsertion EquationSettingInsertionVariable = null;
        StackTree StackTreeVariable = null;
        StackTree StackHoled = null;
        ArrayTree ArrayTreeVariable = null;
        //GraphicallyInterface GraphicallyInterface = null;
        Equation THISEquationVariable = null;
        Drawing DrawingVariable = null;
        Thread ThreadVaribale = null;
        long previous = 0;
        int ParantezOpenedNumber = 0;
        String Current = null;
        bool ISSuitableForFunctionArgumnetVariable = false;
        Formulas.Parantez ParantezVariable = null;
        public bool PreventTowTimeAdded = false;
        public AutoSender(Equation THIS)
        {
            THISEquationVariable = THIS;
            reciverContractionTreeVaribale = new AddToTree.reciverContractionTree();
            EquationSettingInsertionVariable = new Setting.EquationSettingInsertion();
            StackTreeVariable = new StackTree(100);
            StackHoled = new StackTree(100);
            ArrayTreeVariable = new ArrayTree(100);
            DrawingVariable = new Drawing(THIS, this, new GraphicallyInterface(THIS, this));
            ThreadVaribale = new Thread(new ThreadStart(DRAWEDITOR));
            ParantezVariable = THIS.GetParantezFormVariable();
            //Current = new String("");
            //Invisible189264876214 ThreadVaribale.Start();
            //For Create Functions.
            //GraphicallyInterface = new GraphicallyInterface(THIS,this);
            //ArrtificialItelligenceForGraphicallyDrawingVariable = new ArrtificialItelligenceForGraphicallyDrawing(THIS);
        }

        /*public Formulas.Drawing GetDrawing()
        {
        return this.DrawingVariable;
        }
        */
        public String CurrentStirngAccess
        {
            get { return Current; }
            set { Current = value; }
        }
        public Formulas.Drawing DrawingAccess
        {
            get { return this.DrawingVariable; }
            set { this.DrawingVariable = value; }
        }
        public AddToTree.reciverContractionTree reciverCuntractionTreeAccess
        {
            get { return reciverContractionTreeVaribale; }
            set { reciverContractionTreeVaribale = value; }
        }
        public bool ISFrame()
        {
            long TimeCount = 0;
            bool Is = false;
            TimeCount = DateTime.Now.Millisecond + DateTime.Now.Second * 1000 + DateTime.Now.Minute * 60000 + DateTime.Now.Hour * 3600000;
            if ((TimeCount - previous >= 40))
            {
                previous = TimeCount;
                Is = true;
            }
            return Is;
        }
        public void DRAWEDITOR()
        {
            while (true)
            {
                //in Here The Tree Is empty and the null exeption occures
                if (this.ISFrame())
                    DrawingVariable.GraphicsAccess.Clear(Color.White);
                if (TreeConstructed != null)
                    if (TreeConstructed.GetSample() != null)//by this condition ocures.
                        DrawingVariable.Draw(THISEquationVariable, this, 40, 40);

            }
        }
        /*public Setting.EquationSettingInsertion GetEquationSettingInsertionVariable()
        {
            return EquationSettingInsertionVariable;
        }
         */
        public Setting.EquationSettingInsertion EquationSettingInsertionVariableAccess
        {
            get { return EquationSettingInsertionVariable; }
            set { EquationSettingInsertionVariable = value; }
        }
        public bool SetEquationSettingInsertionVariable(Setting.EquationSettingInsertion t)
        {
            EquationSettingInsertionVariable = t;
            return true;
        }
        public AddToTree.Tree NodeAccess
        {
            get { return reciverContractionTreeVaribale.NodeAccess; }
            set { reciverContractionTreeVaribale.NodeAccess = value; }
        }
        private void ChangeTheSideOfArgument(AddToTree.Tree t)
        {
            if (t == null)
                return;
            if (this.IsFunction(t.GetSample()))
            {
                if (t.LeftSideAccess == null)
                    if (t.RightSideAccess != null)
                        t.SetLefTandRightCommonlySide(t.RightSideAccess, t.LeftSideAccess);
            }
            this.ChangeTheSideOfArgument(t.LeftSideAccess);
            this.ChangeTheSideOfArgument(t.RightSideAccess);
        }
        private bool ifIsLastOperatorAndItsLeftOperator(AddToTree.Tree t)
        {
            bool ifIsLastOperatorAndItsLeftOperato = false;
            AddToTree.Tree Dummy = new AddToTree.Tree(null, false);
            Dummy = t;
            if (Dummy != null)
                while (Dummy.RightSideAccess != null)
                    Dummy = Dummy.RightSideAccess;
            if (Dummy.LeftSideAccess != null)
                if (Dummy.RightSideAccess != null)//This Condition Refer to ERROR43713501
                    if (this.IsOperator(Dummy.LeftSideAccess.GetSample()))
                        if (this.IsOperator(Dummy.GetSample()))
                            ifIsLastOperatorAndItsLeftOperato = true;
            return ifIsLastOperatorAndItsLeftOperato;
        }
        private bool ifIsLastOperatorAndItsLeftFunction(AddToTree.Tree t)
        {
            bool ifIsLastOperatorAndItsLeftFunction = false;
            AddToTree.Tree Dummy = new AddToTree.Tree(null, false);
            Dummy = t;
            if (Dummy != null)
                while (Dummy.RightSideAccess != null)
                    Dummy = Dummy.RightSideAccess;
            if (Dummy != null)
                if (this.IsFunction(Dummy.GetSample()))
                    ifIsLastOperatorAndItsLeftFunction = true;
            return ifIsLastOperatorAndItsLeftFunction;
        }
        private bool IsEqualWithThreadConsiderationCommonlySample(String Sample)
        {
            bool Is = false;
            if (Sample == "=")
                Is = true;
            else
                Is = false;
            return Is;

        }
        public bool SettingSenders(String Sample, Equation THIS, ref bool ACT)
        {
            //ERROR73425362 : The "(" Sample is like a number.
            AddToTree.Tree Dummy = new AddToTree.Tree(null, false);
            AddToTree.Tree ADDED = new AddToTree.Tree(null, false);
            AddToTree.Tree Holder = new AddToTree.Tree(null, false);

            //For Page 70
            Dummy = TreeConstructed;

            //ERRORCORCTION0192873 :The Correction of ERROR928375.refre to page 109.

            //ERROR4070 :Thhere is a rellacement between tow ind or num.refer to page 135.


            while ((Dummy != null) && (Dummy.RightSideAccess != null))
                Dummy = Dummy.RightSideAccess;
            Holder = Dummy;
            if (Dummy != null)
                if (!ISSuitableForFunctionArgumnetVariable)
                    if (Dummy.GetSample() != null)
                        if (Dummy.RightSideAccess == null)
                            if (this.IsOperator(Sample) || this.ISindependenceVaribaleOrNumber(Sample) || this.IsFunction(Sample))
                                if (this.IsFunction(Dummy.GetSample()))
                                {

                                    //                    ADDED.SetLefTandRightCommonlySide(Dummy,ADDED.RightSideAccess);
                                    //                  ADDED.SetThread(Dummy.ThreadAccess);
                                    if (Holder.ThreadAccess != null)
                                    {
                                        //TESTNEEDED317125 :refer to page 110.
                                        ADDED.SampleAccess = Sample;
                                        ADDED.ThreadAccess = Holder.ThreadAccess;
                                        Holder.ThreadAccess.SetLefTandRightCommonlySide(Holder.ThreadAccess.LeftSideAccess, ADDED);
                                        Holder.RightSideAccess.LeftSideAccess.ThreadAccess = Holder.RightSideAccess;
                                        THIS.EquationTraceAccess.EquationReadyAccess = true;
                                    }
                                    else
                                    {
                                        //ERRORCAUSE3172425 :refer to page 118.
                                        Holder = null;
                                        Holder = new AddToTree.Tree(null, false);
                                        Holder.SetLefTandRightCommonlySide(TreeConstructed, Holder.RightSideAccess);
                                        //ERRORCORECTION0234988 :refer to page 119.
                                        TreeConstructed.ThreadAccess = Holder;
                                        Holder.SampleAccess = Sample;
                                        TreeConstructed = Holder;
                                        THIS.EquationTraceAccess.EquationReadyAccess = true;
                                        this.reciverContractionTreeVaribale.NodeAccess = TreeConstructed;
                                    }
                                    //Holder.SetThread(ADDED.ThreadAccess);                        
                                    goto End;
                                }
            Dummy = TreeConstructed;
            //ERRORXT1037 : the parantez is like a number.
            if (!IsParantes)
            {
                if (this.ISindependenceVaribaleOrNumber(Sample))
                //ERRORCORECTION219347 :refer to  page 118.
                {
                    while ((Dummy != null) && (Dummy.RightSideAccess != null))
                        Dummy = Dummy.RightSideAccess;
                    if (!this.IsEqualWithThreadConsiderationCommonlySample(Sample))
                        if ((Dummy != null) && (Dummy.LeftSideAccess != null))
                            if (this.IsOperator(Dummy.LeftSideAccess.GetSample()))
                            {
                                //ERROR87124 :refer to page 120.
                                //AddToTree.Tree ADDED=new AddToTree.Tree(null,false);
                                ADDED.SampleAccess = Sample;
                                Dummy.SetLefTandRightCommonlySide(Dummy.LeftSideAccess, ADDED);
                                //ERRORCORECTION29834 : refer to page 119.
                                ADDED.ThreadAccess = Dummy;
                                //ERRORCORECTION19284 :the Node is not set.refer to page 140.
                                reciverContractionTreeVaribale.NodeAccess = Dummy;
                                THIS.EquationTraceAccess.EquationReadyAccess = true;
                                goto End;
                            }
                }
                else
                {
                    //ERRORCORECTION1092387093 :The condition added.refer top page 120.
                    while ((Dummy != null) && (Dummy.RightSideAccess != null))
                        Dummy = Dummy.RightSideAccess;
                    if ((Dummy != null) && (this.ISindependenceVaribaleOrNumber(Dummy.GetSample())))
                    {
                        //ERRORCORECTION98127389724 :Refer to page 185 and LOCATION987127973
                        if ((this.IsOperator(Sample) || this.IsFunction(Sample)) && (!IS.IsMinuseOrPluse(Sample)))
                        {

                            //ERRORCUASE2093487 :The error is from here.The x dose not added.
                            //ERRORCUASE560969 :The Error cause of ERROR3070:The Node Selected Is not correctly Selected.refer to page 133.                            
                            Holder = null;
                            //LOCATION8709 :Below.refer to page 133.
                            //UNREACHED7890 This statment unreached.refer to page 133.
                            //Holder = Dummy.ThreadAccess;
                            //ERROR7887 :This leads to error.we call back.
                            //ERRORCORECTION978213498 :When Holder become null we use of Treeconstructed.refer to page 135.
                            //ERROR9801294 :this could not be usseful.refer to page 135.
                            /*Holder = StackHoled.Pop();
                            if (Holder == null)
                                Holder = TreeConstructed;
                             */
                            //Holder = Holder.ThreadAccess;
                            //LOCATION739734 :At here the node pop needed.    
                            /*if (ParantezOpenedNumber > 0)
                            {
                                if (StackHoled.IsEmpty())
                                    Holder = TreeConstructed;
                                else
                                    Holder = StackHoled.Pop();
                            }
                            else
                            Holder = Dummy.ThreadAccess;
                            */
                            //ERRORCORECTION239487 :The Correction of ERROR192874984.refr to page 139.
                            //Holder = Dummy.ThreadAccess;
                            if (!this.IsPower(Sample))
                            {   //LOCATION31745197  :Refer to page 187.
                                /*if (Dummy.ThreadAccess != null)
                                    if (Dummy.ThreadAccess.ThreadAccess != null)
                                    {
                                        //ERROCORECTION317428 :error Corect.refer to page140.
                                        bool IsRighTrueLeftFalse = false;
                                        bool Is = false;
                                        if (Dummy.ThreadAccess.ThreadAccess.ThreadAccess != null)
                                        {
                                            Is = true;
                                            if (Dummy.ThreadAccess.ThreadAccess.ThreadAccess.LeftSideAccess == Dummy)
                                                IsRighTrueLeftFalse = false;
                                            else
                                                IsRighTrueLeftFalse = true;
                                        }
                                        //LOCATION987127973 :Refet to page 185.
                                        Holder = Dummy.ThreadAccess.ThreadAccess;
                                        ADDED.SampleAccess=Sample;
                                        //ERROR12764 :"Invalid Thread settings.refer to page 140.

                                        //ADDED.SetThread(Holder);
                                        //ADDED.SetLefTandRightCommonlySide(Dummy, ADDED.RightSideAccess);
                                        ADDED.SetLefTandRightCommonlySide(Holder, ADDED.RightSideAccess);
                                        //Dummy.SetThread(ADDED);
                                        Holder.ThreadAccess=ADDED;
                                        //reciverContractionTreeVaribale.SetNode(ADDED);
                                        //Holder.SetLefTandRightCommonlySide(Holder.LeftSideAccess, ADDED); goto End;
                                        //Holder = Dummy.ThreadAccess.ThreadAccess;
                                        //if (Dummy.ThreadAccess.ThreadAccess.ThreadAccess != null)
                                        if (Is)
                                        {
                                            if (!IsRighTrueLeftFalse)
                                                Dummy.ThreadAccess.ThreadAccess.ThreadAccess.SetLefTandRightCommonlySide(Holder, Dummy.ThreadAccess.ThreadAccess.ThreadAccess.RightSideAccess);
                                            else
                                                Dummy.ThreadAccess.ThreadAccess.ThreadAccess.SetLefTandRightCommonlySide(Dummy.ThreadAccess.ThreadAccess.ThreadAccess.LeftSideAccess, Holder);
                                            ADDED.ThreadAccess=Dummy.ThreadAccess.ThreadAccess.ThreadAccess;
                                        }
                                        else
                                            reciverContractionTreeVaribale.NodeAccess=ADDED;*/
                                //  }
                                //else
                                // {
                                Holder = new AddToTree.Tree(null, false);
                                Holder.SampleAccess = Sample;
                                //ADDED.SetSample(Sample);
                                //ADDED.SetThread(Holder);
                                //ERRORCORECTION30171892 :Errorcorrection of ERROR307040.Convert ADDED.RightSideAccess To ADDED.refer to page 139.
                                Holder.SetLefTandRightCommonlySide(TreeConstructed, Holder.RightSideAccess);
                                Holder.LeftSideAccess.ThreadAccess = Holder;
                                TreeConstructed = Holder;
                                THIS.EquationTraceAccess.EquationReadyAccess = true;
                                //ERRORCORECTION1624 :Errorcorrection of ERROR30490678.refer to page 139.
                                reciverContractionTreeVaribale.NodeAccess = TreeConstructed;
                                //}
                            }
                            //ERRORCORCION01823098 :The Power error cuase corection..refer to page 142.
                            else
                            {
                                if (this.ISindependenceVaribaleOrNumber(Dummy.GetSample()))
                                {
                                    Holder = new AddToTree.Tree(null, false);
                                    Holder.SampleAccess = Sample;
                                    Holder.SetLefTandRightCommonlySide(Dummy, Holder.RightSideAccess);
                                    Dummy.ThreadAccess.SetLefTandRightCommonlySide(Dummy.ThreadAccess.LeftSideAccess, Holder);
                                    Holder.ThreadAccess = Dummy.ThreadAccess;
                                    THIS.EquationTraceAccess.EquationReadyAccess = true;
                                    while (Dummy.ThreadAccess != null)
                                        Dummy = Dummy.ThreadAccess;
                                    reciverContractionTreeVaribale.NodeAccess = Dummy;
                                }
                            }
                            /*ADDED.SetSample(Sample);
                            ADDED.SetThread(Holder);
                            ADDED.SetLefTandRightCommonlySide(Dummy, ADDED.RightSideAccess);
                            Dummy.SetThread(ADDED);
                            Holder.SetLefTandRightCommonlySide(Holder.LeftSideAccess, ADDED);
                             */
                            goto End;
                        }
                    }
                }
            }

            //ERROR345678567MCD98 :The Function Dose not found.
            //LOCATION678976509467 :The page 93 request.
            if (!IsParantes)
                if (TreeConstructed != null)
                    //ERRORCORECTION24358734875 :The Condition Will add.
                    if (TreeConstructed.RightSideAccess != null)
                        if (!this.ifIsLastOperatorAndItsLeftOperator(TreeConstructed))
                            if (!this.ifIsLastOperatorAndItsLeftFunction(TreeConstructed))
                                if (this.IsNumber(Sample) || (this.ISindependenceVaribale(Sample)))
                                    if (this.QueueStringVariable.NumberOfElement() == 0)
                                        //Refer to page 93.
                                        if (!ISSuitableForFunctionArgumnetVariable)
                                        {
                                            //LOCATION131705 :Refer to page 185. 
                                            this.reciverContractionTreeVaribale.ResivedTaskFunction(Sample, null, null, 0, null, ref ACT);
                                            return true;
                                        }
            /*//CONDITION317450 :refer to page 186.
            //ERROR345678567MCD98 :The Function Dose not found.
            //LOCATION678976509467 :The page 93 request.
            if (!IsParantes)
                if (TreeConstructed != null)
                    //ERRORCORECTION24358734875 :The Condition Will add.
                    if (TreeConstructed.RightSideAccess != null)
                        if (!this.ifIsLastOperatorAndItsLeftOperator(TreeConstructed))
                            if (!this.ifIsLastOperatorAndItsLeftFunction(TreeConstructed))
                                if (this.IsNumber(Sample) || (this.ISindependenceVaribale(Sample)))
                                    if (this.QueueStringVariable.NumberOfElement() == 0)
                                        QueueStringVariable.Add(Sample);
                                                   
                                        //Refer to page 93.
                                        /*if (!ISSuitableForFunctionArgumnetVariable)
                                        {
                                            //LOCATION131705 :Refer to page 185. 
                                            this.reciverContractionTreeVaribale.ResivedTaskFunction(Sample, null, null, 0, null);
                                            return true;
                                        }
                                         */

            //EROROCORRECTION74523274XA :x should stores and when "+" will comes add to tree.
            //Might to ERRORCuase1298670 :it may on some locations be unsafty.
            //LOCATION765765 :refer to page 185.
            if (!IsParantes)
                if (this.IsFunction(Sample) || this.IsOperator(Sample))
                    if (QueueStringVariable.NumberOfElement() >= 1)
                    {   //e
                        String x0 = null;
                        x0 = QueueStringVariable.Delete();
                        //ERORRCORECTION878919274872 :The number extend to number and variable.
                        //ERROR35724342 : Dose not any effect.refer to page 102.
                        //LOCATION78264928 :Here by refering to page 185.
                        if (this.ISindependenceVaribaleOrNumber(x0))
                            //this.reciverContractionTreeVaribale.ResivedTaskFunction(x0,null,null, 0);
                            //this.reciverContractionTreeVaribale.ResivedTaskFunction(Sample,null,x0, 0,null);
                            //ERORRCORECTION678901297349814CXS :The above satatment replaced by below statment.
                            this.reciverContractionTreeVaribale.ResivedTaskFunction(Sample, x0, null, 0, null, ref ACT);
                        else
                            QueueStringVariable.Add(x0);
                    }
            //ERRORCORECTION41723050
            if (this.IsEqualWithThreadConsiderationCommonlySample(Sample))
                if (QueueStringVariable.NumberOfElement() >= 1)
                {
                    String x0 = null;
                    x0 = QueueStringVariable.Delete();
                    this.reciverContractionTreeVaribale.ResivedTaskFunction(Sample, null, x0, 0, null, ref ACT);
                }

            //The Last operation.
            //ERROR7809678905 : Error on data structure.
            /*if(IsParantes)
              if (this.IsParantez(Sample))
              {
              if (this.QueueStringVariable.NumberOfElement() >= 1)
              {
                 String x0 = null;
                 x0 = QueueStringVariable.Delete();
                 this.reciverContractionTreeVaribale.ResivedTaskFunction(Sample, x0, null, 0, null);
              }
              }
            */
            if (!this.PreventTowTimeAdded)
            {
                if (this.IsParantez(Sample))//for parantez openning and cloSing.
                {
                    if (ParantezVariable.IsOpenedParantez())
                    {
                        IsParantes = true;
                        ParantezOpenedNumber++;

                        //ERRORCORECTION7689 :refer to page 133.
                        //ERROR3456 :it can not be useul.refer to page 135.
                        /*Dummy = TreeConstructed;
                        while (Dummy.RightSideAccess != null)
                            Dummy = Dummy.RightSideAccess;                                       
                        StackHoled.Push(Dummy);
                         */
                    }
                    else
                        if (ParantezVariable.IsClosedParantez())
                    {
                        if (ParantezOpenedNumber > 0)
                        {
                            //LOCATION73808 :At here the node pop inneeded.
                            StackHoled.Pop();
                            ParantezOpenedNumber--;
                        }
                    }
                    this.PreventTowTimeAdded = true;
                }
                if (ParantezOpenedNumber > 0)
                    ISSuitableForFunctionArgumnetVariable = true;
                else
                {
                    ISSuitableForFunctionArgumnetVariable = false;
                    IsParantes = false;
                }
                //ERORRCORECTION890758746789 :The Last Sample of Parantez Closeed.
                if (!ISSuitableForFunctionArgumnetVariable)
                {
                    if (this.QueueStringVariable.NumberOfElement() >= 1)
                    {
                        String x0 = null;
                        x0 = QueueStringVariable.Delete();
                        this.reciverContractionTreeVaribale.ResivedTaskFunction(x0, null, null, 0, null, ref ACT);
                    }
                    //ERRORCORECTION870957834 :For changing the function Argumnet.
                    this.ChangeTheSideOfArgument(TreeConstructed);
                }
            }
            //ERROR34534253 : Cuase to an infinite loop.

            if (IsParantes) ////if is function argument            
            {
                //ERRORCORECTION785606847 :The Error Corect.
                if ((Sample != "()") && (Sample != "(") && (Sample != ")"))
                {
                    //ERORRCORECTION78JDLK981274 :Editing                    
                    IsParantes = !IsParantes;
                    this.SenderToAddToTree(Sample, THIS, true);
                    IsParantes = !IsParantes;


                }
            }
            else
                if (!IsParantes)//if is not function arguments.
            {
                if (this.ISindependenceVaribale(Sample))
                    this.QueueStringVariable.Add(Sample);
                if (this.IsNumber(Sample))
                    this.QueueStringVariable.Add(Sample);
                if ((this.IsOperator(Sample)) || (this.IsFunction(Sample)))
                    if (this.IsOperator(Sample))
                    {
                        if (this.QueueStringVariable.NumberOfElement() >= 1)
                        {
                            String x0 = null;
                            x0 = QueueStringVariable.Delete();
                            this.reciverContractionTreeVaribale.ResivedTaskFunction(Sample, x0, null, 0, null, ref ACT);
                        }
                    }
                    else
                        //ERROR1826432164 :Refer to page 85 .this condition leads to error
                        if (this.IsFunction(Sample))
                        reciverContractionTreeVaribale.ResivedTaskFunction(Sample, null, null, 0, null, ref ACT);
            }

            End:
            return true;
        }
        public bool IsEqualWithThreadConsiderationCommonly(AddToTree.Tree T1, AddToTree.Tree T2)
        {

            if (T1 == null)
                if (T2 == null)
                    return true;
            bool IsEuqalTow = false;

            if (T1 != null)
                if (T2 != null)
                    if (T1.GetHashCode() == T1.GetHashCode())
                        if (T1.GetSample() == T2.GetSample())
                            IsEuqalTow = true;
            return IsEuqalTow;
        }
        public StackTree ToDeleteStackOfArray(StackTree St, ArrayTree At)
        {

            if (St.IsEmpty())
                return St;

            bool IsEqualWithThreadConsiderationCommonly = false;
            AddToTree.Tree Dummy = new AddToTree.Tree(null, false);
            Dummy = St.Pop();


            for (int i = 0; i < At.MexLetghOfElementsAccess + 1; i++)
                if (Dummy.Equals(At.GetIthMember(i)))
                {
                    IsEqualWithThreadConsiderationCommonly = true;
                    break;
                }
            St = this.ToDeleteStackOfArray(St, At);
            if (!IsEqualWithThreadConsiderationCommonly)
                St.Push(Dummy);
            return St;
        }
        private bool ISMovement(String Sample)
        {
            bool Is = false;
            if (Sample != null)
            {
                if (Sample.ToString().ToLower() == "up")
                    Is = true;
                else
                    if (Sample.ToString().ToLower() == "down")
                    Is = true;
                else
                        if (Sample.ToString().ToLower() == "left")
                    Is = true;
                else
                            if (Sample.ToString().ToLower() == "right")
                    Is = true;
            }
            return Is;
        }
        public void SenderToAddToTree(String Sample, Equation THIS, bool Parantez)
        {
            bool EQUATIONINSERTIOn = false;
            if (Sample != null)
                Current = Sample;
            else
            {
                Sample = Current;
                EQUATIONINSERTIOn = true;
            }


            //ERRORCORECTION19274 :the correction of ERROR30408034.refer to page 139.           

            if (this.ISMovement(Sample))
                goto End;
            THISEquationVariable = THIS;
            //ERRORCORECTION78290374987234 :The ERROR34095780976 Correction. 
            ParantezVariable = THIS.GetParantezFormVariable();
            //ERROR125487 .This method dose not work correctly.
            //ERROR43713501 :on Page 78 it illustrate
            //ERROR1234175609 :Error on structure page85
            //ERRORCORECTION786543679086 : if let side is empty do this else do else. refre to AddToTree namespace
            //ERROR456790358754 :ERROR when tow argument are on function (tow function inerr)
            //ERROR34095780976 :  When The Opened Parantez Clicked Nothing Oeccued.
            //ERROR31725 :refer to page 102.
            //ERROR41723150 :The structure is invalid.rfer to page 108.
            //ERROR928375 :The structre is invalid.refer to page 109.
            //ERROR124270 :The graphically draw has far disTance.
            //ERROR403107 : And has no effect.
            //ERRORBIG17242357 :The thread of nodes dose not set correctly or not set.refer to page 117.
            //ERROR137256 :Error on strcture refer to page 118.
            //ERROR40507011 :Error is already existed.refer to page 120.
            //ERROR30704350 :The right side is null.error in structure.

            //ERROR30408034 :The movement charackters fall in structure.
            TreeConstructed = this.NodeAccess;
            AddToTree.Tree Dummy = new AddToTree.Tree(null, false);
            AddToTree.Tree ADDED = new AddToTree.Tree(null, false);
            AddToTree.Tree Holder = new AddToTree.Tree(null, false);


            Holder = TreeConstructed;

            try
            {
                if (THIS.EquationTraceAccess.EquationTraceInsertionAccess.EqauationTraceInsertionAccess)
                    goto End;

            }
            catch (NullReferenceException t) { ExceptionClass.ExceptionClassMethod(t); }

            if (EQUATIONINSERTIOn)
                if (Holder.LeftSideAccess == null)
                    if (Holder.RightSideAccess == null)
                        if (IS.IsOperator(Sample))
                        {
                            Dummy.SampleAccess = Sample;
                            Dummy.SetLefTandRightCommonlySide(Holder, null);
                            Dummy.ThreadAccess = Holder.ThreadAccess;
                            Dummy.LeftSideAccess.ThreadAccess = Dummy;
                            Holder = Dummy;
                            this.reciverContractionTreeVaribale.NodeAccess = Holder;
                            THIS.EquationTraceAccess.EquationReadyAccess = true;
                            goto Return;
                        }

            //To Delete Extra Memebers.
            //e(it might to delete members incorrectly.
            //StackTreeVariable = ToDeleteStackOfArray(StackTreeVariable, ArrayTreeVariable);

            EquationSettingInsertionVariable.SetGropBox1(true, false, false);

            if (EquationSettingInsertionVariable.GropeBox1ReturnIsBegin()
                ||
                EquationSettingInsertionVariable.GropeBox2ReturnIsBegin()
                ||
                EquationSettingInsertionVariable.GropeBox1ReturnISinCurrent()
                ||
                EquationSettingInsertionVariable.GropeBox2ReturnISinCurrent())
            {
                //ERROR1826432164 :Refer to page 85
                bool ACT = false;
                this.SettingSenders(Sample, THIS, ref ACT);
                if (ACT)
                    THIS.EquationTraceAccess.EquationReadyAccess = true;
                //ERROR92834798234 :The strucure on base node is correctly but on local variable is not true.refer to page 103.
                //Inizialization for the first time.
                //if (EquationSettingInsertionVariable.GetHolder().GetSample() == null)

                if (StackTreeVariable.IsEmpty())
                    if (ArrayTreeVariable.IsEmpty())
                        if (this.IsFunction(Sample)
                            ||
                            this.IsOperator(Sample))
                        {
                            StackTreeVariable.Push(TreeConstructed);
                            ArrayTreeVariable.Push(TreeConstructed);
                        }
                //Relative to Parantez argument.
                AddToTree.Tree RightSideLast = null;
                //ERRORCORECTION5687345980 :Th condition was added.
                //ERROR73425273 :The RightSiodeLast is null.
                if (!Parantez)
                    RightSideLast = reciverContractionTreeVaribale.GetRightSideOfLastStage();
                else
                    RightSideLast = reciverContractionTreeVaribale.GetRightSideOfLastStageByParantez();
                //LOCATION678509874  : the sencse location of page 90 tick 
                //ERRORCORECTION780654785 :Add ISParantez varibale
                if (!IsParantes)
                    if (RightSideLast != null)
                        if (this.IsOperator(Sample)
                              ||
                           this.IsFunction(Sample))
                            if (reciverContractionTreeVaribale.GetIsLastRightNumberOrIndependenceVariale())
                            //ERROR30490678 :Enterring To Block Without any neede.refer to page 139.
                            {   //LOCATION87687988 :Refer to page 185.
                                /* Dummy = StackTreeVariable.Pop();                         
                                        ArrayTreeVariable.SetTrueChangingArrayMember(Dummy);
                                        ADDED.SampleAccess=Sample;
                                        ADDED.SetLefTandRightCommonlySide(Dummy.RightSideAccess, ADDED.RightSideAccess);
                                        //ERRORCORECTION901839 :refer to page 119.
                                        Dummy.RightSideAccess.ThreadAccess=ADDED;
                                        //ERROR307040 :Cause of ERRORCORECTION239487.refer to page 139.
                                        ADDED.RightSideAccess.ThreadAccess=ADDED; 
                                        Dummy.SetLefTandRightCommonlySide(Dummy.LeftSideAccess, ADDED);
                                        //ERRORCORECTION901839 :refer to page 119.
                                        ADDED.ThreadAccess=Dummy;
                                        //LOCATION1243
                                        StackTreeVariable.Push(ADDED);
                                        ArrayTreeVariable.Push(ADDED);
                                  */
                                //ERRORCORECTION30714123 :Refer to page 185.
                                if (!Parantez)
                                    Dummy = reciverContractionTreeVaribale.GetRightSideOfLastStage();
                                else
                                    Dummy = reciverContractionTreeVaribale.GetRightSideOfLastStageByParantez();
                                Dummy = Dummy.ThreadAccess;
                                ADDED.SampleAccess = Sample;
                                ADDED.SetLefTandRightCommonlySide(Dummy.LeftSideAccess.CopyNewTree(Dummy).RightSideAccess, null);
                                ADDED.LeftSideAccess.ThreadAccess = ADDED;
                                Dummy.RightSideAccess = ADDED;
                                //Dummy.LeftSideAccess.ThreadAccess = Dummy;
                                Dummy.RightSideAccess.ThreadAccess = Dummy;
                                THIS.EquationTraceAccess.EquationReadyAccess = true;
                                //Completely Rung.
                                /*
                                           if(this.IsOperator(Dummy.GetSample()))
                                               if (this.IsOperator(Dummy.LeftSideAccess.GetSample())
                                                   ||
                                                   this.IsOperator(Dummy.RightSideAccess.GetSample()))
                                               {
                                                   StackTreeVariable.Push(Dummy);
                                                   ArrayTreeVariable.SetFalSechangingArrayMember(Dummy);
                                               }
                                 */


                                /*
                                 * //The Error is Here.
                                //ERROR124576 .Localize ERROR.The Change Operator Is Done Incorrectly.
                                //When The  "x+x^2" Is in tree and A Operator Comes The Error Occures.
                                //Error Description :On Error Some Samples in tree lost.
                                //CORRECTION157398 Strategy : We consider that by hiding error location and add tow stament
                                //Stack push and array push of ADDED node To LOCATION1243 ,do it corrected?
                                //Error By ebove strategy corrected.
                                MessageBox.Show("' " + Dummy.LeftSideAccess.GetSample().ToString() + "' " + Dummy.GetSample().ToString() + "' " + Dummy.RightSideAccess.GetSample().ToString() + " ' is inCurrent?");
                                EquationSettingInsertionVariable.SetGropBox1(false, true, false);                        
                                EquationSettingInsertionVariable.ShowDialog();

                                if (EquationSettingInsertionVariable.GropeBox1ReturnISinCurrent())
                                    StackTreeVariable.Push(Dummy);
                                else
                                StackTreeVariable.Push(ADDED);

                                ArrayTreeVariable.Push(ADDED);
                                  */
                                //For Finding .This is a test. 
                                //ADDED.LeftSideAccess.SetThread(ADDED);

                                //extra
                                //EquationSettingInsertionVariable.SetHolder(ADDED);
                            }
                //ERRORCORECTION780654785 :Add ISParantez varibale
                if (!IsParantes)
                    if (this.IsOperator(Sample)
                        ||
                       this.IsFunction(Sample))
                        if (this.reciverContractionTreeVaribale.GetRightSideOfLastStage() != null)
                            if (this.ISindependenceVaribale(this.reciverContractionTreeVaribale.GetRightSideOfLastStage().GetSample())
                                    ||
                                    this.IsNumber(this.reciverContractionTreeVaribale.GetRightSideOfLastStage().GetSample())
                                    ||
                                    this.IsFunction(this.reciverContractionTreeVaribale.GetRightSideOfLastStage().GetSample()))
                            {
                                MessageBox.Show("If statment Reached To Finished Click 'End' other wise inCurrent.");
                                EquationSettingInsertionVariable.SetGropBox1(false, true, false);
                                EquationSettingInsertionVariable.ShowDialog();
                            }
                //ERRORCORECTION780654785 :Add ISParantez varibale
                if (!IsParantes)

                    if (EquationSettingInsertionVariable.GropeBox2ReturnIsEnd()
                        ||
                        EquationSettingInsertionVariable.GropeBox1ReturnIsEnd())
                        if (TreeConstructed != null)
                        {
                            //fte(The Dummy Contained next idea Node)
                            Dummy = EquationSettingInsertionVariable.GetHolder();
                            ADDED.SampleAccess = Sample;
                            ADDED.SetLefTandRightCommonlySide(Dummy.RightSideAccess, ADDED.RightSideAccess);
                            //ERRORCORECTION190187234 :refer to page 119.
                            if (Dummy.RightSideAccess != null)
                                Dummy.RightSideAccess.ThreadAccess = ADDED;
                            if (ADDED.RightSideAccess != null)
                                ADDED.RightSideAccess.ThreadAccess = ADDED;

                            Dummy.SetLefTandRightCommonlySide(Dummy.LeftSideAccess, ADDED);
                            //ERRORCORECTION190187234 :refer to page 119.
                            ADDED.ThreadAccess = Dummy;
                            EquationSettingInsertionVariable.SetHolder(ADDED);
                            EquationSettingInsertionVariable.SetGropBox1(true, false, false);
                            THIS.EquationTraceAccess.EquationReadyAccess = true;
                        }
            }
            if ((TreeConstructed != null) && (TreeConstructed.GetSample() == null))
                if (this.IsFunction(Sample))
                    TreeConstructed.SampleAccess = Sample;
            //To Set Graphically Settings.
            //GraphicallyInterface.GraphicallyRefreshingToOnotherClass(THIS,this);
            End:
            DrawingVariable.GraphicsAccess.Clear(Color.White);
            if (TreeConstructed != null)
                if (TreeConstructed.GetSample() != null)//by this condition ocures.
                    DrawingVariable.Draw(THISEquationVariable, this, 40, 40);
            Return:
            return;

        }
        public bool IsNumber(String Sample)
        {
            bool IsNumber = false;
            if (Sample != null)
            {
                //ERRORCORECTION89764567 :The condition of being parantez added
                if ((!this.IsFunction(Sample)) && (!this.IsOperator(Sample)) && (!this.ISindependenceVaribale(Sample)) && (!this.IsParantez(Sample)) && (!this.IsEqualWithThreadConsiderationCommonlySample(Sample)))
                    IsNumber = true;
            }
            return IsNumber;
        }
        public bool IsOperator(String Sample)
        {
            bool IsOperator = false;
            if (Sample != null)
            {
                if (Sample.ToString() == "+")
                    IsOperator = true;
                else
                    if (Sample.ToString() == "-")
                    IsOperator = true;
                else
                        if (Sample.ToString() == "*")
                    IsOperator = true;
                else
                            if (Sample.ToString() == "/")
                    IsOperator = true;
                else
                                if (Sample.ToString().ToLower() == "pow")
                    IsOperator = true;
                else
                                    if (Sample.ToString().ToLower() == "^")
                    IsOperator = true;
            }
            return IsOperator;
        }
        private bool IsPower(String Sample)
        {
            bool Is = false;
            if (Sample == "^")
                Is = true;
            return Is;
        }

        public bool IsParantez(String Sample)
        {
            //ERRORCORECTION896709487 : it is like a number ERROR73425362.The problem solved.
            bool IsPrantez = false;
            if (Sample != null)
                if ((Sample.ToString() == "()") || (Sample.ToString() == "(") || (Sample.ToString() == ")"))
                    IsPrantez = true;
            return IsPrantez;
        }
        public bool IsFunction(String Sample)
        {
            bool IsFunction = false;
            if (Sample != null)
            {
                if (Sample.ToString().ToLower() == "sin")
                    IsFunction = true;
                else
                    if (Sample.ToString().ToLower() == "cos")
                    IsFunction = true;
                else
                        if (Sample.ToString().ToLower() == "tan")
                    IsFunction = true;
                else
                            if (Sample.ToString().ToLower() == "cot")
                    IsFunction = true;
                else
                                if (Sample.ToString().ToLower() == "sec")
                    IsFunction = true;
                else
                                    if (Sample.ToString().ToLower() == "csc")
                    IsFunction = true;
                else
                                        if (Sample.ToString().ToLower() == "log")
                    IsFunction = true;
                else
                                            if (Sample.ToString().ToLower() == "ln")
                    IsFunction = true;
                if (Sample.ToString().ToLower() == "root")
                    IsFunction = true;
            }
            return IsFunction;
        }
        public bool ISindependenceVaribale(String Sample)
        {
            bool ISindePendenceVariable = false;
            if (Sample != null)
            {
                if (Sample.ToString().ToLower() == "x")
                    ISindePendenceVariable = true;
                else
                    ISindePendenceVariable = false;
            }
            return ISindePendenceVariable;
        }
        public bool ISindependenceVaribaleOrNumber(String Sample)
        {
            bool ISindePendenceVariableOrNumber = false;
            if (Sample != null)
            {
                if (this.ISindependenceVaribale(Sample))
                    ISindePendenceVariableOrNumber = true;
                if (this.IsNumber(Sample))
                    ISindePendenceVariableOrNumber = true;
            }
            return ISindePendenceVariableOrNumber;
        }
    }
    class QueueString
    {
        String[] QueueStringVariable = null;
        int front, rear;
        int MaxLen = 0;
        public QueueString(int Size)
        {
            QueueStringVariable = new String[Size];
            MaxLen = Size;
            front = rear = -1;
        }
        public bool Add(String Sample)
        {
            bool Isfull = false;
            int k = (rear + 1) % MaxLen;
            if (front == k) Isfull = true;
            else QueueStringVariable[rear = k] = Sample;
            return Isfull;
        }
        public String Delete()
        {
            if (front == rear)
                return null;
            front++;
            front = front % MaxLen;
            String Sample = QueueStringVariable[front];
            QueueStringVariable[front] = null;
            return Sample;
        }
        public bool IsEmpty()
        {
            if (rear == MaxLen - 1) return true;
            else return false;
        }
        public bool IsFull()
        {
            if (front == rear) return true;
            else return false;
        }
        public int NumberOfElement()
        {
            int x = System.Math.Abs((front - rear) % MaxLen);
            return x;
        }
    }
    public class StackTree
    {
        AddToTree.Tree[] StackTreeVariable = null;
        int StackTreePointer = -1;
        int MaxSize = 0;
        public StackTree(int Max)
        {
            StackTreeVariable = new AddToTree.Tree[Max];
            MaxSize = Max;
        }
        public void Push(AddToTree.Tree t)
        {
            if (!this.IsFull())
            {
                StackTreePointer++;
                StackTreeVariable[StackTreePointer] = t;
            }
        }
        public AddToTree.Tree Pop()
        {
            AddToTree.Tree Dummy = null;
            if (!this.IsEmpty())
            {
                Dummy = StackTreeVariable[StackTreePointer];
                StackTreeVariable[StackTreePointer] = null;
                StackTreePointer--;
            }
            return Dummy;
        }
        public bool IsEmpty()
        {
            bool ISEmpty = false;
            if (StackTreePointer == -1)
                ISEmpty = true;
            return ISEmpty;
        }
        public bool IsFull()
        {
            bool ISFull = false;
            if (StackTreePointer == MaxSize)
                ISFull = true;
            return ISFull;
        }
    }
    public class ArrayTree
    {
        AddToTree.Tree[] ArrayTreeVariable = null;
        int CurrentMember = -1;
        bool[] ChangingIndication = null;
        public ArrayTree(int MaxSize)
        {
            ArrayTreeVariable = new AddToTree.Tree[MaxSize];
            ChangingIndication = new bool[MaxSize];
        }
        public int MexLetghOfElementsAccess
        {
            get { return CurrentMember; }
            set { CurrentMember = value; }
        }
        public bool IsEmpty()
        {
            bool ISEmpty = false;
            if (CurrentMember == -1)
                ISEmpty = true;
            return ISEmpty;
        }
        public bool GetIthMemberOfChenging(int i)
        {
            return ChangingIndication[i];
        }
        public AddToTree.Tree GetIthMember(int i)
        {
            return ArrayTreeVariable[i];
        }
        public void Push(AddToTree.Tree t)
        {
            CurrentMember++;
            ArrayTreeVariable[CurrentMember] = t;
            ChangingIndication[CurrentMember] = false;
        }
        //Argumnet is Pop Member
        public void SetTrueChangingArrayMember(AddToTree.Tree t)
        {
            AddToTree.Tree Dummy = new AddToTree.Tree(null, false);
            for (int i = 0; i < CurrentMember + 1; i++)
                if (this.ArrayTreeVariable[i].Equals(t))
                {
                    this.ChangingIndication[i] = true;
                    break;
                }
        }
        public void SetFalSechangingArrayMember(AddToTree.Tree t)
        {
            AddToTree.Tree Dummy = new AddToTree.Tree(null, false);
            for (int i = 0; i < CurrentMember + 1; i++)
                if (this.ArrayTreeVariable[i].Equals(t))
                {
                    this.ChangingIndication[i] = false;
                    break;
                }
        }
        public int CurrentMemberLocationAcess
        {
            get { return CurrentMember; }
            set { CurrentMember = value; }
        }

    }
    public class EquationTraceInsertion
    {
        Equation Equation = null;
        EquationTrace EqautionTrace = null;
        AddToTree.Tree TreeVariable = null;
        Set SetVariable = null;
        bool EquationInsertion = false;
        SenderSample SendeSampleVariable = null;
        Equation EquationNEW = null;
        SenderSample SenderSampleNEW = null;
        public EquationTraceInsertion(Equation THIS)
        {
            Equation = THIS;
            EquationInsertion = true;
            EqautionTrace = THIS.EquationTraceVariable;
            TreeVariable = Equation.SenderAccess.AutoSenderAccess.NodeAccess;
            SetVariable = Equation.SenderAccess.AutoSenderAccess.DrawingAccess.ArrtificialItelligenceForGraphicallyDrawingAccess.NodeSetAcesss;
            SendeSampleVariable = Equation.SenderAccess;
            EquationInsertion = false;
            EquationNEW = new Equation();
            EquationNEW.SenderSampleAccess = new SenderSample(EquationNEW);
            EquationNEW.Hide();
            EquationNEW.SenderSampleAccess.AutoSenderAccess.DrawingAccess.GraphicallyInterfaceAccess.EditorAccesss.Hide();

        }
        public bool EqauationTraceInsertionAccess
        {
            get { return EquationInsertion; }
            set { EquationInsertion = value; }
        }
        public EquationTrace EqauationTraceAccess
        {
            get { return EqautionTrace; }
            set { EqautionTrace = value; }
        }
        public AddToTree.Tree TreeVariableAccess
        {
            get { return TreeVariable; }
            set { TreeVariable = value; }
        }
        public Set SetvariableAccess
        {
            get { return SetVariable; }
            set { SetVariable = value; }
        }
        public SenderSample SenderSDamplevariableAccess
        {
            get { return SendeSampleVariable; }
            set { SendeSampleVariable = value; }
        }
        public void SetTraceTreeVariblefunction(Equation THIS)
        {
            AddToTree.Tree Holder = SendeSampleVariable.AutoSenderAccess.reciverCuntractionTreeAccess.NodeAccess;
            AddToTree.Tree Current = ConvertClass.ConverSetToAddTreeFx(Equation.EquationTraceVariable.CurrentSetAccess);
            //AddToTree.Tree CurrentAdded = new AddToTree.Tree(SendeSampleVariable.AutoSenderAccess.CurrentStirngAccess, false);

            Holder = Holder.FINDTreeWithOutThreadConsiderationWithMoreeficiency(Holder, Current);

            EquationNEW.Hide();

            EquationNEW.SenderSampleAccess.AutoSenderAccess.DrawingAccess.GraphicallyInterfaceAccess.EditorAccesss.Hide();



            //SenderSampleNEW.AutoSenderAccess.SenderToAddToTree(SendeSampleVariable.AutoSenderAccess.CurrentStirngAccess,EquationNEW,false);
            EquationNEW.InizilzingNullEquationTraceInsertionCallObjetcs();

            EquationNEW.SenderAccess.AutoSenderAccess.CurrentStirngAccess = SendeSampleVariable.AutoSenderAccess.CurrentStirngAccess;

            EquationNEW.SenderSampleAccess.AutoSenderAccess.reciverCuntractionTreeAccess.NodeAccess = Current;

            EquationNEW.SenderOperations();
            if (EquationNEW.EquationTraceAccess.EquationReadyAccess)
            {
                Current = EquationNEW.SenderAccess.AutoSenderAccess.reciverCuntractionTreeAccess.NodeAccess;

                AddToTree.Tree COMTAINER = Holder;

                Holder = Holder.ThreadAccess;

                Formulas.UknownIntegralSolver UIS = new UknownIntegralSolver();
                UIS.Hide();
                if (EqualToObject.IsEqualWithOutThreadConsiderationByDivision(COMTAINER, Holder.LeftSideAccess, ref UIS))
                {
                    Holder.LeftSideAccess = Current;
                    Holder.LeftSideAccess.ThreadAccess = Holder;

                }
                else
                {
                    Holder.RightSideAccess = Current;
                    Holder.RightSideAccess.ThreadAccess = Holder;

                }

                while ((Holder != null) && (Holder.ThreadAccess != null))
                    Holder = Holder.ThreadAccess;

                SendeSampleVariable.AutoSenderAccess.reciverCuntractionTreeAccess.NodeAccess = Holder;
                THIS.EquationTraceAccess.EquationReadyAccess = EquationNEW.EquationTraceAccess.EquationReadyAccess;
            }
        }
    }
}