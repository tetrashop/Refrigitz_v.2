/**************************************
***************************************
***************************************
***************************************
***************************************
***************************************
***************************************
***************************************
***************************************
***************************************
***************************************
***************************************
***************************************
***************************************
***************************************
***************************************
***************************************
***************************************
***************************************
***************************************
*************TETRASHOP.IR**************
***************************************
***************************************
***************************************
***************************************
***************************************
***************************************
***************************************
***************************************
***************************************
***************************************
***************************************
***************************************
***************************************
***************************************
***************************************
***************************************
***************************************
***************************************
**************************************/
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Drawing;
using System.IO;
using System.Runtime.Serialization.Formatters.Binary;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
namespace RefrigtzChessPortable
{

    [Serializable]
    public class AllDraw//: IDisposable
    {
        public static bool HarasAct = false;
        public static int StoreInitMaxAStarGreedy = 0;
        public static bool SStopInitMaxAStarGreedy = false;
        //justicce height
        static int MaxxLevel = 0;
        public static int indexStep = 1;
        public int CurrentMaxLevel = 0;
        public static Timer Wtime = null;

        public static Timer Btime = null;
        public static int wtime = 4 * 60 * 1000;
        public static int btime = 4 * 60 * 1000;
        public static int winc = 1000;
        public static int binc = 1000;
        public static int TimeMax = 0;

        public static bool ChangedInTreeOccured = false;
        public static bool ThinkingRunInBothSide = false;
        float TimeNow = 0;
        public static bool IdleInWork = true;
        public const float MaxTimeInMillisseconds = 10;//Max 10 second
        public static float TimeInitiation;

        public static int CalIdle = 1;
        public static int PlatformHelperProcessorCount = 2;

        public static int CompleteNumber = 300;

        public static bool CompleteTreeDo = false;
        public static bool CompleteTreeCancel = false;
        public static int[,,] QuntumTable = {
            {{-1, -1, - 1, -1, -1, -1, -1, -1 },
             {-1, -1, - 1, -1, -1, -1, -1, -1 },
             {-1, -1, - 1, -1, -1, -1, -1, -1 },
             {-1, -1, - 1, -1, -1, -1, -1, -1 },
             {-1, -1, - 1, -1, -1, -1, -1, -1 },
             {-1, -1, - 1, -1, -1, -1, -1, -1 },
             {-1, -1, - 1, -1, -1, -1, -1, -1 },
             {-1, -1, - 1, -1, -1, -1, -1, -1 }},
             {{-1, -1, - 1, -1, -1, -1, -1, -1 },
              {-1, -1, - 1, -1, -1, -1, -1, -1 },
              {-1, -1, - 1, -1, -1, -1, -1, -1 },
              {-1, -1, - 1, -1, -1, -1, -1, -1 },
              {-1, -1, - 1, -1, -1, -1, -1, -1 },
              {-1, -1, - 1, -1, -1, -1, -1, -1 },
              {-1, -1, - 1, -1, -1, -1, -1, -1 },
              {-1, -1, - 1, -1, -1, -1, -1, -1 }}};
        public static bool AllowedSupTrue = false;
        public static int OrderPlateDraw = -1;
        public static bool UniqueLeafDetection = true;
        int NumberOfnewMove = 0;
        bool UsedRestrictedMoveBlitzAndFull = true;
        public List<bool> SolderesOnTableMove = new List<bool>();
        public List<bool> ElephantOnTableMove = new List<bool>();
        public List<bool> HoursesOnTableMove = new List<bool>();
        public List<bool> CastlesOnTableMove = new List<bool>();
        public List<bool> MinisterOnTableMove = new List<bool>();
        public List<bool> KingOnTableMove = new List<bool>();
        public List<bool> CastlingOnTableMove = new List<bool>();
        bool OnlyWin = false;
        public static bool LeafSemaphoreIndex = false;
        //Initiate Variables. 
        bool[] ThinkingAllowed = { false, false, false, false, false, false, false, false, false, false, false, false, false, false };

        [field: NonSerialized] List<Task> tH = new List<Task>();
        [field: NonSerialized] List<Task> TH = new List<Task>();
        public static bool Deeperthandeeper = false;
        public static bool FirstTraversalTree = true;
        public static int NumberOfLeafComputation = 0;
        public bool IsCurrentDraw = false;

        public int HaveKilled = 0;
        StringBuilder Space = new StringBuilder("&nbsp;");
        int Spaces = 0;
        bool SetDeptIgnore = false;
        long Now = DateTime.Now.Hour * (36000000 * 24) + DateTime.Now.Minute * 36000000 + DateTime.Now.Second * 600000 + DateTime.Now.Millisecond;
        long Later = DateTime.Now.Hour * (36000000 * 24) + DateTime.Now.Minute * 36000000 + DateTime.Now.Second * 600000 + DateTime.Now.Millisecond;
        StackFrame callStack = new StackFrame(1, true);
        int[,] Tabl = new int[8, 8];
        public int OrderP = 0;
        public static int DepthIterative = 0;
        int PerceptionCount = 0;
        public String OutPutAction = "";
        public static StringBuilder OutPut = new StringBuilder("");
        public static StringBuilder ActionString = new StringBuilder("");
        public static bool ActionStringReady = false;
        //static variable to be Initiate
        List<int[]> ValuableSelfSupported = new List<int[]>();
        public static bool RegardOccurred = false;
        public static int SuppportCountStaticGray = 0;
        public static int SuppportCountStaticBrown = 0;
        int CurrentAStarGredyMax = 0;
        public static int TaskBegin = 0;
        public static int TaskEnd = 0;
        public static String Root = System.IO.Path.GetDirectoryName(Environment.GetCommandLineArgs()[0]);
        public static int OrderPlate = 1;
        public static bool Blitz = false;
        public static int ConvertedKind = -2;
        public static bool ConvertWait = true;
        public static bool Stockfish = false;
        public static bool Person = true;
        public static bool THISSecradioButtonGrayOrderChecked = false;
        public static bool THISSecradioButtonBrownOrderChecked = false;
        public static String THIScomboBoxMaxLevelText = "";
        public static AllDraw THISDummy = null;
        public static bool StateCP = false;
        public static bool StateCC = false;
        public static int LastRow = -1;
        public static int LastColumn = -1;
        public static int NextRow = -1;
        public static int NextColumn = -1;
        public static int MovmentsNumber = 0;
        public static int MaxAStarGreedyHeuristicProgress = 0;
        public static bool EndOfGame = false;
        const int ThresholdBlitz = 10000;
        const int ThresholdFullGame = 20000;
        public bool SetRowColumnFinished = false;
        public static int MinThinkingTreeDepth = Int32.MaxValue;
        static int MaxDuringLevelThinkingCreation = 0;
        public int MaxHeuristicxT = Int32.MinValue;
        public bool MovementsAStarGreedyHeuristicFoundT = false;
        public bool IgnoreSelfObjectsT = false;
        public bool UsePenaltyRegardMechnisamT = false;
        public bool BestMovmentsT = false;
        public bool PredictHeuristicT = true;
        public bool OnlySelfT = false;
        public bool AStarGreedyHeuristicT = false;
        public int[] Index = { -1, -1, -1, -1, -1, -1 }, jindex = { -1, -1, -1, -1, -1, -1 }, Kind = { -1, -1, -1, -1, -1, -1 };
        public bool ArrangmentsChanged = true;
        public static int AStarGreedytMaxCount = 0;
        public static bool FoundATable = false;
        public static int Less = Int32.MinValue;
        public bool CastlesKing = false;
        List<int[,]> MaxHeuristicAStarGreedytBackWardTable = new List<int[,]>();
        public static int increasedProgress = 0;
        public static int CurrentHeuristic = Int32.MinValue;
        public static int SignAttack = 1;
        public static int SignObjectDangour = 1;
        public static int SignReducedAttacked = -1;
        public static int SignSupport = 1;
        public static int SignKiller = 1;
        public static int SignMovments = 1;
        public static int SignDistance = -1;
        public static int SignKingSafe = -1;
        public static int SignKingDangour = -1;
        public static bool DrawTable = true;
        public static int[,] TableVeryfy = new int[8, 8];
        public static int MaxAStarGreedy = 0; // PlatformHelper.ProcessorCount;
        public static int[,] TableVeryfyConst = new int[8, 8];
        public static List<int[,]> TableCurrent = new List<int[,]>();
        public static bool NoTableFound = false;
        public static bool DynamicAStarGreedytPrograming = false;
        public static List<AllDraw> StoreADraw = new List<AllDraw>();
        public static List<int> StoreADrawAStarGreedy = new List<int>();
        public static bool UseDoubleTime = false;
        public static int AStarGreedyiLevelMax;
        public static bool AStarGreadyFirstSearch = true;
        public static String ImageRoot = AllDraw.Root + "\\Images";
        public static String ImagesSubRoot = AllDraw.ImageRoot + "\\Fit\\Small\\";
        public static bool RedrawTable = true;
        public static String SyntaxToWrite = "";
        public static bool SodierConversionOcuured = false;
        public static int SodierMovments = 1;
        public static int ElefantMovments = 1;
        public static int HourseMovments = 1;
        public static int CastleMovments = 1;
        public static int MinisterMovments = 1;
        public static int KingMovments = 1;

        public int SodierMidle = 0;
        public int SodierHigh = 0;
        public int ElefantMidle = 0;
        public int ElefantHigh = 0;
        public int HourseMidle = 0;
        public int HourseHight = 0;
        public int CastleMidle = 0;
        public int CastleHigh = 0;
        public int MinisterMidle = 0;
        public int MinisterHigh = 0;
        public int KingMidle = 0;
        public int KingHigh = 0;

        int RW = 0;
        int CL = 0;
        int Ki = 0;
        int RW1 = 0;
        int CL1 = 0;
        int Ki1 = 0;
        int MaxLess1 = 0;
        int RW2 = 0;
        int CL2 = 0;
        int Ki2 = 0;
        int MaxLess2 = 0;
        int RW3 = 0;
        int CL3 = 0;
        int Ki3 = 0;
        int MaxLess3 = 0;
        int RW4 = 0;
        int CL4 = 0;
        int Ki4 = 0;
        int MaxLess4 = 0;
        int RW5 = 0;
        int CL5 = 0;
        int Ki5 = 0;
        int MaxLess5 = 0;
        int RW6 = 0;
        int CL6 = 0;
        int Ki6 = 0;
        int MaxLess6 = 0;
        int RW7 = 0;
        int CL7 = 0;
        int Ki7 = 0;
        int MaxLess7 = 0;
        public static int LoopHeuristicIndex = 0;
        static List<int> RWList = new List<int>();
        static List<int> ClList = new List<int>();
        static List<int> KiList = new List<int>();
        static public List<int[,]> TableListAction = new List<int[,]>();
        public int Move = 0;
        static public int MouseClick = 0;
        int[] AStarGreedyIndex = new int[20];
        public List<int[,]> TableList = new List<int[,]>();
        public int AStarGreedy = 0;
        public DrawSoldier[] SolderesOnTable = new DrawSoldier[16];
        public DrawElefant[] ElephantOnTable = new DrawElefant[4];
        public DrawHourse[] HoursesOnTable = new DrawHourse[4];
        public DrawCastle[] CastlesOnTable = new DrawCastle[4];
        public DrawMinister[] MinisterOnTable = new DrawMinister[2];
        public DrawKing[] KingOnTable = new DrawKing[2];
        public DrawCastling[] CastlingOnTable = new DrawCastling[1];
        List<int[]> MaxHeuristicAStarGreedytBackWard = new List<int[]>();
        const int MaxSoldeirFounded = 2;
        const int MaxElephntFounded = 6;
        const int MaxHourseFounded = 10;
        const int MaxCastlesFounded = 14;
        const int MaxMinisterFounded = 18;
        const int MaxKingFounded = 22;
        [NonSerialized()] public Task ob;
        //Making String datastructure to root variable
        public AllDraw AStarGreedyString = null;
        //Error Handling
        static void Log(Exception ex)
        {
            try
            {
                Object a = new Object();
                lock (a)
                {
                    string stackTrace = ex.ToString();
                    //Write to File.
                    Helper.WaitOnUsed(AllDraw.Root + "\\ErrorProgramRun.txt"); File.AppendAllText(AllDraw.Root + "\\ErrorProgramRun.txt", stackTrace + ": On" + DateTime.Now.ToString());
                }
            }
#pragma warning disable CS0168 // The variable 't' is declared but never used
            catch (Exception t) { }
#pragma warning restore CS0168 // The variable 't' is declared but never used
        }
        //Determine when a MoveOccured.
        //Note for before move.At most one  moves.
        public static bool IsAeMoveOccured(bool IsMove)
        {
            long Time = TimeElapced.TimeNow();
            bool Is = false;
            if (!IsMove)
            {
                int IsInt = (new Random()).Next(0, 32);
                Is = System.Convert.ToBoolean(IsInt % 2);
            }

            return Is;
        }
        void TimeEnd()
        {

            Now = DateTime.Now.Hour * (60000 * 24) + DateTime.Now.Minute * 60000 + DateTime.Now.Second * 1000 + DateTime.Now.Millisecond;
            long Later = Now;
            do
            {
                Later = DateTime.Now.Hour * (60000 * 24) + DateTime.Now.Minute * 60000 + DateTime.Now.Second * 1000 + DateTime.Now.Millisecond;
            } while (Later - Now < 3 * 60000);

        }
        //Determine and set numbers of all curent state table severasl kinds node.
        public void SetObjectNumbers(int[,] TabS)
        {

            Object a = new Object();
            lock (a)
            {
                //Initiate
                SodierMidle = 0;
                SodierHigh = 0;
                ElefantMidle = 0;
                ElefantHigh = 0;
                HourseMidle = 0;
                HourseHight = 0;
                CastleMidle = 0;
                CastleHigh = 0;
                MinisterMidle = 0;
                MinisterHigh = 0;
                KingMidle = 0;
                KingHigh = 0;
                for (int h = 0; h < 8; h++)
                    for (int s = 0; s < 8; s++)
                    {
                        //Cal Solider Gray
                        if (TabS[h, s] == 1)
                        {
                            //Increase
                            SodierMidle++;
                            SodierHigh++;
                        }//Elephant Gray
                        else if (TabS[h, s] == 2)
                        {
                            //Increase
                            ElefantMidle++;
                            ElefantHigh++;
                        }
                        //Hoirse Gray
                        else if (TabS[h, s] == 3)
                        {
                            //Increase
                            HourseMidle++;
                            HourseHight++;
                        }
                        //Castle Gray
                        else if (TabS[h, s] == 4)
                        {
                            //Increase
                            CastleMidle++;
                            CastleHigh++;
                        }
                        //Minister Gray
                        else if (TabS[h, s] == 5)
                        {
                            //Increase
                            MinisterMidle++;
                            MinisterHigh++;
                        }
                        //King Gray
                        else if (TabS[h, s] == 6)
                        {
                            //Increase
                            KingMidle++;
                            KingHigh++;
                        }
                        else//Solder Brown
                            if (TabS[h, s] == -1)
                        {
                            //Increase
                            SodierHigh++;
                        }
                        else if (TabS[h, s] == -2)//Elepant Brown
                        {
                            //Increase
                            ElefantHigh++;
                        }
                        else if (TabS[h, s] == -3)//Hourse Brown
                        {
                            //Increase
                            HourseHight++;
                        }
                        else if (TabS[h, s] == -4)//Castle Brown
                        {
                            //Increase
                            CastleHigh++;
                        }
                        else if (TabS[h, s] == -5)//Mincter Brown
                        {
                            //Increase
                            MinisterHigh++;
                        }
                        else if (TabS[h, s] == -6)//King Brown
                        {
                            //Incrrease
                            KingHigh++;
                        }
                    }
            }

        }
        //Found of Specific Objects uniqued
        float[] FoundLocationOfObject(ref int[,] Tabl, int Kind, bool IsGray)
        {

            Object a = new Object();
            lock (a)
            {
                //Initaite
                float[] Location = { -1, -1 };
                //Locate and search
                for (var i = 0; i < 8; i++)
                    for (var j = 0; j < 8; j++)
                    {
                        //When is Gray
                        if (IsGray)
                        {
                            //When object found
                            if (Tabl[i, j] == Kind)
                            {
                                //Srote location
                                Location[0] = i;
                                Location[1] = j;
                                //Clear Objects from table
                                Tabl[i, j] = 0;
                            }
                        }
                        else//Is Brown
                        {
                            //When Found
                            if (Tabl[i, j] * -1 == Kind)
                            {
                                //Store Location
                                Location[0] = i;
                                Location[1] = j;
                                //Clear from table
                                Tabl[i, j] = 0;
                            }
                        }
                    }

                //returnb location
                return Location;
            }
        }
        [field: NonSerialized]
        private readonly CancellationTokenSource feedCancellationTokenSource =
            new CancellationTokenSource();
#pragma warning disable CS0169 // The field 'AllDraw.feedTask' is never used
        [field: NonSerialized] private readonly Task feedTask;
#pragma warning restore CS0169 // The field 'AllDraw.feedTask' is never used

        public void Dispose()
        {
            Dispose(true);

        }
        protected virtual void Dispose(bool disposing)
        {
            if (disposing)
            {




            }
        }
        //Constructor
        public AllDraw(int Order, bool MovementsAStarGreedyHeuristicTFou, bool IgnoreSelfObject, bool UsePenaltyRegardMechnisa, bool BestMovment, bool PredictHurist, bool OnlySel, bool AStarGreedyHuris, bool Arrangments)
        {

            Object a = new Object();
            lock (a)
            {
                if (feedCancellationTokenSource == null) feedCancellationTokenSource = new CancellationTokenSource();
                MaxHeuristicxT = Int32.MinValue;
                MovementsAStarGreedyHeuristicFoundT = MovementsAStarGreedyHeuristicTFou;
                IgnoreSelfObjectsT = IgnoreSelfObject;
                UsePenaltyRegardMechnisamT = UsePenaltyRegardMechnisa;
                BestMovmentsT = BestMovment;
                PredictHeuristicT = PredictHurist;
                OnlySelfT = OnlySel;
                AStarGreedyHeuristicT = AStarGreedyHuris;
                ArrangmentsChanged = Arrangments;
                Object Om = new Object();
                lock (Om)
                {
                    FoundATable = false;
                }
                CastlesKing = false;
                increasedProgress = 0;
                Object ol = new Object();
                lock (ol)
                {
                    CurrentHeuristic = Int32.MinValue;
                    DrawTable = false;
                    TableVeryfy = new int[8, 8];
                    TableVeryfyConst = new int[8, 8];
                    TableCurrent.Clear();
                    NoTableFound = false;
                    DynamicAStarGreedytPrograming = false;
                    UseDoubleTime = false;
                    AStarGreadyFirstSearch = true;
                    ImageRoot = AllDraw.Root + "\\Images";
                    ImagesSubRoot = AllDraw.ImageRoot + "\\Fit\\Small\\";
                }
                RedrawTable = true;
                SodierConversionOcuured = false;
                SodierMovments = 1;
                ElefantMovments = 1;
                HourseMovments = 1;
                CastleMovments = 1;
                MinisterMovments = 1;
                KingMovments = 1;


                RW = 0;
                CL = 0;
                Ki = 0;
                RW1 = 0;
                CL1 = 0;
                Ki1 = 0;
                MaxLess1 = 0;
                RW2 = 0;
                CL2 = 0;
                Ki2 = 0;
                MaxLess2 = 0;
                RW3 = 0;
                CL3 = 0;
                Ki3 = 0;
                MaxLess3 = 0;
                RW4 = 0;
                CL4 = 0;
                Ki4 = 0;
                MaxLess4 = 0;
                RW5 = 0;
                CL5 = 0;
                Ki5 = 0;
                MaxLess5 = 0;
                RW6 = 0;
                CL6 = 0;
                Ki6 = 0;
                MaxLess6 = 0;
                LoopHeuristicIndex = 0;
                Move = 0;

                AStarGreedyIndex = new int[20];
                AStarGreedy = 0;
                SolderesOnTable = null;
                ElephantOnTable = null;
                HoursesOnTable = null;
                CastlesOnTable = null;
                MinisterOnTable = null;
                KingOnTable = null;
                CastlingOnTable = null;
                MaxHeuristicAStarGreedytBackWard.Clear();
                //Initiayte Locally Variables.
                TableList = new List<int[,]>();
                //APredict = new ChessPerdict(CurrentAStarGredyMax, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged//, ref th

                OrderP = Order;

            }
        }
        //Clone Copy Method
        public void Clone(AllDraw AA)
        {

            Object O = new Object();
            lock (O)
            {

                if (AA == null)
                {
                    AA = new AllDraw(OrderP, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged);
                    AA.TableList.Add(CloneATable(TableList[0]));
                }
                AA.Tabl = new int[8, 8];
                for (var i = 0; i < 8; i++)
                    for (var j = 0; j < 8; j++)
                        AA.Tabl[i, j] = Tabl[i, j];
                AA.OrderP = OrderP;
                AA.PerceptionCount = PerceptionCount;
                AA.OutPutAction = OutPutAction;
                //static variable to be Initiate
                AA.ValuableSelfSupported = new List<int[]>();
                for (var i = 0; i < 8; i++)
                    for (var j = 0; j < 8; j++)
                        AA.ValuableSelfSupported.Add(ValuableSelfSupported[i]);
                AA.CurrentAStarGredyMax = CurrentAStarGredyMax;
                for (var i = 0; i < 6; i++)
                    AA.Index[i] = Index[i];
                for (var i = 0; i < 6; i++)
                    AA.jindex[i] = jindex[i];
                for (var i = 0; i < 6; i++)
                    AA.Kind[i] = Kind[i];
                if (AStarGreedyString != null)
                    AStarGreedyString.Clone(AA.AStarGreedyString);
                if (TableList.Count == 1)
                    SetObjectNumbers(TableList[0]);
                MaxHeuristicxT = Int32.MinValue;
                AA.MovementsAStarGreedyHeuristicFoundT = MovementsAStarGreedyHeuristicFoundT;
                AA.IgnoreSelfObjectsT = IgnoreSelfObjectsT;
                AA.UsePenaltyRegardMechnisamT = UsePenaltyRegardMechnisamT;
                AA.BestMovmentsT = BestMovmentsT;
                AA.PredictHeuristicT = PredictHeuristicT;
                AA.OnlySelfT = OnlySelfT;
                AA.AStarGreedyHeuristicT = AStarGreedyHeuristicT;
                AA.ArrangmentsChanged = ArrangmentsChanged;
                AA.CastlesKing = CastlesKing;

                AA.SodierMidle = SodierMidle;
                AA.SodierHigh = SodierHigh;
                AA.ElefantMidle = ElefantMidle;
                AA.ElefantHigh = ElefantHigh;
                AA.HourseMidle = HourseMidle;
                AA.HourseHight = HourseHight;
                AA.CastleMidle = CastleMidle;
                AA.CastleHigh = CastleHigh;
                AA.MinisterMidle = MinisterMidle;
                AA.MinisterHigh = MinisterHigh;
                AA.KingMidle = KingMidle;
                AA.KingHigh = KingHigh;
                //Initiate a new class object and clone a copy.
                AA.SolderesOnTable = new DrawSoldier[SodierHigh];
                AA.ArrangmentsChanged = ArrangmentsChanged;
                for (var i = 0; i < SodierHigh; i++)
                {
                    SolderesOnTable[i].Clone(ref AA.SolderesOnTable[i]);
                }
                AA.ElephantOnTable = new DrawElefant[ElefantHigh];
                for (var i = 0; i < ElefantHigh; i++)
                {
                    ElephantOnTable[i].Clone(ref AA.ElephantOnTable[i]);

                }
                AA.HoursesOnTable = new DrawHourse[HourseHight];
                for (var i = 0; i < HourseHight; i++)
                {
                    HoursesOnTable[i].Clone(ref AA.HoursesOnTable[i]);

                }
                AA.CastlesOnTable = new DrawCastle[CastleHigh];
                for (var i = 0; i < CastleHigh; i++)
                {
                    CastlesOnTable[i].Clone(ref AA.CastlesOnTable[i]);

                }
                AA.MinisterOnTable = new DrawMinister[MinisterHigh];
                for (var i = 0; i < MinisterHigh; i++)
                {
                    MinisterOnTable[i].Clone(ref AA.MinisterOnTable[i]);

                }
                AA.KingOnTable = new DrawKing[KingHigh];
                for (var i = 0; i < KingHigh; i++)
                {
                    KingOnTable[i].Clone(ref AA.KingOnTable[i]);

                }
                AA.CastlingOnTable = new DrawCastling[1];
                for (var i = 0; i < 1; i++)
                {
                    CastlingOnTable[i].Clone(ref AA.CastlingOnTable[i]);

                }


                AA.AStarGreedy = AStarGreedy;
                if (AA.TableList.Count > 0)
                    AA.TableList.Clear();
                for (var i = 0; i < TableList.Count; i++)
                    AA.TableList.Add(CloneATable(TableList[i]));
                if (AA.TableList.Count > 0)
                    AA.SetObjectNumbers(AA.TableList[0]);
                AA.AStarGreedy = AStarGreedy;
            }

        }
        //a Constructor
        public AllDraw(int Order, bool MovementsAStarGreedyHeuristicTFou, bool IgnoreSelfObject, bool UsePenaltyRegardMechnisa, bool BestMovment, bool PredictHurist, bool OnlySel, bool AStarGreedyHuris, bool Arrangments, AllDraw THi)
        {

            Object a = new Object();
            lock (a)
            {
                if (feedCancellationTokenSource == null) feedCancellationTokenSource = new CancellationTokenSource();
                OrderP = Order;
                MaxHeuristicxT = Int32.MinValue;
                MovementsAStarGreedyHeuristicFoundT = MovementsAStarGreedyHeuristicTFou;
                IgnoreSelfObjectsT = IgnoreSelfObject;
                UsePenaltyRegardMechnisamT = UsePenaltyRegardMechnisa;
                BestMovmentsT = BestMovment;
                PredictHeuristicT = PredictHurist;
                OnlySelfT = OnlySel;
                AStarGreedyHeuristicT = AStarGreedyHuris;
                if (!Arrangments)
                    ArrangmentsChanged = Arrangments;
                else
                    ArrangmentsChanged = Arrangments;
                Object Om = new Object();
                lock (Om)
                {
                    AStarGreedytMaxCount = 0;
                }
                Object Omm = new Object();
                lock (Omm)
                {
                    FoundATable = false;
                }
                CastlesKing = false;
                increasedProgress = 0;
                Object ol = new Object();
                lock (ol)
                {
                    CurrentHeuristic = Int32.MinValue;
                    DrawTable = false;
                    TableVeryfy = new int[8, 8];
                    TableVeryfyConst = new int[8, 8];
                    TableCurrent.Clear();
                    NoTableFound = false;
                    DynamicAStarGreedytPrograming = false;
                    UseDoubleTime = false;
                    AStarGreadyFirstSearch = true;
                    ImageRoot = AllDraw.Root + "\\Images";
                    ImagesSubRoot = AllDraw.ImageRoot + "\\Fit\\Small\\";
                }
                RedrawTable = true;
                SodierConversionOcuured = false;
                SodierMovments = 1;
                ElefantMovments = 1;
                HourseMovments = 1;
                CastleMovments = 1;
                MinisterMovments = 1;
                KingMovments = 1;
                SodierMidle = 8;
                SodierHigh = 16;
                ElefantMidle = 2;
                ElefantHigh = 4;
                HourseMidle = 2;
                HourseHight = 4;
                CastleMidle = 2;
                CastleHigh = 4;
                MinisterMidle = 1;
                MinisterHigh = 2;
                KingMidle = 1;
                KingHigh = 2;

                RW = 0;
                CL = 0;
                Ki = 0;
                RW1 = 0;
                CL1 = 0;
                Ki1 = 0;
                MaxLess1 = 0;
                RW2 = 0;
                CL2 = 0;
                Ki2 = 0;
                MaxLess2 = 0;
                RW3 = 0;
                CL3 = 0;
                Ki3 = 0;
                MaxLess3 = 0;
                RW4 = 0;
                CL4 = 0;
                Ki4 = 0;
                MaxLess4 = 0;
                RW5 = 0;
                CL5 = 0;
                Ki5 = 0;
                MaxLess5 = 0;
                RW6 = 0;
                CL6 = 0;
                Ki6 = 0;
                MaxLess6 = 0;
                LoopHeuristicIndex = 0;
                Move = 0;

                AStarGreedyIndex = new int[20];
                AStarGreedy = 0;

                Object OOOO = new Object();
                lock (OOOO)
                {
                    MaxDuringLevelThinkingCreation = System.Convert.ToInt32(AllDraw.THIScomboBoxMaxLevelText);
                }
            }

        }
        //Check For Thinking Of Current Item Movments Finished.
        public bool AllCurrentAStarGreedyThinkingFinished(AllDraw Dum, int i, int j, int Kind)
        {

            Object a = new Object();
            lock (a)
            {
                //For All kind of Current Thinking depend of current type consider finshing state Thinking.
                bool Finished = false;
                {
                    //For Soldier
                    if (Kind == 1)
                    {
                        if (Dum.SolderesOnTable[i].SoldierThinking[0].ThinkingFinished)
                            return true;
                    }
                    //For Elephant
                    else if (Kind == 2)
                    {
                        if (Dum.ElephantOnTable[i].ElefantThinking[0].ThinkingFinished)
                            return true;
                    }
                    //For Hourse.
                    else if (Kind == 3)
                    {
                        if (Dum.HoursesOnTable[i].HourseThinking[0].ThinkingFinished)
                            return true;
                    }
                    //For Castles.
                    else if (Kind == 4)
                    {
                        if (Dum.CastlesOnTable[i].CastleThinking[0].ThinkingFinished)
                            return true;
                    }
                    //For Minsters.
                    else if (Kind == 5)
                    {
                        if (Dum.MinisterOnTable[i].MinisterThinking[0].ThinkingFinished)
                            return true;
                    }
                    //For Kings.
                    else if (Kind == 6)
                    {
                        if (Dum.KingOnTable[i].KingThinking[0].ThinkingFinished)
                            return true;
                    }
                    else if (Kind == 7 || Kind == -7)
                    {
                        if (Dum.CastlingOnTable[i].CastlingThinking[0].ThinkingFinished)
                            return true;
                    }
                }

                return Finished;
            }

        }
        //Rearrange AllDraw Object Content.
        public void SetRowColumn(int index, bool Verify = false)
        {
            SolderesOnTableMove.Clear();
            ElephantOnTableMove.Clear();
            HoursesOnTableMove.Clear();
            CastlesOnTableMove.Clear();
            MinisterOnTableMove.Clear();
            KingOnTableMove.Clear();
            CastlingOnTableMove.Clear();

            if (Verify)
            {
                if (SetRowColumn())
                    return;
                int Dummy = OrderP;
                Object a1 = new Object();
                lock (a1)
                {
                    SetObjectNumbers(TableList[0]);
                    int So1 = 0;
                    int So2 = SodierMidle;
                    for (int i = 0; i < SodierHigh; i++)
                        SolderesOnTableMove.Add(false);
                    int El1 = 0;
                    int El2 = ElefantMidle;
                    for (int i = 0; i < ElefantHigh; i++)
                        ElephantOnTableMove.Add(false);
                    int Ho1 = 0;
                    int Ho2 = HourseMidle;
                    for (int i = 0; i < HourseHight; i++)
                        HoursesOnTableMove.Add(false);
                    int Br1 = 0;
                    int Br2 = CastleMidle;
                    for (int i = 0; i < CastleHigh; i++)
                        CastlesOnTableMove.Add(false);
                    int Mi1 = 0;
                    int Mi2 = MinisterMidle;
                    for (int i = 0; i < MinisterHigh; i++)
                        MinisterOnTableMove.Add(false);
                    int Ki1 = 0;
                    int Ki2 = KingMidle;
                    for (int i = 0; i < KingHigh; i++)
                        KingOnTableMove.Add(false);
                    for (int i = 0; i < 1; i++)
                        CastlingOnTableMove.Add(false);
                    SetRowColumnFinished = false;
                    Move = 0;
                    //Intiate Dummy Variables.
                    //When Conversion Occured.
                    //When Table Exist.
                    if (TableList.Count > 0)
                    {
                        //For Every Table Things.
                        for (int Column = 0; Column < 8; Column++)
                            for (int Row = 0; Row < 8; Row++)
                            {
                                if (CloneATable(TableList[index])[Row, Column] == 0)
                                    continue;
                                //When Things are Soldiers.
                                if (System.Math.Abs(CloneATable(TableList[index])[Row, Column]) == 1)
                                {
                                    //Determine int
                                    Color a;
                                    if (CloneATable(TableList[index])[Row, Column] > 0)
                                    {
                                        OrderP = 1;
                                        a = Color.Gray;
                                    }
                                    else
                                    {
                                        OrderP = -1;
                                        a = Color.Brown;
                                    }     //When int is Gray. 
                                    if (a == Color.Gray)
                                    {
                                        //Construct Soder Gray.
                                        SolderesOnTable[So1].Row = Row;
                                        SolderesOnTable[So1].Column = Column;
                                        var ah = Task.Factory.StartNew(() => BlitzNotValidFullGameThinkingTreePartThree(So1, OrderP, 1));
                                        ah.Wait();
                                        ah.Dispose();
                                        //Increase So1.
                                        So1++;
                                        if (So1 > SodierMidle)
                                        {
                                            SodierMidle++;
                                            SodierHigh++;
                                        }
                                    }
                                    //When int is Brown
                                    else
                                    {
                                        //Construct Soldeir Brown.
                                        SolderesOnTable[So2].Row = Row;
                                        SolderesOnTable[So2].Column = Column;
                                        var ah = Task.Factory.StartNew(() => BlitzNotValidFullGameThinkingTreePartThree(So2, OrderP, 1));
                                        ah.Wait();
                                        ah.Dispose();
                                        //Increase So2.
                                        So2++;
                                        if (So2 > SodierHigh)
                                            SodierHigh++;
                                    }
                                }
                                else //For Elephant Objects.
                                    if (System.Math.Abs(CloneATable(TableList[index])[Row, Column]) == 2)
                                {
                                    //Initiate Local Variables.
                                    Color a;
                                    if (CloneATable(TableList[index])[Row, Column] > 0)
                                    {
                                        OrderP = 1;
                                        a = Color.Gray;
                                    }
                                    else
                                    {
                                        OrderP = -1;
                                        a = Color.Brown;
                                    }    //If Gray Elepahnt
                                    if (a == Color.Gray)
                                    {
                                        //Construction of Draw Object.
                                        ElephantOnTable[El1].Row = Row;
                                        ElephantOnTable[El1].Column = Column;
                                        //satisfied of created deeper three
                                        var ah = Task.Factory.StartNew(() => BlitzNotValidFullGameThinkingTreePartThree(El1, OrderP, 2));
                                        ah.Wait();
                                        ah.Dispose();


                                        //Increament of Gray Index.
                                        El1++;
                                        //If New Object Increament Gray Objects.
                                        if (El1 > ElefantMidle)
                                        {
                                            ElefantMidle++;
                                            ElefantHigh++;
                                        }
                                    }
                                    else//For Brown Elephant .Objects
                                    {
                                        //Construction of Draw Brown Elephant Object. 
                                        ElephantOnTable[El2].Row = Row;
                                        ElephantOnTable[El2].Column = Column;
                                        //satisfied of created deeper three
                                        BlitzNotValidFullGameThinkingTreePartThree(El2, OrderP, 2);
                                        var ah = Task.Factory.StartNew(() => BlitzNotValidFullGameThinkingTreePartThree(El2, OrderP, 2));
                                        ah.Wait();
                                        ah.Dispose();

                                        //Increament of Index.
                                        El2++;
                                        //When New Brown Elephant Object Increament of Index.
                                        if (El2 > ElefantHigh)
                                            ElefantHigh++;
                                    }
                                }
                                else//For Hourse Objects.
                                        if (System.Math.Abs(CloneATable(TableList[index])[Row, Column]) == 3)
                                {
                                    //Initiate Local Varibale and int.
                                    Color a;
                                    if (CloneATable(TableList[index])[Row, Column] > 0)
                                    {
                                        OrderP = 1;
                                        a = Color.Gray;
                                    }
                                    else
                                    {
                                        OrderP = -1;
                                        a = Color.Brown;
                                    }                //If Gray Hourse.
                                    if (a == Color.Gray)
                                    {
                                        //Construction of Draw Brown Hourse.
                                        HoursesOnTable[Ho1].Row = Row;
                                        HoursesOnTable[Ho1].Column = Column;
                                        //satisfied of created deeper three
                                        var ah = Task.Factory.StartNew(() => BlitzNotValidFullGameThinkingTreePartThree(Ho1, OrderP, 3));
                                        ah.Wait();
                                        ah.Dispose();

                                        //Increament of Index.
                                        Ho1++;
                                        //when There is New Gray Hourse Increase.
                                        if (Ho1 > HourseMidle)
                                        {
                                            HourseMidle++;
                                            HourseHight++;
                                        }
                                    }//For Brown Hourses.
                                    else
                                    {
                                        //Construction of Draw Brown Hourse.
                                        HoursesOnTable[Ho2].Row = Row;
                                        HoursesOnTable[Ho2].Column = Column;
                                        var ah = Task.Factory.StartNew(() => BlitzNotValidFullGameThinkingTreePartThree(Ho2, OrderP, 3));
                                        ah.Wait();
                                        ah.Dispose();

                                        //Increament of Index.
                                        Ho2++;
                                        //When New Brown Hourse Exist Exist Index.
                                        if (Ho2 > HourseHight)
                                            HourseHight++;
                                    }
                                }
                                else//For Castles Objects.
                                            if (System.Math.Abs(CloneATable(TableList[index])[Row, Column]) == 4)
                                {
                                    //Initiate of Local Variables.
                                    Color a;
                                    if (CloneATable(TableList[index])[Row, Column] > 0)
                                    {
                                        OrderP = 1;
                                        a = Color.Gray;
                                    }
                                    else
                                    {
                                        OrderP = -1;
                                        a = Color.Brown;
                                    }         //For Gray int.
                                    if (a == Color.Gray)
                                    {
                                        //Construction of New Draw Gray Castles.
                                        CastlesOnTable[Br1].Row = Row;
                                        CastlesOnTable[Br1].Column = Column;
                                        var ah = Task.Factory.StartNew(() => BlitzNotValidFullGameThinkingTreePartThree(Br1, OrderP, 4));
                                        ah.Wait();
                                        ah.Dispose();

                                        //Increamnt of Index.
                                        Br1++;
                                        //When New Gray Briges Increamnt Max Index.
                                        if (Br1 > CastleMidle)
                                        {
                                            CastleMidle++;
                                            CastleHigh++;
                                        }
                                    }//For Brown Castles.
                                    else
                                    {
                                        //Construction Draw of New Brown Castles.
                                        CastlesOnTable[Br2].Row = Row;
                                        CastlesOnTable[Br2].Column = Column;
                                        var ah = Task.Factory.StartNew(() => BlitzNotValidFullGameThinkingTreePartThree(Br2, OrderP, 4));
                                        ah.Wait();
                                        ah.Dispose();

                                        //Increament of Index.
                                        Br2++;
                                        //wehn Brown New Castles Detected Increament Max Index.
                                        if (Br2 > CastleHigh)
                                            CastleHigh++;
                                    }
                                }
                                else//For Minister Objects.
                                                if (System.Math.Abs(CloneATable(TableList[index])[Row, Column]) == 5)
                                {
                                    //Initiate Local int Varibales.
                                    Color a;
                                    if (CloneATable(TableList[index])[Row, Column] > 0)
                                    {
                                        OrderP = 1;
                                        a = Color.Gray;
                                    }
                                    else
                                    {
                                        OrderP = -1;
                                        a = Color.Brown;
                                    }     //For Gray ints.
                                    if (a == Color.Gray)
                                    {

                                        //construction of new draw Gray Minster.
                                        MinisterOnTable[Mi1].Row = Row;
                                        MinisterOnTable[Mi1].Column = Column;
                                        var ah = Task.Factory.StartNew(() => BlitzNotValidFullGameThinkingTreePartThree(Mi1, OrderP, 5));
                                        ah.Wait();
                                        ah.Dispose();

                                        //Increament of Index.
                                        Mi1++;
                                        //Wehn New Gray Minster Detected Increament Max Indexes.
                                        if (Mi1 > MinisterMidle)
                                        {
                                            MinisterMidle++;
                                            MinisterHigh++;
                                        }
                                    }//For Brown  ints.
                                    else
                                    {
                                        //Construction of New Draw Brown Minster.
                                        MinisterOnTable[Mi2].Row = Row;
                                        MinisterOnTable[Mi2].Column = Column;
                                        var ah = Task.Factory.StartNew(() => BlitzNotValidFullGameThinkingTreePartThree(Mi2, OrderP, 5));
                                        ah.Wait();
                                        ah.Dispose();

                                        //Increament Index.
                                        Mi2++;
                                        //When New Brown Minister Detected Increament Max Index.
                                        if (Mi2 > MinisterHigh)
                                            MinisterHigh++;
                                    }
                                }
                                else//for King Objects.        
                                if (System.Math.Abs(CloneATable(TableList[index])[Row, Column]) == 6)
                                {
                                    //Initiate Of int.
                                    Color a;
                                    if (CloneATable(TableList[index])[Row, Column] > 0)
                                    {
                                        OrderP = 1;
                                        a = Color.Gray;
                                    }
                                    else
                                    {
                                        OrderP = -1;
                                        a = Color.Brown;
                                    }     //int consideration.
                                    if (a == Color.Gray)
                                    {
                                        //Construction of New Draw Gray King.
                                        KingOnTable[Ki1].Row = Row;
                                        KingOnTable[Ki1].Column = Column;
                                        var ah = Task.Factory.StartNew(() => BlitzNotValidFullGameThinkingTreePartThree(Ki1, OrderP, 6));
                                        ah.Wait();
                                        ah.Dispose();

                                        //Increament of Index.
                                        Ki1++;
                                        //when New Draw  Object Detected Increament Max Index.
                                        if (Ki1 > KingMidle)
                                        {
                                            KingMidle++;
                                            KingHigh++;
                                        }
                                    }//For Brown King int
                                    else
                                    {
                                        //Construction of New Draw King Brown Object.
                                        KingOnTable[Ki2].Row = Row;
                                        KingOnTable[Ki2].Column = Column;
                                        var ah = Task.Factory.StartNew(() => BlitzNotValidFullGameThinkingTreePartThree(Ki2, OrderP, 6));
                                        ah.Wait();
                                        ah.Dispose();

                                        //Increament of Index.
                                        Ki2++;
                                        //When New Object Detected Increament Of Brown King Max Index.
                                        if (Ki2 > KingHigh)
                                            KingHigh++;
                                    }
                                }
                            }
                        //Make Empty Remaining.
                    }
                    if (Dummy == 1)
                    {
                        var ah = Task.Factory.StartNew(() => BlitzNotValidFullGameThinkingTreePartThree(0, Dummy, 7));
                        ah.Wait();
                        ah.Dispose();
                    }
                    else
                    {
                        var ah = Task.Factory.StartNew(() => BlitzNotValidFullGameThinkingTreePartThree(0, Dummy, -7));
                        ah.Wait();
                        ah.Dispose();
                    }
                    SetObjectNumbers(TableList[0]);
                    for (var i = So1; i < SodierMidle; i++)
                        SolderesOnTable[i] = null;
                    for (var i = So2; i < SodierHigh; i++)
                        SolderesOnTable[i] = null;
                    for (var i = El1; i < ElefantMidle; i++)
                        ElephantOnTable[i] = null;
                    for (var i = El2; i < ElefantHigh; i++)
                        ElephantOnTable[i] = null;
                    for (var i = Ho1; i < HourseMidle; i++)
                        HoursesOnTable[i] = null;
                    for (var i = Ho2; i < HourseHight; i++)
                        HoursesOnTable[i] = null;
                    for (var i = Br1; i < CastleMidle; i++)
                        CastlesOnTable[i] = null;
                    for (var i = Br2; i < CastleHigh; i++)
                        CastlesOnTable[i] = null;
                    for (var i = Mi1; i < MinisterMidle; i++)
                        MinisterOnTable[i] = null;
                    for (var i = Mi2; i < MinisterHigh; i++)
                        MinisterOnTable[i] = null;
                    for (var i = Ki1; i < KingMidle; i++)
                        KingOnTable[i] = null;
                    for (var i = Ki2; i < KingHigh; i++)
                        KingOnTable[i] = null;
                    if (TableList.Count > 0)
                    {
                        for (var i = 0; i < 8; i++)
                            for (var j = 0; j < 8; j++)
                                Tabl[i, j] = TableList[0][i, j];
                    }
                    SetRowColumnFinished = true;
                }
                Spaces--;

                OrderP = Dummy;
            }
            else
            {
                int Dummy = OrderP;
                Object a1 = new Object();
                lock (a1)
                {
                    SetObjectNumbers(TableList[0]);
                    int So1 = 0;
                    int So2 = SodierMidle;
                    for (int i = 0; i < SodierHigh; i++)
                        SolderesOnTableMove.Add(false);
                    int El1 = 0;
                    int El2 = ElefantMidle;
                    for (int i = 0; i < ElefantHigh; i++)
                        ElephantOnTableMove.Add(false);
                    int Ho1 = 0;
                    int Ho2 = HourseMidle;
                    for (int i = 0; i < HourseHight; i++)
                        HoursesOnTableMove.Add(false);
                    int Br1 = 0;
                    int Br2 = CastleMidle;
                    for (int i = 0; i < CastleHigh; i++)
                        CastlesOnTableMove.Add(false);
                    int Mi1 = 0;
                    int Mi2 = MinisterMidle;
                    for (int i = 0; i < MinisterHigh; i++)
                        MinisterOnTableMove.Add(false);
                    int Ki1 = 0;
                    int Ki2 = KingMidle;
                    for (int i = 0; i < KingHigh; i++)
                        KingOnTableMove.Add(false);
                    for (int i = 0; i < 1; i++)
                        CastlingOnTableMove.Add(false);
                    SetRowColumnFinished = false;
                    Move = 0;
                    //Intiate Dummy Variables.
                    //When Conversion Occured.
                    SolderesOnTable = new DrawSoldier[SodierHigh];
                    ElephantOnTable = new DrawElefant[ElefantHigh];
                    HoursesOnTable = new DrawHourse[HourseHight];
                    CastlesOnTable = new DrawCastle[CastleHigh];
                    MinisterOnTable = new DrawMinister[MinisterHigh];
                    KingOnTable = new DrawKing[KingHigh];
                    CastlingOnTable = new DrawCastling[1];
                    AllDraw.SodierConversionOcuured = false;
                    //When Table Exist.
                    if (TableList.Count > 0)
                    {
                        //For Every Table Things.
                        for (int Column = 0; Column < 8; Column++)
                            for (int Row = 0; Row < 8; Row++)
                            {
                                if (CloneATable(TableList[index])[Row, Column] == 0)
                                    continue;
                                //When Things are Soldiers.
                                if (System.Math.Abs(CloneATable(TableList[index])[Row, Column]) == 1)
                                {
                                    //Determine int
                                    Color a;
                                    if (CloneATable(TableList[index])[Row, Column] > 0)
                                    {
                                        OrderP = 1;
                                        a = Color.Gray;
                                    }
                                    else
                                    {
                                        OrderP = -1;
                                        a = Color.Brown;
                                    }     //When int is Gray. 
                                    if (a == Color.Gray)
                                    {
                                        //Construct Soder Gray.
                                        SolderesOnTable[So1] = new DrawSoldier(CurrentAStarGredyMax, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged, Row, Column, a, CloneATable(TableList[index]), 1, false, So1);
                                        //satisfied of created deeper three
                                        var ah = Task.Factory.StartNew(() => BlitzNotValidFullGameThinkingTreePartThree(So1, OrderP, 1));
                                        ah.Wait();
                                        ah.Dispose();
                                        //Increase So1.
                                        So1++;
                                        if (So1 > SodierMidle)
                                        {
                                            SodierMidle++;
                                            SodierHigh++;
                                        }
                                    }
                                    //When int is Brown
                                    else
                                    {
                                        //Construct Soldeir Brown.
                                        SolderesOnTable[So2] = new DrawSoldier(CurrentAStarGredyMax, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged, Row, Column, a, CloneATable(TableList[index]), -1, false, So2);
                                        //satisfied of created deeper three
                                        var ah = Task.Factory.StartNew(() => BlitzNotValidFullGameThinkingTreePartThree(So2, OrderP, 1));
                                        ah.Wait();
                                        ah.Dispose();
                                        //Increase So2.
                                        So2++;
                                        if (So2 > SodierHigh)
                                            SodierHigh++;
                                    }
                                }
                                else //For Elephant Objects.
                                    if (System.Math.Abs(CloneATable(TableList[index])[Row, Column]) == 2)
                                {
                                    //Initiate Local Variables.
                                    Color a;
                                    if (CloneATable(TableList[index])[Row, Column] > 0)
                                    {
                                        OrderP = 1;
                                        a = Color.Gray;
                                    }
                                    else
                                    {
                                        OrderP = -1;
                                        a = Color.Brown;
                                    }    //If Gray Elepahnt
                                    if (a == Color.Gray)
                                    {
                                        //Construction of Draw Object.
                                        ElephantOnTable[El1] = new DrawElefant(CurrentAStarGredyMax, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged, Row, Column, a, CloneATable(TableList[index]), 1, false, El1);
                                        //satisfied of created deeper three
                                        var ah = Task.Factory.StartNew(() => BlitzNotValidFullGameThinkingTreePartThree(El1, OrderP, 2));
                                        ah.Wait();
                                        ah.Dispose();
                                        //Increament of Gray Index.
                                        El1++;
                                        //If New Object Increament Gray Objects.
                                        if (El1 > ElefantMidle)
                                        {
                                            ElefantMidle++;
                                            ElefantHigh++;
                                        }
                                    }
                                    else//For Brown Elephant .Objects
                                    {
                                        //Construction of Draw Brown Elephant Object. 
                                        ElephantOnTable[El2] = new DrawElefant(CurrentAStarGredyMax, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged, Row, Column, a, CloneATable(TableList[index]), -1, false, El2);
                                        //satisfied of created deeper three
                                        var ah = Task.Factory.StartNew(() => BlitzNotValidFullGameThinkingTreePartThree(El2, OrderP, 2));
                                        ah.Wait();
                                        ah.Dispose();
                                        //Increament of Index.
                                        El2++;
                                        //When New Brown Elephant Object Increament of Index.
                                        if (El2 > ElefantHigh)
                                            ElefantHigh++;
                                    }
                                }
                                else//For Hourse Objects.
                                        if (System.Math.Abs(CloneATable(TableList[index])[Row, Column]) == 3)
                                {
                                    //Initiate Local Varibale and int.
                                    Color a;
                                    if (CloneATable(TableList[index])[Row, Column] > 0)
                                    {
                                        OrderP = 1;
                                        a = Color.Gray;
                                    }
                                    else
                                    {
                                        OrderP = -1;
                                        a = Color.Brown;
                                    }                //If Gray Hourse.
                                    if (a == Color.Gray)
                                    {
                                        //Construction of Draw Brown Hourse.
                                        HoursesOnTable[Ho1] = new DrawHourse(CurrentAStarGredyMax, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged, Row, Column, a, CloneATable(TableList[index]), 1, false, Ho1);
                                        //satisfied of created deeper three
                                        var ah = Task.Factory.StartNew(() => BlitzNotValidFullGameThinkingTreePartThree(Ho1, OrderP, 3));
                                        ah.Wait();
                                        ah.Dispose();
                                        //Increament of Index.
                                        Ho1++;
                                        //when There is New Gray Hourse Increase.
                                        if (Ho1 > HourseMidle)
                                        {
                                            HourseMidle++;
                                            HourseHight++;
                                        }
                                    }//For Brown Hourses.
                                    else
                                    {
                                        //Construction of Draw Brown Hourse.
                                        HoursesOnTable[Ho2] = new DrawHourse(CurrentAStarGredyMax, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged, Row, Column, a, CloneATable(TableList[index]), -1, false, Ho2);
                                        //satisfied of created deeper three
                                        var ah = Task.Factory.StartNew(() => BlitzNotValidFullGameThinkingTreePartThree(Ho2, OrderP, 3));
                                        ah.Wait();
                                        ah.Dispose();
                                        //Increament of Index.
                                        Ho2++;
                                        //When New Brown Hourse Exist Exist Index.
                                        if (Ho2 > HourseHight)
                                            HourseHight++;
                                    }
                                }
                                else//For Castles Objects.
                                            if (System.Math.Abs(CloneATable(TableList[index])[Row, Column]) == 4)
                                {
                                    //Initiate of Local Variables.
                                    Color a;
                                    if (CloneATable(TableList[index])[Row, Column] > 0)
                                    {
                                        OrderP = 1;
                                        a = Color.Gray;
                                    }
                                    else
                                    {
                                        OrderP = -1;
                                        a = Color.Brown;
                                    }         //For Gray int.
                                    if (a == Color.Gray)
                                    {
                                        //Construction of New Draw Gray Castles.
                                        CastlesOnTable[Br1] = new DrawCastle(CurrentAStarGredyMax, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged, Row, Column, a, CloneATable(TableList[index]), 1, false, Br1);
                                        //satisfied of created deeper three
                                        var ah = Task.Factory.StartNew(() => BlitzNotValidFullGameThinkingTreePartThree(Br1, OrderP, 4));
                                        ah.Wait();
                                        ah.Dispose();

                                        //Increamnt of Index.
                                        Br1++;
                                        //When New Gray Briges Increamnt Max Index.
                                        if (Br1 > CastleMidle)
                                        {
                                            CastleMidle++;
                                            CastleHigh++;
                                        }
                                    }//For Brown Castles.
                                    else
                                    {
                                        //Construction Draw of New Brown Castles.
                                        CastlesOnTable[Br2] = new DrawCastle(CurrentAStarGredyMax, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged, Row, Column, a, CloneATable(TableList[index]), -1, false, Br2);
                                        //satisfied of created deeper three
                                        var ah = Task.Factory.StartNew(() => BlitzNotValidFullGameThinkingTreePartThree(Br2, OrderP, 4));
                                        ah.Wait();
                                        ah.Dispose();

                                        //Increament of Index.
                                        Br2++;
                                        //wehn Brown New Castles Detected Increament Max Index.
                                        if (Br2 > CastleHigh)
                                            CastleHigh++;
                                    }
                                }
                                else//For Minister Objects.
                                                if (System.Math.Abs(CloneATable(TableList[index])[Row, Column]) == 5)
                                {
                                    //Initiate Local int Varibales.
                                    Color a;
                                    if (CloneATable(TableList[index])[Row, Column] > 0)
                                    {
                                        OrderP = 1;
                                        a = Color.Gray;
                                    }
                                    else
                                    {
                                        OrderP = -1;
                                        a = Color.Brown;
                                    }     //For Gray ints.
                                    if (a == Color.Gray)
                                    {

                                        //construction of new draw Gray Minster.
                                        MinisterOnTable[Mi1] = new DrawMinister(CurrentAStarGredyMax, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged, Row, Column, a, CloneATable(TableList[index]), 1, false, Mi1);
                                        //satisfied of created deeper three
                                        var ah = Task.Factory.StartNew(() => BlitzNotValidFullGameThinkingTreePartThree(Mi1, OrderP, 5));
                                        ah.Wait();
                                        ah.Dispose();

                                        //Increament of Index.
                                        Mi1++;
                                        //Wehn New Gray Minster Detected Increament Max Indexes.
                                        if (Mi1 > MinisterMidle)
                                        {
                                            MinisterMidle++;
                                            MinisterHigh++;
                                        }
                                    }//For Brown  ints.
                                    else
                                    {
                                        //Construction of New Draw Brown Minster.
                                        MinisterOnTable[Mi2] = new DrawMinister(CurrentAStarGredyMax, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged, Row, Column, a, CloneATable(TableList[index]), -1, false, Mi2);
                                        //satisfied of created deeper three
                                        var ah = Task.Factory.StartNew(() => BlitzNotValidFullGameThinkingTreePartThree(Mi2, OrderP, 5));
                                        ah.Wait();
                                        ah.Dispose();

                                        //Increament Index.
                                        Mi2++;
                                        //When New Brown Minister Detected Increament Max Index.
                                        if (Mi2 > MinisterHigh)
                                            MinisterHigh++;
                                    }
                                }
                                else//for King Objects.        
                                if (System.Math.Abs(CloneATable(TableList[index])[Row, Column]) == 6)
                                {
                                    //Initiate Of int.
                                    Color a;
                                    if (CloneATable(TableList[index])[Row, Column] > 0)
                                    {
                                        OrderP = 1;
                                        a = Color.Gray;
                                    }
                                    else
                                    {
                                        OrderP = -1;
                                        a = Color.Brown;
                                    }     //int consideration.
                                    if (a == Color.Gray)
                                    {
                                        //Construction of New Draw Gray King.
                                        KingOnTable[Ki1] = new DrawKing(CurrentAStarGredyMax, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged, Row, Column, a, CloneATable(TableList[index]), 1, false, Ki1);
                                        //satisfied of created deeper three
                                        var ah = Task.Factory.StartNew(() => BlitzNotValidFullGameThinkingTreePartThree(Ki1, OrderP, 6));
                                        ah.Wait();
                                        ah.Dispose();

                                        //Increament of Index.
                                        Ki1++;
                                        //when New Draw  Object Detected Increament Max Index.
                                        if (Ki1 > KingMidle)
                                        {
                                            KingMidle++;
                                            KingHigh++;
                                        }
                                    }//For Brown King int
                                    else
                                    {
                                        //Construction of New Draw King Brown Object.
                                        KingOnTable[Ki2] = new DrawKing(CurrentAStarGredyMax, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged, Row, Column, a, CloneATable(TableList[index]), -1, false, Ki2);
                                        //satisfied of created deeper three
                                        var ah = Task.Factory.StartNew(() => BlitzNotValidFullGameThinkingTreePartThree(Ki2, OrderP, 6));
                                        ah.Wait();
                                        ah.Dispose();

                                        //Increament of Index.
                                        Ki2++;
                                        //When New Object Detected Increament Of Brown King Max Index.
                                        if (Ki2 > KingHigh)
                                            KingHigh++;
                                    }
                                }
                            }
                        //Make Empty Remaining.
                    }
                    if (CastlingBoundryCondition())
                    {
                        if (Dummy == 1)
                        {
                            CastlingOnTable[0] = new DrawCastling(CurrentAStarGredyMax, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged, KingOnTable[0].Row, KingOnTable[0].Column, Color.Gray, CloneATable(TableList[index]), 1, false, 0);

                            var ah = Task.Factory.StartNew(() => BlitzNotValidFullGameThinkingTreePartThree(0, Dummy, 7));
                            ah.Wait();
                            ah.Dispose();
                        }
                        else
                        {
                            CastlingOnTable[0] = new DrawCastling(CurrentAStarGredyMax, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged, KingOnTable[1].Row, KingOnTable[1].Column, Color.Brown, CloneATable(TableList[index]), -1, false, 0);

                            var ah = Task.Factory.StartNew(() => BlitzNotValidFullGameThinkingTreePartThree(0, Dummy, -7));
                            ah.Wait();
                            ah.Dispose();
                        }
                    }
                    SetObjectNumbers(TableList[0]);
                    for (var i = So1; i < SodierMidle; i++)
                        SolderesOnTable[i] = null;
                    for (var i = So2; i < SodierHigh; i++)
                        SolderesOnTable[i] = null;
                    for (var i = El1; i < ElefantMidle; i++)
                        ElephantOnTable[i] = null;
                    for (var i = El2; i < ElefantHigh; i++)
                        ElephantOnTable[i] = null;
                    for (var i = Ho1; i < HourseMidle; i++)
                        HoursesOnTable[i] = null;
                    for (var i = Ho2; i < HourseHight; i++)
                        HoursesOnTable[i] = null;
                    for (var i = Br1; i < CastleMidle; i++)
                        CastlesOnTable[i] = null;
                    for (var i = Br2; i < CastleHigh; i++)
                        CastlesOnTable[i] = null;
                    for (var i = Mi1; i < MinisterMidle; i++)
                        MinisterOnTable[i] = null;
                    for (var i = Mi2; i < MinisterHigh; i++)
                        MinisterOnTable[i] = null;
                    for (var i = Ki1; i < KingMidle; i++)
                        KingOnTable[i] = null;
                    for (var i = Ki2; i < KingHigh; i++)
                        KingOnTable[i] = null;
                    if (TableList.Count > 0)
                    {
                        for (var i = 0; i < 8; i++)
                            for (var j = 0; j < 8; j++)
                                Tabl[i, j] = TableList[0][i, j];
                    }
                    SetRowColumnFinished = true;
                }
                Spaces--;

                OrderP = Dummy;
                SetObjectNumbers(Tabl);
            }
        }
        bool CastlingBoundryCondition()
        {
            if (CastlingOnTable == null)
                return true;
            if (CastlingOnTable[0] == null)
                return true;
            // if (CastlingOnTable[0].CastlingThinking == null)
            //     return true;
            //if (CastlingOnTable[0].CastlingThinking[0] == null)
            //  return true;
            //if (CastlingOnTable[0].CastlingThinking[0].AStarGreedy == null)
            //    return true;
            //if (CastlingOnTable[0].CastlingThinking[0].AStarGreedy.Count==0)
            //  return true;

            return false;
        }
        public bool SetRowColumn()
        {
            int Dummy = OrderP;

            Object a1 = new Object();
            lock (a1)
            {
                SetObjectNumbers(TableList[0]);
                int So1 = 0;
                int So2 = SodierMidle;
                int El1 = 0;
                int El2 = ElefantMidle;
                int Ho1 = 0;
                int Ho2 = HourseMidle;
                int Br1 = 0;
                int Br2 = CastleMidle;
                int Mi1 = 0;
                int Mi2 = MinisterMidle;
                int Ki1 = 0;
                int Ki2 = KingMidle;

                SetRowColumnFinished = false;
                Move = 0;
                //When Table Exist.
                if (TableList.Count > 0)
                {
                    //For Every Table Things.
                    for (int Column = 0; Column < 8; Column++)
                        for (int Row = 0; Row < 8; Row++)
                        {
                            if (CloneATable(TableList[0])[Row, Column] == 0)
                                continue;
                            //When Things are Soldiers.
                            if (System.Math.Abs(CloneATable(TableList[0])[Row, Column]) == 1)
                            {
                                //Determine int
                                Color a;
                                if (CloneATable(TableList[0])[Row, Column] > 0)
                                {
                                    OrderP = 1;
                                    a = Color.Gray;
                                }
                                else
                                {
                                    OrderP = -1;
                                    a = Color.Brown;
                                }     //When int is Gray. 
                                if (a == Color.Gray)
                                {
                                    if (TableList[0][(int)SolderesOnTable[So1].Row, (int)SolderesOnTable[So1].Column] != 1)
                                        return false;
                                    //IncreASe So1.
                                    So1++;
                                    if (So1 > SodierMidle)
                                    {
                                        SodierMidle++;
                                        SodierHigh++;
                                    }

                                }
                                //When int is Brown
                                else
                                {
                                    if (TableList[0][(int)SolderesOnTable[So2].Row, (int)SolderesOnTable[So2].Column] != -1)
                                        return false;
                                    //IncreASe So2.
                                    So2++;
                                    if (So2 > SodierHigh)
                                        SodierHigh++;

                                }
                            }
                            else //For Elephant Objects.
                                if (System.Math.Abs(CloneATable(TableList[0])[Row, Column]) == 2)
                            {
                                //Initiate Local Variables.
                                Color a;
                                if (CloneATable(TableList[0])[Row, Column] > 0)
                                {
                                    OrderP = 1;
                                    a = Color.Gray;
                                }
                                else
                                {
                                    OrderP = -1;
                                    a = Color.Brown;
                                }    //If Gray Elepahnt
                                if (a == Color.Gray)
                                {

                                    if (TableList[0][(int)ElephantOnTable[El1].Row, (int)ElephantOnTable[El1].Column] != 2)
                                        return false;
                                    //Increament of Gray 0.
                                    El1++;
                                    //If New Object Increament Gray Objects.
                                    if (El1 > ElefantMidle)
                                    {
                                        ElefantMidle++;
                                        ElefantHigh++;
                                    }
                                }
                                else//For Brown Elephant .Objects
                                {

                                    if (TableList[0][(int)ElephantOnTable[El2].Row, (int)ElephantOnTable[El2].Column] != -2)
                                        return false;
                                    //Increament of 0.
                                    El2++;
                                    //When New Brown Elephant Object Increament of 0.
                                    if (El2 > ElefantHigh)
                                        ElefantHigh++;

                                }
                            }
                            else//For Hourse Objects.
                                    if (System.Math.Abs(CloneATable(TableList[0])[Row, Column]) == 3)
                            {
                                //Initiate Local Varibale and int.
                                Color a;
                                if (CloneATable(TableList[0])[Row, Column] > 0)
                                {
                                    OrderP = 1;
                                    a = Color.Gray;
                                }
                                else
                                {
                                    OrderP = -1;
                                    a = Color.Brown;
                                }                //If Gray Hourse.
                                if (a == Color.Gray)
                                {

                                    if (TableList[0][(int)HoursesOnTable[Ho1].Row, (int)HoursesOnTable[Ho1].Column] != 3)
                                        return false;
                                    //Increament of 0.
                                    Ho1++;
                                    //when There is New Gray Hourse IncreASe.
                                    if (Ho1 > HourseMidle)
                                    {
                                        HourseMidle++;
                                        HourseHight++;
                                    }
                                }//For Brown Hourses.
                                else
                                {

                                    if (TableList[0][(int)HoursesOnTable[Ho2].Row, (int)HoursesOnTable[Ho2].Column] != -3)
                                        return false;
                                    //Increament of 0.
                                    Ho2++;
                                    //When New Brown Hourse Exist Exist 0.
                                    if (Ho2 > HourseHight)
                                        HourseHight++;
                                }
                            }
                            else//For Castles Objects.
                                        if (System.Math.Abs(CloneATable(TableList[0])[Row, Column]) == 4)
                            {
                                //Initiate of Local Variables.
                                Color a;
                                if (CloneATable(TableList[0])[Row, Column] > 0)
                                {
                                    OrderP = 1;
                                    a = Color.Gray;
                                }
                                else
                                {
                                    OrderP = -1;
                                    a = Color.Brown;
                                }         //For Gray int.
                                if (a == Color.Gray)
                                {

                                    if (TableList[0][(int)CastlesOnTable[Br1].Row, (int)CastlesOnTable[Br1].Column] != 4)
                                        return false;
                                    //Increamnt of 0.
                                    Br1++;
                                    //When New Gray Briges Increamnt Max 0.
                                    if (Br1 > CastleMidle)
                                    {
                                        CastleMidle++;
                                        CastleHigh++;
                                    }
                                }//For Brown Castles.
                                else
                                {

                                    if (TableList[0][(int)CastlesOnTable[Br2].Row, (int)CastlesOnTable[Br2].Column] != -4)
                                        return false;
                                    //Increament of 0.
                                    Br2++;
                                    //wehn Brown New Castles Detected Increament Max 0.
                                    if (Br2 > CastleHigh)
                                        CastleHigh++;
                                }
                            }
                            else//For Minister Objects.
                                            if (System.Math.Abs(CloneATable(TableList[0])[Row, Column]) == 5)
                            {
                                //Initiate Local int Varibales.
                                Color a;
                                if (CloneATable(TableList[0])[Row, Column] > 0)
                                {
                                    OrderP = 1;
                                    a = Color.Gray;
                                }
                                else
                                {
                                    OrderP = -1;
                                    a = Color.Brown;
                                }     //For Gray ints.
                                if (a == Color.Gray)
                                {


                                    if (TableList[0][(int)MinisterOnTable[Mi1].Row, (int)MinisterOnTable[Mi1].Column] != 5)
                                        return false;
                                    //Increament of 0.
                                    Mi1++;
                                    //Wehn New Gray Minster Detected Increament Max 0es.
                                    if (Mi1 > MinisterMidle)
                                    {
                                        MinisterMidle++;
                                        MinisterHigh++;
                                    }

                                }//For Brown  ints.
                                else
                                {

                                    if (TableList[0][(int)MinisterOnTable[Mi2].Row, (int)MinisterOnTable[Mi2].Column] != -5)
                                        return false;
                                    //Increament 0.
                                    Mi2++;
                                    //When New Brown Minister Detected Increament Max 0.
                                    if (Mi2 > MinisterHigh)
                                        MinisterHigh++;
                                }
                            }
                            else//for King Objects.        
                            if (System.Math.Abs(CloneATable(TableList[0])[Row, Column]) == 6)
                            {
                                //Initiate Of int.
                                Color a;
                                if (CloneATable(TableList[0])[Row, Column] > 0)
                                {
                                    OrderP = 1;
                                    a = Color.Gray;
                                }
                                else
                                {
                                    OrderP = -1;
                                    a = Color.Brown;
                                }     //int consideration.
                                if (a == Color.Gray)
                                {

                                    if (TableList[0][(int)KingOnTable[Ki1].Row, (int)KingOnTable[Ki1].Column] != 6)
                                        return false;
                                    //Increament of 0.
                                    Ki1++;
                                    //when New Draw  Object Detected Increament Max 0.
                                    if (Ki1 > KingMidle)
                                    {
                                        KingMidle++;
                                        KingHigh++;
                                    }
                                }//For Brown King int
                                else
                                {

                                    if (TableList[0][(int)KingOnTable[Ki2].Row, (int)KingOnTable[Ki2].Column] != -6)
                                        return false;
                                    //Increament of 0.
                                    Ki2++;
                                    //When New Object Detected Increament Of Brown King Max 0.
                                    if (Ki2 > KingHigh)
                                        KingHigh++;
                                }
                            }
                        }
                    //Make Empty Remaining.

                }

                SetObjectNumbers(TableList[0]);
                for (var i = Ki2; i < KingHigh; i++)
                    KingOnTable[i] = null;
                if (TableList.Count > 0)
                {
                    for (var i = 0; i < 8; i++)
                        for (var j = 0; j < 8; j++)
                            Tabl[i, j] = TableList[0][i, j];
                }
                SetRowColumnFinished = true;
            }
            Spaces--;

            OrderP = Dummy;
            return true;
        }
        //Waite semaphore
        void SetRowColumnFinishedWait()
        {

            Object a = new Object();
            lock (a)
            {
                do
                {

                } while (!SetRowColumnFinished);
            }

        }
        //Max Index List Of Heuristic AStarGreedy First Method.
        public void BeginIndexFoundingMaxLessofMaxList(int ListIndex, List<int> Founded, ref int LessB)
        {

            Object a = new Object();
            lock (a)
            {
                //When There is Maximum Huristsic AStar Gredy Back Ward in Blitz Games.
                if (MaxHeuristicAStarGreedytBackWard.Count > 0)
                {
                    //When List Index is LessB than Founded.
                    if (ListIndex < MaxHeuristicAStarGreedytBackWard.Count)
                        return;
                    //Initiate Variable.
                    bool Added = false;
                    //Recursive Method.
                    int Le = LessB;
                    var ah = Task.Factory.StartNew(() => BeginIndexFoundingMaxLessofMaxList(ListIndex++, Founded, ref Le));
                    ah.Wait();
                    ah.Dispose();
                    LessB = Le;

                    //When Greater LessB of First index Object Found.
                    if (LessB < MaxHeuristicAStarGreedytBackWard[ListIndex][1])
                    {
                        LessB = MaxHeuristicAStarGreedytBackWard[ListIndex][1];
                        Added = true;
                        Founded.Add(2);
                    }
                    //When Greater LessB of Second index Object Found.
                    if (LessB < MaxHeuristicAStarGreedytBackWard[ListIndex][5])
                    {
                        LessB = MaxHeuristicAStarGreedytBackWard[ListIndex][5];
                        if (Added)
                            Founded.RemoveAt(Founded.Count - 1);
                        Added = true;
                        Founded.Add(6);
                    }
                    //When Greater LessB of Third index Object Found.
                    if (LessB < MaxHeuristicAStarGreedytBackWard[ListIndex][9])
                    {
                        LessB = MaxHeuristicAStarGreedytBackWard[ListIndex][9];
                        if (Added)
                            Founded.RemoveAt(Founded.Count - 1);
                        Added = true;
                        Founded.Add(10);
                    }
                    //When Greater LessB of Foutrh index Object Found.
                    if (LessB < MaxHeuristicAStarGreedytBackWard[ListIndex][13])
                    {
                        LessB = MaxHeuristicAStarGreedytBackWard[ListIndex][13];
                        if (Added)
                            Founded.RemoveAt(Founded.Count - 1);
                        Added = true;
                        Founded.Add(14);
                    }
                    //When Greater LessB of Fifth index Object Found.
                    if (LessB < MaxHeuristicAStarGreedytBackWard[ListIndex][18])
                    {
                        LessB = MaxHeuristicAStarGreedytBackWard[ListIndex][18];
                        if (Added)
                            Founded.RemoveAt(Founded.Count - 1);
                        Added = true;
                        Founded.Add(19);
                    }
                    //When Greater LessB of Sith index Object Found.
                    if (LessB < MaxHeuristicAStarGreedytBackWard[ListIndex][22])
                    {
                        LessB = MaxHeuristicAStarGreedytBackWard[ListIndex][22];
                        if (Added)
                            Founded.RemoveAt(Founded.Count - 1);
                        Added = true;
                        Founded.Add(23);
                    }
                }
            }

        }
        //Method for Check of Existence of Checkmate less than for checked mate.
        bool IsToCheckMateHasLessDeeperThanForCheckMate(AllDraw A, int Order, ref int ToCheckMate, ref int ForCheckMate, int AStarGreedy)
        {

            Object a = new Object();
            lock (a)
            {
                //Initiate variables.
                bool AA = false;
                int CDummy = Order;
                //For Gray One.
                if (Order == 1)
                {
                    //For Solderis.
                    for (var i = 0; i < SodierMidle; i++)
                        for (var j = 0; A.SolderesOnTable != null && SolderesOnTable[i] != null && A.SolderesOnTable[i].SoldierThinking[0] != null && j < A.SolderesOnTable[i].SoldierThinking[0].TableListSolder.Count; j++)
                        {

                            //When there is Brown checked mate.
                            if (A.SolderesOnTable[i].SoldierThinking[0].CheckMateAStarGreedy == -1)
                            {
                                //Set.
                                ForCheckMate = AStarGreedy;
                                if (ToCheckMate >= 0)
                                    if (ToCheckMate < ForCheckMate && ToCheckMate >= 0)
                                        AA = true;
                            }
                            else
                            {
                                //When there is Gray Checked mate.
                                if (A.SolderesOnTable[i].SoldierThinking[0].CheckMateAStarGreedy == 1)
                                {
                                    ToCheckMate = AStarGreedy;
                                    if (ForCheckMate >= 0)
                                        if (ToCheckMate < ForCheckMate && ToCheckMate >= 0)
                                            AA = true;
                                }
                            }
                            Order *= -1;
                            for (var ii = 0; A.SolderesOnTable != null && SolderesOnTable[i] != null && A.SolderesOnTable[i].SoldierThinking[0] != null && ii < A.SolderesOnTable[i].SoldierThinking[0].AStarGreedy.Count; ii++)
                                AA = AA || IsToCheckMateHasLessDeeperThanForCheckMate(A.SolderesOnTable[i].SoldierThinking[0].AStarGreedy[ii], Order, ref ToCheckMate, ref ForCheckMate, AStarGreedy++);
                            Order = CDummy;
                        }
                    for (var i = 0; i < ElefantMidle; i++)
                        for (var j = 0; A.ElephantOnTable != null && ElephantOnTable[i] != null && A.ElephantOnTable[i].ElefantThinking[0] != null && j < A.ElephantOnTable[i].ElefantThinking[0].TableListElefant.Count; j++)
                        {

                            //When there is Brown checked mate.
                            if (A.ElephantOnTable[i].ElefantThinking[0].CheckMateAStarGreedy == -1)
                            {
                                ForCheckMate = AStarGreedy;
                                if (ToCheckMate >= 0)
                                    if (ToCheckMate < ForCheckMate && ToCheckMate >= 0)
                                        AA = true;

                            }
                            else
                            {
                                //When there is Gray Checked mate.
                                if (A.ElephantOnTable[i].ElefantThinking[0].CheckMateAStarGreedy == 1)
                                {
                                    ToCheckMate = AStarGreedy;
                                    if (ForCheckMate >= 0)
                                        if (ToCheckMate < ForCheckMate && ToCheckMate >= 0)
                                            AA = true;
                                }
                            }
                            Order *= -1;
                            for (var ii = 0; A.ElephantOnTable != null && ElephantOnTable[i] != null && A.ElephantOnTable[i].ElefantThinking[0] != null && ii < A.ElephantOnTable[i].ElefantThinking[0].AStarGreedy.Count; ii++)
                                AA = AA || IsToCheckMateHasLessDeeperThanForCheckMate(A.ElephantOnTable[i].ElefantThinking[0].AStarGreedy[ii], Order, ref ToCheckMate, ref ForCheckMate, AStarGreedy++);
                            Order = CDummy;
                        }
                    for (var i = 0; i < HourseMidle; i++)
                        for (var j = 0; A.HoursesOnTable != null && HoursesOnTable[i] != null && A.HoursesOnTable[i].HourseThinking[0] != null && j < A.HoursesOnTable[i].HourseThinking[0].TableListHourse.Count; j++)
                        {

                            //When there is Brown checked mate.
                            if (A.HoursesOnTable[i].HourseThinking[0].CheckMateAStarGreedy == -1)
                            {
                                ForCheckMate = AStarGreedy;
                                if (ToCheckMate >= 0)
                                    if (ToCheckMate < ForCheckMate && ToCheckMate >= 0)
                                        AA = true;
                            }
                            else
                            {
                                //When there is Gray Checked mate.
                                if (A.HoursesOnTable[i].HourseThinking[0].CheckMateAStarGreedy == 1)
                                {
                                    ToCheckMate = AStarGreedy;
                                    if (ForCheckMate >= 0)
                                        if (ToCheckMate < ForCheckMate && ToCheckMate >= 0)
                                            AA = true;
                                }
                            }
                            Order *= -1;
                            for (var ii = 0; A.HoursesOnTable != null && HoursesOnTable[i] != null && A.HoursesOnTable[i].HourseThinking[0] != null && ii < A.HoursesOnTable[i].HourseThinking[0].AStarGreedy.Count; ii++)
                                AA = AA || IsToCheckMateHasLessDeeperThanForCheckMate(A.HoursesOnTable[i].HourseThinking[0].AStarGreedy[ii], Order, ref ToCheckMate, ref ForCheckMate, AStarGreedy++);
                            Order = CDummy;
                        }
                    for (var i = 0; i < CastleMidle; i++)
                        for (var j = 0; A.CastlesOnTable != null && CastlesOnTable[i] != null && A.CastlesOnTable[i].CastleThinking[0] != null && j < A.CastlesOnTable[i].CastleThinking[0].TableListCastle.Count; j++)
                        {

                            //When there is Brown checked mate.
                            if (A.CastlesOnTable[i].CastleThinking[0].CheckMateAStarGreedy == -1)
                            {
                                ForCheckMate = AStarGreedy;
                                if (ToCheckMate >= 0)
                                    if (ToCheckMate < ForCheckMate && ToCheckMate >= 0)
                                        AA = true;
                            }
                            else
                            {
                                //When there is Gray Checked mate.
                                if (A.CastlesOnTable[i].CastleThinking[0].CheckMateAStarGreedy == 1)
                                {
                                    ToCheckMate = AStarGreedy;
                                    if (ForCheckMate >= 0)
                                        if (ToCheckMate < ForCheckMate && ToCheckMate >= 0)
                                            AA = true;
                                }
                            }
                            Order *= -1;
                            for (var ii = 0; A.CastlesOnTable != null && CastlesOnTable[i] != null && A.CastlesOnTable[i].CastleThinking[0] != null && ii < A.CastlesOnTable[i].CastleThinking[0].AStarGreedy.Count; ii++)
                                AA = AA || IsToCheckMateHasLessDeeperThanForCheckMate(A.CastlesOnTable[i].CastleThinking[0].AStarGreedy[ii], Order, ref ToCheckMate, ref ForCheckMate, AStarGreedy++);
                            Order = CDummy;
                        }
                    for (var i = 0; i < MinisterMidle; i++)
                        for (var j = 0; A.MinisterOnTable != null && MinisterOnTable[i] != null && A.MinisterOnTable[i].MinisterThinking[0] != null && j < A.MinisterOnTable[i].MinisterThinking[0].TableListMinister.Count; j++)
                        {

                            //When there is Brown checked mate.
                            if (A.MinisterOnTable[i].MinisterThinking[0].CheckMateAStarGreedy == -1)
                            {
                                ForCheckMate = AStarGreedy;
                                if (ToCheckMate >= 0)
                                    if (ToCheckMate < ForCheckMate && ToCheckMate >= 0)
                                        AA = true;
                            }
                            else
                            {
                                //When there is Gray Checked mate.
                                if (A.MinisterOnTable[i].MinisterThinking[0].CheckMateAStarGreedy == 1)
                                {
                                    ToCheckMate = AStarGreedy;
                                    if (ForCheckMate >= 0)
                                        if (ToCheckMate < ForCheckMate && ToCheckMate >= 0)
                                            AA = true;

                                }
                            }
                            Order *= -1;
                            for (var ii = 0; A.MinisterOnTable != null && MinisterOnTable[i] != null && A.MinisterOnTable[i].MinisterThinking[0] != null && ii < A.MinisterOnTable[i].MinisterThinking[0].AStarGreedy.Count; ii++)
                                AA = AA || IsToCheckMateHasLessDeeperThanForCheckMate(A.MinisterOnTable[i].MinisterThinking[0].AStarGreedy[ii], Order, ref ToCheckMate, ref ForCheckMate, AStarGreedy++);
                            Order = CDummy;
                        }
                    for (var i = 0; i < KingMidle; i++)
                        for (var j = 0; A.KingOnTable != null && KingOnTable[i] != null && A.KingOnTable[i].KingThinking[0] != null && j < A.KingOnTable[i].KingThinking[0].TableListKing.Count; j++)
                        {

                            //When there is Brown checked mate.
                            if (A.KingOnTable[i].KingThinking[0].CheckMateAStarGreedy == -1)
                            {
                                ForCheckMate = AStarGreedy;
                                if (ToCheckMate >= 0)
                                    if (ToCheckMate < ForCheckMate && ToCheckMate >= 0)
                                        AA = true;
                            }
                            else
                            {
                                //When there is Gray Checked mate.
                                if (A.KingOnTable[i].KingThinking[0].CheckMateAStarGreedy == 1)
                                {
                                    ToCheckMate = AStarGreedy;
                                    if (ForCheckMate >= 0)
                                        if (ToCheckMate < ForCheckMate && ToCheckMate >= 0)
                                            AA = true;
                                }
                            }
                            Order *= -1;
                            for (var ii = 0; A.KingOnTable != null && KingOnTable[i] != null && A.KingOnTable[i].KingThinking[0] != null && ii < A.KingOnTable[i].KingThinking[0].AStarGreedy.Count; ii++)
                                AA = AA || IsToCheckMateHasLessDeeperThanForCheckMate(A.KingOnTable[i].KingThinking[0].AStarGreedy[ii], Order, ref ToCheckMate, ref ForCheckMate, AStarGreedy++);
                            Order = CDummy;
                        }
                    for (var i = 0; i < 1; i++)
                        for (var j = 0; A.CastlingOnTable != null && CastlingOnTable[i] != null && A.CastlingOnTable[i].CastlingThinking[0] != null && j < A.CastlingOnTable[i].CastlingThinking[0].TableListCastling.Count; j++)
                        {

                            //When there is Brown checked mate.
                            if (A.CastlingOnTable[i].CastlingThinking[0].CheckMateAStarGreedy == -1)
                            {
                                ForCheckMate = AStarGreedy;
                                if (ToCheckMate >= 0)
                                    if (ToCheckMate < ForCheckMate && ToCheckMate >= 0)
                                        AA = true;
                            }
                            else
                            {
                                //When there is Gray Checked mate.
                                if (A.CastlingOnTable[i].CastlingThinking[0].CheckMateAStarGreedy == 1)
                                {
                                    ToCheckMate = AStarGreedy;
                                    if (ForCheckMate >= 0)
                                        if (ToCheckMate < ForCheckMate && ToCheckMate >= 0)
                                            AA = true;
                                }
                            }
                            Order *= -1;
                            for (var ii = 0; A.CastlingOnTable != null && CastlingOnTable[i] != null && A.CastlingOnTable[i].CastlingThinking[0] != null && ii < A.CastlingOnTable[i].CastlingThinking[0].AStarGreedy.Count; ii++)
                                AA = AA || IsToCheckMateHasLessDeeperThanForCheckMate(A.CastlingOnTable[i].CastlingThinking[0].AStarGreedy[ii], Order, ref ToCheckMate, ref ForCheckMate, AStarGreedy++);
                            Order = CDummy;
                        }
                }
                else
                {

                    for (var i = SodierMidle; i < SodierHigh; i++)
                        for (var j = 0; A.SolderesOnTable != null && SolderesOnTable[i] != null && A.SolderesOnTable[i].SoldierThinking[0] != null && j < A.SolderesOnTable[i].SoldierThinking[0].TableListSolder.Count; j++)
                        {

                            //When there is Brown checked mate.
                            if (A.SolderesOnTable[i].SoldierThinking[0].CheckMateAStarGreedy == -1)
                            {
                                ForCheckMate = AStarGreedy;
                                if (ToCheckMate >= 0)
                                    if (ToCheckMate < ForCheckMate && ToCheckMate >= 0)
                                        AA = true;
                            }
                            else
                            {
                                //When there is Gray Checked mate.
                                if (A.SolderesOnTable[i].SoldierThinking[0].CheckMateAStarGreedy == 1)
                                {
                                    ToCheckMate = AStarGreedy;
                                    if (ForCheckMate >= 0)
                                        if (ToCheckMate < ForCheckMate && ToCheckMate >= 0)
                                            AA = true;
                                }
                            }
                            Order *= -1;
                            for (var ii = 0; A.SolderesOnTable != null && SolderesOnTable[i] != null && A.SolderesOnTable[i].SoldierThinking[0] != null && ii < A.SolderesOnTable[i].SoldierThinking[0].AStarGreedy.Count; ii++)
                                AA = AA || IsToCheckMateHasLessDeeperThanForCheckMate(A.SolderesOnTable[i].SoldierThinking[0].AStarGreedy[ii], Order, ref ToCheckMate, ref ForCheckMate, AStarGreedy++);
                            Order = CDummy;
                        }
                    for (var i = ElefantMidle; i < ElefantHigh; i++)
                        for (var j = 0; A.ElephantOnTable != null && ElephantOnTable[i] != null && A.ElephantOnTable[i].ElefantThinking[0] != null && j < A.ElephantOnTable[i].ElefantThinking[0].TableListElefant.Count; j++)
                        {

                            //When there is Brown checked mate.
                            if (A.ElephantOnTable[i].ElefantThinking[0].CheckMateAStarGreedy == -1)
                            {
                                ForCheckMate = AStarGreedy;
                                if (ToCheckMate >= 0)
                                    if (ToCheckMate < ForCheckMate && ToCheckMate >= 0)
                                        AA = true;
                            }
                            else
                            {
                                //When there is Gray Checked mate.
                                if (A.ElephantOnTable[i].ElefantThinking[0].CheckMateAStarGreedy == 1)
                                {
                                    ToCheckMate = AStarGreedy;
                                    if (ForCheckMate >= 0)
                                        if (ToCheckMate < ForCheckMate && ToCheckMate >= 0)
                                            AA = true;
                                }
                            }
                            Order *= -1;
                            for (var ii = 0; A.ElephantOnTable != null && ElephantOnTable[i] != null && A.ElephantOnTable[i].ElefantThinking[0] != null && ii < A.ElephantOnTable[i].ElefantThinking[0].AStarGreedy.Count; ii++)
                                AA = AA || IsToCheckMateHasLessDeeperThanForCheckMate(A.ElephantOnTable[i].ElefantThinking[0].AStarGreedy[ii], Order, ref ToCheckMate, ref ForCheckMate, AStarGreedy++);
                            Order = CDummy;
                        }
                    for (var i = HourseMidle; i < HourseHight; i++)
                        for (var j = 0; A.HoursesOnTable != null && HoursesOnTable[i] != null && A.HoursesOnTable[i].HourseThinking[0] != null && j < A.HoursesOnTable[i].HourseThinking[0].TableListHourse.Count; j++)
                        {

                            //When there is Brown checked mate.
                            if (A.HoursesOnTable[i].HourseThinking[0].CheckMateAStarGreedy == -1)
                            {
                                ForCheckMate = AStarGreedy;
                                if (ToCheckMate >= 0)
                                    if (ToCheckMate < ForCheckMate && ToCheckMate >= 0)
                                        AA = true;
                            }
                            else
                            {
                                //When there is Gray Checked mate.
                                if (A.HoursesOnTable[i].HourseThinking[0].CheckMateAStarGreedy == 1)
                                {
                                    ToCheckMate = AStarGreedy;
                                    if (ForCheckMate >= 0)
                                        if (ToCheckMate < ForCheckMate && ToCheckMate >= 0)
                                            AA = true;
                                }
                            }
                            Order *= -1;
                            for (var ii = 0; A.HoursesOnTable != null && HoursesOnTable[i] != null && A.HoursesOnTable[i].HourseThinking[0] != null && ii < A.HoursesOnTable[i].HourseThinking[0].AStarGreedy.Count; ii++)
                                AA = AA || IsToCheckMateHasLessDeeperThanForCheckMate(A.HoursesOnTable[i].HourseThinking[0].AStarGreedy[ii], Order, ref ToCheckMate, ref ForCheckMate, AStarGreedy++);
                            Order = CDummy;
                        }
                    for (var i = CastleMidle; i < CastleHigh; i++)
                        for (var j = 0; A.CastlesOnTable != null && CastlesOnTable[i] != null && A.CastlesOnTable[i].CastleThinking[0] != null && j < A.CastlesOnTable[i].CastleThinking[0].TableListCastle.Count; j++)
                        {

                            //When there is Brown checked mate.
                            if (A.CastlesOnTable[i].CastleThinking[0].CheckMateAStarGreedy == -1)
                            {
                                ForCheckMate = AStarGreedy;
                                if (ToCheckMate >= 0)
                                    if (ToCheckMate < ForCheckMate && ToCheckMate >= 0)
                                        AA = true;
                            }
                            else
                            {
                                //When there is Gray Checked mate.
                                if (A.CastlesOnTable[i].CastleThinking[0].CheckMateAStarGreedy == 1)
                                {
                                    ToCheckMate = AStarGreedy;
                                    if (ForCheckMate >= 0)
                                        if (ToCheckMate < ForCheckMate && ToCheckMate >= 0)
                                            AA = true;
                                }
                            }
                            Order *= -1;
                            for (var ii = 0; A.CastlesOnTable != null && CastlesOnTable[i] != null && A.CastlesOnTable[i].CastleThinking[0] != null && ii < A.CastlesOnTable[i].CastleThinking[0].AStarGreedy.Count; ii++)
                                AA = AA || IsToCheckMateHasLessDeeperThanForCheckMate(A.CastlesOnTable[i].CastleThinking[0].AStarGreedy[ii], Order, ref ToCheckMate, ref ForCheckMate, AStarGreedy++);
                            Order = CDummy;
                        }
                    for (var i = MinisterMidle; i < MinisterHigh; i++)
                        for (var j = 0; A.MinisterOnTable != null && MinisterOnTable[i] != null && A.MinisterOnTable[i].MinisterThinking[0] != null && j < A.MinisterOnTable[i].MinisterThinking[0].TableListMinister.Count; j++)
                        {

                            //When there is Brown checked mate.
                            if (A.MinisterOnTable[i].MinisterThinking[0].CheckMateAStarGreedy == -1)
                            {
                                ForCheckMate = AStarGreedy;
                                if (ToCheckMate >= 0)
                                    if (ToCheckMate < ForCheckMate && ToCheckMate >= 0)
                                        AA = true;
                            }
                            else
                            {
                                //When there is Gray Checked mate.
                                if (A.MinisterOnTable[i].MinisterThinking[0].CheckMateAStarGreedy == 1)
                                {
                                    ToCheckMate = AStarGreedy;
                                    if (ForCheckMate >= 0)
                                        if (ToCheckMate < ForCheckMate && ToCheckMate >= 0)
                                            AA = true;
                                }
                            }

                            Order *= -1;
                            for (var ii = 0; A.MinisterOnTable != null && MinisterOnTable[i] != null && A.MinisterOnTable[i].MinisterThinking[0] != null && ii < A.MinisterOnTable[i].MinisterThinking[0].AStarGreedy.Count; ii++)
                                AA = AA || IsToCheckMateHasLessDeeperThanForCheckMate(A.MinisterOnTable[i].MinisterThinking[0].AStarGreedy[ii], Order, ref ToCheckMate, ref ForCheckMate, AStarGreedy++);
                            Order = CDummy;
                        }
                    for (var i = KingMidle; i < KingHigh; i++)
                        for (var j = 0; A.KingOnTable != null && KingOnTable[i] != null && A.KingOnTable[i].KingThinking[0] != null && j < A.KingOnTable[i].KingThinking[0].TableListKing.Count; j++)
                        {

                            //When there is Brown checked mate.
                            if (A.KingOnTable[i].KingThinking[0].CheckMateAStarGreedy == -1)
                            {
                                ForCheckMate = AStarGreedy;
                                if (ToCheckMate >= 0)
                                    if (ToCheckMate < ForCheckMate && ToCheckMate >= 0)
                                        AA = true;
                            }
                            else
                            {
                                //When there is Gray Checked mate.
                                if (A.KingOnTable[i].KingThinking[0].CheckMateAStarGreedy == 1)
                                {
                                    ToCheckMate = AStarGreedy;
                                    if (ForCheckMate >= 0)
                                        if (ToCheckMate < ForCheckMate && ToCheckMate >= 0)
                                            AA = true;
                                }
                            }

                            Order *= -1;
                            for (var ii = 0; A.KingOnTable != null && KingOnTable[i] != null && A.KingOnTable[i].KingThinking[0] != null && ii < A.KingOnTable[i].KingThinking[0].AStarGreedy.Count; ii++)
                                AA = AA || IsToCheckMateHasLessDeeperThanForCheckMate(A.KingOnTable[i].KingThinking[0].AStarGreedy[ii], Order, ref ToCheckMate, ref ForCheckMate, AStarGreedy++);
                            Order = CDummy;
                        }
                    for (var i = 0; i < 1; i++)
                        for (var j = 0; A.CastlingOnTable != null && CastlingOnTable[i] != null && A.CastlingOnTable[i].CastlingThinking[0] != null && j < A.CastlingOnTable[i].CastlingThinking[0].TableListCastling.Count; j++)
                        {

                            //When there is Brown checked mate.
                            if (A.CastlingOnTable[i].CastlingThinking[0].CheckMateAStarGreedy == -1)
                            {
                                ForCheckMate = AStarGreedy;
                                if (ToCheckMate >= 0)
                                    if (ToCheckMate < ForCheckMate && ToCheckMate >= 0)
                                        AA = true;
                            }
                            else
                            {
                                //When there is Gray Checked mate.
                                if (A.CastlingOnTable[i].CastlingThinking[0].CheckMateAStarGreedy == 1)
                                {
                                    ToCheckMate = AStarGreedy;
                                    if (ForCheckMate >= 0)
                                        if (ToCheckMate < ForCheckMate && ToCheckMate >= 0)
                                            AA = true;
                                }
                            }
                            Order *= -1;
                            for (var ii = 0; A.CastlingOnTable != null && CastlingOnTable[i] != null && A.CastlingOnTable[i].CastlingThinking[0] != null && ii < A.CastlingOnTable[i].CastlingThinking[0].AStarGreedy.Count; ii++)
                                AA = AA || IsToCheckMateHasLessDeeperThanForCheckMate(A.CastlingOnTable[i].CastlingThinking[0].AStarGreedy[ii], Order, ref ToCheckMate, ref ForCheckMate, AStarGreedy++);
                            Order = CDummy;
                        }
                }

                ChessRules.CurrentOrder = CDummy;
                return AA;
            }
        }
        //When Penalty Regard Branches expanded to sub branches.
        void IsPenaltyRegardCheckMateAtBranch(int Order, ref int Do, AllDraw Base)
        {

            Object a = new Object();
            lock (a)
            {
                int CDummy = ChessRules.CurrentOrder;
                int COrder = Order;
                //For Gray Order.
                if (Order == 1)
                {
                    ChessRules AA = null;

                    //For  Soldeirs.
                    for (var i = 0; i < SodierMidle; i++)
                        for (var j = 0; SolderesOnTable != null && SolderesOnTable[i] != null && SolderesOnTable[i].SoldierThinking[0] != null && j < SolderesOnTable[i].SoldierThinking[0].TableListSolder.Count; j++)
                        {

                            //Create Rules Objects For Soldiers.
                            AA = new ChessRules(CurrentAStarGredyMax, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged, CloneATable(SolderesOnTable[i].SoldierThinking[0].TableListSolder[j])[SolderesOnTable[i].SoldierThinking[0].RowColumnSoldier[j][0], SolderesOnTable[i].SoldierThinking[0].RowColumnSoldier[j][1]]
                                , CloneATable(SolderesOnTable[i].SoldierThinking[0].TableListSolder[j])
                                , Order
                                , SolderesOnTable[i].SoldierThinking[0].RowColumnSoldier[j][0]
                                , SolderesOnTable[i].SoldierThinking[0].RowColumnSoldier[j][1]);
                            //When CheckMate Occured for Current Sodiers
                            bool ac = false;
                            var ah = Task.Factory.StartNew(() => ac = AA.CheckMate(SolderesOnTable[i].SoldierThinking[0].TableListSolder[j], Order));
                            ah.Wait();
                            ah.Dispose();
                            if (ac)
                            {
                                //When Self CheckMate
                                if (AllDraw.OrderPlateDraw == 1 && AA.CheckMateGray)
                                {
                                    //Return Ignore
                                    Do = -1;
                                    //Set Superposition.
                                    SolderesOnTable[i].SoldierThinking[0].CheckMateAStarGreedy = -1;
                                    //Penalty Subbranchs.
                                    var ah1 = Task.Factory.StartNew(() => MakePenaltyAllCheckMateBranches(Base, AllDraw.OrderPlate));
                                    ah1.Wait();
                                    ah1.Dispose();

                                }
                                else
                                {
                                    //When Enemy CheckMate
                                    if (AllDraw.OrderPlateDraw == -1 && AA.CheckMateBrown)
                                    {
                                        //Set Regard and Set Movements.
                                        Do = 1;
                                        //Regard Subbranchs.
                                        var ah1 = Task.Factory.StartNew(() => MakePenaltyAllCheckMateBranches(Base, AllDraw.OrderPlate));
                                        ah1.Wait();
                                        ah1.Dispose();
                                        //Set Superpostion.
                                        SolderesOnTable[i].SoldierThinking[0].CheckMateAStarGreedy = 1;
                                    }
                                }
                            }
                            if (Do != -1)
                            {
                                Order *= -1;
                                ChessRules.CurrentOrder *= -1;
                                //For Subbranchs.
                                for (var ii = 0; SolderesOnTable != null && SolderesOnTable[i] != null && SolderesOnTable[i].SoldierThinking[0] != null && ii < SolderesOnTable[i].SoldierThinking[0].AStarGreedy.Count; ii++)
                                {
                                    int D = Do;
                                    var ah1 = Task.Factory.StartNew(() => SolderesOnTable[ii].SoldierThinking[0].AStarGreedy[i].IsPenaltyRegardCheckMateAtBranch(Order, ref D, Base));
                                    ah1.Wait();
                                    ah1.Dispose();
                                    Do = D;
                                }
                                Order = COrder;
                                ChessRules.CurrentOrder = CDummy;
                            }
                        }

                    //For Elephant.
                    for (var i = 0; i < ElefantMidle; i++)
                        for (var j = 0; ElephantOnTable != null && ElephantOnTable[i] != null && ElephantOnTable[i].ElefantThinking[0] != null && j < ElephantOnTable[i].ElefantThinking[0].TableListElefant.Count; j++)
                        {

                            //Create Elephant Rules.
                            AA = new ChessRules(CurrentAStarGredyMax, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged, CloneATable(ElephantOnTable[i].ElefantThinking[0].TableListElefant[j])[ElephantOnTable[i].ElefantThinking[0].RowColumnElefant[j][0], ElephantOnTable[i].ElefantThinking[0].RowColumnElefant[j][1]]
                            , CloneATable(ElephantOnTable[i].ElefantThinking[0].TableListElefant[j])
                            , Order
                            , ElephantOnTable[i].ElefantThinking[0].RowColumnElefant[j][0]
                            , ElephantOnTable[i].ElefantThinking[0].RowColumnElefant[j][1]);
                            //When CheckMate Occured for Current Elephant.
                            bool ac = false;
                            var ah = Task.Factory.StartNew(() => ac = AA.CheckMate(CloneATable(ElephantOnTable[i].ElefantThinking[0].TableListElefant[j]), Order));
                            ah.Wait();
                            ah.Dispose();
                            if (ac)
                            {
                                //For Self Order CheckMate.
                                if (AllDraw.OrderPlateDraw == 1 && AA.CheckMateGray)
                                {
                                    //Set Penalty Ignore.
                                    Do = -1;
                                    //Set Superposition.
                                    ElephantOnTable[i].ElefantThinking[0].CheckMateAStarGreedy = -1;
                                    //Penalty Subbranchs.
                                    var ah1 = Task.Factory.StartNew(() => MakePenaltyAllCheckMateBranches(Base, AllDraw.OrderPlate));
                                    ah1.Wait();
                                    ah1.Dispose();

                                }
                                else
                                {
                                    //For Enemy Order CheckMate.
                                    if (AllDraw.OrderPlateDraw == -1 && AA.CheckMateBrown)
                                    {
                                        //Set Regard Continue.
                                        Do = 1;
                                        //Regard Subolders.
                                        var ah1 = Task.Factory.StartNew(() => MakePenaltyAllCheckMateBranches(Base, AllDraw.OrderPlate));
                                        ah1.Wait();
                                        ah1.Dispose();
                                        //Set Superposition.
                                        ElephantOnTable[i].ElefantThinking[0].CheckMateAStarGreedy = 1;
                                    }
                                }
                            }
                            if (Do != -1)
                            {
                                Order *= -1;
                                ChessRules.CurrentOrder *= -1;
                                //For Subbranchs.
                                for (var ii = 0; ElephantOnTable != null && ElephantOnTable[i] != null && ElephantOnTable[i].ElefantThinking[0] != null && ii < ElephantOnTable[i].ElefantThinking[0].AStarGreedy.Count; ii++)
                                {
                                    int D = Do;

                                    var ah1 = Task.Factory.StartNew(() => ElephantOnTable[ii].ElefantThinking[0].AStarGreedy[i].IsPenaltyRegardCheckMateAtBranch(Order, ref D, Base));
                                    ah1.Wait();
                                    ah1.Dispose();
                                    Do = D;
                                }

                                Order = COrder;
                                ChessRules.CurrentOrder = CDummy;
                            }
                        }
                    //For Hourse.
                    for (var i = 0; i < HourseMidle; i++)
                        for (var j = 0; HoursesOnTable != null && HoursesOnTable[i] != null && HoursesOnTable[i].HourseThinking[0] != null && j < HoursesOnTable[i].HourseThinking[0].TableListHourse.Count; j++)
                        {

                            //Set Hourse Rules Objects.
                            AA = new ChessRules(CurrentAStarGredyMax, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged, CloneATable(HoursesOnTable[i].HourseThinking[0].TableListHourse[j])[HoursesOnTable[i].HourseThinking[0].RowColumnHourse[j][0], HoursesOnTable[i].HourseThinking[0].RowColumnHourse[j][1]]
                            , CloneATable(HoursesOnTable[i].HourseThinking[0].TableListHourse[j])
                            , Order
                            , HoursesOnTable[i].HourseThinking[0].RowColumnHourse[j][0]
                            , HoursesOnTable[i].HourseThinking[0].RowColumnHourse[j][1]);
                            //When CheckMate Occured.
                            bool ac = false;
                            var ah = Task.Factory.StartNew(() => ac = AA.CheckMate(CloneATable(HoursesOnTable[i].HourseThinking[0].TableListHourse[j]), Order));
                            ah.Wait();
                            ah.Dispose();
                            if (ac)
                            {
                                //For Self CheckMate.
                                if (AllDraw.OrderPlateDraw == 1 && AA.CheckMateGray)
                                {
                                    //Set Ignore.
                                    Do = -1;
                                    //Set Superposition.
                                    HoursesOnTable[i].HourseThinking[0].CheckMateAStarGreedy = -1;
                                    //Penalty Subbranchs.
                                    var ah1 = Task.Factory.StartNew(() => MakePenaltyAllCheckMateBranches(Base, AllDraw.OrderPlate));
                                    ah1.Wait();
                                    ah1.Dispose();
                                }
                                else
                                {
                                    //For Enemy CheckMate.
                                    if (AllDraw.OrderPlateDraw == -1 && AA.CheckMateBrown)
                                    {
                                        //Set Regard.
                                        Do = 1;
                                        //Superposition.
                                        HoursesOnTable[i].HourseThinking[0].CheckMateAStarGreedy = 1;
                                        //Set Regard For Sub Branches.
                                        var ah1 = Task.Factory.StartNew(() => MakePenaltyAllCheckMateBranches(Base, AllDraw.OrderPlate));
                                        ah1.Wait();
                                        ah1.Dispose();
                                    }
                                }
                            }
                            if (Do != -1)
                            {
                                Order *= -1;
                                ChessRules.CurrentOrder *= -1;
                                //Sub branchs For Hourse.
                                for (var ii = 0; HoursesOnTable != null && HoursesOnTable[i] != null && HoursesOnTable[i].HourseThinking[0] != null && ii < HoursesOnTable[i].HourseThinking[0].AStarGreedy.Count; ii++)
                                {
                                    int D = Do;

                                    var ah1 = Task.Factory.StartNew(() => HoursesOnTable[i].HourseThinking[0].AStarGreedy[ii].IsPenaltyRegardCheckMateAtBranch(Order, ref D, Base));
                                    ah1.Wait();
                                    ah1.Dispose();
                                    Do = D;
                                }

                                Order = COrder;
                                ChessRules.CurrentOrder = CDummy;
                            }
                        }
                    //For Gray Briges.
                    for (var i = 0; i < CastleMidle; i++)
                        for (var j = 0; CastlesOnTable != null && CastlesOnTable[i] != null && CastlesOnTable[i].CastleThinking[0] != null && j < CastlesOnTable[i].CastleThinking[0].TableListCastle.Count; j++)
                        {

                            //Castles Gray Rules.
                            AA = new ChessRules(CurrentAStarGredyMax, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged, CloneATable(CastlesOnTable[i].CastleThinking[0].TableListCastle[j])[CastlesOnTable[i].CastleThinking[0].RowColumnCastle[j][0], CastlesOnTable[i].CastleThinking[0].RowColumnCastle[j][1]]
                            , CloneATable(CastlesOnTable[i].CastleThinking[0].TableListCastle[j])
                            , Order
                            , CastlesOnTable[i].CastleThinking[0].RowColumnCastle[j][0]
                            , CastlesOnTable[i].CastleThinking[0].RowColumnCastle[j][1]);
                            //When Current Gray Castles CheckMate.
                            bool ac = false;
                            var ah = Task.Factory.StartNew(() => ac = AA.CheckMate(CloneATable(CastlesOnTable[i].CastleThinking[0].TableListCastle[j]), Order));
                            ah.Wait();
                            ah.Dispose();
                            if (ac)
                            {
                                //For Self CheckMate
                                if (AllDraw.OrderPlateDraw == 1 && AA.CheckMateGray)
                                {
                                    //Set Penalty Ignore.
                                    Do = -1;
                                    //Set Superposition.
                                    CastlesOnTable[i].CastleThinking[0].CheckMateAStarGreedy = -1;
                                    //Penalty Sub branchs.
                                    var ah1 = Task.Factory.StartNew(() => MakePenaltyAllCheckMateBranches(Base, AllDraw.OrderPlate));
                                    ah1.Wait();
                                    ah1.Dispose();
                                }

                                else
                                {
                                    //For Enemy CheckMate.
                                    if (AllDraw.OrderPlateDraw == -1 && AA.CheckMateBrown)
                                    {
                                        //Set Regard.
                                        Do = 1;
                                        //Superpoistion.
                                        CastlesOnTable[i].CastleThinking[0].CheckMateAStarGreedy = 1;
                                        //Set Regard Subbranchs.
                                        var ah1 = Task.Factory.StartNew(() => MakePenaltyAllCheckMateBranches(Base, AllDraw.OrderPlate));
                                        ah1.Wait();
                                        ah1.Dispose();
                                    }
                                }
                            }
                            if (Do != -1)
                            {
                                Order *= -1;
                                ChessRules.CurrentOrder *= -1;
                                //For Castles Gray Subbranchs.
                                for (var ii = 0; CastlesOnTable != null && CastlesOnTable[i] != null && CastlesOnTable[i].CastleThinking[0] != null && ii < CastlesOnTable[i].CastleThinking[0].AStarGreedy.Count; ii++)
                                {
                                    int D = Do;

                                    var ah1 = Task.Factory.StartNew(() => CastlesOnTable[i].CastleThinking[0].AStarGreedy[ii].IsPenaltyRegardCheckMateAtBranch(Order, ref D, Base));
                                    ah1.Wait();
                                    ah1.Dispose();
                                    Do = D;
                                }

                                Order = COrder;
                                ChessRules.CurrentOrder = CDummy;
                            }
                        }
                    //For Ministers Gray.
                    for (var i = 0; i < MinisterMidle; i++)
                        for (var j = 0; MinisterOnTable != null && MinisterOnTable[i] != null && MinisterOnTable[i].MinisterThinking[0] != null && j < MinisterOnTable[i].MinisterThinking[0].TableListMinister.Count; j++)
                        {

                            //Minister Gray Rules.
                            AA = new ChessRules(CurrentAStarGredyMax, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged, CloneATable(MinisterOnTable[i].MinisterThinking[0].TableListMinister[j])[MinisterOnTable[i].MinisterThinking[0].RowColumnMinister[j][0], MinisterOnTable[i].MinisterThinking[0].RowColumnMinister[j][1]]
                            , CloneATable(MinisterOnTable[i].MinisterThinking[0].TableListMinister[j])
                            , Order
                            , MinisterOnTable[i].MinisterThinking[0].RowColumnMinister[j][0]
                            , MinisterOnTable[i].MinisterThinking[0].RowColumnMinister[j][1]);
                            //When M ate Occured in Minister Gray.
                            bool ac = false;
                            var ah = Task.Factory.StartNew(() => ac = AA.CheckMate(CloneATable(MinisterOnTable[i].MinisterThinking[0].TableListMinister[j]), Order));
                            ah.Wait();
                            ah.Dispose();
                            if (ac)
                            {
                                //Self CheckMate.
                                if (AllDraw.OrderPlateDraw == 1 && AA.CheckMateGray)
                                {
                                    //Penalty Ignore.
                                    Do = -1;
                                    //Superpostion.
                                    MinisterOnTable[i].MinisterThinking[0].CheckMateAStarGreedy = -1;
                                    //Penalty Subbranchs.
                                    var ah1 = Task.Factory.StartNew(() => MakePenaltyAllCheckMateBranches(Base, AllDraw.OrderPlate));
                                    ah1.Wait();
                                    ah1.Dispose();
                                }
                                else
                                {
                                    //For Enemy CheckMate.
                                    if (AllDraw.OrderPlateDraw == -1 && AA.CheckMateBrown)
                                    {
                                        //Regard Setting.
                                        Do = 1;
                                        //Superpoistion.
                                        MinisterOnTable[i].MinisterThinking[0].CheckMateAStarGreedy = 1;
                                        //Set Subbranchs Regard.
                                        var ah1 = Task.Factory.StartNew(() => MakePenaltyAllCheckMateBranches(Base, AllDraw.OrderPlate));
                                        ah1.Wait();
                                        ah1.Dispose();
                                    }
                                }
                            }
                            if (Do != -1)
                            {
                                Order *= -1;
                                ChessRules.CurrentOrder *= -1;
                                //For Gray Ministers Subbranchs.
                                for (var ii = 0; MinisterOnTable != null && MinisterOnTable[i] != null && MinisterOnTable[i].MinisterThinking[0] != null && ii < MinisterOnTable[i].MinisterThinking[0].AStarGreedy.Count; ii++)
                                {
                                    int D = Do;

                                    var ah1 = Task.Factory.StartNew(() => MinisterOnTable[i].MinisterThinking[0].AStarGreedy[ii].IsPenaltyRegardCheckMateAtBranch(Order, ref D, Base));
                                    ah1.Wait();
                                    ah1.Dispose();
                                    Do = D;
                                }

                                Order = COrder;
                                ChessRules.CurrentOrder = CDummy;
                            }
                        }
                    //For Gray King.
                    for (var i = 0; i < KingMidle; i++)
                        for (var j = 0; KingOnTable != null && KingOnTable[i] != null && KingOnTable[i].KingThinking[0] != null && j < KingOnTable[i].KingThinking[0].TableListKing.Count; j++)
                        {

                            //Gray King Rules.
                            AA = new ChessRules(CurrentAStarGredyMax, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged, CloneATable(KingOnTable[i].KingThinking[0].TableListKing[j])[KingOnTable[i].KingThinking[0].RowColumnKing[j][0], KingOnTable[i].KingThinking[0].RowColumnKing[j][1]]
                            , CloneATable(KingOnTable[i].KingThinking[0].TableListKing[j])
                            , Order
                            , KingOnTable[i].KingThinking[0].RowColumnKing[j][0]
                            , KingOnTable[i].KingThinking[0].RowColumnKing[j][1]);
                            //When CheckMate Occured in King Gray.
                            bool ac = false;
                            var ah = Task.Factory.StartNew(() => ac = AA.CheckMate(CloneATable(KingOnTable[i].KingThinking[0].TableListKing[j]), Order));
                            ah.Wait();
                            ah.Dispose();
                            if (ac)
                            {
                                //Self CheckMate.
                                if (AllDraw.OrderPlateDraw == 1 && AA.CheckMateGray)
                                {
                                    //Penalty Ignore.
                                    Do = -1;
                                    //Superposition.
                                    KingOnTable[i].KingThinking[0].CheckMateAStarGreedy = -1;
                                    //Penalty Subbranchs.
                                    var ah1 = Task.Factory.StartNew(() => MakePenaltyAllCheckMateBranches(Base, AllDraw.OrderPlate));
                                    ah1.Wait();
                                    ah1.Dispose();
                                }
                                else
                                {
                                    //Self CheckMate.
                                    if (AllDraw.OrderPlateDraw == -1 && AA.CheckMateBrown)
                                    {
                                        //Regard Setting.
                                        Do = 1;
                                        //Superpoistion.
                                        KingOnTable[i].KingThinking[0].CheckMateAStarGreedy = 1;
                                        //Regard Subbranchs.
                                        var ah1 = Task.Factory.StartNew(() => MakePenaltyAllCheckMateBranches(Base, AllDraw.OrderPlate));
                                        ah1.Wait();
                                        ah1.Dispose();
                                    }
                                }
                            }
                            if (Do != -1)
                            {
                                Order *= -1;
                                ChessRules.CurrentOrder *= -1;
                                //For King Gray Subbranchs.
                                for (var ii = 0; KingOnTable != null && KingOnTable[i] != null && KingOnTable[i].KingThinking[0] != null && ii < KingOnTable[i].KingThinking[0].AStarGreedy.Count; ii++)
                                {
                                    int D = Do;

                                    var ah1 = Task.Factory.StartNew(() => KingOnTable[i].KingThinking[0].AStarGreedy[ii].IsPenaltyRegardCheckMateAtBranch(Order, ref D, Base));
                                    ah1.Wait();
                                    ah1.Dispose();
                                    Do = D;
                                }

                                Order = COrder;
                                ChessRules.CurrentOrder = CDummy;
                            }
                        }
                    for (var i = 0; i < 1; i++)
                        for (var j = 0; CastlingOnTable != null && CastlingOnTable[i] != null && CastlingOnTable[i].CastlingThinking[0] != null && j < CastlingOnTable[i].CastlingThinking[0].TableListCastling.Count; j++)
                        {

                            //Gray Castling Rules.
                            AA = new ChessRules(CurrentAStarGredyMax, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged, CloneATable(CastlingOnTable[i].CastlingThinking[0].TableListCastling[j])[CastlingOnTable[i].CastlingThinking[0].RowColumnCastling[j][0], CastlingOnTable[i].CastlingThinking[0].RowColumnCastling[j][1]]
                            , CloneATable(CastlingOnTable[i].CastlingThinking[0].TableListCastling[j])
                            , Order
                            , CastlingOnTable[i].CastlingThinking[0].RowColumnCastling[j][0]
                            , CastlingOnTable[i].CastlingThinking[0].RowColumnCastling[j][1]);
                            //When CheckMate Occured in Castling Gray.
                            bool ac = false;
                            var ah = Task.Factory.StartNew(() => ac = AA.CheckMate(CloneATable(CastlingOnTable[i].CastlingThinking[0].TableListCastling[j]), Order));
                            ah.Wait();
                            ah.Dispose();
                            if (ac)
                            {
                                //Self CheckMate.
                                if (AllDraw.OrderPlateDraw == 1 && AA.CheckMateGray)
                                {
                                    //Penalty Ignore.
                                    Do = -1;
                                    //Superposition.
                                    CastlingOnTable[i].CastlingThinking[0].CheckMateAStarGreedy = -1;
                                    //Penalty Subbranchs.
                                    var ah1 = Task.Factory.StartNew(() => MakePenaltyAllCheckMateBranches(Base, AllDraw.OrderPlate));
                                    ah1.Wait();
                                    ah1.Dispose();
                                }
                                else
                                {
                                    //Self CheckMate.
                                    if (AllDraw.OrderPlateDraw == -1 && AA.CheckMateBrown)
                                    {
                                        //Regard Setting.
                                        Do = 1;
                                        //Superpoistion.
                                        CastlingOnTable[i].CastlingThinking[0].CheckMateAStarGreedy = 1;
                                        //Regard Subbranchs.
                                        var ah1 = Task.Factory.StartNew(() => MakePenaltyAllCheckMateBranches(Base, AllDraw.OrderPlate));
                                        ah1.Wait();
                                        ah1.Dispose();
                                    }
                                }
                            }
                            if (Do != -1)
                            {
                                Order *= -1;
                                ChessRules.CurrentOrder *= -1;
                                //For Castling Gray Subbranchs.
                                for (var ii = 0; CastlingOnTable != null && CastlingOnTable[i] != null && CastlingOnTable[i].CastlingThinking[0] != null && ii < CastlingOnTable[i].CastlingThinking[0].AStarGreedy.Count; ii++)
                                {
                                    int D = Do;

                                    var ah1 = Task.Factory.StartNew(() => CastlingOnTable[i].CastlingThinking[0].AStarGreedy[ii].IsPenaltyRegardCheckMateAtBranch(Order, ref D, Base));
                                    ah1.Wait();
                                    ah1.Dispose();
                                    Do = D;
                                }

                                Order = COrder;
                                ChessRules.CurrentOrder = CDummy;
                            }
                        }
                }
                //For Brown Order.
                else
                {
                    ChessRules AA = null;

                    //For Solders Brown.
                    for (var i = SodierMidle; i < SodierHigh; i++)
                        for (var j = 0; SolderesOnTable != null && SolderesOnTable[i] != null && SolderesOnTable[i].SoldierThinking[0] != null && j < SolderesOnTable[i].SoldierThinking[0].TableListSolder.Count; j++)
                        {

                            //Solders Brown Rules.
                            AA = new ChessRules(CurrentAStarGredyMax, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged, CloneATable(SolderesOnTable[i].SoldierThinking[0].TableListSolder[j])[SolderesOnTable[i].SoldierThinking[0].RowColumnSoldier[j][0], SolderesOnTable[i].SoldierThinking[0].RowColumnSoldier[j][1]]
                            , CloneATable(SolderesOnTable[i].SoldierThinking[0].TableListSolder[j])
                            , Order
                            , SolderesOnTable[i].SoldierThinking[0].RowColumnSoldier[j][0]
                            , SolderesOnTable[i].SoldierThinking[0].RowColumnSoldier[j][1]);
                            //When Solders Brown CheckMate Occured.
                            bool ac = false;
                            var ah = Task.Factory.StartNew(() => ac = AA.CheckMate(SolderesOnTable[i].SoldierThinking[0].TableListSolder[j], Order));
                            ah.Wait();
                            ah.Dispose();
                            if (ac)
                            {     //Self CheckMate.
                                if (AllDraw.OrderPlateDraw == -1 && AA.CheckMateBrown)
                                {
                                    //Ignore Penalty.
                                    Do = -1;
                                    //Supperpoistion.
                                    SolderesOnTable[i].SoldierThinking[0].CheckMateAStarGreedy = -1;
                                    //Penalty Subbranchs Soders Brown.
                                    var ah1 = Task.Factory.StartNew(() => MakePenaltyAllCheckMateBranches(Base, AllDraw.OrderPlate));
                                    ah1.Wait();
                                    ah1.Dispose();
                                }
                                else
                                {
                                    //Self CheckMate.
                                    if (AllDraw.OrderPlateDraw == 1 && AA.CheckMateGray)
                                    {
                                        //Set Regard.
                                        Do = 1;
                                        //Superpoition.
                                        SolderesOnTable[i].SoldierThinking[0].CheckMateAStarGreedy = 1;
                                        //Penalty Subbranchs.
                                        var ah1 = Task.Factory.StartNew(() => MakePenaltyAllCheckMateBranches(Base, AllDraw.OrderPlate));
                                        ah1.Wait();
                                        ah1.Dispose();
                                    }
                                }
                            }
                            if (Do != -1)
                            {
                                Order *= -1;
                                ChessRules.CurrentOrder *= -1;
                                //Solders Brown Subbranchs Calling.
                                for (var ii = 0; SolderesOnTable != null && SolderesOnTable[i] != null && SolderesOnTable[i].SoldierThinking[0] != null && ii < SolderesOnTable[i].SoldierThinking[0].AStarGreedy.Count; ii++)
                                {
                                    int D = Do;

                                    var ah1 = Task.Factory.StartNew(() => SolderesOnTable[i].SoldierThinking[0].AStarGreedy[ii].IsPenaltyRegardCheckMateAtBranch(Order, ref D, Base));
                                    ah1.Wait();
                                    ah1.Dispose();
                                    Do = D;
                                }

                                Order = COrder;
                                ChessRules.CurrentOrder = CDummy;
                            }
                        }
                    //Elephant Brown 
                    for (var i = ElefantMidle; i < ElefantHigh; i++)
                        for (var j = 0; ElephantOnTable != null && ElephantOnTable[i] != null && ElephantOnTable[i].ElefantThinking[0] != null && j < ElephantOnTable[i].ElefantThinking[0].TableListElefant.Count; j++)
                        {

                            //Elephant Brown Rules.
                            AA = new ChessRules(CurrentAStarGredyMax, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged, CloneATable(ElephantOnTable[i].ElefantThinking[0].TableListElefant[j])[ElephantOnTable[i].ElefantThinking[0].RowColumnElefant[j][0], ElephantOnTable[i].ElefantThinking[0].RowColumnElefant[j][1]]
                            , CloneATable(ElephantOnTable[i].ElefantThinking[0].TableListElefant[j])
                            , Order
                            , ElephantOnTable[i].ElefantThinking[0].RowColumnElefant[j][0]
                            , ElephantOnTable[i].ElefantThinking[0].RowColumnElefant[j][1]);
                            //CheckMate Occured in Elephenat Brown.
                            bool ac = false;
                            var ah = Task.Factory.StartNew(() => ac = AA.CheckMate(CloneATable(ElephantOnTable[i].ElefantThinking[0].TableListElefant[j]), Order));
                            ah.Wait();
                            ah.Dispose();
                            if (ac)
                            {
                                //Self CheckMate.
                                if (AllDraw.OrderPlateDraw == -1 && AA.CheckMateBrown)
                                {
                                    //Ignore Penalty.
                                    Do = -1;
                                    //Superpoistion.
                                    ElephantOnTable[i].ElefantThinking[0].CheckMateAStarGreedy = -1;
                                    //Penalty Subbranchs.
                                    var ah1 = Task.Factory.StartNew(() => MakePenaltyAllCheckMateBranches(Base, AllDraw.OrderPlate));
                                    ah1.Wait();
                                    ah1.Dispose();
                                }
                                else
                                {
                                    //CheckMate Enemy.
                                    if (AllDraw.OrderPlateDraw == 1 && AA.CheckMateGray)
                                    {
                                        //Set Regrading.
                                        Do = 1;
                                        //Superposition.
                                        ElephantOnTable[i].ElefantThinking[0].CheckMateAStarGreedy = 1;
                                        //Regrad Subbranchs.
                                        var ah1 = Task.Factory.StartNew(() => MakePenaltyAllCheckMateBranches(Base, AllDraw.OrderPlate));
                                        ah1.Wait();
                                        ah1.Dispose();
                                    }
                                }
                            }
                            if (Do != -1)
                            {
                                Order *= -1;
                                ChessRules.CurrentOrder *= -1;
                                //Subbranchs Elephenat Brown Calling.
                                for (var ii = 0; ElephantOnTable != null && ElephantOnTable[i] != null && ElephantOnTable[i].ElefantThinking[0] != null && ii < ElephantOnTable[i].ElefantThinking[0].AStarGreedy.Count; ii++)
                                {
                                    int D = Do;

                                    var ah1 = Task.Factory.StartNew(() => ElephantOnTable[i].ElefantThinking[0].AStarGreedy[ii].IsPenaltyRegardCheckMateAtBranch(Order, ref D, Base));
                                    ah1.Wait();
                                    ah1.Dispose();
                                    Do = D;
                                }

                                Order = COrder;
                                ChessRules.CurrentOrder = CDummy;
                            }
                        }
                    //Hourse Brown 
                    for (var i = HourseMidle; i < HourseHight; i++)
                        for (var j = 0; HoursesOnTable != null && HoursesOnTable[i] != null && HoursesOnTable[i].HourseThinking[0] != null && j < HoursesOnTable[i].HourseThinking[0].TableListHourse.Count; j++)
                        {

                            //Hourse Brown Rules.
                            AA = new ChessRules(CurrentAStarGredyMax, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged, CloneATable(HoursesOnTable[i].HourseThinking[0].TableListHourse[j])[HoursesOnTable[i].HourseThinking[0].RowColumnHourse[j][0], HoursesOnTable[i].HourseThinking[0].RowColumnHourse[j][1]]
                            , CloneATable(HoursesOnTable[i].HourseThinking[0].TableListHourse[j])
                            , Order
                            , HoursesOnTable[i].HourseThinking[0].RowColumnHourse[j][0]
                            , HoursesOnTable[i].HourseThinking[0].RowColumnHourse[j][1]);
                            //When Hourse Broin CheckMate Ocuucred.
                            bool ac = false;
                            var ah = Task.Factory.StartNew(() => ac = AA.CheckMate(CloneATable(HoursesOnTable[i].HourseThinking[0].TableListHourse[j]), Order));
                            ah.Wait();
                            ah.Dispose();
                            if (ac)
                            {

                                //Self CheckMate.
                                if (AllDraw.OrderPlateDraw == -1 && AA.CheckMateBrown)
                                {
                                    //Ignore Penalty.
                                    Do = -1;
                                    //Superposition.
                                    HoursesOnTable[i].HourseThinking[0].CheckMateAStarGreedy = -1;
                                    //Penalty Subbranchs.
                                    var ah1 = Task.Factory.StartNew(() => MakePenaltyAllCheckMateBranches(Base, AllDraw.OrderPlate));
                                    ah1.Wait();
                                    ah1.Dispose();
                                }
                                else
                                {
                                    //CheckMate Enemy.
                                    if (AllDraw.OrderPlateDraw == 1 && AA.CheckMateGray)
                                    {
                                        //Set Regrad.
                                        Do = 1;
                                        //Superposition.
                                        HoursesOnTable[i].HourseThinking[0].CheckMateAStarGreedy = 1;
                                        //Regrad Subbranchs.
                                        var ah1 = Task.Factory.StartNew(() => MakePenaltyAllCheckMateBranches(Base, AllDraw.OrderPlate));
                                        ah1.Wait();
                                        ah1.Dispose();
                                    }
                                }
                            }
                            if (Do != -1)
                            {
                                Order *= -1;
                                ChessRules.CurrentOrder *= -1;
                                //Hourse Brown Calling Subbranchs.
                                for (var ii = 0; HoursesOnTable != null && HoursesOnTable[i] != null && HoursesOnTable[i].HourseThinking[0] != null && ii < HoursesOnTable[i].HourseThinking[0].AStarGreedy.Count; ii++)
                                {
                                    int D = Do;

                                    var ah1 = Task.Factory.StartNew(() => HoursesOnTable[i].HourseThinking[0].AStarGreedy[ii].IsPenaltyRegardCheckMateAtBranch(Order, ref D, Base));
                                    ah1.Wait();
                                    ah1.Dispose();
                                    Do = D;
                                }

                                Order = COrder;
                                ChessRules.CurrentOrder = CDummy;
                            }
                        }
                    //Castles Brown 
                    for (var i = CastleMidle; i < CastleHigh; i++)
                        for (var j = 0; CastlesOnTable != null && CastlesOnTable[i] != null && CastlesOnTable[i].CastleThinking[0] != null && j < CastlesOnTable[i].CastleThinking[0].TableListCastle.Count; j++)
                        {

                            //Castles Brown Rules.
                            AA = new ChessRules(CurrentAStarGredyMax, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged, CloneATable(CastlesOnTable[i].CastleThinking[0].TableListCastle[j])[CastlesOnTable[i].CastleThinking[0].RowColumnCastle[j][0], CastlesOnTable[i].CastleThinking[0].RowColumnCastle[j][1]]
                            , CloneATable(CastlesOnTable[i].CastleThinking[0].TableListCastle[j])
                            , Order
                            , CastlesOnTable[i].CastleThinking[0].RowColumnCastle[j][0]
                            , CastlesOnTable[i].CastleThinking[0].RowColumnCastle[j][1]);
                            //When Brown Castles CheckMate Occured.
                            bool ac = false;
                            var ah = Task.Factory.StartNew(() => ac = AA.CheckMate(CloneATable(CastlesOnTable[i].CastleThinking[0].TableListCastle[j]), Order));
                            ah.Wait();
                            ah.Dispose();
                            if (ac)
                            {
                                //Self CheckMate.
                                if (AllDraw.OrderPlateDraw == -1 && AA.CheckMateBrown)
                                {
                                    //Ignore CheckMate.
                                    Do = -1;
                                    //Superpoistion.
                                    CastlesOnTable[i].CastleThinking[0].CheckMateAStarGreedy = -1;
                                    //Subbranchs Penalty.
                                    var ah1 = Task.Factory.StartNew(() => MakePenaltyAllCheckMateBranches(Base, AllDraw.OrderPlate));
                                    ah1.Wait();
                                    ah1.Dispose();
                                }
                                else
                                {
                                    //CheckMate Enemy.
                                    if (AllDraw.OrderPlateDraw == 1 && AA.CheckMateGray)
                                    {
                                        //Set Regard.
                                        Do = 1;
                                        //Superpoistion.
                                        CastlesOnTable[i].CastleThinking[0].CheckMateAStarGreedy = 1;
                                        //Regard Subbranchs.
                                        var ah1 = Task.Factory.StartNew(() => MakePenaltyAllCheckMateBranches(Base, AllDraw.OrderPlate));
                                        ah1.Wait();
                                        ah1.Dispose();
                                    }
                                }
                            }
                            if (Do != -1)
                            {
                                Order *= -1;
                                ChessRules.CurrentOrder *= -1;
                                //Brown Castles Calling Subbranches.
                                for (var ii = 0; CastlesOnTable != null && CastlesOnTable[i] != null && CastlesOnTable[i].CastleThinking[0] != null && ii < CastlesOnTable[i].CastleThinking[0].AStarGreedy.Count; ii++)
                                {
                                    int D = Do;

                                    var ah1 = Task.Factory.StartNew(() => CastlesOnTable[i].CastleThinking[0].AStarGreedy[ii].IsPenaltyRegardCheckMateAtBranch(Order, ref D, Base));
                                    ah1.Wait();
                                    ah1.Dispose();
                                    Do = D;
                                }

                                Order = COrder;
                                ChessRules.CurrentOrder = CDummy;
                            }
                        }
                    //Minister Brown 
                    for (var i = MinisterMidle; i < MinisterHigh; i++)
                        for (var j = 0; MinisterOnTable != null && MinisterOnTable[i] != null && MinisterOnTable[i].MinisterThinking[0] != null && j < MinisterOnTable[i].MinisterThinking[0].TableListMinister.Count; j++)
                        {

                            //Minister Brown Rules.
                            AA = new ChessRules(CurrentAStarGredyMax, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged, CloneATable(MinisterOnTable[i].MinisterThinking[0].TableListMinister[j])[MinisterOnTable[i].MinisterThinking[0].RowColumnMinister[j][0], MinisterOnTable[i].MinisterThinking[0].RowColumnMinister[j][1]]
                            , CloneATable(MinisterOnTable[i].MinisterThinking[0].TableListMinister[j])
                            , Order
                            , MinisterOnTable[i].MinisterThinking[0].RowColumnMinister[j][0]
                            , MinisterOnTable[i].MinisterThinking[0].RowColumnMinister[j][1]);
                            //When Minister Borwn CheckMate Occcured.
                            bool ac = false;
                            var ah = Task.Factory.StartNew(() => ac = AA.CheckMate(CloneATable(MinisterOnTable[i].MinisterThinking[0].TableListMinister[j]), Order));
                            ah.Wait();
                            ah.Dispose();
                            if (ac)
                            {
                                //Self CheckMate.
                                if (AllDraw.OrderPlateDraw == -1 && AA.CheckMateBrown)
                                {
                                    //Set Ignore.
                                    Do = -1;
                                    //Superpoistion.
                                    MinisterOnTable[i].MinisterThinking[0].CheckMateAStarGreedy = -1;
                                    //Penalty Subbranches.
                                    var ah1 = Task.Factory.StartNew(() => MakePenaltyAllCheckMateBranches(Base, AllDraw.OrderPlate));
                                    ah1.Wait();
                                    ah1.Dispose();
                                }
                                else
                                {
                                    //CheckMate Enemy.
                                    if (AllDraw.OrderPlateDraw == 1 && AA.CheckMateGray)
                                    {
                                        //Set Regard.
                                        Do = 1;
                                        //Superposition.
                                        MinisterOnTable[i].MinisterThinking[0].CheckMateAStarGreedy = 1;
                                        //Regard SubBranches.
                                        var ah1 = Task.Factory.StartNew(() => MakePenaltyAllCheckMateBranches(Base, AllDraw.OrderPlate));
                                        ah1.Wait();
                                        ah1.Dispose();
                                    }
                                }
                            }
                            if (Do != -1)
                            {
                                Order *= -1;
                                ChessRules.CurrentOrder *= -1;
                                //Minister Brown SubBranches Calling.
                                for (var ii = 0; MinisterOnTable != null && MinisterOnTable[i] != null && MinisterOnTable[i].MinisterThinking[0] != null && ii < MinisterOnTable[i].MinisterThinking[0].AStarGreedy.Count; ii++)
                                {
                                    int D = Do;

                                    var ah1 = Task.Factory.StartNew(() => MinisterOnTable[i].MinisterThinking[0].AStarGreedy[ii].IsPenaltyRegardCheckMateAtBranch(Order, ref D, Base));
                                    ah1.Wait();
                                    ah1.Dispose();
                                    Do = D;
                                }
                                Order = COrder;
                                ChessRules.CurrentOrder = CDummy;
                            }
                        }
                    //King Brown
                    for (var i = KingMidle; i < KingHigh; i++)
                        for (var j = 0; KingOnTable != null && KingOnTable[i] != null && KingOnTable[i].KingThinking[0] != null && j < KingOnTable[i].KingThinking[0].TableListKing.Count; j++)
                        {

                            //King Brown Rules.
                            AA = new ChessRules(CurrentAStarGredyMax, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged, CloneATable(KingOnTable[i].KingThinking[0].TableListKing[j])[KingOnTable[i].KingThinking[0].RowColumnKing[j][0], KingOnTable[i].KingThinking[0].RowColumnKing[j][1]]
                            , CloneATable(KingOnTable[i].KingThinking[0].TableListKing[j])
                            , Order
                            , KingOnTable[i].KingThinking[0].RowColumnKing[j][0]
                            , KingOnTable[i].KingThinking[0].RowColumnKing[j][1]);
                            //When King Brown Rules CheckMate Occcured.
                            bool ac = false;
                            var ah = Task.Factory.StartNew(() => ac = AA.CheckMate(CloneATable(KingOnTable[i].KingThinking[0].TableListKing[j]), Order));
                            ah.Wait();
                            ah.Dispose();
                            if (ac)
                            {
                                //Self CheckMate.
                                if (AllDraw.OrderPlateDraw == -1 && AA.CheckMateBrown)
                                {
                                    //Set Ignore.
                                    Do = -1;
                                    //Superposition.
                                    KingOnTable[i].KingThinking[0].CheckMateAStarGreedy = -1;
                                    //Penalty SubBranches.
                                    var ah1 = Task.Factory.StartNew(() => MakePenaltyAllCheckMateBranches(Base, AllDraw.OrderPlate));
                                    ah1.Wait();
                                    ah1.Dispose();
                                }
                                else
                                {
                                    //CheckMate Enemy.
                                    if (AllDraw.OrderPlateDraw == 1 && AA.CheckMateGray)
                                    {
                                        //Set Regard.
                                        Do = 1;
                                        //Superposition.
                                        KingOnTable[i].KingThinking[0].CheckMateAStarGreedy = 1;
                                        //Regard Subbranches.
                                        var ah1 = Task.Factory.StartNew(() => MakePenaltyAllCheckMateBranches(Base, AllDraw.OrderPlate));
                                        ah1.Wait();
                                        ah1.Dispose();
                                    }
                                }
                            }
                            if (Do != -1)
                            {
                                Order *= -1;
                                ChessRules.CurrentOrder *= -1;
                                //King Brown Subbranches Calling.
                                for (var ii = 0; KingOnTable != null && KingOnTable[i] != null && KingOnTable[i].KingThinking[0] != null && ii < KingOnTable[i].KingThinking[0].AStarGreedy.Count; ii++)
                                {
                                    int D = Do;

                                    var ah1 = Task.Factory.StartNew(() => KingOnTable[i].KingThinking[0].AStarGreedy[ii].IsPenaltyRegardCheckMateAtBranch(Order, ref D, Base));
                                    ah1.Wait();
                                    ah1.Dispose();
                                    Do = D;
                                }
                                Order = COrder;
                                ChessRules.CurrentOrder = CDummy;
                            }
                        }
                    for (var i = 0; i < 1; i++)
                        for (var j = 0; CastlingOnTable != null && CastlingOnTable[i] != null && CastlingOnTable[i].CastlingThinking[0] != null && j < CastlingOnTable[i].CastlingThinking[0].TableListCastling.Count; j++)
                        {

                            //Gray Castling Rules.
                            AA = new ChessRules(CurrentAStarGredyMax, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged, CloneATable(CastlingOnTable[i].CastlingThinking[0].TableListCastling[j])[CastlingOnTable[i].CastlingThinking[0].RowColumnCastling[j][0], CastlingOnTable[i].CastlingThinking[0].RowColumnCastling[j][1]]
                            , CloneATable(CastlingOnTable[i].CastlingThinking[0].TableListCastling[j])
                            , Order
                            , CastlingOnTable[i].CastlingThinking[0].RowColumnCastling[j][0]
                            , CastlingOnTable[i].CastlingThinking[0].RowColumnCastling[j][1]);
                            //When CheckMate Occured in Castling Gray.
                            bool ac = false;
                            var ah = Task.Factory.StartNew(() => ac = AA.CheckMate(CloneATable(CastlingOnTable[i].CastlingThinking[0].TableListCastling[j]), Order));
                            ah.Wait();
                            ah.Dispose();
                            if (ac)
                            {
                                //Self CheckMate.
                                if (AllDraw.OrderPlateDraw == 1 && AA.CheckMateGray)
                                {
                                    //Penalty Ignore.
                                    Do = -1;
                                    //Superposition.
                                    CastlingOnTable[i].CastlingThinking[0].CheckMateAStarGreedy = -1;
                                    //Penalty Subbranchs.
                                    var ah1 = Task.Factory.StartNew(() => MakePenaltyAllCheckMateBranches(Base, AllDraw.OrderPlate));
                                    ah1.Wait();
                                    ah1.Dispose();
                                }
                                else
                                {
                                    //Self CheckMate.
                                    if (AllDraw.OrderPlateDraw == -1 && AA.CheckMateBrown)
                                    {
                                        //Regard Setting.
                                        Do = 1;
                                        //Superpoistion.
                                        CastlingOnTable[i].CastlingThinking[0].CheckMateAStarGreedy = 1;
                                        //Regard Subbranchs.
                                        var ah1 = Task.Factory.StartNew(() => MakePenaltyAllCheckMateBranches(Base, AllDraw.OrderPlate));
                                        ah1.Wait();
                                        ah1.Dispose();
                                    }
                                }
                            }
                            if (Do != -1)
                            {
                                Order *= -1;
                                ChessRules.CurrentOrder *= -1;
                                //For Castling Gray Subbranchs.
                                for (var ii = 0; CastlingOnTable != null && CastlingOnTable[i] != null && CastlingOnTable[i].CastlingThinking[0] != null && ii < CastlingOnTable[i].CastlingThinking[0].AStarGreedy.Count; ii++)
                                {
                                    int D = Do;

                                    var ah1 = Task.Factory.StartNew(() => CastlingOnTable[i].CastlingThinking[0].AStarGreedy[ii].IsPenaltyRegardCheckMateAtBranch(Order, ref D, Base));
                                    ah1.Wait();
                                    ah1.Dispose();
                                    Do = D;
                                }

                                Order = COrder;
                                ChessRules.CurrentOrder = CDummy;
                            }
                        }
                }
                ChessRules.CurrentOrder = CDummy;
            }

        }
        //A Mechanisam for penalty all subbranches of chiled of root at contained of same childes  of making penalty by target 
        public void MakePenaltyAllCheckMateBranches(AllDraw A, int Order)
        {

            Object a = new Object();
            lock (a)
            {
                int COrder = Order;
                int CDummy = ChessRules.CurrentOrder;
                if (Order == 1)
                {
                    //For Solider Gray
                    for (var i = 0; i < SodierMidle; i++)
                        for (var j = 0; A.SolderesOnTable != null && SolderesOnTable[i] != null && A.SolderesOnTable[i].SoldierThinking[0] != null && j < A.SolderesOnTable[i].SoldierThinking[0].TableListSolder.Count; j++)
                        {
                            //make penalty
                            A.SolderesOnTable[i].SoldierThinking[0].PenaltyRegardListSolder[i].LearningAlgorithmPenalty();
                            //For deeper chiled.
                            Order *= -1; ChessRules.CurrentOrder *= -1;
                            for (var ii = 0; A.SolderesOnTable != null && SolderesOnTable[i] != null && A.SolderesOnTable[i].SoldierThinking[0] != null && ii < A.SolderesOnTable[i].SoldierThinking[0].AStarGreedy.Count; ii++)
                            {
                                var ah1 = Task.Factory.StartNew(() => MakePenaltyAllCheckMateBranches(A.SolderesOnTable[i].SoldierThinking[0].AStarGreedy[ii], Order));
                                ah1.Wait();
                                ah1.Dispose();
                            }
                            Order = COrder; ChessRules.CurrentOrder = CDummy;
                        }
                    //For Elephant Gray 
                    for (var i = 0; i < ElefantMidle; i++)
                        for (var j = 0; A.ElephantOnTable != null && ElephantOnTable[i] != null && A.ElephantOnTable[i].ElefantThinking[0] != null && j < A.ElephantOnTable[i].ElefantThinking[0].TableListElefant.Count; j++)
                        {
                            //make penalty
                            A.ElephantOnTable[i].ElefantThinking[0].PenaltyRegardListElefant[j].LearningAlgorithmPenalty();
                            //For Depper chiled
                            Order *= -1; ChessRules.CurrentOrder *= -1;
                            for (var ii = 0; A.ElephantOnTable != null && ElephantOnTable[i] != null && A.ElephantOnTable[i].ElefantThinking[0] != null && ii < A.ElephantOnTable[i].ElefantThinking[0].AStarGreedy.Count; ii++)
                            {
                                var ah1 = Task.Factory.StartNew(() => MakePenaltyAllCheckMateBranches(A.ElephantOnTable[i].ElefantThinking[0].AStarGreedy[ii], Order));
                                ah1.Wait();
                                ah1.Dispose();
                            }
                            Order = COrder; ChessRules.CurrentOrder = CDummy;
                        }
                    //For Hourse Gray
                    for (var i = 0; i < HourseMidle; i++)
                        for (var j = 0; A.HoursesOnTable != null && HoursesOnTable[i] != null && A.HoursesOnTable[i].HourseThinking[0] != null && j < A.HoursesOnTable[i].HourseThinking[0].TableListHourse.Count; j++)
                        {
                            //make penalty
                            A.HoursesOnTable[i].HourseThinking[0].PenaltyRegardListHourse[j].LearningAlgorithmPenalty();

                            //for deeper chiled
                            Order *= -1; ChessRules.CurrentOrder *= -1;
                            for (var ii = 0; A.HoursesOnTable != null && HoursesOnTable[i] != null && A.HoursesOnTable[i].HourseThinking[0] != null && ii < A.HoursesOnTable[i].HourseThinking[0].AStarGreedy.Count; ii++)
                            {
                                var ah1 = Task.Factory.StartNew(() => MakePenaltyAllCheckMateBranches(A.HoursesOnTable[i].HourseThinking[0].AStarGreedy[ii], Order));
                                ah1.Wait();
                                ah1.Dispose();
                            }

                            Order = COrder; ChessRules.CurrentOrder = CDummy;
                        }
                    //for Castle Gray
                    for (var i = 0; i < CastleMidle; i++)
                        for (var j = 0; A.CastlesOnTable != null && CastlesOnTable[i] != null && A.CastlesOnTable[i].CastleThinking[0] != null && j < A.CastlesOnTable[i].CastleThinking[0].TableListCastle.Count; j++)
                        {
                            //make penalty
                            A.CastlesOnTable[i].CastleThinking[0].PenaltyRegardListCastle[j].LearningAlgorithmPenalty();
                            //for deeper chiled
                            Order *= -1; ChessRules.CurrentOrder *= -1;
                            for (var ii = 0; A.CastlesOnTable != null && CastlesOnTable[i] != null && A.CastlesOnTable[i].CastleThinking[0] != null && ii < A.CastlesOnTable[i].CastleThinking[0].AStarGreedy.Count; ii++)
                            {
                                var ah1 = Task.Factory.StartNew(() => MakePenaltyAllCheckMateBranches(A.CastlesOnTable[i].CastleThinking[0].AStarGreedy[ii], Order));
                                ah1.Wait();
                                ah1.Dispose();
                            }

                            Order = COrder; ChessRules.CurrentOrder = CDummy;
                        }
                    //for minister Gray
                    for (var i = 0; i < MinisterMidle; i++)
                        for (var j = 0; A.MinisterOnTable != null && MinisterOnTable[i] != null && A.MinisterOnTable[i].MinisterThinking[0] != null && j < A.MinisterOnTable[i].MinisterThinking[0].TableListMinister.Count; j++)
                        {
                            //make penalty
                            A.MinisterOnTable[i].MinisterThinking[0].PenaltyRegardListMinister[j].LearningAlgorithmPenalty();
                            //for deeper chiled
                            Order *= -1; ChessRules.CurrentOrder *= -1;
                            for (var ii = 0; A.MinisterOnTable != null && MinisterOnTable[i] != null && A.MinisterOnTable[i].MinisterThinking[0] != null && ii < A.MinisterOnTable[i].MinisterThinking[0].AStarGreedy.Count; ii++)
                            {
                                var ah1 = Task.Factory.StartNew(() => MakePenaltyAllCheckMateBranches(A.MinisterOnTable[i].MinisterThinking[0].AStarGreedy[ii], Order));
                                ah1.Wait();
                                ah1.Dispose();
                            }
                            Order = COrder; ChessRules.CurrentOrder = CDummy;
                        }
                    //for Gray king
                    for (var i = 0; i < KingMidle; i++)
                        for (var j = 0; A.KingOnTable != null && KingOnTable[i] != null && A.KingOnTable[i].KingThinking[0] != null && j < A.KingOnTable[i].KingThinking[0].TableListKing.Count; j++)
                        {
                            //make penalty  
                            A.KingOnTable[i].KingThinking[0].PenaltyRegardListKing[j].LearningAlgorithmPenalty();
                            //for deeper chiled
                            Order *= -1; ChessRules.CurrentOrder *= -1;
                            for (var ii = 0; A.KingOnTable != null && KingOnTable[i] != null && A.KingOnTable[i].KingThinking[0] != null && ii < A.KingOnTable[i].KingThinking[0].AStarGreedy.Count; ii++)
                            {
                                var ah1 = Task.Factory.StartNew(() => MakePenaltyAllCheckMateBranches(A.KingOnTable[i].KingThinking[0].AStarGreedy[ii], Order));
                                ah1.Wait();
                                ah1.Dispose();
                            }
                            Order = COrder; ChessRules.CurrentOrder = CDummy;
                        }
                    for (var i = 0; i < 1; i++)
                        for (var j = 0; A.CastlingOnTable != null && CastlingOnTable[i] != null && A.CastlingOnTable[i].CastlingThinking[0] != null && j < A.CastlingOnTable[i].CastlingThinking[0].TableListCastling.Count; j++)
                        {
                            //make penalty  
                            A.CastlingOnTable[i].CastlingThinking[0].PenaltyRegardListCastling[j].LearningAlgorithmPenalty();
                            //for deeper chiled
                            Order *= -1; ChessRules.CurrentOrder *= -1;
                            for (var ii = 0; A.CastlingOnTable != null && CastlingOnTable[i] != null && A.CastlingOnTable[i].CastlingThinking[0] != null && ii < A.CastlingOnTable[i].CastlingThinking[0].AStarGreedy.Count; ii++)
                            {
                                var ah1 = Task.Factory.StartNew(() => MakePenaltyAllCheckMateBranches(A.CastlingOnTable[i].CastlingThinking[0].AStarGreedy[ii], Order));
                                ah1.Wait();
                                ah1.Dispose();
                            }
                            Order = COrder; ChessRules.CurrentOrder = CDummy;
                        }
                }
                else//Brown
                {
                    //for soldier Brown
                    for (var i = SodierMidle; i < SodierHigh; i++)
                        for (var j = 0; A.SolderesOnTable != null && SolderesOnTable[i] != null && A.SolderesOnTable[i].SoldierThinking[0] != null && j < A.SolderesOnTable[i].SoldierThinking[0].TableListSolder.Count; j++)
                        {
                            //make penalty
                            A.SolderesOnTable[i].SoldierThinking[0].PenaltyRegardListSolder[i].LearningAlgorithmPenalty();
                            //for deeper chiled
                            Order *= -1; ChessRules.CurrentOrder *= -1;
                            for (var ii = 0; A.SolderesOnTable != null && SolderesOnTable[i] != null && A.SolderesOnTable[i].SoldierThinking[0] != null && ii < A.SolderesOnTable[i].SoldierThinking[0].AStarGreedy.Count; ii++)
                            {
                                var ah1 = Task.Factory.StartNew(() => MakePenaltyAllCheckMateBranches(A.SolderesOnTable[i].SoldierThinking[0].AStarGreedy[ii], Order));
                                ah1.Wait();
                                ah1.Dispose();
                            }
                            Order = COrder; ChessRules.CurrentOrder = CDummy;
                        }
                    //for elephant Brown
                    for (var i = ElefantMidle; i < ElefantHigh; i++)
                        for (var j = 0; A.ElephantOnTable != null && ElephantOnTable[i] != null && A.ElephantOnTable[i].ElefantThinking[0] != null && j < A.ElephantOnTable[i].ElefantThinking[0].TableListElefant.Count; j++)
                        {
                            //make penalty
                            A.ElephantOnTable[i].ElefantThinking[0].PenaltyRegardListElefant[j].LearningAlgorithmPenalty();
                            //for deeper chiled
                            Order *= -1; ChessRules.CurrentOrder *= -1;
                            for (var ii = 0; A.ElephantOnTable != null && ElephantOnTable[i] != null && A.ElephantOnTable[i].ElefantThinking[0] != null && ii < A.ElephantOnTable[i].ElefantThinking[0].AStarGreedy.Count; ii++)
                            {
                                var ah1 = Task.Factory.StartNew(() => MakePenaltyAllCheckMateBranches(A.ElephantOnTable[i].ElefantThinking[0].AStarGreedy[ii], Order));
                                ah1.Wait();
                                ah1.Dispose();
                            }
                            Order = COrder; ChessRules.CurrentOrder = CDummy;
                        }
                    //for hourse Brown
                    for (var i = HourseMidle; i < HourseHight; i++)
                        for (var j = 0; A.HoursesOnTable != null && HoursesOnTable[i] != null && A.HoursesOnTable[i].HourseThinking[0] != null && j < A.HoursesOnTable[i].HourseThinking[0].TableListHourse.Count; j++)
                        {
                            //make penalty
                            A.HoursesOnTable[i].HourseThinking[0].PenaltyRegardListHourse[j].LearningAlgorithmPenalty();

                            //for deeper chiled
                            Order *= -1; ChessRules.CurrentOrder *= -1;
                            for (var ii = 0; A.HoursesOnTable != null && HoursesOnTable[i] != null && A.HoursesOnTable[i].HourseThinking[0] != null && ii < A.HoursesOnTable[i].HourseThinking[0].AStarGreedy.Count; ii++)
                            {
                                var ah1 = Task.Factory.StartNew(() => MakePenaltyAllCheckMateBranches(A.HoursesOnTable[i].HourseThinking[0].AStarGreedy[ii], Order));
                                ah1.Wait();
                                ah1.Dispose();
                            }
                            Order = COrder; ChessRules.CurrentOrder = CDummy;
                        }
                    //for casytle Brown
                    for (var i = CastleMidle; i < CastleHigh; i++)
                        for (var j = 0; A.CastlesOnTable != null && CastlesOnTable[i] != null && A.CastlesOnTable[i].CastleThinking[0] != null && j < A.CastlesOnTable[i].CastleThinking[0].TableListCastle.Count; j++)
                        {
                            //make penalty
                            A.CastlesOnTable[i].CastleThinking[0].PenaltyRegardListCastle[j].LearningAlgorithmPenalty();
                            //for deeper chiled
                            Order *= -1; ChessRules.CurrentOrder *= -1;
                            for (var ii = 0; A.CastlesOnTable != null && CastlesOnTable[i] != null && A.CastlesOnTable[i].CastleThinking[0] != null && ii < A.CastlesOnTable[i].CastleThinking[0].AStarGreedy.Count; ii++)
                            {
                                var ah1 = Task.Factory.StartNew(() => MakePenaltyAllCheckMateBranches(A.CastlesOnTable[i].CastleThinking[0].AStarGreedy[ii], Order));
                                ah1.Wait();
                                ah1.Dispose();
                            }
                            Order = COrder; ChessRules.CurrentOrder = CDummy;
                        }
                    //for minsiter Brown
                    for (var i = MinisterMidle; i < MinisterHigh; i++)
                        for (var j = 0; A.MinisterOnTable != null && MinisterOnTable[i] != null && A.MinisterOnTable[i].MinisterThinking[0] != null && j < A.MinisterOnTable[i].MinisterThinking[0].TableListMinister.Count; j++)
                        {
                            //make penalty
                            A.MinisterOnTable[i].MinisterThinking[0].PenaltyRegardListMinister[j].LearningAlgorithmPenalty();
                            //fopfor weeper chiled
                            Order *= -1; ChessRules.CurrentOrder *= -1;
                            for (var ii = 0; A.MinisterOnTable != null && MinisterOnTable[i] != null && A.MinisterOnTable[i].MinisterThinking[0] != null && ii < A.MinisterOnTable[i].MinisterThinking[0].AStarGreedy.Count; ii++)
                            {
                                var ah1 = Task.Factory.StartNew(() => MakePenaltyAllCheckMateBranches(A.MinisterOnTable[i].MinisterThinking[0].AStarGreedy[ii], Order));
                                ah1.Wait();
                                ah1.Dispose();
                            }
                            Order = COrder; ChessRules.CurrentOrder = CDummy;
                        }
                    //for king Brown
                    for (var i = KingMidle; i < MinisterHigh; i++)
                        for (var j = 0; A.KingOnTable != null && KingOnTable[i] != null && A.KingOnTable[i].KingThinking[0] != null && j < A.KingOnTable[i].KingThinking[0].TableListKing.Count; j++)
                        {
                            //make penalty
                            A.KingOnTable[i].KingThinking[0].PenaltyRegardListKing[j].LearningAlgorithmPenalty();
                            //for deeper chiled
                            Order *= -1; ChessRules.CurrentOrder *= -1;
                            for (var ii = 0; A.KingOnTable != null && KingOnTable[i] != null && A.KingOnTable[i].KingThinking[0] != null && ii < A.KingOnTable[i].KingThinking[0].AStarGreedy.Count; ii++)
                            {
                                var ah1 = Task.Factory.StartNew(() => MakePenaltyAllCheckMateBranches(A.KingOnTable[i].KingThinking[0].AStarGreedy[ii], Order));
                                ah1.Wait();
                                ah1.Dispose();
                            }
                            Order = COrder; ChessRules.CurrentOrder = CDummy;
                        }
                    for (var i = 0; i < 1; i++)
                        for (var j = 0; A.CastlingOnTable != null && CastlingOnTable[i] != null && A.CastlingOnTable[i].CastlingThinking[0] != null && j < A.CastlingOnTable[i].CastlingThinking[0].TableListCastling.Count; j++)
                        {
                            //make penalty  
                            A.CastlingOnTable[i].CastlingThinking[0].PenaltyRegardListCastling[j].LearningAlgorithmPenalty();
                            //for deeper chiled
                            Order *= -1; ChessRules.CurrentOrder *= -1;
                            for (var ii = 0; A.CastlingOnTable != null && CastlingOnTable[i] != null && A.CastlingOnTable[i].CastlingThinking[0] != null && ii < A.CastlingOnTable[i].CastlingThinking[0].AStarGreedy.Count; ii++)
                            {
                                var ah1 = Task.Factory.StartNew(() => MakePenaltyAllCheckMateBranches(A.CastlingOnTable[i].CastlingThinking[0].AStarGreedy[ii], Order));
                                ah1.Wait();
                                ah1.Dispose();
                            }
                            Order = COrder; ChessRules.CurrentOrder = CDummy;
                        }
                }
            }

        }
        //remove penalty from root current node.
        public AllDraw RemovePenalltyFromFirstBranches(int Order)
        {

            Object a = new Object();
            lock (a)
            {
                //Gray
                if (Order == 1)
                {
                    //for Gray solder
                    for (var i = 0; i < SodierMidle; i++)
                        for (var j = 0; SolderesOnTable != null && SolderesOnTable[i] != null && SolderesOnTable[i].SoldierThinking[0] != null && j < SolderesOnTable[i].SoldierThinking[0].TableListSolder.Count; j++)
                        {
                            //iniatite penalty vars to false.
                            UsePenaltyRegardMechnisamT = false;
                            var ah = Task.Factory.StartNew(() => SolderesOnTable[i].SoldierThinking[0].PenaltyRegardListSolder[j].Initiate());
                            ah.Wait();
                            ah.Dispose();
                            for (int k = 0; k < SolderesOnTable[i].SoldierThinking[0].AStarGreedy.Count; k++)
                            {
                                var ah1 = Task.Factory.StartNew(() => SolderesOnTable[i].SoldierThinking[0].AStarGreedy[k].RemovePenalltyFromFirstBranches(Order * -1));
                                ah1.Wait();
                                ah1.Dispose();
                            }

                        }
                    //for Gray elephant
                    for (var i = 0; i < ElefantMidle; i++)
                        for (var j = 0; ElephantOnTable != null && ElephantOnTable[i] != null && ElephantOnTable[i].ElefantThinking[0] != null && j < ElephantOnTable[i].ElefantThinking[0].TableListElefant.Count; j++)
                        {
                            //iniatite penalty vars to false.
                            UsePenaltyRegardMechnisamT = false;

                            var ah = Task.Factory.StartNew(() => ElephantOnTable[i].ElefantThinking[0].PenaltyRegardListElefant[j].Initiate());
                            ah.Wait();
                            ah.Dispose();
                            for (int k = 0; k < ElephantOnTable[i].ElefantThinking[0].AStarGreedy.Count; k++)
                            {
                                var ah1 = Task.Factory.StartNew(() => ElephantOnTable[i].ElefantThinking[0].AStarGreedy[k].RemovePenalltyFromFirstBranches(Order * -1));
                                ah1.Wait();
                                ah1.Dispose();
                            }

                        }
                    //for Gray hourse
                    for (var i = 0; i < HourseMidle; i++)
                        for (var j = 0; HoursesOnTable != null && HoursesOnTable[i] != null && HoursesOnTable[i].HourseThinking[0] != null && j < HoursesOnTable[i].HourseThinking[0].TableListHourse.Count; j++)
                        {
                            //iniatite penalty vars to false.
                            UsePenaltyRegardMechnisamT = false;
                            var ah = Task.Factory.StartNew(() => HoursesOnTable[i].HourseThinking[0].PenaltyRegardListHourse[j].Initiate());
                            ah.Wait();
                            ah.Dispose();
                            for (int k = 0; k < HoursesOnTable[i].HourseThinking[0].AStarGreedy.Count; k++)
                            {
                                var ah1 = Task.Factory.StartNew(() => HoursesOnTable[i].HourseThinking[0].AStarGreedy[k].RemovePenalltyFromFirstBranches(Order * -1));
                                ah1.Wait();
                                ah1.Dispose();
                            }

                        }
                    //for Castle Gray
                    for (var i = 0; i < CastleMidle; i++)
                        for (var j = 0; CastlesOnTable != null && CastlesOnTable[i] != null && CastlesOnTable[i].CastleThinking[0] != null && j < CastlesOnTable[i].CastleThinking[0].TableListCastle.Count; j++)
                        {
                            //iniatite penalty vars to false.
                            UsePenaltyRegardMechnisamT = false;

                            var ah = Task.Factory.StartNew(() => CastlesOnTable[i].CastleThinking[0].PenaltyRegardListCastle[j].Initiate());
                            ah.Wait();
                            ah.Dispose();
                            for (int k = 0; k < CastlesOnTable[i].CastleThinking[0].AStarGreedy.Count; k++)
                            {
                                var ah1 = Task.Factory.StartNew(() => CastlesOnTable[i].CastleThinking[0].AStarGreedy[k].RemovePenalltyFromFirstBranches(Order * -1));
                                ah1.Wait();
                                ah1.Dispose();
                            }

                        }
                    //for Gray minsiter
                    for (var i = 0; i < MinisterMidle; i++)
                        for (var j = 0; MinisterOnTable != null && MinisterOnTable[i] != null && MinisterOnTable[i].MinisterThinking[0] != null && j < MinisterOnTable[i].MinisterThinking[0].TableListMinister.Count; j++)
                        {
                            //iniatite penalty vars to false.
                            UsePenaltyRegardMechnisamT = false;

                            var ah = Task.Factory.StartNew(() => MinisterOnTable[i].MinisterThinking[0].PenaltyRegardListMinister[j].Initiate());
                            ah.Wait();
                            ah.Dispose();
                            for (int k = 0; k < MinisterOnTable[i].MinisterThinking[0].AStarGreedy.Count; k++)
                            {
                                var ah1 = Task.Factory.StartNew(() => MinisterOnTable[i].MinisterThinking[0].AStarGreedy[k].RemovePenalltyFromFirstBranches(Order * -1));
                                ah1.Wait();
                                ah1.Dispose();
                            }

                        }
                    //for Gray minster
                    for (var i = 0; i < KingMidle; i++)
                        for (var j = 0; KingOnTable != null && KingOnTable[i] != null && KingOnTable[i].KingThinking[0] != null && j < KingOnTable[i].KingThinking[0].TableListKing.Count; j++)
                        {
                            //iniatite penalty vars to false.
                            UsePenaltyRegardMechnisamT = false;

                            var ah = Task.Factory.StartNew(() => KingOnTable[i].KingThinking[0].PenaltyRegardListKing[j].Initiate());
                            ah.Wait();
                            ah.Dispose();
                            for (int k = 0; k < KingOnTable[i].KingThinking[0].AStarGreedy.Count; k++)
                            {
                                var ah1 = Task.Factory.StartNew(() => KingOnTable[i].KingThinking[0].AStarGreedy[k].RemovePenalltyFromFirstBranches(Order * -1));
                                ah1.Wait();
                                ah1.Dispose();
                            }

                        }
                    for (var i = 0; i < 1; i++)
                        for (var j = 0; CastlingOnTable != null && CastlingOnTable[i] != null && CastlingOnTable[i].CastlingThinking[0] != null && j < CastlingOnTable[i].CastlingThinking[0].TableListCastling.Count; j++)
                        {
                            //iniatite penalty vars to false.
                            UsePenaltyRegardMechnisamT = false;

                            var ah = Task.Factory.StartNew(() => CastlingOnTable[i].CastlingThinking[0].PenaltyRegardListCastling[j].Initiate());
                            ah.Wait();
                            ah.Dispose();
                            for (int k = 0; k < CastlingOnTable[i].CastlingThinking[0].AStarGreedy.Count; k++)
                            {
                                var ah1 = Task.Factory.StartNew(() => CastlingOnTable[i].CastlingThinking[0].AStarGreedy[k].RemovePenalltyFromFirstBranches(Order * -1));
                                ah1.Wait();
                                ah1.Dispose();
                            }

                        }

                }
                else
                {
                    //for Brown soldeir
                    for (var i = SodierMidle; i < SodierHigh; i++)
                        for (var j = 0; SolderesOnTable != null && SolderesOnTable[i] != null && SolderesOnTable[i].SoldierThinking != null && j < SolderesOnTable[i].SoldierThinking[0].TableListSolder.Count; j++)
                        {
                            //iniatite penalty vars to false.
                            UsePenaltyRegardMechnisamT = false;

                            var ah = Task.Factory.StartNew(() => SolderesOnTable[i].SoldierThinking[0].PenaltyRegardListSolder[j].Initiate());
                            ah.Wait();
                            ah.Dispose();
                            for (int k = 0; k < SolderesOnTable[i].SoldierThinking[0].AStarGreedy.Count; k++)
                            {
                                var ah1 = Task.Factory.StartNew(() => SolderesOnTable[i].SoldierThinking[0].AStarGreedy[k].RemovePenalltyFromFirstBranches(Order * -1));
                                ah1.Wait();
                                ah1.Dispose();
                            }
                        }
                    //for Brown elephant
                    for (var i = ElefantMidle; i < ElefantHigh; i++)
                        for (var j = 0; ElephantOnTable != null && ElephantOnTable[i] != null && ElephantOnTable[i].ElefantThinking[0] != null && j < ElephantOnTable[i].ElefantThinking[0].TableListElefant.Count; j++)
                        {
                            //iniatite penalty vars to false.
                            UsePenaltyRegardMechnisamT = false;

                            var ah = Task.Factory.StartNew(() => ElephantOnTable[i].ElefantThinking[0].PenaltyRegardListElefant[j].Initiate());
                            ah.Wait();
                            ah.Dispose();
                            for (int k = 0; k < ElephantOnTable[i].ElefantThinking[0].AStarGreedy.Count; k++)
                            {
                                var ah1 = Task.Factory.StartNew(() => ElephantOnTable[i].ElefantThinking[0].AStarGreedy[k].RemovePenalltyFromFirstBranches(Order * -1));
                                ah1.Wait();
                                ah1.Dispose();
                            }
                        }
                    //for Brown hourse
                    for (var i = HourseMidle; i < HourseHight; i++)
                        for (var j = 0; HoursesOnTable != null && HoursesOnTable[i] != null && HoursesOnTable[i].HourseThinking[0] != null && j < HoursesOnTable[i].HourseThinking[0].TableListHourse.Count; j++)
                        {
                            //iniatite penalty vars to false.
                            UsePenaltyRegardMechnisamT = false;

                            var ah = Task.Factory.StartNew(() => HoursesOnTable[i].HourseThinking[0].PenaltyRegardListHourse[j].Initiate());
                            ah.Wait();
                            ah.Dispose();
                            for (int k = 0; k < HoursesOnTable[i].HourseThinking[0].AStarGreedy.Count; k++)
                            {
                                var ah1 = Task.Factory.StartNew(() => HoursesOnTable[i].HourseThinking[0].AStarGreedy[k].RemovePenalltyFromFirstBranches(Order * -1));
                                ah1.Wait();
                                ah1.Dispose();
                            }
                        }
                    //for Brown Castle
                    for (var i = CastleMidle; i < CastleHigh; i++)
                        for (var j = 0; CastlesOnTable != null && CastlesOnTable[i] != null && CastlesOnTable[i].CastleThinking[0] != null && j < CastlesOnTable[i].CastleThinking[0].TableListCastle.Count; j++)
                        {
                            //iniatite penalty vars to false.
                            UsePenaltyRegardMechnisamT = false;

                            var ah = Task.Factory.StartNew(() => CastlesOnTable[i].CastleThinking[0].PenaltyRegardListCastle[j].Initiate());
                            ah.Wait();
                            ah.Dispose();
                            for (int k = 0; k < CastlesOnTable[i].CastleThinking[0].AStarGreedy.Count; k++)
                            {
                                var ah1 = Task.Factory.StartNew(() => CastlesOnTable[i].CastleThinking[0].AStarGreedy[k].RemovePenalltyFromFirstBranches(Order * -1));
                                ah1.Wait();
                                ah1.Dispose();
                            }
                        }
                    //for Brown ,minster
                    for (var i = MinisterMidle; i < MinisterHigh; i++)
                        for (var j = 0; MinisterOnTable != null && MinisterOnTable[i] != null && MinisterOnTable[i].MinisterThinking[0] != null && j < MinisterOnTable[i].MinisterThinking[0].TableListMinister.Count; j++)
                        {
                            //iniatite penalty vars to false.
                            UsePenaltyRegardMechnisamT = false;

                            var ah = Task.Factory.StartNew(() => MinisterOnTable[i].MinisterThinking[0].PenaltyRegardListMinister[j].Initiate());
                            ah.Wait();
                            ah.Dispose();
                            for (int k = 0; k < MinisterOnTable[i].MinisterThinking[0].AStarGreedy.Count; k++)
                            {
                                var ah1 = Task.Factory.StartNew(() => MinisterOnTable[i].MinisterThinking[0].AStarGreedy[k].RemovePenalltyFromFirstBranches(Order * -1));
                                ah1.Wait();
                                ah1.Dispose();
                            }
                        }
                    //for Brown king
                    for (var i = KingMidle; i < KingHigh; i++)
                        for (var j = 0; KingOnTable != null && KingOnTable[i] != null
                            && KingOnTable[i].KingThinking[0] != null && j < KingOnTable[i].KingThinking[0].TableListKing.Count; j++)
                        {
                            //iniatite penalty vars to false.
                            UsePenaltyRegardMechnisamT = false;
                            var ah = Task.Factory.StartNew(() => KingOnTable[i].KingThinking[0].PenaltyRegardListKing[j].Initiate());
                            ah.Wait();
                            ah.Dispose();
                            for (int k = 0; k < KingOnTable[i].KingThinking[0].AStarGreedy.Count; k++)
                            {
                                var ah1 = Task.Factory.StartNew(() => KingOnTable[i].KingThinking[0].AStarGreedy[k].RemovePenalltyFromFirstBranches(Order * -1));
                                ah1.Wait();
                                ah1.Dispose();
                            }
                        }
                    for (var i = 0; i < 1; i++)
                        for (var j = 0; CastlingOnTable != null && CastlingOnTable[i] != null && CastlingOnTable[i].CastlingThinking[0] != null && j < CastlingOnTable[i].CastlingThinking[0].TableListCastling.Count; j++)
                        {
                            //iniatite penalty vars to false.
                            UsePenaltyRegardMechnisamT = false;

                            var ah = Task.Factory.StartNew(() => CastlingOnTable[i].CastlingThinking[0].PenaltyRegardListCastling[j].Initiate());
                            ah.Wait();
                            ah.Dispose();
                            for (int k = 0; k < CastlingOnTable[i].CastlingThinking[0].AStarGreedy.Count; k++)
                            {
                                var ah1 = Task.Factory.StartNew(() => CastlingOnTable[i].CastlingThinking[0].AStarGreedy[k].RemovePenalltyFromFirstBranches(Order * -1));
                                ah1.Wait();
                                ah1.Dispose();
                            }

                        }

                }

                return this;
            }
        }
        //when index is out of boundry return false when is valid return true
        bool BondryObjectNumber(int i, int Kind, int Order)
        {
            bool Is = true;
            if (Order == 1)
            {
                if (Kind == 1)
                {
                    if (i >= SodierMidle)
                        Is = false;
                }
                else
                    if (Kind == 2)
                {
                    if (i >= ElefantMidle)
                        Is = false;
                }
                else
                    if (Kind == 3)
                {
                    if (i >= HourseMidle)
                        Is = false;
                }
                else
                    if (Kind == 4)
                {
                    if (i >= CastleMidle)
                        Is = false;
                }
                else
                    if (Kind == 5)
                {
                    if (i >= MinisterMidle)
                        Is = false;
                }
                else
                    if (Kind == 6)
                {
                    if (i >= KingMidle)
                        Is = false;
                }
                else
                   if (Kind == 7 || Kind == -7)
                {
                    if (i < 0 || i > 0)
                        Is = false;
                }
            }
            else
            {
                if (Kind == 1)
                {
                    if (i < SodierMidle || i >= SodierHigh)
                        Is = false;
                }
                else
                   if (Kind == 2)
                {
                    if (i < ElefantMidle || i >= ElefantHigh)
                        Is = false;
                }
                else
                   if (Kind == 3)
                {
                    if (i < HourseMidle || i >= HourseHight)
                        Is = false;
                }
                else
                   if (Kind == 4)
                {
                    if (i < CastleMidle || i >= CastleHigh)
                        Is = false;
                }
                else
                   if (Kind == 5)
                {
                    if (i < MinisterMidle || i >= MinisterHigh)
                        Is = false;
                }
                else
                   if (Kind == 6)
                {
                    if (i < KingMidle || i >= KingHigh)
                        Is = false;
                }
                else
                   if (Kind == 7 || Kind == -7)
                {
                    if (i < 0 || i > 0)
                        Is = false;
                }
            }
            return Is;
        }
        //All valid call of current alldraw deeper of founding get node.
        public AllDraw FoundOfCurrentTableNodeAstardGreedy(int i, int j, int[,] Tab, int Order, ref AllDraw THIS, ref bool Found)
        {
            //soldier
            bool ac = false;
            var ah = Task.Factory.StartNew(() => ac = BondryObjectNumber(i, 1, Order));
            ah.Wait();
            ah.Dispose();
            if (ac && SolderesOnTable != null && SolderesOnTable[i] != null && SolderesOnTable[i].SoldierThinking[0] != null && SolderesOnTable[i].SoldierThinking[0].TableListSolder != null && j < SolderesOnTable[i].SoldierThinking[0].TableListSolder.Count && SolderesOnTable[i].SoldierThinking[0].AStarGreedy != null)
            {


                if (SolderesOnTable[i].SoldierThinking[0].AStarGreedy.Count > j && SolderesOnTable[i].SoldierThinking[0].AStarGreedy != null)
                {
                    AllDraw This = THIS;
                    bool fou = Found;
                    var ah6 = Task.Factory.StartNew(() => SolderesOnTable[i].SoldierThinking[0].AStarGreedy[j].FoundOfCurrentTableNode(CloneATable(Tab), Order * -1, ref This, ref fou));
                    ah6.Wait();
                    ah6.Dispose();
                    THIS = This;
                    Found = fou;

                }
            }
            //elephant
            var ah1 = Task.Factory.StartNew(() => ac = BondryObjectNumber(i, 2, Order));
            ah1.Wait();
            ah1.Dispose();
            if (ac && ElephantOnTable != null && ElephantOnTable[i] != null && ElephantOnTable[i].ElefantThinking[0] != null && ElephantOnTable[i].ElefantThinking[0].TableListElefant != null && j < ElephantOnTable[i].ElefantThinking[0].TableListElefant.Count && ElephantOnTable[i].ElefantThinking[0].AStarGreedy != null)
            {


                if (ElephantOnTable[i].ElefantThinking[0].AStarGreedy.Count > j && ElephantOnTable[i].ElefantThinking[0].AStarGreedy != null)
                {
                    AllDraw This = THIS;
                    bool fou = Found;
                    var ah6 = Task.Factory.StartNew(() => ElephantOnTable[i].ElefantThinking[0].AStarGreedy[j].FoundOfCurrentTableNode(CloneATable(Tab), Order * -1, ref This, ref fou));
                    ah6.Wait();
                    ah6.Dispose();
                    THIS = This;
                    Found = fou;

                }
            }
            //hourse
            var ah2 = Task.Factory.StartNew(() => ac = BondryObjectNumber(i, 3, Order));
            ah2.Wait();
            ah2.Dispose();
            if (ac && HoursesOnTable != null && HoursesOnTable[i] != null && HoursesOnTable[i].HourseThinking[0] != null && HoursesOnTable[i].HourseThinking[0].TableListHourse != null && j < HoursesOnTable[i].HourseThinking[0].TableListHourse.Count && HoursesOnTable[i].HourseThinking[0].AStarGreedy != null)
            {


                if (HoursesOnTable[i].HourseThinking[0].AStarGreedy.Count > j && HoursesOnTable[i].HourseThinking[0].AStarGreedy != null)
                {
                    AllDraw This = THIS;
                    bool fou = Found;
                    var ah6 = Task.Factory.StartNew(() => HoursesOnTable[i].HourseThinking[0].AStarGreedy[j].FoundOfCurrentTableNode(CloneATable(Tab), Order * -1, ref This, ref fou));
                    ah6.Wait();
                    ah6.Dispose();
                    THIS = This;
                    Found = fou;

                }

            }
            //Castle
            var ah3 = Task.Factory.StartNew(() => ac = BondryObjectNumber(i, 4, Order));
            ah3.Wait();
            ah3.Dispose();
            if (ac && CastlesOnTable != null && CastlesOnTable[i] != null && CastlesOnTable[i].CastleThinking[0] != null && CastlesOnTable[i].CastleThinking[0].TableListCastle != null && j < CastlesOnTable[i].CastleThinking[0].TableListCastle.Count && CastlesOnTable[i].CastleThinking[0].AStarGreedy != null)
            {

                if (CastlesOnTable[i].CastleThinking[0].AStarGreedy.Count > j && CastlesOnTable[i].CastleThinking[0].AStarGreedy != null)
                {
                    AllDraw This = THIS;
                    bool fou = Found;
                    var ah6 = Task.Factory.StartNew(() => CastlesOnTable[i].CastleThinking[0].AStarGreedy[j].FoundOfCurrentTableNode(CloneATable(Tab), Order * -1, ref This, ref fou));
                    ah6.Wait();
                    ah6.Dispose();
                    THIS = This;
                    Found = fou;

                }
            }
            //minster
            var ah4 = Task.Factory.StartNew(() => ac = BondryObjectNumber(i, 5, Order));
            ah4.Wait();
            ah4.Dispose();
            if (ac && MinisterOnTable != null && MinisterOnTable[i] != null && MinisterOnTable[i].MinisterThinking[0] != null && j < MinisterOnTable[i].MinisterThinking[0].TableListMinister.Count && MinisterOnTable[i].MinisterThinking[0].AStarGreedy != null)
            {


                if (MinisterOnTable[i].MinisterThinking[0].AStarGreedy.Count > j && MinisterOnTable[i].MinisterThinking[0].AStarGreedy != null)
                {
                    AllDraw This = THIS;
                    bool fou = Found;
                    var ah6 = Task.Factory.StartNew(() => MinisterOnTable[i].MinisterThinking[0].AStarGreedy[j].FoundOfCurrentTableNode(CloneATable(Tab), Order * -1, ref This, ref fou));
                    ah6.Wait();
                    ah6.Dispose();
                    THIS = This;
                    Found = fou;

                }

            }
            //king
            var ah5 = Task.Factory.StartNew(() => ac = BondryObjectNumber(i, 6, Order));
            ah5.Wait();
            ah5.Dispose();
            if (ac && KingOnTable != null && KingOnTable[i] != null && KingOnTable[i].KingThinking[0] != null && KingOnTable[i].KingThinking[0].TableListKing != null && j < KingOnTable[i].KingThinking[0].TableListKing.Count && KingOnTable[i].KingThinking[0].AStarGreedy.Count > j && KingOnTable[i].KingThinking[0].AStarGreedy != null)
            {
                if (KingOnTable[i].KingThinking[0].AStarGreedy.Count > j && KingOnTable[i].KingThinking[0].AStarGreedy != null)
                {
                    AllDraw This = THIS;
                    bool fou = Found;
                    var ah6 = Task.Factory.StartNew(() => KingOnTable[i].KingThinking[0].AStarGreedy[j].FoundOfCurrentTableNode(CloneATable(Tab), Order * -1, ref This, ref fou));
                    ah6.Wait();
                    ah6.Dispose();
                    THIS = This;
                    Found = fou;

                }
            }
            var ah7 = Task.Factory.StartNew(() => ac = BondryObjectNumber(i, 7, Order));
            ah7.Wait();
            ah7.Dispose();
            if (ac && CastlingOnTable != null && CastlingOnTable[i] != null && CastlingOnTable[i].CastlingThinking[0] != null && CastlingOnTable[i].CastlingThinking[0].TableListCastling != null && j < CastlingOnTable[i].CastlingThinking[0].TableListCastling.Count && CastlingOnTable[i].CastlingThinking[0].AStarGreedy.Count > j && CastlingOnTable[i].CastlingThinking[0].AStarGreedy != null)
            {
                if (CastlingOnTable[i].CastlingThinking[0].AStarGreedy.Count > j && CastlingOnTable[i].CastlingThinking[0].AStarGreedy != null)
                {
                    AllDraw This = THIS;
                    bool fou = Found;
                    var ah8 = Task.Factory.StartNew(() => CastlingOnTable[i].CastlingThinking[0].AStarGreedy[j].FoundOfCurrentTableNode(CloneATable(Tab), Order * -1, ref This, ref fou));
                    ah8.Wait();
                    ah8.Dispose();
                    THIS = This;
                    Found = fou;

                }
            }

            return THIS;
        }
        //when current alldraw is equal of table state return node and set true
        public AllDraw FoundOfCurrentTableNode(int[,] Tab, int Order, ref AllDraw THIS, ref bool Found)
        {

            Object a = new Object();
            lock (a)
            {
                //when current stisgied
                bool ac = false;
                AllDraw This = THIS;
                bool fou = Found;
                var ah = Task.Factory.StartNew(() => ac = (TableList.Count > 0 && ThinkingRefrigtzChessPortable.TableEqual(TableList[0], Tab)) || FoundOfCurrentTableNodeFirstLevel(CloneATable(Tab), Order, ref This, ref fou));
                ah.Wait();
                ah.Dispose();
                THIS = This;
                Found = fou;
                if (ac)
                {
                    if (!Found)
                    {
                        THIS = this;
                        Found = true;
                    }

                    return THIS;
                }
                else//else Gray
                if (Order == 1)
                {
                    //soldier
                    for (var i = 0; i < SodierMidle; i++)
                    {
                        for (var j = 0; SolderesOnTable != null && SolderesOnTable[i] != null && SolderesOnTable[i].SoldierThinking[0] != null && SolderesOnTable[i].SoldierThinking[0].TableListSolder != null && j < SolderesOnTable[i].SoldierThinking[0].TableListSolder.Count; j++)
                        {
                            var ah1 = Task.Factory.StartNew(() => ac = IsSupHuTrue(i, j, 0, 1));
                            ah1.Wait();
                            ah1.Dispose();
                            if (ac)
                                continue;
                            var ah2 = Task.Factory.StartNew(() => ac = ThinkingRefrigtzChessPortable.TableEqual(SolderesOnTable[i].SoldierThinking[0].TableListSolder[j], Tab));
                            ah2.Wait();
                            ah2.Dispose();
                            if (ac)
                            {
                                This = THIS;
                                fou = Found;
                                var ah6 = Task.Factory.StartNew(() => FoundOfCurrentTableNodeSolderIJ(i, j, CloneATable(Tab), Order, ref This, ref fou));
                                ah6.Wait();
                                ah6.Dispose();
                                THIS = This;
                                Found = fou;
                                if (Found)
                                    return THIS;
                            }
                            else
                            {

                                //SolderesOnTable[i].SoldierThinking[0].AStarGreedy[k].
                                This = THIS;
                                fou = Found;
                                var ah6 = Task.Factory.StartNew(() => FoundOfCurrentTableNodeAstardGreedy(i, j, CloneATable(Tab), Order, ref This, ref fou));
                                ah6.Wait();
                                ah6.Dispose();
                                THIS = This;
                                Found = fou;
                                if (Found)
                                    return THIS;

                            }
                        }
                    }
                    //elephant
                    for (var i = 0; i < ElefantMidle; i++)
                    {
                        for (var j = 0; ElephantOnTable != null && ElephantOnTable[i] != null && ElephantOnTable[i].ElefantThinking[0] != null && ElephantOnTable[i].ElefantThinking[0].TableListElefant != null && j < ElephantOnTable[i].ElefantThinking[0].TableListElefant.Count; j++)
                        {
                            var ah1 = Task.Factory.StartNew(() => ac = IsSupHuTrue(i, j, 0, 2));
                            ah1.Wait();
                            ah1.Dispose();
                            if (ac)
                                continue;
                            var ah2 = Task.Factory.StartNew(() => ac = ThinkingRefrigtzChessPortable.TableEqual(ElephantOnTable[i].ElefantThinking[0].TableListElefant[j], Tab));
                            ah2.Wait();
                            ah2.Dispose();
                            if (ac)
                            {
                                This = THIS;
                                fou = Found;
                                var ah6 = Task.Factory.StartNew(() => FoundOfCurrentTableNodeElephantIJ(i, j, CloneATable(Tab), Order, ref This, ref fou));
                                ah6.Wait();
                                ah6.Dispose();
                                THIS = This;
                                Found = fou;
                                if (Found)
                                    return THIS;
                            }
                            else
                            {


                                //ElephantOnTable[i].ElefantThinking[0].AStarGreedy[k].
                                This = THIS;
                                fou = Found;
                                var ah6 = Task.Factory.StartNew(() => FoundOfCurrentTableNodeAstardGreedy(i, j, CloneATable(Tab), Order, ref This, ref fou));
                                ah6.Wait();
                                ah6.Dispose();
                                THIS = This;
                                Found = fou;
                                if (Found)
                                    return THIS;
                            }
                        }
                    }
                    //hourse
                    for (var i = 0; i < HourseMidle; i++)
                    {
                        for (var j = 0; HoursesOnTable != null && HoursesOnTable[i] != null && HoursesOnTable[i].HourseThinking[0] != null && HoursesOnTable[i].HourseThinking[0].TableListHourse != null && j < HoursesOnTable[i].HourseThinking[0].TableListHourse.Count; j++)
                        {
                            var ah1 = Task.Factory.StartNew(() => ac = IsSupHuTrue(i, j, 0, 3));
                            ah1.Wait();
                            ah1.Dispose();
                            if (ac)
                                continue;
                            var ah2 = Task.Factory.StartNew(() => ac = ThinkingRefrigtzChessPortable.TableEqual(HoursesOnTable[i].HourseThinking[0].TableListHourse[j], Tab));
                            ah2.Wait();
                            ah2.Dispose();
                            if (ac)
                            {
                                This = THIS;
                                fou = Found;
                                var ah6 = Task.Factory.StartNew(() => FoundOfCurrentTableNodeHourseIJ(i, j, CloneATable(Tab), Order, ref This, ref fou));
                                ah6.Wait();
                                ah6.Dispose();
                                THIS = This;
                                Found = fou;
                                if (Found)
                                    return THIS;
                            }
                            else
                            {

                                //HoursesOnTable[i].HourseThinking[0].AStarGreedy[k].
                                This = THIS;
                                fou = Found;
                                var ah6 = Task.Factory.StartNew(() => FoundOfCurrentTableNodeAstardGreedy(i, j, CloneATable(Tab), Order, ref This, ref fou));
                                ah6.Wait();
                                ah6.Dispose();
                                THIS = This;
                                Found = fou;
                                if (Found)
                                    return THIS;
                            }
                        }
                    }
                    //Castle
                    for (var i = 0; i < CastleMidle; i++)
                    {
                        for (var j = 0; CastlesOnTable != null && CastlesOnTable[i] != null && CastlesOnTable[i].CastleThinking[0] != null && CastlesOnTable[i].CastleThinking[0].TableListCastle != null && j < CastlesOnTable[i].CastleThinking[0].TableListCastle.Count; j++)
                        {
                            var ah1 = Task.Factory.StartNew(() => ac = IsSupHuTrue(i, j, 0, 4));
                            ah1.Wait();
                            ah1.Dispose();
                            if (ac)
                                continue;

                            var ah2 = Task.Factory.StartNew(() => ac = ThinkingRefrigtzChessPortable.TableEqual(CastlesOnTable[i].CastleThinking[0].TableListCastle[j], Tab));
                            ah2.Wait();
                            ah2.Dispose();
                            if (ac)
                            {
                                This = THIS;
                                fou = Found;
                                var ah6 = Task.Factory.StartNew(() => FoundOfCurrentTableNodeCastleIJ(i, j, CloneATable(Tab), Order, ref This, ref fou));
                                ah6.Wait();
                                ah6.Dispose();
                                THIS = This;
                                Found = fou;
                                if (Found)
                                    return THIS;
                            }
                            else
                            {

                                // CastlesOnTable[i].CastleThinking[0].AStarGreedy[k].
                                This = THIS;
                                fou = Found;
                                var ah6 = Task.Factory.StartNew(() => FoundOfCurrentTableNodeAstardGreedy(i, j, CloneATable(Tab), Order, ref This, ref fou));
                                ah6.Wait();
                                ah6.Dispose();
                                THIS = This;
                                Found = fou;
                                if (Found)
                                    return THIS;
                            }
                        }
                    }
                    //minster
                    for (var i = 0; i < MinisterMidle; i++)
                    {
                        for (var j = 0; MinisterOnTable != null && MinisterOnTable[i] != null && MinisterOnTable[i].MinisterThinking[0] != null && MinisterOnTable[i].MinisterThinking[0].TableListMinister != null && j < MinisterOnTable[i].MinisterThinking[0].TableListMinister.Count; j++)
                        {
                            var ah1 = Task.Factory.StartNew(() => ac = IsSupHuTrue(i, j, 0, 5));
                            ah1.Wait();
                            ah1.Dispose();
                            if (ac)
                                continue;
                            var ah2 = Task.Factory.StartNew(() => ac = ThinkingRefrigtzChessPortable.TableEqual(MinisterOnTable[i].MinisterThinking[0].TableListMinister[j], Tab));
                            ah2.Wait();
                            ah2.Dispose();
                            if (ac)
                            {
                                This = THIS;
                                fou = Found;
                                var ah6 = Task.Factory.StartNew(() => FoundOfCurrentTableNodeMinisterIJ(i, j, CloneATable(Tab), Order, ref This, ref fou));
                                ah6.Wait();
                                ah6.Dispose();
                                THIS = This;
                                Found = fou;
                                if (Found)
                                    return THIS;
                            }
                            else
                            {

                                //MinisterOnTable[i].MinisterThinking[0].AStarGreedy[k].
                                This = THIS;
                                fou = Found;
                                var ah6 = Task.Factory.StartNew(() => FoundOfCurrentTableNodeAstardGreedy(i, j, CloneATable(Tab), Order, ref This, ref fou));
                                ah6.Wait();
                                ah6.Dispose();
                                THIS = This;
                                Found = fou;
                                if (Found)
                                    return THIS;
                            }
                        }
                    }
                    //king
                    for (var i = 0; i < KingMidle; i++)
                    {
                        for (var j = 0; KingOnTable != null && KingOnTable[i] != null && KingOnTable[i].KingThinking[0] != null && KingOnTable[i].KingThinking[0].TableListKing != null && j < KingOnTable[i].KingThinking[0].TableListKing.Count; j++)
                        {
                            var ah1 = Task.Factory.StartNew(() => ac = IsSupHuTrue(i, j, 0, 6));
                            ah1.Wait();
                            ah1.Dispose();
                            if (ac)
                                continue;
                            var ah2 = Task.Factory.StartNew(() => ac = ThinkingRefrigtzChessPortable.TableEqual(KingOnTable[i].KingThinking[0].TableListKing[j], Tab));
                            ah2.Wait();
                            ah2.Dispose();
                            if (ac)
                            {
                                This = THIS;
                                fou = Found;
                                var ah6 = Task.Factory.StartNew(() => FoundOfCurrentTableNodeKingIJ(i, j, CloneATable(Tab), Order, ref This, ref fou));
                                ah6.Wait();
                                ah6.Dispose();
                                THIS = This;
                                Found = fou;
                                if (Found)
                                    return THIS;
                            }
                            else
                            {

                                //KingOnTable[i].KingThinking[0].AStarGreedy[k].
                                This = THIS;
                                fou = Found;
                                var ah6 = Task.Factory.StartNew(() => FoundOfCurrentTableNodeAstardGreedy(i, j, CloneATable(Tab), Order, ref This, ref fou));
                                ah6.Wait();
                                ah6.Dispose();
                                THIS = This;
                                Found = fou;
                                if (Found)
                                    return THIS;
                            }
                        }
                    }
                    for (var i = 0; i < 1; i++)
                    {
                        for (var j = 0; CastlingOnTable != null && CastlingOnTable[i] != null && CastlingOnTable[i].CastlingThinking[0] != null && CastlingOnTable[i].CastlingThinking[0].TableListCastling != null && j < CastlingOnTable[i].CastlingThinking[0].TableListCastling.Count; j++)
                        {
                            var ah1 = Task.Factory.StartNew(() => ac = IsSupHuTrue(i, j, 0, 7));
                            ah1.Wait();
                            ah1.Dispose();
                            if (ac)
                                continue;
                            var ah2 = Task.Factory.StartNew(() => ac = ThinkingRefrigtzChessPortable.TableEqual(CastlingOnTable[i].CastlingThinking[0].TableListCastling[j], Tab));
                            ah2.Wait();
                            ah2.Dispose();
                            if (ac)
                            {
                                This = THIS;
                                fou = Found;
                                var ah6 = Task.Factory.StartNew(() => FoundOfCurrentTableNodeCastlingIJ(i, j, CloneATable(Tab), Order, ref This, ref fou));
                                ah6.Wait();
                                ah6.Dispose();
                                THIS = This;
                                Found = fou;
                                if (Found)
                                    return THIS;
                            }
                            else
                            {

                                //CastlingOnTable[i].CastlingThinking[0].AStarGreedy[k].
                                This = THIS;
                                fou = Found;
                                var ah6 = Task.Factory.StartNew(() => FoundOfCurrentTableNodeAstardGreedy(i, j, CloneATable(Tab), Order, ref This, ref fou));
                                ah6.Wait();
                                ah6.Dispose();
                                THIS = This;
                                Found = fou;
                                if (Found)
                                    return THIS;
                            }
                        }
                    }
                }//Brown
                else
                {
                    //soldier
                    for (var i = SodierMidle; i < SodierHigh; i++)
                    {
                        for (var j = 0; SolderesOnTable != null && SolderesOnTable[i] != null && SolderesOnTable[i].SoldierThinking[0] != null && SolderesOnTable[i].SoldierThinking[0].TableListSolder != null && j < SolderesOnTable[i].SoldierThinking[0].TableListSolder.Count; j++)
                        {
                            var ah1 = Task.Factory.StartNew(() => ac = IsSupHuTrue(i, j, 0, 1));
                            ah1.Wait();
                            ah1.Dispose();
                            if (ac)
                                continue;
                            var ah2 = Task.Factory.StartNew(() => ac = ThinkingRefrigtzChessPortable.TableEqual(SolderesOnTable[i].SoldierThinking[0].TableListSolder[j], Tab));
                            ah2.Wait();
                            ah2.Dispose();
                            if (ac)
                            {
                                This = THIS;
                                fou = Found;
                                var ah6 = Task.Factory.StartNew(() => FoundOfCurrentTableNodeSolderIJ(i, j, CloneATable(Tab), Order, ref This, ref fou));
                                ah6.Wait();
                                ah6.Dispose();
                                THIS = This;
                                Found = fou;
                                if (Found)
                                    return THIS;
                            }
                            else
                            {

                                //SolderesOnTable[i].SoldierThinking[0].AStarGreedy[k].
                                This = THIS;
                                fou = Found;
                                var ah6 = Task.Factory.StartNew(() => FoundOfCurrentTableNodeAstardGreedy(i, j, CloneATable(Tab), Order, ref This, ref fou));
                                ah6.Wait();
                                ah6.Dispose();
                                THIS = This;
                                Found = fou;
                                if (Found)
                                    return THIS;

                            }
                        }
                    }
                    //elephant
                    for (var i = ElefantMidle; i < ElefantHigh; i++)
                    {
                        for (var j = 0; ElephantOnTable != null && ElephantOnTable[i] != null && ElephantOnTable[i].ElefantThinking[0] != null && ElephantOnTable[i].ElefantThinking[0].TableListElefant != null && j < ElephantOnTable[i].ElefantThinking[0].TableListElefant.Count; j++)
                        {
                            var ah1 = Task.Factory.StartNew(() => ac = IsSupHuTrue(i, j, 0, 2));
                            ah1.Wait();
                            ah1.Dispose();
                            if (ac)
                                continue;
                            var ah2 = Task.Factory.StartNew(() => ac = ThinkingRefrigtzChessPortable.TableEqual(ElephantOnTable[i].ElefantThinking[0].TableListElefant[j], Tab));
                            ah2.Wait();
                            ah2.Dispose();
                            if (ac)
                            {
                                This = THIS;
                                fou = Found;
                                var ah6 = Task.Factory.StartNew(() => FoundOfCurrentTableNodeElephantIJ(i, j, CloneATable(Tab), Order, ref This, ref fou));
                                ah6.Wait();
                                ah6.Dispose();
                                THIS = This;
                                Found = fou;
                                if (Found)
                                    return THIS;
                            }
                            else
                            {


                                //ElephantOnTable[i].ElefantThinking[0].AStarGreedy[k].
                                This = THIS;
                                fou = Found;
                                var ah6 = Task.Factory.StartNew(() => FoundOfCurrentTableNodeAstardGreedy(i, j, CloneATable(Tab), Order, ref This, ref fou));
                                ah6.Wait();
                                ah6.Dispose();
                                THIS = This;
                                Found = fou;
                                if (Found)
                                    return THIS;
                            }
                        }
                    }
                    //hourse
                    for (var i = HourseMidle; i < HourseHight; i++)
                    {
                        for (var j = 0; HoursesOnTable != null && HoursesOnTable[i] != null && HoursesOnTable[i].HourseThinking[0] != null && HoursesOnTable[i].HourseThinking[0].TableListHourse != null && j < HoursesOnTable[i].HourseThinking[0].TableListHourse.Count; j++)
                        {
                            var ah1 = Task.Factory.StartNew(() => ac = IsSupHuTrue(i, j, 0, 3));
                            ah1.Wait();
                            ah1.Dispose();
                            if (ac)
                                continue;
                            var ah2 = Task.Factory.StartNew(() => ac = ThinkingRefrigtzChessPortable.TableEqual(HoursesOnTable[i].HourseThinking[0].TableListHourse[j], Tab));
                            ah2.Wait();
                            ah2.Dispose();
                            if (ac)
                            {
                                This = THIS;
                                fou = Found;
                                var ah6 = Task.Factory.StartNew(() => FoundOfCurrentTableNodeHourseIJ(i, j, CloneATable(Tab), Order, ref This, ref fou));
                                ah6.Wait();
                                ah6.Dispose();
                                THIS = This;
                                Found = fou;
                                if (Found)
                                    return THIS;
                            }
                            else
                            {

                                //HoursesOnTable[i].HourseThinking[0].AStarGreedy[k].
                                This = THIS;
                                fou = Found;
                                var ah6 = Task.Factory.StartNew(() => FoundOfCurrentTableNodeAstardGreedy(i, j, CloneATable(Tab), Order, ref This, ref fou));
                                ah6.Wait();
                                ah6.Dispose();
                                THIS = This;
                                Found = fou;
                                if (Found)
                                    return THIS;
                            }
                        }
                    }
                    //Castle
                    for (var i = CastleMidle; i < CastleHigh; i++)
                    {
                        for (var j = 0; CastlesOnTable != null && CastlesOnTable[i] != null && CastlesOnTable[i].CastleThinking[0] != null && CastlesOnTable[i].CastleThinking[0].TableListCastle != null && j < CastlesOnTable[i].CastleThinking[0].TableListCastle.Count; j++)
                        {
                            var ah1 = Task.Factory.StartNew(() => ac = IsSupHuTrue(i, j, 0, 4));
                            ah1.Wait();
                            ah1.Dispose();
                            if (ac)
                                continue;

                            var ah2 = Task.Factory.StartNew(() => ac = ThinkingRefrigtzChessPortable.TableEqual(CastlesOnTable[i].CastleThinking[0].TableListCastle[j], Tab));
                            ah2.Wait();
                            ah2.Dispose();
                            if (ac)
                            {
                                This = THIS;
                                fou = Found;
                                var ah6 = Task.Factory.StartNew(() => FoundOfCurrentTableNodeCastleIJ(i, j, CloneATable(Tab), Order, ref This, ref fou));
                                ah6.Wait();
                                ah6.Dispose();
                                THIS = This;
                                Found = fou;
                                if (Found)
                                    return THIS;
                            }
                            else
                            {

                                // CastlesOnTable[i].CastleThinking[0].AStarGreedy[k].
                                This = THIS;
                                fou = Found;
                                var ah6 = Task.Factory.StartNew(() => FoundOfCurrentTableNodeAstardGreedy(i, j, CloneATable(Tab), Order, ref This, ref fou));
                                ah6.Wait();
                                ah6.Dispose();
                                THIS = This;
                                Found = fou;
                                if (Found)
                                    return THIS;
                            }
                        }
                    }
                    //minster
                    for (var i = MinisterMidle; i < MinisterHigh; i++)
                    {
                        for (var j = 0; MinisterOnTable != null && MinisterOnTable[i] != null && MinisterOnTable[i].MinisterThinking[0] != null && MinisterOnTable[i].MinisterThinking[0].TableListMinister != null && j < MinisterOnTable[i].MinisterThinking[0].TableListMinister.Count; j++)
                        {
                            var ah1 = Task.Factory.StartNew(() => ac = IsSupHuTrue(i, j, 0, 5));
                            ah1.Wait();
                            ah1.Dispose();
                            if (ac)
                                continue;
                            var ah2 = Task.Factory.StartNew(() => ac = ThinkingRefrigtzChessPortable.TableEqual(MinisterOnTable[i].MinisterThinking[0].TableListMinister[j], Tab));
                            ah2.Wait();
                            ah2.Dispose();
                            if (ac)
                            {
                                This = THIS;
                                fou = Found;
                                var ah6 = Task.Factory.StartNew(() => FoundOfCurrentTableNodeMinisterIJ(i, j, CloneATable(Tab), Order, ref This, ref fou));
                                ah6.Wait();
                                ah6.Dispose();
                                THIS = This;
                                Found = fou;
                                if (Found)
                                    return THIS;
                            }
                            else
                            {

                                //MinisterOnTable[i].MinisterThinking[0].AStarGreedy[k].
                                This = THIS;
                                fou = Found;
                                var ah6 = Task.Factory.StartNew(() => FoundOfCurrentTableNodeAstardGreedy(i, j, CloneATable(Tab), Order, ref This, ref fou));
                                ah6.Wait();
                                ah6.Dispose();
                                THIS = This;
                                Found = fou;
                                if (Found)
                                    return THIS;
                            }
                        }
                    }
                    //king
                    for (var i = KingMidle; i < KingHigh; i++)
                    {
                        for (var j = 0; KingOnTable != null && KingOnTable[i] != null && KingOnTable[i].KingThinking[0] != null && KingOnTable[i].KingThinking[0].TableListKing != null && j < KingOnTable[i].KingThinking[0].TableListKing.Count; j++)
                        {
                            var ah1 = Task.Factory.StartNew(() => ac = IsSupHuTrue(i, j, 0, 6));
                            ah1.Wait();
                            ah1.Dispose();
                            if (ac)
                                continue;
                            var ah2 = Task.Factory.StartNew(() => ac = ThinkingRefrigtzChessPortable.TableEqual(KingOnTable[i].KingThinking[0].TableListKing[j], Tab));
                            ah2.Wait();
                            ah2.Dispose();
                            if (ac)
                            {
                                This = THIS;
                                fou = Found;
                                var ah6 = Task.Factory.StartNew(() => FoundOfCurrentTableNodeKingIJ(i, j, CloneATable(Tab), Order, ref This, ref fou));
                                ah6.Wait();
                                ah6.Dispose();
                                THIS = This;
                                Found = fou;
                                if (Found)
                                    return THIS;
                            }
                            else
                            {

                                //KingOnTable[i].KingThinking[0].AStarGreedy[k].
                                This = THIS;
                                fou = Found;
                                var ah6 = Task.Factory.StartNew(() => FoundOfCurrentTableNodeAstardGreedy(i, j, CloneATable(Tab), Order, ref This, ref fou));
                                ah6.Wait();
                                ah6.Dispose();
                                THIS = This;
                                Found = fou;
                                if (Found)
                                    return THIS;
                            }
                        }
                    }
                    for (var i = 0; i < 1; i++)
                    {
                        for (var j = 0; CastlingOnTable != null && CastlingOnTable[i] != null && CastlingOnTable[i].CastlingThinking[0] != null && CastlingOnTable[i].CastlingThinking[0].TableListCastling != null && j < CastlingOnTable[i].CastlingThinking[0].TableListCastling.Count; j++)
                        {
                            var ah1 = Task.Factory.StartNew(() => ac = IsSupHuTrue(i, j, 0, -7));
                            ah1.Wait();
                            ah1.Dispose();
                            if (ac)
                                continue;
                            var ah2 = Task.Factory.StartNew(() => ac = ThinkingRefrigtzChessPortable.TableEqual(CastlingOnTable[i].CastlingThinking[0].TableListCastling[j], Tab));
                            ah2.Wait();
                            ah2.Dispose();
                            if (ac)
                            {
                                This = THIS;
                                fou = Found;
                                var ah6 = Task.Factory.StartNew(() => FoundOfCurrentTableNodeCastlingIJ(i, j, CloneATable(Tab), Order, ref This, ref fou));
                                ah6.Wait();
                                ah6.Dispose();
                                THIS = This;
                                Found = fou;
                                if (Found)
                                    return THIS;
                            }
                            else
                            {

                                //CastlingOnTable[i].CastlingThinking[0].AStarGreedy[k].
                                This = THIS;
                                fou = Found;
                                var ah6 = Task.Factory.StartNew(() => FoundOfCurrentTableNodeAstardGreedy(i, j, CloneATable(Tab), Order, ref This, ref fou));
                                ah6.Wait();
                                ah6.Dispose();
                                THIS = This;
                                Found = fou;
                                if (Found)
                                    return THIS;
                            }
                        }
                    }

                }
                return THIS;
            }
        }
        public AllDraw FoundOfCurrentTableNodeCreateAStarGreedy(int[,] Tab, int Order, ref AllDraw THIS, ref bool Found)
        {

            Object a = new Object();
            lock (a)
            {

                bool ac = false;
                AllDraw This = THIS;
                bool fou = Found;
                //else Gray
                if (Order == 1)
                {
                    //soldier
                    for (var i = 0; i < SodierMidle; i++)
                    {
                        for (var j = 0; SolderesOnTable != null && SolderesOnTable[i] != null && SolderesOnTable[i].SoldierThinking[0] != null && SolderesOnTable[i].SoldierThinking[0].TableListSolder != null && j < SolderesOnTable[i].SoldierThinking[0].TableListSolder.Count; j++)
                        {
                            var ah1 = Task.Factory.StartNew(() => ac = IsSupHuTrue(i, j, 0, 1));
                            ah1.Wait();
                            ah1.Dispose();
                            if (ac)
                                continue;
                            var ah2 = Task.Factory.StartNew(() => ac = ThinkingRefrigtzChessPortable.TableEqual(SolderesOnTable[i].SoldierThinking[0].TableListSolder[j], Tab));
                            ah2.Wait();
                            ah2.Dispose();
                            if (ac)
                            {
                                This = THIS;
                                fou = Found;
                                var ah6 = Task.Factory.StartNew(() => FoundOfCurrentTableNodeSolderIJ(i, j, CloneATable(Tab), Order, ref This, ref fou));
                                ah6.Wait();
                                ah6.Dispose();
                                THIS = This;
                                Found = fou;
                                if (Found)
                                    return THIS;
                            }
                            else
                            {

                                //SolderesOnTable[i].SoldierThinking[0].AStarGreedy[k].
                                This = THIS;
                                fou = Found;
                                var ah6 = Task.Factory.StartNew(() => FoundOfCurrentTableNodeAstardGreedy(i, j, CloneATable(Tab), Order, ref This, ref fou));
                                ah6.Wait();
                                ah6.Dispose();
                                THIS = This;
                                Found = fou;
                                if (Found)
                                    return THIS;

                            }
                        }
                    }
                    //elephant
                    for (var i = 0; i < ElefantMidle; i++)
                    {
                        for (var j = 0; ElephantOnTable != null && ElephantOnTable[i] != null && ElephantOnTable[i].ElefantThinking[0] != null && ElephantOnTable[i].ElefantThinking[0].TableListElefant != null && j < ElephantOnTable[i].ElefantThinking[0].TableListElefant.Count; j++)
                        {
                            var ah1 = Task.Factory.StartNew(() => ac = IsSupHuTrue(i, j, 0, 2));
                            ah1.Wait();
                            ah1.Dispose();
                            if (ac)
                                continue;
                            var ah2 = Task.Factory.StartNew(() => ac = ThinkingRefrigtzChessPortable.TableEqual(ElephantOnTable[i].ElefantThinking[0].TableListElefant[j], Tab));
                            ah2.Wait();
                            ah2.Dispose();
                            if (ac)
                            {
                                This = THIS;
                                fou = Found;
                                var ah6 = Task.Factory.StartNew(() => FoundOfCurrentTableNodeElephantIJ(i, j, CloneATable(Tab), Order, ref This, ref fou));
                                ah6.Wait();
                                ah6.Dispose();
                                THIS = This;
                                Found = fou;
                                if (Found)
                                    return THIS;
                            }
                            else
                            {


                                //ElephantOnTable[i].ElefantThinking[0].AStarGreedy[k].
                                This = THIS;
                                fou = Found;
                                var ah6 = Task.Factory.StartNew(() => FoundOfCurrentTableNodeAstardGreedy(i, j, CloneATable(Tab), Order, ref This, ref fou));
                                ah6.Wait();
                                ah6.Dispose();
                                THIS = This;
                                Found = fou;
                                if (Found)
                                    return THIS;
                            }
                        }
                    }
                    //hourse
                    for (var i = 0; i < HourseMidle; i++)
                    {
                        for (var j = 0; HoursesOnTable != null && HoursesOnTable[i] != null && HoursesOnTable[i].HourseThinking[0] != null && HoursesOnTable[i].HourseThinking[0].TableListHourse != null && j < HoursesOnTable[i].HourseThinking[0].TableListHourse.Count; j++)
                        {
                            var ah1 = Task.Factory.StartNew(() => ac = IsSupHuTrue(i, j, 0, 3));
                            ah1.Wait();
                            ah1.Dispose();
                            if (ac)
                                continue;
                            var ah2 = Task.Factory.StartNew(() => ac = ThinkingRefrigtzChessPortable.TableEqual(HoursesOnTable[i].HourseThinking[0].TableListHourse[j], Tab));
                            ah2.Wait();
                            ah2.Dispose();
                            if (ac)
                            {
                                This = THIS;
                                fou = Found;
                                var ah6 = Task.Factory.StartNew(() => FoundOfCurrentTableNodeHourseIJ(i, j, CloneATable(Tab), Order, ref This, ref fou));
                                ah6.Wait();
                                ah6.Dispose();
                                THIS = This;
                                Found = fou;
                                if (Found)
                                    return THIS;
                            }
                            else
                            {

                                //HoursesOnTable[i].HourseThinking[0].AStarGreedy[k].
                                This = THIS;
                                fou = Found;
                                var ah6 = Task.Factory.StartNew(() => FoundOfCurrentTableNodeAstardGreedy(i, j, CloneATable(Tab), Order, ref This, ref fou));
                                ah6.Wait();
                                ah6.Dispose();
                                THIS = This;
                                Found = fou;
                                if (Found)
                                    return THIS;
                            }
                        }
                    }
                    //Castle
                    for (var i = 0; i < CastleMidle; i++)
                    {
                        for (var j = 0; CastlesOnTable != null && CastlesOnTable[i] != null && CastlesOnTable[i].CastleThinking[0] != null && CastlesOnTable[i].CastleThinking[0].TableListCastle != null && j < CastlesOnTable[i].CastleThinking[0].TableListCastle.Count; j++)
                        {
                            var ah1 = Task.Factory.StartNew(() => ac = IsSupHuTrue(i, j, 0, 4));
                            ah1.Wait();
                            ah1.Dispose();
                            if (ac)
                                continue;

                            var ah2 = Task.Factory.StartNew(() => ac = ThinkingRefrigtzChessPortable.TableEqual(CastlesOnTable[i].CastleThinking[0].TableListCastle[j], Tab));
                            ah2.Wait();
                            ah2.Dispose();
                            if (ac)
                            {
                                This = THIS;
                                fou = Found;
                                var ah6 = Task.Factory.StartNew(() => FoundOfCurrentTableNodeCastleIJ(i, j, CloneATable(Tab), Order, ref This, ref fou));
                                ah6.Wait();
                                ah6.Dispose();
                                THIS = This;
                                Found = fou;
                                if (Found)
                                    return THIS;
                            }
                            else
                            {

                                // CastlesOnTable[i].CastleThinking[0].AStarGreedy[k].
                                This = THIS;
                                fou = Found;
                                var ah6 = Task.Factory.StartNew(() => FoundOfCurrentTableNodeAstardGreedy(i, j, CloneATable(Tab), Order, ref This, ref fou));
                                ah6.Wait();
                                ah6.Dispose();
                                THIS = This;
                                Found = fou;
                                if (Found)
                                    return THIS;
                            }
                        }
                    }
                    //minster
                    for (var i = 0; i < MinisterMidle; i++)
                    {
                        for (var j = 0; MinisterOnTable != null && MinisterOnTable[i] != null && MinisterOnTable[i].MinisterThinking[0] != null && MinisterOnTable[i].MinisterThinking[0].TableListMinister != null && j < MinisterOnTable[i].MinisterThinking[0].TableListMinister.Count; j++)
                        {
                            var ah1 = Task.Factory.StartNew(() => ac = IsSupHuTrue(i, j, 0, 5));
                            ah1.Wait();
                            ah1.Dispose();
                            if (ac)
                                continue;
                            var ah2 = Task.Factory.StartNew(() => ac = ThinkingRefrigtzChessPortable.TableEqual(MinisterOnTable[i].MinisterThinking[0].TableListMinister[j], Tab));
                            ah2.Wait();
                            ah2.Dispose();
                            if (ac)
                            {
                                This = THIS;
                                fou = Found;
                                var ah6 = Task.Factory.StartNew(() => FoundOfCurrentTableNodeMinisterIJ(i, j, CloneATable(Tab), Order, ref This, ref fou));
                                ah6.Wait();
                                ah6.Dispose();
                                THIS = This;
                                Found = fou;
                                if (Found)
                                    return THIS;
                            }
                            else
                            {

                                //MinisterOnTable[i].MinisterThinking[0].AStarGreedy[k].
                                This = THIS;
                                fou = Found;
                                var ah6 = Task.Factory.StartNew(() => FoundOfCurrentTableNodeAstardGreedy(i, j, CloneATable(Tab), Order, ref This, ref fou));
                                ah6.Wait();
                                ah6.Dispose();
                                THIS = This;
                                Found = fou;
                                if (Found)
                                    return THIS;
                            }
                        }
                    }
                    //king
                    for (var i = 0; i < KingMidle; i++)
                    {
                        for (var j = 0; KingOnTable != null && KingOnTable[i] != null && KingOnTable[i].KingThinking[0] != null && KingOnTable[i].KingThinking[0].TableListKing != null && j < KingOnTable[i].KingThinking[0].TableListKing.Count; j++)
                        {
                            var ah1 = Task.Factory.StartNew(() => ac = IsSupHuTrue(i, j, 0, 6));
                            ah1.Wait();
                            ah1.Dispose();
                            if (ac)
                                continue;
                            var ah2 = Task.Factory.StartNew(() => ac = ThinkingRefrigtzChessPortable.TableEqual(KingOnTable[i].KingThinking[0].TableListKing[j], Tab));
                            ah2.Wait();
                            ah2.Dispose();
                            if (ac)
                            {
                                This = THIS;
                                fou = Found;
                                var ah6 = Task.Factory.StartNew(() => FoundOfCurrentTableNodeKingIJ(i, j, CloneATable(Tab), Order, ref This, ref fou));
                                ah6.Wait();
                                ah6.Dispose();
                                THIS = This;
                                Found = fou;
                                if (Found)
                                    return THIS;
                            }
                            else
                            {

                                //KingOnTable[i].KingThinking[0].AStarGreedy[k].
                                This = THIS;
                                fou = Found;
                                var ah6 = Task.Factory.StartNew(() => FoundOfCurrentTableNodeAstardGreedy(i, j, CloneATable(Tab), Order, ref This, ref fou));
                                ah6.Wait();
                                ah6.Dispose();
                                THIS = This;
                                Found = fou;
                                if (Found)
                                    return THIS;
                            }
                        }
                    }
                    for (var i = 0; i < 1; i++)
                    {
                        for (var j = 0; CastlingOnTable != null && CastlingOnTable[i] != null && CastlingOnTable[i].CastlingThinking[0] != null && CastlingOnTable[i].CastlingThinking[0].TableListCastling != null && j < CastlingOnTable[i].CastlingThinking[0].TableListCastling.Count; j++)
                        {
                            var ah1 = Task.Factory.StartNew(() => ac = IsSupHuTrue(i, j, 0, 7));
                            ah1.Wait();
                            ah1.Dispose();
                            if (ac)
                                continue;
                            var ah2 = Task.Factory.StartNew(() => ac = ThinkingRefrigtzChessPortable.TableEqual(CastlingOnTable[i].CastlingThinking[0].TableListCastling[j], Tab));
                            ah2.Wait();
                            ah2.Dispose();
                            if (ac)
                            {
                                This = THIS;
                                fou = Found;
                                var ah6 = Task.Factory.StartNew(() => FoundOfCurrentTableNodeCastlingIJ(i, j, CloneATable(Tab), Order, ref This, ref fou));
                                ah6.Wait();
                                ah6.Dispose();
                                THIS = This;
                                Found = fou;
                                if (Found)
                                    return THIS;
                            }
                            else
                            {

                                //CastlingOnTable[i].CastlingThinking[0].AStarGreedy[k].
                                This = THIS;
                                fou = Found;
                                var ah6 = Task.Factory.StartNew(() => FoundOfCurrentTableNodeAstardGreedy(i, j, CloneATable(Tab), Order, ref This, ref fou));
                                ah6.Wait();
                                ah6.Dispose();
                                THIS = This;
                                Found = fou;
                                if (Found)
                                    return THIS;
                            }
                        }
                    }
                }//Brown
                else
                {
                    //soldier
                    for (var i = SodierMidle; i < SodierHigh; i++)
                    {
                        for (var j = 0; SolderesOnTable != null && SolderesOnTable[i] != null && SolderesOnTable[i].SoldierThinking[0] != null && SolderesOnTable[i].SoldierThinking[0].TableListSolder != null && j < SolderesOnTable[i].SoldierThinking[0].TableListSolder.Count; j++)
                        {
                            var ah1 = Task.Factory.StartNew(() => ac = IsSupHuTrue(i, j, 0, 1));
                            ah1.Wait();
                            ah1.Dispose();
                            if (ac)
                                continue;
                            var ah2 = Task.Factory.StartNew(() => ac = ThinkingRefrigtzChessPortable.TableEqual(SolderesOnTable[i].SoldierThinking[0].TableListSolder[j], Tab));
                            ah2.Wait();
                            ah2.Dispose();
                            if (ac)
                            {
                                This = THIS;
                                fou = Found;
                                var ah6 = Task.Factory.StartNew(() => FoundOfCurrentTableNodeSolderIJ(i, j, CloneATable(Tab), Order, ref This, ref fou));
                                ah6.Wait();
                                ah6.Dispose();
                                THIS = This;
                                Found = fou;
                                if (Found)
                                    return THIS;
                            }
                            else
                            {

                                //SolderesOnTable[i].SoldierThinking[0].AStarGreedy[k].
                                This = THIS;
                                fou = Found;
                                var ah6 = Task.Factory.StartNew(() => FoundOfCurrentTableNodeAstardGreedy(i, j, CloneATable(Tab), Order, ref This, ref fou));
                                ah6.Wait();
                                ah6.Dispose();
                                THIS = This;
                                Found = fou;
                                if (Found)
                                    return THIS;

                            }
                        }
                    }
                    //elephant
                    for (var i = ElefantMidle; i < ElefantHigh; i++)
                    {
                        for (var j = 0; ElephantOnTable != null && ElephantOnTable[i] != null && ElephantOnTable[i].ElefantThinking[0] != null && ElephantOnTable[i].ElefantThinking[0].TableListElefant != null && j < ElephantOnTable[i].ElefantThinking[0].TableListElefant.Count; j++)
                        {
                            var ah1 = Task.Factory.StartNew(() => ac = IsSupHuTrue(i, j, 0, 2));
                            ah1.Wait();
                            ah1.Dispose();
                            if (ac)
                                continue;
                            var ah2 = Task.Factory.StartNew(() => ac = ThinkingRefrigtzChessPortable.TableEqual(ElephantOnTable[i].ElefantThinking[0].TableListElefant[j], Tab));
                            ah2.Wait();
                            ah2.Dispose();
                            if (ac)
                            {
                                This = THIS;
                                fou = Found;
                                var ah6 = Task.Factory.StartNew(() => FoundOfCurrentTableNodeElephantIJ(i, j, CloneATable(Tab), Order, ref This, ref fou));
                                ah6.Wait();
                                ah6.Dispose();
                                THIS = This;
                                Found = fou;
                                if (Found)
                                    return THIS;
                            }
                            else
                            {


                                //ElephantOnTable[i].ElefantThinking[0].AStarGreedy[k].
                                This = THIS;
                                fou = Found;
                                var ah6 = Task.Factory.StartNew(() => FoundOfCurrentTableNodeAstardGreedy(i, j, CloneATable(Tab), Order, ref This, ref fou));
                                ah6.Wait();
                                ah6.Dispose();
                                THIS = This;
                                Found = fou;
                                if (Found)
                                    return THIS;
                            }
                        }
                    }
                    //hourse
                    for (var i = HourseMidle; i < HourseHight; i++)
                    {
                        for (var j = 0; HoursesOnTable != null && HoursesOnTable[i] != null && HoursesOnTable[i].HourseThinking[0] != null && HoursesOnTable[i].HourseThinking[0].TableListHourse != null && j < HoursesOnTable[i].HourseThinking[0].TableListHourse.Count; j++)
                        {
                            var ah1 = Task.Factory.StartNew(() => ac = IsSupHuTrue(i, j, 0, 3));
                            ah1.Wait();
                            ah1.Dispose();
                            if (ac)
                                continue;
                            var ah2 = Task.Factory.StartNew(() => ac = ThinkingRefrigtzChessPortable.TableEqual(HoursesOnTable[i].HourseThinking[0].TableListHourse[j], Tab));
                            ah2.Wait();
                            ah2.Dispose();
                            if (ac)
                            {
                                This = THIS;
                                fou = Found;
                                var ah6 = Task.Factory.StartNew(() => FoundOfCurrentTableNodeHourseIJ(i, j, CloneATable(Tab), Order, ref This, ref fou));
                                ah6.Wait();
                                ah6.Dispose();
                                THIS = This;
                                Found = fou;
                                if (Found)
                                    return THIS;
                            }
                            else
                            {

                                //HoursesOnTable[i].HourseThinking[0].AStarGreedy[k].
                                This = THIS;
                                fou = Found;
                                var ah6 = Task.Factory.StartNew(() => FoundOfCurrentTableNodeAstardGreedy(i, j, CloneATable(Tab), Order, ref This, ref fou));
                                ah6.Wait();
                                ah6.Dispose();
                                THIS = This;
                                Found = fou;
                                if (Found)
                                    return THIS;
                            }
                        }
                    }
                    //Castle
                    for (var i = CastleMidle; i < CastleHigh; i++)
                    {
                        for (var j = 0; CastlesOnTable != null && CastlesOnTable[i] != null && CastlesOnTable[i].CastleThinking[0] != null && CastlesOnTable[i].CastleThinking[0].TableListCastle != null && j < CastlesOnTable[i].CastleThinking[0].TableListCastle.Count; j++)
                        {
                            var ah1 = Task.Factory.StartNew(() => ac = IsSupHuTrue(i, j, 0, 4));
                            ah1.Wait();
                            ah1.Dispose();
                            if (ac)
                                continue;

                            var ah2 = Task.Factory.StartNew(() => ac = ThinkingRefrigtzChessPortable.TableEqual(CastlesOnTable[i].CastleThinking[0].TableListCastle[j], Tab));
                            ah2.Wait();
                            ah2.Dispose();
                            if (ac)
                            {
                                This = THIS;
                                fou = Found;
                                var ah6 = Task.Factory.StartNew(() => FoundOfCurrentTableNodeCastleIJ(i, j, CloneATable(Tab), Order, ref This, ref fou));
                                ah6.Wait();
                                ah6.Dispose();
                                THIS = This;
                                Found = fou;
                                if (Found)
                                    return THIS;
                            }
                            else
                            {

                                // CastlesOnTable[i].CastleThinking[0].AStarGreedy[k].
                                This = THIS;
                                fou = Found;
                                var ah6 = Task.Factory.StartNew(() => FoundOfCurrentTableNodeAstardGreedy(i, j, CloneATable(Tab), Order, ref This, ref fou));
                                ah6.Wait();
                                ah6.Dispose();
                                THIS = This;
                                Found = fou;
                                if (Found)
                                    return THIS;
                            }
                        }
                    }
                    //minster
                    for (var i = MinisterMidle; i < MinisterHigh; i++)
                    {
                        for (var j = 0; MinisterOnTable != null && MinisterOnTable[i] != null && MinisterOnTable[i].MinisterThinking[0] != null && MinisterOnTable[i].MinisterThinking[0].TableListMinister != null && j < MinisterOnTable[i].MinisterThinking[0].TableListMinister.Count; j++)
                        {
                            var ah1 = Task.Factory.StartNew(() => ac = IsSupHuTrue(i, j, 0, 5));
                            ah1.Wait();
                            ah1.Dispose();
                            if (ac)
                                continue;
                            var ah2 = Task.Factory.StartNew(() => ac = ThinkingRefrigtzChessPortable.TableEqual(MinisterOnTable[i].MinisterThinking[0].TableListMinister[j], Tab));
                            ah2.Wait();
                            ah2.Dispose();
                            if (ac)
                            {
                                This = THIS;
                                fou = Found;
                                var ah6 = Task.Factory.StartNew(() => FoundOfCurrentTableNodeMinisterIJ(i, j, CloneATable(Tab), Order, ref This, ref fou));
                                ah6.Wait();
                                ah6.Dispose();
                                THIS = This;
                                Found = fou;
                                if (Found)
                                    return THIS;
                            }
                            else
                            {

                                //MinisterOnTable[i].MinisterThinking[0].AStarGreedy[k].
                                This = THIS;
                                fou = Found;
                                var ah6 = Task.Factory.StartNew(() => FoundOfCurrentTableNodeAstardGreedy(i, j, CloneATable(Tab), Order, ref This, ref fou));
                                ah6.Wait();
                                ah6.Dispose();
                                THIS = This;
                                Found = fou;
                                if (Found)
                                    return THIS;
                            }
                        }
                    }
                    //king
                    for (var i = KingMidle; i < KingHigh; i++)
                    {
                        for (var j = 0; KingOnTable != null && KingOnTable[i] != null && KingOnTable[i].KingThinking[0] != null && KingOnTable[i].KingThinking[0].TableListKing != null && j < KingOnTable[i].KingThinking[0].TableListKing.Count; j++)
                        {
                            var ah1 = Task.Factory.StartNew(() => ac = IsSupHuTrue(i, j, 0, 6));
                            ah1.Wait();
                            ah1.Dispose();
                            if (ac)
                                continue;
                            var ah2 = Task.Factory.StartNew(() => ac = ThinkingRefrigtzChessPortable.TableEqual(KingOnTable[i].KingThinking[0].TableListKing[j], Tab));
                            ah2.Wait();
                            ah2.Dispose();
                            if (ac)
                            {
                                This = THIS;
                                fou = Found;
                                var ah6 = Task.Factory.StartNew(() => FoundOfCurrentTableNodeKingIJ(i, j, CloneATable(Tab), Order, ref This, ref fou));
                                ah6.Wait();
                                ah6.Dispose();
                                THIS = This;
                                Found = fou;
                                if (Found)
                                    return THIS;
                            }
                            else
                            {

                                //KingOnTable[i].KingThinking[0].AStarGreedy[k].
                                This = THIS;
                                fou = Found;
                                var ah6 = Task.Factory.StartNew(() => FoundOfCurrentTableNodeAstardGreedy(i, j, CloneATable(Tab), Order, ref This, ref fou));
                                ah6.Wait();
                                ah6.Dispose();
                                THIS = This;
                                Found = fou;
                                if (Found)
                                    return THIS;
                            }
                        }
                    }
                    for (var i = 0; i < 1; i++)
                    {
                        for (var j = 0; CastlingOnTable != null && CastlingOnTable[i] != null && CastlingOnTable[i].CastlingThinking[0] != null && CastlingOnTable[i].CastlingThinking[0].TableListCastling != null && j < CastlingOnTable[i].CastlingThinking[0].TableListCastling.Count; j++)
                        {
                            var ah1 = Task.Factory.StartNew(() => ac = IsSupHuTrue(i, j, 0, -7));
                            ah1.Wait();
                            ah1.Dispose();
                            if (ac)
                                continue;
                            var ah2 = Task.Factory.StartNew(() => ac = ThinkingRefrigtzChessPortable.TableEqual(CastlingOnTable[i].CastlingThinking[0].TableListCastling[j], Tab));
                            ah2.Wait();
                            ah2.Dispose();
                            if (ac)
                            {
                                This = THIS;
                                fou = Found;
                                var ah6 = Task.Factory.StartNew(() => FoundOfCurrentTableNodeCastlingIJ(i, j, CloneATable(Tab), Order, ref This, ref fou));
                                ah6.Wait();
                                ah6.Dispose();
                                THIS = This;
                                Found = fou;
                                if (Found)
                                    return THIS;
                            }
                            else
                            {

                                //CastlingOnTable[i].CastlingThinking[0].AStarGreedy[k].
                                This = THIS;
                                fou = Found;
                                var ah6 = Task.Factory.StartNew(() => FoundOfCurrentTableNodeAstardGreedy(i, j, CloneATable(Tab), Order, ref This, ref fou));
                                ah6.Wait();
                                ah6.Dispose();
                                THIS = This;
                                Found = fou;
                                if (Found)
                                    return THIS;
                            }
                        }
                    }
                }
                return THIS;
            }
        }
        //when current level founf of node
        public bool FoundOfCurrentTableNodeFirstLevel(int[,] Tab, int Order, ref AllDraw THIS, ref bool Found)
        {
            if (!Found)
            {
                AllDraw This = THIS;
                bool fou = Found;
                var ah = Task.Factory.StartNew(() => FoundOfCurrentTableNodeSoldeir(CloneATable(Tab), Order, ref This, ref fou));
                ah.Wait();
                ah.Dispose();
            }
            if (!Found)
            {
                AllDraw This = THIS;
                bool fou = Found;
                var ah = Task.Factory.StartNew(() => FoundOfCurrentTableNodeElephant(CloneATable(Tab), Order, ref This, ref fou));
                ah.Wait();
                ah.Dispose();
            }
            if (!Found)
            {
                AllDraw This = THIS;
                bool fou = Found;
                var ah = Task.Factory.StartNew(() => FoundOfCurrentTableNodeHourse(CloneATable(Tab), Order, ref This, ref fou));
                ah.Wait();
                ah.Dispose();
            }
            if (!Found)
            {
                AllDraw This = THIS;
                bool fou = Found;
                var ah = Task.Factory.StartNew(() => FoundOfCurrentTableNodeCastle(CloneATable(Tab), Order, ref This, ref fou));
                ah.Wait();
                ah.Dispose();
            }
            if (!Found)
            {
                AllDraw This = THIS;
                bool fou = Found;
                var ah = Task.Factory.StartNew(() => FoundOfCurrentTableNodeMinister(CloneATable(Tab), Order, ref This, ref fou));
                ah.Wait();
                ah.Dispose();
            }
            if (!Found)
            {
                AllDraw This = THIS;
                bool fou = Found;
                var ah = Task.Factory.StartNew(() => FoundOfCurrentTableNodeKing(CloneATable(Tab), Order, ref This, ref fou));
                ah.Wait();
                ah.Dispose();
            }
            return Found;
        }
        //when deeper have some calclulated nodes
        bool IsAstargreedyHaveNode(int Kind, int Order)
        {
            bool Is = false;
            if (Order == 1)
            {
                if (Kind == 1)
                {
                    for (int i = 0; SolderesOnTable != null && i < SodierMidle; i++)
                    {
                        if (SolderesOnTable[i] != null && SolderesOnTable[i].SoldierThinking != null && SolderesOnTable[i].SoldierThinking[0] != null && SolderesOnTable[i].SoldierThinking[0].TableListSolder != null && SolderesOnTable[i].SoldierThinking[0].TableListSolder.Count > 0)
                        {
                            Is = true;
                        }
                    }
                }
                else if (Kind == 2)
                {
                    for (int i = 0; ElephantOnTable != null && i < ElefantMidle; i++)
                    {
                        if (ElephantOnTable[i] != null && ElephantOnTable[i].ElefantThinking != null && ElephantOnTable[i].ElefantThinking[0] != null && ElephantOnTable[i].ElefantThinking[0].TableListElefant != null && ElephantOnTable[i].ElefantThinking[0].TableListElefant.Count > 0)
                        {
                            Is = true;
                        }
                    }
                }
                else if (Kind == 3)
                {
                    for (int i = 0; HoursesOnTable != null && i < HourseMidle; i++)
                    {
                        if (HoursesOnTable[i] != null && HoursesOnTable[i].HourseThinking != null && HoursesOnTable[i].HourseThinking[0] != null && HoursesOnTable[i].HourseThinking[0].TableListHourse != null && HoursesOnTable[i].HourseThinking[0].TableListHourse.Count > 0)
                        {
                            Is = true;
                        }
                    }
                }
                else if (Kind == 4)
                {
                    for (int i = 0; CastlesOnTable != null && i < CastleMidle; i++)
                    {
                        if (CastlesOnTable[i] != null && CastlesOnTable[i].CastleThinking != null && CastlesOnTable[i].CastleThinking[0] != null && CastlesOnTable[i].CastleThinking[0].TableListCastle != null && CastlesOnTable[i].CastleThinking[0].TableListCastle.Count > 0)
                        {
                            Is = true;
                        }
                    }
                }
                else if (Kind == 5)
                {
                    for (int i = 0; MinisterOnTable != null && i < MinisterMidle; i++)
                    {
                        if (MinisterOnTable[i] != null && MinisterOnTable[i].MinisterThinking != null && MinisterOnTable[i].MinisterThinking[0] != null && MinisterOnTable[i].MinisterThinking[0].TableListMinister != null && MinisterOnTable[i].MinisterThinking[0].TableListMinister.Count > 0)
                        {
                            Is = true;
                        }
                    }
                }
                else
                    if (Kind == 6)
                {
                    for (int i = 0; KingOnTable != null && i < KingMidle; i++)
                    {
                        if (KingOnTable[i] != null && KingOnTable[i].KingThinking != null && KingOnTable[i].KingThinking[0] != null && KingOnTable[i].KingThinking[0].TableListKing != null && KingOnTable[i].KingThinking[0].TableListKing.Count > 0)
                        {
                            Is = true;
                        }
                    }
                }
                else if (Kind == 7 || Kind == -7)
                {
                    for (int i = 0; CastlingOnTable != null && i < 1; i++)
                    {
                        if (CastlingOnTable[i] != null && CastlingOnTable[i].CastlingThinking != null && CastlingOnTable[i].CastlingThinking[0] != null && CastlingOnTable[i].CastlingThinking[0].TableListCastling != null && CastlingOnTable[i].CastlingThinking[0].TableListCastling.Count > 0)
                        {
                            Is = true;
                        }
                    }
                }
            }
            else
            {
                if (Kind == 1)
                {
                    for (int i = SodierMidle; SolderesOnTable != null && i < SodierHigh; i++)
                    {
                        if (SolderesOnTable[i] != null && SolderesOnTable[i].SoldierThinking != null && SolderesOnTable[i].SoldierThinking[0] != null && SolderesOnTable[i].SoldierThinking[0].TableListSolder != null && SolderesOnTable[i].SoldierThinking[0].TableListSolder.Count > 0)
                        {
                            Is = true;
                        }
                    }
                }
                else if (Kind == 2)
                {
                    for (int i = ElefantMidle; ElephantOnTable != null && i < ElefantHigh; i++)
                    {
                        if (ElephantOnTable[i] != null && ElephantOnTable[i].ElefantThinking != null && ElephantOnTable[i].ElefantThinking[0] != null && ElephantOnTable[i].ElefantThinking[0].TableListElefant != null && ElephantOnTable[i].ElefantThinking[0].TableListElefant.Count > 0)
                        {
                            Is = true;
                        }
                    }
                }
                else if (Kind == 3)
                {
                    for (int i = HourseMidle; HoursesOnTable != null && i < HourseHight; i++)
                    {
                        if (HoursesOnTable[i] != null && HoursesOnTable[i].HourseThinking != null && HoursesOnTable[i].HourseThinking[0] != null && HoursesOnTable[i].HourseThinking[0].TableListHourse != null && HoursesOnTable[i].HourseThinking[0].TableListHourse.Count > 0)
                        {
                            Is = true;
                        }
                    }
                }
                else
                    if (Kind == 4)
                {
                    for (int i = CastleMidle; CastlesOnTable != null && i < CastleHigh; i++)
                    {
                        if (CastlesOnTable[i] != null && CastlesOnTable[i].CastleThinking != null && CastlesOnTable[i].CastleThinking[0] != null && CastlesOnTable[i].CastleThinking[0].TableListCastle != null && CastlesOnTable[i].CastleThinking[0].TableListCastle.Count > 0)
                        {
                            Is = true;
                        }
                    }
                }
                else
                    if (Kind == 5)
                {
                    for (int i = MinisterHigh; MinisterOnTable != null && i < MinisterHigh; i++)
                    {
                        if (MinisterOnTable[i] != null && MinisterOnTable[i].MinisterThinking != null && MinisterOnTable[i].MinisterThinking[0] != null && MinisterOnTable[i].MinisterThinking[0].TableListMinister != null && MinisterOnTable[i].MinisterThinking[0].TableListMinister.Count > 0)
                        {
                            Is = true;
                        }
                    }
                }
                else if (Kind == 6)
                {
                    for (int i = KingMidle; KingOnTable != null && i < KingHigh; i++)
                    {
                        if (KingOnTable[i] != null && KingOnTable[i].KingThinking != null && KingOnTable[i].KingThinking[0] != null && KingOnTable[i].KingThinking[0].TableListKing != null && KingOnTable[i].KingThinking[0].TableListKing.Count > 0)
                        {
                            Is = true;
                        }
                    }
                }
                else if (Kind == 7 || Kind == -7)
                {
                    for (int i = 0; CastlingOnTable != null && i < 1; i++)
                    {
                        if (CastlingOnTable[i] != null && CastlingOnTable[i].CastlingThinking != null && CastlingOnTable[i].CastlingThinking[0] != null && CastlingOnTable[i].CastlingThinking[0].TableListCastling != null && CastlingOnTable[i].CastlingThinking[0].TableListCastling.Count > 0)
                        {
                            Is = true;
                        }
                    }
                }
            }
            return Is;

        }
        public void ClearAllTablesHeuristicsAndMoreGray(int Order)
        {
            Object O = new Object();
            lock (O)
            {      //soldier
                for (int i = 0; SolderesOnTable != null && i < SodierMidle; i++)
                {
                    if (SolderesOnTable[i] != null && SolderesOnTable[i].SoldierThinking != null && SolderesOnTable[i].SoldierThinking[0] != null && SolderesOnTable[i].SoldierThinking[0].TableListSolder != null && SolderesOnTable[i].SoldierThinking[0].TableListSolder.Count > 0)
                    {
                        for (int j = 0; j < SolderesOnTable[i].SoldierThinking[0].TableListSolder.Count; j++)
                        {
                            //when is not validity
                            var ah = Task.Factory.StartNew(() => ClearAllTablesHeuristicsAndMoreSoldier(Order, i, j));
                            ah.Wait();
                            ah.Dispose();

                        }
                    }
                }
                //elephant
                for (int i = 0; ElephantOnTable != null && i < ElefantMidle; i++)
                {
                    if (ElephantOnTable[i] != null && ElephantOnTable[i].ElefantThinking != null && ElephantOnTable[i].ElefantThinking[0] != null && ElephantOnTable[i].ElefantThinking[0].TableListElefant != null && ElephantOnTable[i].ElefantThinking[0].TableListElefant.Count > 0)
                    {
                        for (int j = 0; j < ElephantOnTable[i].ElefantThinking[0].TableListElefant.Count; j++)
                        {
                            //when is not validity
                            var ah = Task.Factory.StartNew(() => ClearAllTablesHeuristicsAndMoreElephant(Order, i, j));
                            ah.Wait();
                            ah.Dispose();
                        }
                    }
                }
                //hourse
                for (int i = 0; HoursesOnTable != null && i < HourseMidle; i++)
                {
                    if (HoursesOnTable[i] != null && HoursesOnTable[i].HourseThinking != null && HoursesOnTable[i].HourseThinking[0] != null && HoursesOnTable[i].HourseThinking[0].TableListHourse != null && HoursesOnTable[i].HourseThinking[0].TableListHourse.Count > 0)
                    {
                        for (int j = 0; j < HoursesOnTable[i].HourseThinking[0].TableListHourse.Count; j++)
                        {
                            //when is not validity
                            var ah = Task.Factory.StartNew(() => ClearAllTablesHeuristicsAndMoreHourse(Order, i, j));
                            ah.Wait();
                            ah.Dispose();
                        }
                    }
                }
                //Castle
                for (int i = 0; CastlesOnTable != null && i < CastleMidle; i++)
                {
                    if (CastlesOnTable[i] != null && CastlesOnTable[i].CastleThinking != null && CastlesOnTable[i].CastleThinking[0] != null && CastlesOnTable[i].CastleThinking[0].TableListCastle != null && CastlesOnTable[i].CastleThinking[0].TableListCastle.Count > 0)
                    {
                        for (int j = 0; j < CastlesOnTable[i].CastleThinking[0].TableListCastle.Count; j++)
                        {
                            //when is not validity
                            var ah = Task.Factory.StartNew(() => ClearAllTablesHeuristicsAndMoreCastle(Order, i, j));
                            ah.Wait();
                            ah.Dispose();
                        }
                    }
                }
                //minster
                for (int i = 0; MinisterOnTable != null && i < MinisterMidle; i++)
                {
                    if (MinisterOnTable[i] != null && MinisterOnTable[i].MinisterThinking != null && MinisterOnTable[i].MinisterThinking[0] != null && MinisterOnTable[i].MinisterThinking[0].TableListMinister != null && MinisterOnTable[i].MinisterThinking[0].TableListMinister.Count > 0)
                    {
                        for (int j = 0; j < MinisterOnTable[i].MinisterThinking[0].TableListMinister.Count; j++)
                        {
                            //when is not validity
                            var ah = Task.Factory.StartNew(() => ClearAllTablesHeuristicsAndMoreMinister(Order, i, j));
                            ah.Wait();
                            ah.Dispose();
                        }
                    }
                }
                //king
                for (int i = 0; KingOnTable != null && i < KingMidle; i++)
                {
                    if (KingOnTable[i] != null && KingOnTable[i].KingThinking != null && KingOnTable[i].KingThinking[0] != null && KingOnTable[i].KingThinking[0].TableListKing != null && KingOnTable[i].KingThinking[0].TableListKing.Count > 0)
                    {
                        for (int j = 0; j < KingOnTable[i].KingThinking[0].TableListKing.Count; j++)
                        {
                            //when is not validity
                            var ah = Task.Factory.StartNew(() => ClearAllTablesHeuristicsAndMoreKing(Order, i, j));
                            ah.Wait();
                            ah.Dispose();
                        }
                    }
                }
                for (int i = 0; CastlingOnTable != null && i < 1; i++)
                {
                    if (CastlingOnTable[i] != null && CastlingOnTable[i].CastlingThinking != null && CastlingOnTable[i].CastlingThinking[0] != null && CastlingOnTable[i].CastlingThinking[0].TableListCastling != null && CastlingOnTable[i].CastlingThinking[0].TableListCastling.Count > 0)
                    {
                        for (int j = 0; j < CastlingOnTable[i].CastlingThinking[0].TableListCastling.Count; j++)
                        {
                            //when is not validity
                            var ah = Task.Factory.StartNew(() => ClearAllTablesHeuristicsAndMoreCastling(Order, i, j));
                            ah.Wait();
                            ah.Dispose();
                        }
                    }
                }
            }
        }
        public void ClearAllTablesHeuristicsAndMoreBrown(int Order)
        {
            Object O = new Object();
            lock (O)
            {          //soldier
                for (int i = SodierMidle; SolderesOnTable != null && i < SodierHigh; i++)
                {
                    if (SolderesOnTable[i] != null && SolderesOnTable[i].SoldierThinking != null && SolderesOnTable[i].SoldierThinking[0] != null && SolderesOnTable[i].SoldierThinking[0].TableListSolder != null && SolderesOnTable[i].SoldierThinking[0].TableListSolder.Count > 0)
                    {
                        for (int j = 0; j < SolderesOnTable[i].SoldierThinking[0].TableListSolder.Count; j++)
                        {
                            //when is not validity
                            var ah = Task.Factory.StartNew(() => ClearAllTablesHeuristicsAndMoreSoldier(Order, i, j));
                            ah.Wait();
                            ah.Dispose();
                        }
                    }
                }
                //elephant
                for (int i = ElefantMidle; ElephantOnTable != null && i < ElefantHigh; i++)
                {
                    if (ElephantOnTable[i] != null && ElephantOnTable[i].ElefantThinking != null && ElephantOnTable[i].ElefantThinking[0] != null && ElephantOnTable[i].ElefantThinking[0].TableListElefant != null && ElephantOnTable[i].ElefantThinking[0].TableListElefant.Count > 0)
                    {
                        for (int j = 0; j < ElephantOnTable[i].ElefantThinking[0].TableListElefant.Count; j++)
                        {
                            //when is not validity
                            var ah = Task.Factory.StartNew(() => ClearAllTablesHeuristicsAndMoreElephant(Order, i, j));
                            ah.Wait();
                            ah.Dispose();
                        }
                    }
                }
                //hourse
                for (int i = HourseMidle; HoursesOnTable != null && i < HourseHight; i++)
                {
                    if (HoursesOnTable[i] != null && HoursesOnTable[i].HourseThinking != null && HoursesOnTable[i].HourseThinking[0] != null && HoursesOnTable[i].HourseThinking[0].TableListHourse != null && HoursesOnTable[i].HourseThinking[0].TableListHourse.Count > 0)
                    {
                        for (int j = 0; j < HoursesOnTable[i].HourseThinking[0].TableListHourse.Count; j++)
                        {
                            //when is not validity
                            var ah = Task.Factory.StartNew(() => ClearAllTablesHeuristicsAndMoreHourse(Order, i, j));
                            ah.Wait();
                            ah.Dispose();
                        }
                    }
                }
                //Castle
                for (int i = CastleMidle; CastlesOnTable != null && i < CastleHigh; i++)
                {
                    if (CastlesOnTable[i] != null && CastlesOnTable[i].CastleThinking != null && CastlesOnTable[i].CastleThinking[0] != null && CastlesOnTable[i].CastleThinking[0].TableListCastle != null && CastlesOnTable[i].CastleThinking[0].TableListCastle.Count > 0)
                    {
                        for (int j = 0; j < CastlesOnTable[i].CastleThinking[0].TableListCastle.Count; j++)
                        {
                            //when is not validity
                            var ah = Task.Factory.StartNew(() => ClearAllTablesHeuristicsAndMoreCastle(Order, i, j));
                            ah.Wait();
                            ah.Dispose();
                        }
                    }
                }
                //minster
                for (int i = MinisterMidle; MinisterOnTable != null && i < MinisterHigh; i++)
                {
                    if (MinisterOnTable[i] != null && MinisterOnTable[i].MinisterThinking != null && MinisterOnTable[i].MinisterThinking[0] != null && MinisterOnTable[i].MinisterThinking[0].TableListMinister != null && MinisterOnTable[i].MinisterThinking[0].TableListMinister.Count > 0)
                    {
                        for (int j = 0; j < MinisterOnTable[i].MinisterThinking[0].TableListMinister.Count; j++)
                        {
                            //when is not validity
                            var ah = Task.Factory.StartNew(() => ClearAllTablesHeuristicsAndMoreMinister(Order, i, j));
                            ah.Wait();
                            ah.Dispose();
                        }
                    }
                }
                //king
                for (int i = KingMidle; KingOnTable != null && i < KingHigh; i++)
                {
                    if (KingOnTable[i] != null && KingOnTable[i].KingThinking != null && KingOnTable[i].KingThinking[0] != null && KingOnTable[i].KingThinking[0].TableListKing != null && KingOnTable[i].KingThinking[0].TableListKing.Count > 0)
                    {
                        for (int j = 0; j < KingOnTable[i].KingThinking[0].TableListKing.Count; j++)
                        {
                            //when is not validity
                            var ah = Task.Factory.StartNew(() => ClearAllTablesHeuristicsAndMoreKing(Order, i, j));
                            ah.Wait();
                            ah.Dispose();
                        }
                    }
                }
                for (int i = 0; CastlingOnTable != null && i < 1; i++)
                {
                    if (CastlingOnTable[i] != null && CastlingOnTable[i].CastlingThinking != null && CastlingOnTable[i].CastlingThinking[0] != null && CastlingOnTable[i].CastlingThinking[0].TableListCastling != null && CastlingOnTable[i].CastlingThinking[0].TableListCastling.Count > 0)
                    {
                        for (int j = 0; j < CastlingOnTable[i].CastlingThinking[0].TableListCastling.Count; j++)
                        {
                            //when is not validity
                            var ah = Task.Factory.StartNew(() => ClearAllTablesHeuristicsAndMoreCastling(Order, i, j));
                            ah.Wait();
                            ah.Dispose();
                        }
                    }
                }
            }
        }
        //clear all non nessaraly nodes of current
        public void ClearAllTablesHeuristicsAndMore(int Order)
        {
            Object O = new Object();
            lock (O)
            {
                //Gray
                if (Order == 1)
                {
                    var ah = Task.Factory.StartNew(() => ClearAllTablesHeuristicsAndMoreGray(Order));
                    ah.Wait();
                    ah.Dispose();
                }
                else//Brown
                {
                    var ah = Task.Factory.StartNew(() => ClearAllTablesHeuristicsAndMoreBrown(Order));
                    ah.Wait();
                    ah.Dispose();
                }
            }
        }
        //When list of alldraw and deeper is not valid clear all lists
        public void ClearAllTablesHeuristicsAndMoreSoldier(int Order, int i, int j)
        {
            Object O = new Object();
            lock (O)
            {
                bool ac = false;
                var ah = Task.Factory.StartNew(() => ac = IsNonValidityAllTablesHeuristicsAndMore(1, Order, i, j));
                ah.Wait();
                ah.Dispose();
                if (ac)
                {
                    //clear all lists
                    SolderesOnTable[i].SoldierThinking[0].TableListSolder.Clear();
                    SolderesOnTable[i].SoldierThinking[0].HeuristicListSolder.Clear();
                    SolderesOnTable[i].SoldierThinking[0].RowColumnSoldier.Clear();
                    SolderesOnTable[i].SoldierThinking[0].PenaltyRegardListSolder.Clear();
                    if (SolderesOnTable[i].SoldierThinking[0].AStarGreedy != null && SolderesOnTable[i].SoldierThinking[0].AStarGreedy.Count > j)
                        SolderesOnTable[i].SoldierThinking[0].AStarGreedy[j] = new AllDraw(Order * -1, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged);
                    else
                        SolderesOnTable[i].SoldierThinking[0].AStarGreedy = new List<AllDraw>();
                }
            }
        }
        //When list of alldraw and deeper is not valid clear all lists
        public void ClearAllTablesHeuristicsAndMoreElephant(int Order, int i, int j)
        {
            Object O = new Object();
            lock (O)
            {
                bool ac = false;
                var ah = Task.Factory.StartNew(() => ac = IsNonValidityAllTablesHeuristicsAndMore(2, Order, i, j));
                ah.Wait();
                ah.Dispose();
                if (ac)
                {
                    //clear all lists
                    ElephantOnTable[i].ElefantThinking[0].TableListElefant.Clear();
                    ElephantOnTable[i].ElefantThinking[0].HeuristicListElefant.Clear();
                    ElephantOnTable[i].ElefantThinking[0].RowColumnElefant.Clear();
                    ElephantOnTable[i].ElefantThinking[0].PenaltyRegardListElefant.Clear();
                    if (ElephantOnTable[i].ElefantThinking[0].AStarGreedy != null && ElephantOnTable[i].ElefantThinking[0].AStarGreedy.Count > j)
                        ElephantOnTable[i].ElefantThinking[0].AStarGreedy[j] = new AllDraw(Order * -1, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged);
                    else
                        ElephantOnTable[i].ElefantThinking[0].AStarGreedy = new List<AllDraw>();
                }
            }
        }
        //When list of alldraw and deeper is not valid clear all lists
        public void ClearAllTablesHeuristicsAndMoreHourse(int Order, int i, int j)
        {
            Object O = new Object();
            lock (O)
            {
                bool ac = false;
                var ah = Task.Factory.StartNew(() => ac = IsNonValidityAllTablesHeuristicsAndMore(3, Order, i, j));
                ah.Wait();
                ah.Dispose();
                if (ac)
                {
                    //clear all lists
                    HoursesOnTable[i].HourseThinking[0].TableListHourse.Clear();
                    HoursesOnTable[i].HourseThinking[0].HeuristicListHourse.Clear();
                    HoursesOnTable[i].HourseThinking[0].RowColumnHourse.Clear();
                    HoursesOnTable[i].HourseThinking[0].PenaltyRegardListHourse.Clear();
                    if (HoursesOnTable[i].HourseThinking[0].AStarGreedy != null && HoursesOnTable[i].HourseThinking[0].AStarGreedy.Count > j)
                        HoursesOnTable[i].HourseThinking[0].AStarGreedy[j] = new AllDraw(Order * -1, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged);
                    else
                        HoursesOnTable[i].HourseThinking[0].AStarGreedy = new List<AllDraw>();
                }
            }
        }
        //When list of alldraw and deeper is not valid clear all lists
        public void ClearAllTablesHeuristicsAndMoreCastle(int Order, int i, int j)
        {
            Object O = new Object();
            lock (O)
            {
                bool ac = false;
                var ah = Task.Factory.StartNew(() => ac = IsNonValidityAllTablesHeuristicsAndMore(4, Order, i, j));
                ah.Wait();
                ah.Dispose();
                if (ac)
                {
                    //clear all lists
                    CastlesOnTable[i].CastleThinking[0].TableListCastle.Clear();
                    CastlesOnTable[i].CastleThinking[0].HeuristicListCastle.Clear();
                    CastlesOnTable[i].CastleThinking[0].RowColumnCastle.Clear();
                    CastlesOnTable[i].CastleThinking[0].PenaltyRegardListCastle.Clear();
                    if (CastlesOnTable[i].CastleThinking[0].AStarGreedy != null && CastlesOnTable[i].CastleThinking[0].AStarGreedy.Count > j)
                        CastlesOnTable[i].CastleThinking[0].AStarGreedy[j] = new AllDraw(Order * -1, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged);
                    else
                        CastlesOnTable[i].CastleThinking[0].AStarGreedy = new List<AllDraw>();
                }
            }
        }
        //When list of alldraw and deeper is not valid clear all lists
        public void ClearAllTablesHeuristicsAndMoreMinister(int Order, int i, int j)
        {
            Object O = new Object();
            lock (O)
            {
                bool ac = false;
                var ah = Task.Factory.StartNew(() => ac = IsNonValidityAllTablesHeuristicsAndMore(5, Order, i, j));
                ah.Wait();
                ah.Dispose();
                if (ac)
                {
                    //clear all lists
                    MinisterOnTable[i].MinisterThinking[0].TableListMinister.Clear();
                    MinisterOnTable[i].MinisterThinking[0].HeuristicListMinister.Clear();
                    MinisterOnTable[i].MinisterThinking[0].RowColumnMinister.Clear();
                    MinisterOnTable[i].MinisterThinking[0].PenaltyRegardListMinister.Clear();
                    if (MinisterOnTable[i].MinisterThinking[0].AStarGreedy != null && MinisterOnTable[i].MinisterThinking[0].AStarGreedy.Count > j)
                        MinisterOnTable[i].MinisterThinking[0].AStarGreedy[j] = new AllDraw(Order * -1, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged);
                    else
                        MinisterOnTable[i].MinisterThinking[0].AStarGreedy = new List<AllDraw>();
                }
            }
        }
        //When list of alldraw and deeper is not valid clear all lists
        public void ClearAllTablesHeuristicsAndMoreKing(int Order, int i, int j)
        {
            Object O = new Object();
            lock (O)
            {
                bool ac = false;
                var ah = Task.Factory.StartNew(() => ac = IsNonValidityAllTablesHeuristicsAndMore(6, Order, i, j));
                ah.Wait();
                ah.Dispose();
                if (ac)
                {
                    //clear all lists
                    KingOnTable[i].KingThinking[0].TableListKing.Clear();
                    KingOnTable[i].KingThinking[0].HeuristicListKing.Clear();
                    KingOnTable[i].KingThinking[0].RowColumnKing.Clear();
                    KingOnTable[i].KingThinking[0].PenaltyRegardListKing.Clear();
                    if (KingOnTable[i].KingThinking[0].AStarGreedy != null && KingOnTable[i].KingThinking[0].AStarGreedy.Count > j)
                        KingOnTable[i].KingThinking[0].AStarGreedy[j] = new AllDraw(Order * -1, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged);
                    else
                        KingOnTable[i].KingThinking[0].AStarGreedy = new List<AllDraw>();
                }
            }
        }
        public void ClearAllTablesHeuristicsAndMoreCastling(int Order, int i, int j)
        {
            Object O = new Object();
            lock (O)
            {
                bool ac = false;
                var ah = Task.Factory.StartNew(() => ac = IsNonValidityAllTablesHeuristicsAndMore(7, Order, i, j));
                ah.Wait();
                ah.Dispose();
                if (ac)
                {
                    //clear all lists
                    CastlingOnTable[i].CastlingThinking[0].TableListCastling.Clear();
                    CastlingOnTable[i].CastlingThinking[0].HeuristicListCastling.Clear();
                    CastlingOnTable[i].CastlingThinking[0].RowColumnCastling.Clear();
                    CastlingOnTable[i].CastlingThinking[0].PenaltyRegardListCastling.Clear();
                    if (CastlingOnTable[i].CastlingThinking[0].AStarGreedy != null && CastlingOnTable[i].CastlingThinking[0].AStarGreedy.Count > j)
                        CastlingOnTable[i].CastlingThinking[0].AStarGreedy[j] = new AllDraw(Order * -1, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged);
                    else
                        CastlingOnTable[i].CastlingThinking[0].AStarGreedy = new List<AllDraw>();
                }
            }
        }
        //when there is a colision in lists of current return true and remove extra lists
        bool A_B_C_D_E_ISNonEqual(int a, int b, int c, int d, int e, int i, int j, int Kind)
        {
            bool Is = false;
            //when deeper is grater and is not empty
            if (e > a && e != -1)
            {
                //soldier
                if (Kind == 1)
                {
                    //remove extra
                    for (int h = a; h < SolderesOnTable[i].SoldierThinking[0].AStarGreedy.Count; h++)
                    {
                        SolderesOnTable[i].SoldierThinking[0].AStarGreedy.RemoveAt(h);
                    }
                }
                else//elephant
                    if (Kind == 2)
                {
                    //remove extra
                    for (int h = a; h < ElephantOnTable[i].ElefantThinking[0].AStarGreedy.Count; h++)
                    {
                        ElephantOnTable[i].ElefantThinking[0].AStarGreedy.RemoveAt(h);
                    }
                }
                else//hourse
                    if (Kind == 3)
                {
                    //remove extra
                    for (int h = a; h < HoursesOnTable[i].HourseThinking[0].AStarGreedy.Count; h++)
                    {
                        HoursesOnTable[i].HourseThinking[0].AStarGreedy.RemoveAt(h);
                    }
                }
                else//Castle
                    if (Kind == 4)
                {
                    //remove extra
                    for (int h = a; h < CastlesOnTable[i].CastleThinking[0].AStarGreedy.Count; h++)
                    {
                        CastlesOnTable[i].CastleThinking[0].AStarGreedy.RemoveAt(h);
                    }
                }
                else//minster
                    if (Kind == 5)
                {
                    //remove extra
                    for (int h = a; h < MinisterOnTable[i].MinisterThinking[0].AStarGreedy.Count; h++)
                    {
                        MinisterOnTable[i].MinisterThinking[0].AStarGreedy.RemoveAt(h);
                    }
                }
                else//king
                    if (Kind == 6)
                {
                    //remove extra
                    for (int h = a; h < KingOnTable[i].KingThinking[0].AStarGreedy.Count; h++)
                    {
                        KingOnTable[i].KingThinking[0].AStarGreedy.RemoveAt(h);
                    }
                }
                else//king
                         if (Kind == 7 || Kind == -7)
                {
                    //remove extra
                    for (int h = a; h < CastlingOnTable[i].CastlingThinking[0].AStarGreedy.Count; h++)
                    {
                        CastlingOnTable[i].CastlingThinking[0].AStarGreedy.RemoveAt(h);
                    }
                }
            }
            //when therse is collision in lists number return true
            if ((!(a == b && b == c && c == d)) || j > e || a == 0 || e == 0 || e == -1)
                Is = true;
            //when there is not
            if (!Is)
            {
                //soldier
                if (Kind == 1)
                {
                    //when current alldraw lists is collision of stored lists tables state return true
                    if (SolderesOnTable[i].SoldierThinking[0].AStarGreedy[j].TableList.Count != 0 && (!ThinkingRefrigtzChessPortable.TableEqual(SolderesOnTable[i].SoldierThinking[0].AStarGreedy[j].TableList[0], CloneATable(SolderesOnTable[i].SoldierThinking[0].TableListSolder[j]))))
                        Is = true;
                }
                else//elephant
                                    if (Kind == 2)
                {
                    //when current alldraw lists is collision of stored lists tables state return true
                    if (ElephantOnTable[i].ElefantThinking[0].AStarGreedy[j].TableList.Count != 0 && (!ThinkingRefrigtzChessPortable.TableEqual(ElephantOnTable[i].ElefantThinking[0].AStarGreedy[j].TableList[0], CloneATable(ElephantOnTable[i].ElefantThinking[0].TableListElefant[j]))))
                        Is = true;
                }
                else//hourse
                                    if (Kind == 3)
                {
                    //when current alldraw lists is collision of stored lists tables state return true
                    if (HoursesOnTable[i].HourseThinking[0].AStarGreedy[j].TableList.Count != 0 && (!ThinkingRefrigtzChessPortable.TableEqual(HoursesOnTable[i].HourseThinking[0].AStarGreedy[j].TableList[0], CloneATable(HoursesOnTable[i].HourseThinking[0].TableListHourse[j]))))
                        Is = true;
                }
                else//Castle
                                    if (Kind == 4)
                {
                    //when current alldraw lists is collision of stored lists tables state return true
                    if (CastlesOnTable[i].CastleThinking[0].AStarGreedy[j].TableList.Count != 0 && (!ThinkingRefrigtzChessPortable.TableEqual(CastlesOnTable[i].CastleThinking[0].AStarGreedy[j].TableList[0], CloneATable(CastlesOnTable[i].CastleThinking[0].TableListCastle[j]))))
                        Is = true;
                }
                else//minster
                                    if (Kind == 5)
                {
                    //when current alldraw lists is collision of stored lists tables state return true
                    if (MinisterOnTable[i].MinisterThinking[0].AStarGreedy[j].TableList.Count != 0 && (!ThinkingRefrigtzChessPortable.TableEqual(MinisterOnTable[i].MinisterThinking[0].AStarGreedy[j].TableList[0], CloneATable(MinisterOnTable[i].MinisterThinking[0].TableListMinister[j]))))
                        Is = true;
                }
                else//king
                                    if (Kind == 6)
                {
                    //when current alldraw lists is collision of stored lists tables state return true
                    if (KingOnTable[i].KingThinking[0].AStarGreedy[j].TableList.Count != 0 && (!ThinkingRefrigtzChessPortable.TableEqual(KingOnTable[i].KingThinking[0].AStarGreedy[j].TableList[0], CloneATable(KingOnTable[i].KingThinking[0].TableListKing[j]))))
                        Is = true;
                }
                else//king
                                    if (Kind == 7 || Kind == -7)
                {
                    //when current alldraw lists is collision of stored lists tables state return true
                    if (CastlingOnTable[i].CastlingThinking[0].AStarGreedy[j].TableList.Count != 0 && (!ThinkingRefrigtzChessPortable.TableEqual(CastlingOnTable[i].CastlingThinking[0].AStarGreedy[j].TableList[0], CloneATable(CastlingOnTable[i].CastlingThinking[0].TableListCastling[j]))))
                        Is = true;
                }
            }
            return Is;
        }
        //calculation of lists count and call collision methods determinstics
        public bool IsNonValidityAllTablesHeuristicsAndMore(int Kind, int Order, int i, int j)
        {
            bool Is = true;
            //soldier
            if (Kind == 1)
            {
                //when there is
                if (SolderesOnTable[i] != null && SolderesOnTable[i].SoldierThinking != null && SolderesOnTable[i].SoldierThinking[0] != null && SolderesOnTable[i].SoldierThinking[0].TableListSolder != null && SolderesOnTable[i].SoldierThinking[0].TableListSolder.Count > 0)
                {
                    //calculate of lists count and dynamic micprogramming
                    int a = SolderesOnTable[i].SoldierThinking[0].TableListSolder.Count;
                    int b = SolderesOnTable[i].SoldierThinking[0].HeuristicListSolder.Count;
                    int c = SolderesOnTable[i].SoldierThinking[0].RowColumnSoldier.Count;
                    int d = SolderesOnTable[i].SoldierThinking[0].PenaltyRegardListSolder.Count;
                    int e = 0;
                    if (SolderesOnTable[i].SoldierThinking[0].AStarGreedy != null && SolderesOnTable[i].SoldierThinking[0].AStarGreedy.Count > j)
                        e = -1;
                    else
                        e = SolderesOnTable[i].SoldierThinking[0].AStarGreedy.Count;

                    var ah = Task.Factory.StartNew(() => Is = A_B_C_D_E_ISNonEqual(a, b, c, d, e, i, j, 1));
                    ah.Wait();
                    ah.Dispose();
                }
            }
            else if (Kind == 2)
            {
                //when there is
                if (ElephantOnTable[i] != null && ElephantOnTable[i].ElefantThinking != null && ElephantOnTable[i].ElefantThinking[0] != null && ElephantOnTable[i].ElefantThinking[0].TableListElefant != null && ElephantOnTable[i].ElefantThinking[0].TableListElefant.Count > 0)
                {
                    //calculate of lists count and dynamic micprogramming
                    int a = ElephantOnTable[i].ElefantThinking[0].TableListElefant.Count;
                    int b = ElephantOnTable[i].ElefantThinking[0].HeuristicListElefant.Count;
                    int c = ElephantOnTable[i].ElefantThinking[0].RowColumnElefant.Count;
                    int d = ElephantOnTable[i].ElefantThinking[0].PenaltyRegardListElefant.Count;
                    int e = 0;
                    if (ElephantOnTable[i].ElefantThinking[0].AStarGreedy != null && ElephantOnTable[i].ElefantThinking[0].AStarGreedy.Count > j)
                        e = -1;
                    else
                        e = ElephantOnTable[i].ElefantThinking[0].AStarGreedy.Count;
                    var ah = Task.Factory.StartNew(() => Is = A_B_C_D_E_ISNonEqual(a, b, c, d, e, i, j, 2));
                    ah.Wait();
                    ah.Dispose();
                }
            }
            else if (Kind == 3)
            {
                //when there is
                if (HoursesOnTable[i] != null && HoursesOnTable[i].HourseThinking != null && HoursesOnTable[i].HourseThinking[0] != null && HoursesOnTable[i].HourseThinking[0].TableListHourse != null && HoursesOnTable[i].HourseThinking[0].TableListHourse.Count > 0)
                {
                    //calculate of lists count and dynamic micprogramming
                    int a = HoursesOnTable[i].HourseThinking[0].TableListHourse.Count;
                    int b = HoursesOnTable[i].HourseThinking[0].HeuristicListHourse.Count;
                    int c = HoursesOnTable[i].HourseThinking[0].RowColumnHourse.Count;
                    int d = HoursesOnTable[i].HourseThinking[0].PenaltyRegardListHourse.Count;
                    int e = 0;
                    if (HoursesOnTable[i].HourseThinking[0].AStarGreedy != null && HoursesOnTable[i].HourseThinking[0].AStarGreedy.Count > j)
                        e = -1;
                    else
                        e = HoursesOnTable[i].HourseThinking[0].AStarGreedy.Count;
                    var ah = Task.Factory.StartNew(() => Is = A_B_C_D_E_ISNonEqual(a, b, c, d, e, i, j, 3));
                    ah.Wait();
                    ah.Dispose();
                }
            }
            else if (Kind == 4)
            {
                //when there is
                if (CastlesOnTable[i] != null && CastlesOnTable[i].CastleThinking != null && CastlesOnTable[i].CastleThinking[0] != null && CastlesOnTable[i].CastleThinking[0].TableListCastle != null && CastlesOnTable[i].CastleThinking[0].TableListCastle.Count > 0)
                {
                    //calculate of lists count and dynamic micprogramming
                    int a = CastlesOnTable[i].CastleThinking[0].TableListCastle.Count;
                    int b = CastlesOnTable[i].CastleThinking[0].HeuristicListCastle.Count;
                    int c = CastlesOnTable[i].CastleThinking[0].RowColumnCastle.Count;
                    int d = CastlesOnTable[i].CastleThinking[0].PenaltyRegardListCastle.Count;
                    int e = 0;
                    if (CastlesOnTable[i].CastleThinking[0].AStarGreedy != null && CastlesOnTable[i].CastleThinking[0].AStarGreedy.Count > j)
                        e = -1;
                    else
                        e = CastlesOnTable[i].CastleThinking[0].AStarGreedy.Count;
                    //if (a == b && b == c && d == c && a > 0)
                    var ah = Task.Factory.StartNew(() => Is = A_B_C_D_E_ISNonEqual(a, b, c, d, e, i, j, 4));
                    ah.Wait();
                    ah.Dispose();
                }
            }
            else if (Kind == 5)
            {
                //when there is
                if (MinisterOnTable[i] != null && MinisterOnTable[i].MinisterThinking != null && MinisterOnTable[i].MinisterThinking[0] != null && MinisterOnTable[i].MinisterThinking[0].TableListMinister != null && MinisterOnTable[i].MinisterThinking[0].TableListMinister.Count > 0)
                {
                    //calculate of lists count and dynamic micprogramming
                    int a = MinisterOnTable[i].MinisterThinking[0].TableListMinister.Count;
                    int b = MinisterOnTable[i].MinisterThinking[0].HeuristicListMinister.Count;
                    int c = MinisterOnTable[i].MinisterThinking[0].RowColumnMinister.Count;
                    int d = MinisterOnTable[i].MinisterThinking[0].PenaltyRegardListMinister.Count;
                    int e = 0;
                    if (MinisterOnTable[i].MinisterThinking[0].AStarGreedy != null && MinisterOnTable[i].MinisterThinking[0].AStarGreedy.Count > j)
                        e = -1;
                    else
                        e = MinisterOnTable[i].MinisterThinking[0].AStarGreedy.Count;
                    var ah = Task.Factory.StartNew(() => Is = A_B_C_D_E_ISNonEqual(a, b, c, d, e, i, j, 5));
                    ah.Wait();
                    ah.Dispose();
                }
            }
            else if (Kind == 6)
            {
                //when there is
                if (KingOnTable[i] != null && KingOnTable[i].KingThinking != null && KingOnTable[i].KingThinking[0] != null && KingOnTable[i].KingThinking[0].TableListKing != null && KingOnTable[i].KingThinking[0].TableListKing.Count > 0)
                {
                    //calculate of lists count and dynamic micprogramming
                    int a = KingOnTable[i].KingThinking[0].TableListKing.Count;
                    int b = KingOnTable[i].KingThinking[0].HeuristicListKing.Count;
                    int c = KingOnTable[i].KingThinking[0].RowColumnKing.Count;
                    int d = KingOnTable[i].KingThinking[0].PenaltyRegardListKing.Count;
                    int e = 0;
                    if (KingOnTable[i].KingThinking[0].AStarGreedy != null && KingOnTable[i].KingThinking[0].AStarGreedy.Count > j)
                        e = -1;
                    else
                        e = KingOnTable[i].KingThinking[0].AStarGreedy.Count;
                    var ah = Task.Factory.StartNew(() => Is = A_B_C_D_E_ISNonEqual(a, b, c, d, e, i, j, 6));
                    ah.Wait();
                    ah.Dispose();
                }
            }
            else if (Kind == 7 || Kind == -7)
            {
                //when there is
                if (CastlingOnTable[i] != null && CastlingOnTable[i].CastlingThinking != null && CastlingOnTable[i].CastlingThinking[0] != null && CastlingOnTable[i].CastlingThinking[0].TableListCastling != null && CastlingOnTable[i].CastlingThinking[0].TableListCastling.Count > 0)
                {
                    //calculate of lists count and dynamic micprogramming
                    int a = CastlingOnTable[i].CastlingThinking[0].TableListCastling.Count;
                    int b = CastlingOnTable[i].CastlingThinking[0].HeuristicListCastling.Count;
                    int c = CastlingOnTable[i].CastlingThinking[0].RowColumnCastling.Count;
                    int d = CastlingOnTable[i].CastlingThinking[0].PenaltyRegardListCastling.Count;
                    int e = 0;
                    if (CastlingOnTable[i].CastlingThinking[0].AStarGreedy != null && CastlingOnTable[i].CastlingThinking[0].AStarGreedy.Count > j)
                        e = -1;
                    else
                        e = CastlingOnTable[i].CastlingThinking[0].AStarGreedy.Count;
                    var ah = Task.Factory.StartNew(() => Is = A_B_C_D_E_ISNonEqual(a, b, c, d, e, i, j, 7));
                    ah.Wait();
                    ah.Dispose();
                }
            }
            return (Is);
        }
        public bool FoundOfCurrentTableNodeSolderIJ(int i, int j, int[,] Tab, int Order, ref AllDraw THIS, ref bool Found)
        {
            //if (IsSupHuTrue(i, j, 0, 1))

            //when is null creation enough but empty and create deeper node 
            if (SolderesOnTable[i].SoldierThinking[0].AStarGreedy.Count == 0)
            {
                for (int h = 0; h <= j; h++)
                //satisfied of created deeper three
                {
                    var ah = Task.Factory.StartNew(() => BlitzNotValidFullGameThinkingTreePartThree(i, Order, 1));
                    ah.Wait();
                    ah.Dispose();
                }
                SolderesOnTable[i].SoldierThinking[0].AStarGreedy[j].TableList.Clear();
                SolderesOnTable[i].SoldierThinking[0].AStarGreedy[j].TableList.Add(CloneATable(SolderesOnTable[i].SoldierThinking[0].TableListSolder[j]));
                SolderesOnTable[i].SoldierThinking[0].AStarGreedy[j].SetRowColumn(0);
                SolderesOnTable[i].SoldierThinking[0].AStarGreedy[j].AStarGreedyString = this;
                THIS = SolderesOnTable[i].SoldierThinking[0].AStarGreedy[j];
                Found = true;
                return true;
            }//when is not deeper null and is less than j index create empty but create deeper node table
            else
                                    if (SolderesOnTable[i].SoldierThinking[0].AStarGreedy != null && SolderesOnTable[i].SoldierThinking[0].AStarGreedy.Count < j + 1)
            {
                for (int h = SolderesOnTable[i].SoldierThinking[0].AStarGreedy.Count; h <= j; h++)
                //satisfied of created deeper three
                {
                    var ah = Task.Factory.StartNew(() => BlitzNotValidFullGameThinkingTreePartThree(i, Order, 1));
                    ah.Wait();
                    ah.Dispose();
                }
                SolderesOnTable[i].SoldierThinking[0].AStarGreedy[j].TableList.Clear();
                SolderesOnTable[i].SoldierThinking[0].AStarGreedy[j].TableList.Add(CloneATable(SolderesOnTable[i].SoldierThinking[0].TableListSolder[j]));
                SolderesOnTable[i].SoldierThinking[0].AStarGreedy[j].SetRowColumn(0);
                SolderesOnTable[i].SoldierThinking[0].AStarGreedy[j].AStarGreedyString = this;
                THIS = SolderesOnTable[i].SoldierThinking[0].AStarGreedy[j];
                Found = true;
                return true;
            }//when is enough and determine about creation of empty deeper than deeper or return exist
            else
            {
                if (SolderesOnTable[i].SoldierThinking[0].AStarGreedy != null && SolderesOnTable[i].SoldierThinking[0].AStarGreedy.Count > j)
                {
                    THIS = SolderesOnTable[i].SoldierThinking[0].AStarGreedy[j];
                    Found = true;
                    return true;
                }
            }
            return false;
        }
        //determine about found of equality of lists of current alldraw and call determinition of deeper 
        public bool FoundOfCurrentTableNodeSoldeir(int[,] Tab, int Order, ref AllDraw THIS, ref bool Found)
        {
            if (Order == 1)
            {
                for (int i = 0; SolderesOnTable != null && i < SodierMidle; i++)
                {
                    for (int j = 0; SolderesOnTable[i] != null && SolderesOnTable[i].SoldierThinking != null && SolderesOnTable[i].SoldierThinking[0] != null && SolderesOnTable[i].SoldierThinking[0].TableListSolder != null && SolderesOnTable[i].SoldierThinking[0].TableListSolder.Count > j; j++)
                    {
                        bool ac = false;
                        var ah = Task.Factory.StartNew(() => ac = IsSupHuTrue(i, j, 0, 1));
                        ah.Wait();
                        ah.Dispose();
                        if (ac)
                            continue;
                        var ah1 = Task.Factory.StartNew(() => ac = ThinkingRefrigtzChessPortable.TableEqual(SolderesOnTable[i].SoldierThinking[0].TableListSolder[j], Tab));
                        ah1.Wait();
                        ah1.Dispose();
                        if (ac)
                        {
                            AllDraw This = THIS;
                            bool fou = Found;
                            var ah2 = Task.Factory.StartNew(() => FoundOfCurrentTableNodeSolderIJ(i, j, CloneATable(Tab), Order, ref This, ref fou));
                            ah2.Wait();
                            ah2.Dispose();
                            Found = fou;
                            THIS = This;
                            if (Found)
                                return Found;
                        }
                    }
                }
            }
            else
            {
                for (int i = SodierMidle; SolderesOnTable != null && i < SodierHigh; i++)
                {
                    for (int j = 0; SolderesOnTable[i] != null && SolderesOnTable[i].SoldierThinking != null && SolderesOnTable[i].SoldierThinking[0] != null && SolderesOnTable[i].SoldierThinking[0].TableListSolder != null && SolderesOnTable[i].SoldierThinking[0].TableListSolder.Count > j; j++)
                    {
                        bool ac = false;
                        var ah = Task.Factory.StartNew(() => ac = IsSupHuTrue(i, j, 0, 1));
                        ah.Wait();
                        ah.Dispose();
                        if (ac)
                            continue;
                        var ah1 = Task.Factory.StartNew(() => ac = ThinkingRefrigtzChessPortable.TableEqual(SolderesOnTable[i].SoldierThinking[0].TableListSolder[j], Tab));
                        ah1.Wait();
                        ah1.Dispose();
                        if (ac)
                        {
                            AllDraw This = THIS;
                            bool fou = Found;
                            var ah2 = Task.Factory.StartNew(() => FoundOfCurrentTableNodeSolderIJ(i, j, CloneATable(Tab), Order, ref This, ref fou));
                            ah2.Wait();
                            ah2.Dispose();
                            Found = fou;
                            THIS = This;
                            if (Found)
                                return Found;
                        }
                    }
                }
            }
            return Found;
        }
        //Creation Table and deeper when there is not deeper or there is  
        public bool FoundOfCurrentTableNodeElephantIJ(int i, int j, int[,] Tab, int Order, ref AllDraw THIS, ref bool Found)
        {
            //if (IsSupHuTrue(i, j, 0, 2))

            //when is null creation enough but empty and create deeper node 
            if (ElephantOnTable[i].ElefantThinking[0].AStarGreedy.Count == 0)
            {
                for (int h = 0; h <= j; h++)
                //satisfied of created deeper three
                {
                    var ah = Task.Factory.StartNew(() => BlitzNotValidFullGameThinkingTreePartThree(i, Order, 2));
                    ah.Wait();
                    ah.Dispose();
                }
                ElephantOnTable[i].ElefantThinking[0].AStarGreedy[j].TableList.Clear();
                ElephantOnTable[i].ElefantThinking[0].AStarGreedy[j].TableList.Add(CloneATable(ElephantOnTable[i].ElefantThinking[0].TableListElefant[j]));
                ElephantOnTable[i].ElefantThinking[0].AStarGreedy[j].SetRowColumn(0);
                ElephantOnTable[i].ElefantThinking[0].AStarGreedy[j].AStarGreedyString = this;
                THIS = ElephantOnTable[i].ElefantThinking[0].AStarGreedy[j];
                Found = true;
                return true;
            }//when is not deeper null and is less than j index create empty but create deeper node table
            else
                                    if (ElephantOnTable[i].ElefantThinking[0].AStarGreedy != null && ElephantOnTable[i].ElefantThinking[0].AStarGreedy.Count < j + 1)
            {
                for (int h = ElephantOnTable[i].ElefantThinking[0].AStarGreedy.Count; h <= j; h++)
                //satisfied of created deeper three
                {
                    var ah = Task.Factory.StartNew(() => BlitzNotValidFullGameThinkingTreePartThree(i, Order, 2));
                    ah.Wait();
                    ah.Dispose();
                }
                ElephantOnTable[i].ElefantThinking[0].AStarGreedy[j].TableList.Clear();
                ElephantOnTable[i].ElefantThinking[0].AStarGreedy[j].TableList.Add(CloneATable(ElephantOnTable[i].ElefantThinking[0].TableListElefant[j]));
                ElephantOnTable[i].ElefantThinking[0].AStarGreedy[j].SetRowColumn(0);
                ElephantOnTable[i].ElefantThinking[0].AStarGreedy[j].AStarGreedyString = this;
                THIS = ElephantOnTable[i].ElefantThinking[0].AStarGreedy[j];
                Found = true;
                return true;
            }//when is enough and determine about creation of empty deeper than deeper or return exist
            else
            {
                if (ElephantOnTable[i].ElefantThinking[0].AStarGreedy != null && ElephantOnTable[i].ElefantThinking[0].AStarGreedy.Count > j)
                {
                    THIS = ElephantOnTable[i].ElefantThinking[0].AStarGreedy[j];
                    Found = true;
                    return true;
                }
            }
            return false;
        }
        //determine about found of equality of lists of current alldraw and call determinition of deeper 
        public bool FoundOfCurrentTableNodeElephant(int[,] Tab, int Order, ref AllDraw THIS, ref bool Found)
        {
            if (Order == 1)
            {
                for (int i = 0; ElephantOnTable != null && i < ElefantMidle; i++)
                {
                    for (int j = 0; ElephantOnTable[i] != null && ElephantOnTable[i].ElefantThinking != null && ElephantOnTable[i].ElefantThinking[0] != null && ElephantOnTable[i].ElefantThinking[0].TableListElefant != null && ElephantOnTable[i].ElefantThinking[0].TableListElefant.Count > j; j++)
                    {
                        bool ac = false;
                        var ah = Task.Factory.StartNew(() => ac = IsSupHuTrue(i, j, 0, 2));
                        ah.Wait();
                        ah.Dispose();
                        if (ac)
                            continue;
                        var ah1 = Task.Factory.StartNew(() => ac = ThinkingRefrigtzChessPortable.TableEqual(ElephantOnTable[i].ElefantThinking[0].TableListElefant[j], Tab));
                        ah1.Wait();
                        ah1.Dispose();
                        if (ac)
                        {
                            AllDraw This = THIS;
                            bool fou = Found;
                            var ah2 = Task.Factory.StartNew(() => FoundOfCurrentTableNodeElephantIJ(i, j, CloneATable(Tab), Order, ref This, ref fou));
                            ah2.Wait();
                            ah2.Dispose();
                            Found = fou;
                            THIS = This;
                            if (Found)
                                return Found;
                        }
                    }
                }
            }//when is not deeper null and is less than j index create empty but create deeper node table
            else
            {
                for (int i = ElefantMidle; ElephantOnTable != null && i < ElefantHigh; i++)
                {
                    for (int j = 0; ElephantOnTable[i] != null && ElephantOnTable[i].ElefantThinking != null && ElephantOnTable[i].ElefantThinking[0] != null && ElephantOnTable[i].ElefantThinking[0].TableListElefant != null && ElephantOnTable[i].ElefantThinking[0].TableListElefant.Count > j; j++)
                    {
                        bool ac = false;
                        var ah = Task.Factory.StartNew(() => ac = IsSupHuTrue(i, j, 0, 2));
                        ah.Wait();
                        ah.Dispose();
                        if (ac)
                            continue;
                        var ah1 = Task.Factory.StartNew(() => ac = ThinkingRefrigtzChessPortable.TableEqual(ElephantOnTable[i].ElefantThinking[0].TableListElefant[j], Tab));
                        ah1.Wait();
                        ah1.Dispose();
                        if (ac)
                        {
                            AllDraw This = THIS;
                            bool fou = Found;
                            var ah2 = Task.Factory.StartNew(() => FoundOfCurrentTableNodeElephantIJ(i, j, CloneATable(Tab), Order, ref This, ref fou));
                            ah2.Wait();
                            ah2.Dispose();
                            Found = fou;
                            THIS = This;
                            if (Found)
                                return Found;
                        }
                    }
                }
            }
            return Found;
        }
        //Creation Table and deeper when there is not deeper or there is  
        public bool FoundOfCurrentTableNodeHourseIJ(int i, int j, int[,] Tab, int Order, ref AllDraw THIS, ref bool Found)
        {
            //if (IsSupHuTrue(i, j, 0, 3))

            //when is null creation enough but empty and create deeper node 
            if (HoursesOnTable[i].HourseThinking[0].AStarGreedy.Count == 0)
            {
                for (int h = 0; h <= j; h++)
                //satisfied of created deeper three
                {
                    var ah = Task.Factory.StartNew(() => BlitzNotValidFullGameThinkingTreePartThree(i, Order, 3));
                    ah.Wait();
                    ah.Dispose();
                }
                HoursesOnTable[i].HourseThinking[0].AStarGreedy[j].TableList.Clear();
                HoursesOnTable[i].HourseThinking[0].AStarGreedy[j].TableList.Add(CloneATable(HoursesOnTable[i].HourseThinking[0].TableListHourse[j]));
                HoursesOnTable[i].HourseThinking[0].AStarGreedy[j].SetRowColumn(0);
                HoursesOnTable[i].HourseThinking[0].AStarGreedy[j].AStarGreedyString = this;
                THIS = HoursesOnTable[i].HourseThinking[0].AStarGreedy[j];
                Found = true;
                return true;
            }//when is not deeper null and is less than j index create empty but create deeper node table
            else
                                   if (HoursesOnTable[i].HourseThinking[0].AStarGreedy != null && HoursesOnTable[i].HourseThinking[0].AStarGreedy.Count < j + 1)
            {
                for (int h = HoursesOnTable[i].HourseThinking[0].AStarGreedy.Count; h <= j; h++)
                //satisfied of created deeper three
                {
                    var ah = Task.Factory.StartNew(() => BlitzNotValidFullGameThinkingTreePartThree(i, Order, 3));
                    ah.Wait();
                    ah.Dispose();
                }
                HoursesOnTable[i].HourseThinking[0].AStarGreedy[j].TableList.Clear();
                HoursesOnTable[i].HourseThinking[0].AStarGreedy[j].TableList.Add(CloneATable(HoursesOnTable[i].HourseThinking[0].TableListHourse[j]));
                HoursesOnTable[i].HourseThinking[0].AStarGreedy[j].SetRowColumn(0);
                HoursesOnTable[i].HourseThinking[0].AStarGreedy[j].AStarGreedyString = this;
                THIS = HoursesOnTable[i].HourseThinking[0].AStarGreedy[j];
                Found = true;
                return true;
            }//when is enough and determine about creation of empty deeper than deeper or return exist
            else
            {
                if (HoursesOnTable[i].HourseThinking[0].AStarGreedy != null && HoursesOnTable[i].HourseThinking[0].AStarGreedy.Count > j)
                {
                    THIS = HoursesOnTable[i].HourseThinking[0].AStarGreedy[j];
                    Found = true;
                    return true;
                }
            }
            return false;
        }
        //determine about found of equality of lists of current alldraw and call determinition of deeper 
        public bool FoundOfCurrentTableNodeHourse(int[,] Tab, int Order, ref AllDraw THIS, ref bool Found)
        {
            if (Order == 1)
            {
                for (int i = 0; HoursesOnTable != null && i < ElefantMidle; i++)
                {
                    for (int j = 0; HoursesOnTable[i] != null && HoursesOnTable[i].HourseThinking != null && HoursesOnTable[i].HourseThinking[0] != null && HoursesOnTable[i].HourseThinking[0].TableListHourse != null && HoursesOnTable[i].HourseThinking[0].TableListHourse.Count > j; j++)
                    {
                        bool ac = false;
                        var ah = Task.Factory.StartNew(() => ac = IsSupHuTrue(i, j, 0, 3));
                        ah.Wait();
                        ah.Dispose();
                        if (ac)
                            continue;
                        var ah1 = Task.Factory.StartNew(() => ac = ThinkingRefrigtzChessPortable.TableEqual(HoursesOnTable[i].HourseThinking[0].TableListHourse[j], Tab));
                        ah1.Wait();
                        ah1.Dispose();
                        if (ac)
                        {
                            AllDraw This = THIS;
                            bool fou = Found;
                            var ah2 = Task.Factory.StartNew(() => FoundOfCurrentTableNodeHourseIJ(i, j, CloneATable(Tab), Order, ref This, ref fou));
                            ah2.Wait();
                            ah2.Dispose();
                            Found = fou;
                            THIS = This;
                            if (Found)
                                return Found;
                        }
                    }
                }
            }
            else
            {
                for (int i = HourseMidle; HoursesOnTable != null && i < HourseHight; i++)
                {
                    for (int j = 0; HoursesOnTable[i] != null && HoursesOnTable[i].HourseThinking != null && HoursesOnTable[i].HourseThinking[0] != null && HoursesOnTable[i].HourseThinking[0].TableListHourse != null && HoursesOnTable[i].HourseThinking[0].TableListHourse.Count > j; j++)
                    {
                        bool ac = false;
                        var ah = Task.Factory.StartNew(() => ac = IsSupHuTrue(i, j, 0, 3));
                        ah.Wait();
                        ah.Dispose();
                        if (ac)
                            continue;
                        var ah1 = Task.Factory.StartNew(() => ac = ThinkingRefrigtzChessPortable.TableEqual(HoursesOnTable[i].HourseThinking[0].TableListHourse[j], Tab));
                        ah1.Wait();
                        ah1.Dispose();
                        if (ac)
                        {
                            AllDraw This = THIS;
                            bool fou = Found;
                            var ah2 = Task.Factory.StartNew(() => FoundOfCurrentTableNodeHourseIJ(i, j, CloneATable(Tab), Order, ref This, ref fou));
                            ah2.Wait();
                            ah2.Dispose();
                            Found = fou;
                            THIS = This;
                            if (Found)
                                return Found;
                        }
                    }
                }
            }
            return Found;
        }
        //Creation Table and deeper when there is not deeper or there is  
        public bool FoundOfCurrentTableNodeCastleIJ(int i, int j, int[,] Tab, int Order, ref AllDraw THIS, ref bool Found)
        {
            //if (IsSupHuTrue(i, j, 0, 4))

            //when is null creation enough but empty and create deeper node 
            if (CastlesOnTable[i].CastleThinking[0].AStarGreedy.Count == 0)
            {
                for (int h = 0; h <= j; h++)
                //satisfied of created deeper three
                {
                    var ah = Task.Factory.StartNew(() => BlitzNotValidFullGameThinkingTreePartThree(i, Order, 4));
                    ah.Wait();
                    ah.Dispose();
                }
                CastlesOnTable[i].CastleThinking[0].AStarGreedy[j].TableList.Clear();
                CastlesOnTable[i].CastleThinking[0].AStarGreedy[j].TableList.Add(CloneATable(CastlesOnTable[i].CastleThinking[0].TableListCastle[j]));
                CastlesOnTable[i].CastleThinking[0].AStarGreedy[j].SetRowColumn(0);
                CastlesOnTable[i].CastleThinking[0].AStarGreedy[j].AStarGreedyString = this;
                THIS = CastlesOnTable[i].CastleThinking[0].AStarGreedy[j];
                Found = true;
                return true;
            }//when is not deeper null and is less than j index create empty but create deeper node table
            else
                      if (CastlesOnTable[i].CastleThinking[0].AStarGreedy != null && CastlesOnTable[i].CastleThinking[0].AStarGreedy.Count < j + 1)
            {
                for (int h = CastlesOnTable[i].CastleThinking[0].AStarGreedy.Count; h <= j; h++)
                //satisfied of created deeper three
                {
                    var ah = Task.Factory.StartNew(() => BlitzNotValidFullGameThinkingTreePartThree(i, Order, 4));
                    ah.Wait();
                    ah.Dispose();
                }
                CastlesOnTable[i].CastleThinking[0].AStarGreedy[j].TableList.Clear();
                CastlesOnTable[i].CastleThinking[0].AStarGreedy[j].TableList.Add(CloneATable(CastlesOnTable[i].CastleThinking[0].TableListCastle[j]));
                CastlesOnTable[i].CastleThinking[0].AStarGreedy[j].SetRowColumn(0);
                CastlesOnTable[i].CastleThinking[0].AStarGreedy[j].AStarGreedyString = this;
                THIS = CastlesOnTable[i].CastleThinking[0].AStarGreedy[j];
                Found = true;
                return true;
            }//when is enough and determine about creation of empty deeper than deeper or return exist
            else
            {
                if (CastlesOnTable[i].CastleThinking[0].AStarGreedy != null && CastlesOnTable[i].CastleThinking[0].AStarGreedy.Count > j)
                {
                    THIS = CastlesOnTable[i].CastleThinking[0].AStarGreedy[j];
                    Found = true;
                    return true;
                }
            }
            return false;
        }
        //determine about found of equality of lists of current alldraw and call determinition of deeper 
        public bool FoundOfCurrentTableNodeCastle(int[,] Tab, int Order, ref AllDraw THIS, ref bool Found)
        {
            if (Order == 1)
            {
                for (int i = 0; CastlesOnTable != null && i < CastleMidle; i++)
                {
                    for (int j = 0; CastlesOnTable[i] != null && CastlesOnTable[i].CastleThinking != null && CastlesOnTable[i].CastleThinking[0] != null && CastlesOnTable[i].CastleThinking[0].TableListCastle != null && CastlesOnTable[i].CastleThinking[0].TableListCastle.Count > j; j++)
                    {
                        bool ac = false;
                        var ah = Task.Factory.StartNew(() => ac = IsSupHuTrue(i, j, 0, 4));
                        ah.Wait();
                        ah.Dispose();
                        if (ac)
                            continue;
                        var ah1 = Task.Factory.StartNew(() => ac = ThinkingRefrigtzChessPortable.TableEqual(CastlesOnTable[i].CastleThinking[0].TableListCastle[j], Tab));
                        ah1.Wait();
                        ah1.Dispose();
                        if (ac)
                        {
                            AllDraw This = THIS;
                            bool fou = Found;
                            var ah2 = Task.Factory.StartNew(() => FoundOfCurrentTableNodeCastleIJ(i, j, CloneATable(Tab), Order, ref This, ref fou));
                            ah2.Wait();
                            ah2.Dispose();
                            Found = fou;
                            THIS = This;
                            if (Found)
                                return Found;
                        }
                    }
                }
            }
            else
            {
                for (int i = CastleMidle; CastlesOnTable != null && i < CastleHigh; i++)
                {
                    for (int j = 0; CastlesOnTable[i] != null && CastlesOnTable[i].CastleThinking != null && CastlesOnTable[i].CastleThinking[0] != null && CastlesOnTable[i].CastleThinking[0].TableListCastle != null && CastlesOnTable[i].CastleThinking[0].TableListCastle.Count > j; j++)
                    {
                        bool ac = false;
                        var ah = Task.Factory.StartNew(() => ac = IsSupHuTrue(i, j, 0, 4));
                        ah.Wait();
                        ah.Dispose();
                        if (ac)
                            continue;
                        var ah1 = Task.Factory.StartNew(() => ac = ThinkingRefrigtzChessPortable.TableEqual(CastlesOnTable[i].CastleThinking[0].TableListCastle[j], Tab));
                        ah1.Wait();
                        ah1.Dispose();
                        if (ac)
                        {
                            AllDraw This = THIS;
                            bool fou = Found;
                            var ah2 = Task.Factory.StartNew(() => FoundOfCurrentTableNodeCastleIJ(i, j, CloneATable(Tab), Order, ref This, ref fou));
                            ah2.Wait();
                            ah2.Dispose();
                            Found = fou;
                            THIS = This;
                            if (Found)
                                return Found;
                        }
                    }
                }
            }
            return Found;
        }
        //Creation Table and deeper when there is not deeper or there is  
        public bool FoundOfCurrentTableNodeMinisterIJ(int i, int j, int[,] Tab, int Order, ref AllDraw THIS, ref bool Found)
        {
            //if (IsSupHuTrue(i, j, 0, 5))

            //when is null creation enough but empty and create deeper node 
            if (MinisterOnTable[i].MinisterThinking[0].AStarGreedy.Count == 0)
            {
                for (int h = 0; h <= j; h++)
                //satisfied of created deeper three
                {
                    var ah = Task.Factory.StartNew(() => BlitzNotValidFullGameThinkingTreePartThree(i, Order, 5));
                    ah.Wait();
                    ah.Dispose();
                }
                MinisterOnTable[i].MinisterThinking[0].AStarGreedy[j].TableList.Clear();
                MinisterOnTable[i].MinisterThinking[0].AStarGreedy[j].TableList.Add(CloneATable(MinisterOnTable[i].MinisterThinking[0].TableListMinister[j]));
                MinisterOnTable[i].MinisterThinking[0].AStarGreedy[j].SetRowColumn(0);
                MinisterOnTable[i].MinisterThinking[0].AStarGreedy[j].AStarGreedyString = this;
                THIS = MinisterOnTable[i].MinisterThinking[0].AStarGreedy[j];
                Found = true;
                return true;
            }//when is not deeper null and is less than j index create empty but create deeper node table
            else
                                    if (MinisterOnTable[i].MinisterThinking[0].AStarGreedy != null && MinisterOnTable[i].MinisterThinking[0].AStarGreedy.Count < j + 1)
            {
                for (int h = MinisterOnTable[i].MinisterThinking[0].AStarGreedy.Count; h <= j; h++)
                //satisfied of created deeper three
                {
                    var ah = Task.Factory.StartNew(() => BlitzNotValidFullGameThinkingTreePartThree(i, Order, 5));
                    ah.Wait();
                    ah.Dispose();
                }
                MinisterOnTable[i].MinisterThinking[0].AStarGreedy[j].TableList.Clear();
                MinisterOnTable[i].MinisterThinking[0].AStarGreedy[j].TableList.Add(CloneATable(MinisterOnTable[i].MinisterThinking[0].TableListMinister[j]));
                MinisterOnTable[i].MinisterThinking[0].AStarGreedy[j].SetRowColumn(0);
                MinisterOnTable[i].MinisterThinking[0].AStarGreedy[j].AStarGreedyString = this;
                THIS = MinisterOnTable[i].MinisterThinking[0].AStarGreedy[j];
                Found = true;
                return true;
            }//when is enough and determine about creation of empty deeper than deeper or return exist
            else
            {
                if (MinisterOnTable[i].MinisterThinking[0].AStarGreedy != null && MinisterOnTable[i].MinisterThinking[0].AStarGreedy.Count > j)
                {
                    THIS = MinisterOnTable[i].MinisterThinking[0].AStarGreedy[j];
                    Found = true;
                    return true;
                }
            }
            return false;
        }
        //determine about found of equality of lists of current alldraw and call determinition of deeper 
        public bool FoundOfCurrentTableNodeMinister(int[,] Tab, int Order, ref AllDraw THIS, ref bool Found)
        {
            if (Order == 1)
            {
                for (int i = 0; MinisterOnTable != null && i < MinisterMidle; i++)
                {
                    for (int j = 0; MinisterOnTable[i] != null && MinisterOnTable[i].MinisterThinking != null && MinisterOnTable[i].MinisterThinking[0] != null && MinisterOnTable[i].MinisterThinking[0].TableListMinister != null && MinisterOnTable[i].MinisterThinking[0].TableListMinister.Count > j; j++)
                    {
                        bool ac = false;
                        var ah = Task.Factory.StartNew(() => ac = IsSupHuTrue(i, j, 0, 5));
                        ah.Wait();
                        ah.Dispose();
                        if (ac)
                            continue;
                        var ah1 = Task.Factory.StartNew(() => ac = ThinkingRefrigtzChessPortable.TableEqual(MinisterOnTable[i].MinisterThinking[0].TableListMinister[j], Tab));
                        ah1.Wait();
                        ah1.Dispose();
                        if (ac)
                        {
                            AllDraw This = THIS;
                            bool fou = Found;
                            var ah2 = Task.Factory.StartNew(() => FoundOfCurrentTableNodeMinisterIJ(i, j, CloneATable(Tab), Order, ref This, ref fou));
                            ah2.Wait();
                            ah2.Dispose();
                            Found = fou;
                            THIS = This;
                            if (Found)
                                return Found;
                        }
                    }
                }
            }
            else
            {
                for (int i = MinisterMidle; MinisterOnTable != null && i < MinisterHigh; i++)
                {
                    for (int j = 0; MinisterOnTable[i] != null && MinisterOnTable[i].MinisterThinking != null && MinisterOnTable[i].MinisterThinking[0] != null && MinisterOnTable[i].MinisterThinking[0].TableListMinister != null && MinisterOnTable[i].MinisterThinking[0].TableListMinister.Count > j; j++)
                    {
                        bool ac = false;
                        var ah = Task.Factory.StartNew(() => ac = IsSupHuTrue(i, j, 0, 5));
                        ah.Wait();
                        ah.Dispose();
                        if (ac)
                            continue;
                        var ah1 = Task.Factory.StartNew(() => ac = ThinkingRefrigtzChessPortable.TableEqual(MinisterOnTable[i].MinisterThinking[0].TableListMinister[j], Tab));
                        ah1.Wait();
                        ah1.Dispose();
                        if (ac)
                        {
                            AllDraw This = THIS;
                            bool fou = Found;
                            var ah2 = Task.Factory.StartNew(() => FoundOfCurrentTableNodeMinisterIJ(i, j, CloneATable(Tab), Order, ref This, ref fou));
                            ah2.Wait();
                            ah2.Dispose();
                            Found = fou;
                            THIS = This;
                            if (Found)
                                return Found;
                        }
                    }
                }
            }
            return Found;
        }
        //Creation Table and deeper when there is not deeper or there is  
        public bool FoundOfCurrentTableNodeKingIJ(int i, int j, int[,] Tab, int Order, ref AllDraw THIS, ref bool Found)
        {
            //if (IsSupHuTrue(i, j, 0, 6))

            //when is null creation enough but empty and create deeper node 
            if (KingOnTable[i].KingThinking[0].AStarGreedy.Count == 0)
            {
                for (int h = 0; h <= j; h++)
                //satisfied of created deeper three
                {
                    var ah = Task.Factory.StartNew(() => BlitzNotValidFullGameThinkingTreePartThree(i, Order, 6));
                    ah.Wait();
                    ah.Dispose();
                }
                KingOnTable[i].KingThinking[0].AStarGreedy[j].TableList.Clear();
                KingOnTable[i].KingThinking[0].AStarGreedy[j].TableList.Add(CloneATable(KingOnTable[i].KingThinking[0].TableListKing[j]));
                KingOnTable[i].KingThinking[0].AStarGreedy[j].SetRowColumn(0);
                KingOnTable[i].KingThinking[0].AStarGreedy[j].AStarGreedyString = this;
                THIS = KingOnTable[i].KingThinking[0].AStarGreedy[j];
                Found = true;
                return true;
            }//when is not deeper null and is less than j index create empty but create deeper node table
            else
                                    if (KingOnTable[i].KingThinking[0].AStarGreedy != null && KingOnTable[i].KingThinking[0].AStarGreedy.Count < j + 1)
            {
                for (int h = KingOnTable[i].KingThinking[0].AStarGreedy.Count; h <= j; h++)
                //satisfied of created deeper three
                {
                    var ah = Task.Factory.StartNew(() => BlitzNotValidFullGameThinkingTreePartThree(i, Order, 6));
                    ah.Wait();
                    ah.Dispose();
                }
                KingOnTable[i].KingThinking[0].AStarGreedy[j].TableList.Clear();
                KingOnTable[i].KingThinking[0].AStarGreedy[j].TableList.Add(CloneATable(KingOnTable[i].KingThinking[0].TableListKing[j]));
                KingOnTable[i].KingThinking[0].AStarGreedy[j].SetRowColumn(0);
                KingOnTable[i].KingThinking[0].AStarGreedy[j].AStarGreedyString = this;
                THIS = KingOnTable[i].KingThinking[0].AStarGreedy[j];
                Found = true;
                return true;
            }//when is enough and determine about creation of empty deeper than deeper or return exist
            else
            {
                if (KingOnTable[i].KingThinking[0].AStarGreedy != null && KingOnTable[i].KingThinking[0].AStarGreedy.Count > j)
                {
                    THIS = KingOnTable[i].KingThinking[0].AStarGreedy[j];
                    Found = true;
                    return true;
                }
            }
            return false;
        }
        //Creation Table and deeper when there is not deeper or there is  
        public bool FoundOfCurrentTableNodeCastlingIJ(int i, int j, int[,] Tab, int Order, ref AllDraw THIS, ref bool Found)
        {
            //if (IsSupHuTrue(i, j, 0, 6))

            //when is null creation enough but empty and create deeper node 
            if (CastlingOnTable[i].CastlingThinking[0].AStarGreedy.Count == 0)
            {
                for (int h = 0; h <= j; h++)
                //satisfied of created deeper three
                {
                    var ah = Task.Factory.StartNew(() => BlitzNotValidFullGameThinkingTreePartThree(i, Order, 7));
                    ah.Wait();
                    ah.Dispose();
                }
                CastlingOnTable[i].CastlingThinking[0].AStarGreedy[j].TableList.Clear();
                CastlingOnTable[i].CastlingThinking[0].AStarGreedy[j].TableList.Add(CloneATable(CastlingOnTable[i].CastlingThinking[0].TableListCastling[j]));
                CastlingOnTable[i].CastlingThinking[0].AStarGreedy[j].SetRowColumn(0);
                CastlingOnTable[i].CastlingThinking[0].AStarGreedy[j].AStarGreedyString = this;
                THIS = CastlingOnTable[i].CastlingThinking[0].AStarGreedy[j];
                Found = true;
                return true;
            }//when is not deeper null and is less than j index create empty but create deeper node table
            else
                                    if (CastlingOnTable[i].CastlingThinking[0].AStarGreedy != null && CastlingOnTable[i].CastlingThinking[0].AStarGreedy.Count < j + 1)
            {
                for (int h = CastlingOnTable[i].CastlingThinking[0].AStarGreedy.Count; h <= j; h++)
                //satisfied of created deeper three
                {
                    var ah = Task.Factory.StartNew(() => BlitzNotValidFullGameThinkingTreePartThree(i, Order, 7));
                    ah.Wait();
                    ah.Dispose();
                }
                CastlingOnTable[i].CastlingThinking[0].AStarGreedy[j].TableList.Clear();
                CastlingOnTable[i].CastlingThinking[0].AStarGreedy[j].TableList.Add(CloneATable(CastlingOnTable[i].CastlingThinking[0].TableListCastling[j]));
                CastlingOnTable[i].CastlingThinking[0].AStarGreedy[j].SetRowColumn(0);
                CastlingOnTable[i].CastlingThinking[0].AStarGreedy[j].AStarGreedyString = this;
                THIS = CastlingOnTable[i].CastlingThinking[0].AStarGreedy[j];
                Found = true;
                return true;
            }//when is enough and determine about creation of empty deeper than deeper or return exist
            else
            {
                if (CastlingOnTable[i].CastlingThinking[0].AStarGreedy != null && CastlingOnTable[i].CastlingThinking[0].AStarGreedy.Count > j)
                {
                    THIS = CastlingOnTable[i].CastlingThinking[0].AStarGreedy[j];
                    Found = true;
                    return true;
                }
            }
            return false;
        }
        //determine about found of equality of lists of current alldraw and call determinition of deeper 
        public bool FoundOfCurrentTableNodeKing(int[,] Tab, int Order, ref AllDraw THIS, ref bool Found)
        {
            if (Order == 1)
            {
                for (int i = 0; KingOnTable != null && i < KingMidle; i++)
                {
                    for (int j = 0; KingOnTable[i] != null && KingOnTable[i].KingThinking != null && KingOnTable[i].KingThinking[0] != null && KingOnTable[i].KingThinking[0].TableListKing != null && KingOnTable[i].KingThinking[0].TableListKing.Count > j; j++)
                    {
                        bool ac = false;
                        var ah = Task.Factory.StartNew(() => ac = IsSupHuTrue(i, j, 0, 6));
                        ah.Wait();
                        ah.Dispose();
                        if (ac)
                            continue;
                        var ah1 = Task.Factory.StartNew(() => ac = ThinkingRefrigtzChessPortable.TableEqual(KingOnTable[i].KingThinking[0].TableListKing[j], Tab));
                        ah1.Wait();
                        ah1.Dispose();
                        if (ac)
                        {
                            AllDraw This = THIS;
                            bool fou = Found;
                            var ah2 = Task.Factory.StartNew(() => FoundOfCurrentTableNodeKingIJ(i, j, CloneATable(Tab), Order, ref This, ref fou));
                            ah2.Wait();
                            ah2.Dispose();
                            Found = fou;
                            THIS = This;
                            if (Found)
                                return Found;

                        }
                    }
                }
            }
            else
            {
                for (int i = KingMidle; KingOnTable != null && i < KingHigh; i++)
                {
                    for (int j = 0; KingOnTable[i] != null && KingOnTable[i].KingThinking != null && KingOnTable[i].KingThinking[0] != null && KingOnTable[i].KingThinking[0].TableListKing != null && KingOnTable[i].KingThinking[0].TableListKing.Count > j; j++)
                    {
                        bool ac = false;
                        var ah = Task.Factory.StartNew(() => ac = IsSupHuTrue(i, j, 0, 6));
                        ah.Wait();
                        ah.Dispose();
                        if (ac)
                            continue;
                        var ah1 = Task.Factory.StartNew(() => ac = ThinkingRefrigtzChessPortable.TableEqual(KingOnTable[i].KingThinking[0].TableListKing[j], Tab));
                        ah1.Wait();
                        ah1.Dispose();
                        if (ac)
                        {
                            AllDraw This = THIS;
                            bool fou = Found;
                            var ah2 = Task.Factory.StartNew(() => FoundOfCurrentTableNodeKingIJ(i, j, CloneATable(Tab), Order, ref This, ref fou));
                            ah2.Wait();
                            ah2.Dispose();
                            Found = fou;
                            THIS = This;
                            if (Found)
                                return Found;
                            if (Found)
                                return Found;
                        }
                    }
                }
            }
            return Found;
        }
        //determine about found of equality of lists of current alldraw and call determinition of deeper 
        public bool FoundOfCurrentTableNodeCastling(int[,] Tab, int Order, ref AllDraw THIS, ref bool Found)
        {
            if (Order == 1)
            {
                for (int i = 0; CastlingOnTable != null && i < 1; i++)
                {
                    for (int j = 0; CastlingOnTable[i] != null && CastlingOnTable[i].CastlingThinking != null && CastlingOnTable[i].CastlingThinking[0] != null && CastlingOnTable[i].CastlingThinking[0].TableListCastling != null && CastlingOnTable[i].CastlingThinking[0].TableListCastling.Count > j; j++)
                    {
                        bool ac = false;
                        var ah = Task.Factory.StartNew(() => ac = IsSupHuTrue(i, j, 0, 7));
                        ah.Wait();
                        ah.Dispose();
                        if (ac)
                            continue;
                        var ah1 = Task.Factory.StartNew(() => ac = ThinkingRefrigtzChessPortable.TableEqual(CastlingOnTable[i].CastlingThinking[0].TableListCastling[j], Tab));
                        ah1.Wait();
                        ah1.Dispose();
                        if (ac)
                        {
                            AllDraw This = THIS;
                            bool fou = Found;
                            var ah2 = Task.Factory.StartNew(() => FoundOfCurrentTableNodeCastlingIJ(i, j, CloneATable(Tab), Order, ref This, ref fou));
                            ah2.Wait();
                            ah2.Dispose();
                            Found = fou;
                            THIS = This;
                            if (Found)
                                return Found;

                        }
                    }
                }
            }
            else
            {
                for (int i = 0; CastlingOnTable != null && i < 1; i++)
                {
                    for (int j = 0; CastlingOnTable[i] != null && CastlingOnTable[i].CastlingThinking != null && CastlingOnTable[i].CastlingThinking[0] != null && CastlingOnTable[i].CastlingThinking[0].TableListCastling != null && CastlingOnTable[i].CastlingThinking[0].TableListCastling.Count > j; j++)
                    {
                        bool ac = false;
                        var ah = Task.Factory.StartNew(() => ac = IsSupHuTrue(i, j, 0, -7));
                        ah.Wait();
                        ah.Dispose();
                        if (ac)
                            continue;
                        var ah1 = Task.Factory.StartNew(() => ac = ThinkingRefrigtzChessPortable.TableEqual(CastlingOnTable[i].CastlingThinking[0].TableListCastling[j], Tab));
                        ah1.Wait();
                        ah1.Dispose();
                        if (ac)
                        {
                            AllDraw This = THIS;
                            bool fou = Found;
                            var ah2 = Task.Factory.StartNew(() => FoundOfCurrentTableNodeCastlingIJ(i, j, CloneATable(Tab), Order, ref This, ref fou));
                            ah2.Wait();
                            ah2.Dispose();
                            Found = fou;
                            THIS = This;
                            if (Found)
                                return Found;
                            if (Found)
                                return Found;
                        }
                    }
                }
            }
            return Found;
        }
        public AllDraw FoundOfLeafDepenOfKindSoldier(int i, ref AllDraw Leaf, ref bool Found, int Order, int LeafDeep, int ik, int jk, int iii, int jjj)
        {
            Object a = new Object();
            lock (a)
            {
                //when found return recursive
                if (Found)
                    return Leaf;

                for (var j = 0; SolderesOnTable != null && SolderesOnTable[i] != null && SolderesOnTable[i].SoldierThinking[0] != null && j < SolderesOnTable[i].SoldierThinking[0].TableListSolder.Count; j++)
                {
                    bool ac = false;
                    var ah = Task.Factory.StartNew(() => ac = IsSupHuTrue(i, j, 0, 1));
                    ah.Wait();
                    ah.Dispose();
                    if (ac)
                        continue;
                    //when leaf found set refer bool and alldraw refer objects
                    if ((!SolderesOnTableMove[i]) && SolderesOnTable[i].SoldierThinking[0].AStarGreedy.Count > j// && Kind == 1
                    )
                    {

                        if (Order == 1)
                        {
                            for (var k = 0; SolderesOnTable != null && SolderesOnTable[i] != null && SolderesOnTable[i].SoldierThinking[0] != null && k < SolderesOnTable[i].SoldierThinking[0].AStarGreedy[j].SodierMidle; k++)
                            {
                                if (!SolderesOnTable[i].SoldierThinking[0].AStarGreedy[j].SolderesOnTableMove[k])
                                {
                                    //StoreInitMaxAStarGreedy = CurrentMaxLevel; MaxAStarGreedy = CurrentMaxLevel;
                                    Color aa = Color.Gray;
                                    if (Order * -1 == -1)
                                        aa = Color.Brown;
                                    var H = Task.Factory.StartNew(() => SolderesOnTable[i].SoldierThinking[0].AStarGreedy[j].InitiateAStarGreedyt(PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, 0, 0, aa, CloneATable(SolderesOnTable[i].SoldierThinking[0].TableListSolder[j]), Order * -1, false, false, 0));
                                    H.Wait();
                                    H.Dispose();
                                    SolderesOnTable[i].SoldierThinking[0].AStarGreedy[j].AStarGreedyString = this;
                                    Leaf = SolderesOnTable[i].SoldierThinking[0].AStarGreedy[j];
                                    Found = true;
                                    return Leaf;
                                }
                            }
                        }
                        else
                        {
                            for (var k = SolderesOnTable[i].SoldierThinking[0].AStarGreedy[j].SodierMidle; SolderesOnTable != null && SolderesOnTable[i] != null && SolderesOnTable[i].SoldierThinking[0] != null && k < SolderesOnTable[i].SoldierThinking[0].AStarGreedy[j].SodierHigh; k++)
                            {
                                if (!SolderesOnTable[i].SoldierThinking[0].AStarGreedy[j].SolderesOnTableMove[k])
                                {
                                    //StoreInitMaxAStarGreedy = CurrentMaxLevel; MaxAStarGreedy = CurrentMaxLevel;
                                    Color aa = Color.Gray;
                                    if (Order * -1 == -1)
                                        aa = Color.Brown;
                                    var H = Task.Factory.StartNew(() => SolderesOnTable[i].SoldierThinking[0].AStarGreedy[j].InitiateAStarGreedyt(PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, 0, 0, aa, CloneATable(SolderesOnTable[i].SoldierThinking[0].TableListSolder[j]), Order * -1, false, false, 0));
                                    H.Wait();
                                    H.Dispose();
                                    SolderesOnTable[i].SoldierThinking[0].AStarGreedy[j].AStarGreedyString = this;

                                    Leaf = SolderesOnTable[i].SoldierThinking[0].AStarGreedy[j];
                                    Found = true;
                                    return Leaf;
                                }
                            }
                        }
                    }
                    else//deeper
                        for (var ii = 0; ii < SolderesOnTable[i].SoldierThinking[0].AStarGreedy.Count; ii++)
                            SolderesOnTable[i].SoldierThinking[0].AStarGreedy[ii].FoundOfLeafDepenOfKind(ref Leaf, ref Found, Order * -1, LeafDeep++, ik, jk, iii, jjj);

                }

                return Leaf;
            }
        }
        public AllDraw FoundOfLeafDepenOfKindElephant(int i, ref AllDraw Leaf, ref bool Found, int Order, int LeafDeep, int ik, int jk, int iii, int jjj)
        {
            Object a = new Object();
            lock (a)
            {
                //when found return recursive
                if (Found)
                    return Leaf;

                for (var j = 0; ElephantOnTable != null && ElephantOnTable[i] != null && ElephantOnTable[i].ElefantThinking[0] != null && j < ElephantOnTable[i].ElefantThinking[0].TableListElefant.Count; j++)
                {
                    bool ac = false;
                    var ah = Task.Factory.StartNew(() => ac = IsSupHuTrue(i, j, 0, 2));
                    ah.Wait();
                    ah.Dispose();
                    if (ac)
                        continue;
                    //when leaf found set refer bool and alldraw refer objects
                    if ((!ElephantOnTableMove[i]) && ElephantOnTable[i].ElefantThinking[0].AStarGreedy.Count > j// && Kind == 1
                    )
                    {

                        if (Order == 1)
                        {
                            for (var k = 0; ElephantOnTable != null && ElephantOnTable[i] != null && ElephantOnTable[i].ElefantThinking[0] != null && k < ElephantOnTable[i].ElefantThinking[0].AStarGreedy[j].ElefantMidle; k++)
                            {
                                if (!ElephantOnTable[i].ElefantThinking[0].AStarGreedy[j].ElephantOnTableMove[k])
                                {
                                    //StoreInitMaxAStarGreedy = CurrentMaxLevel; MaxAStarGreedy = CurrentMaxLevel;
                                    Color aa = Color.Gray;
                                    if (Order * -1 == -1)
                                        aa = Color.Brown;
                                    var H = Task.Factory.StartNew(() => ElephantOnTable[i].ElefantThinking[0].AStarGreedy[j].InitiateAStarGreedyt(PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, 0, 0, aa, CloneATable(ElephantOnTable[i].ElefantThinking[0].TableListElefant[j]), Order * -1, false, false, 0));
                                    H.Wait();
                                    H.Dispose();
                                    ElephantOnTable[i].ElefantThinking[0].AStarGreedy[j].AStarGreedyString = this;
                                    Leaf = ElephantOnTable[i].ElefantThinking[0].AStarGreedy[j];
                                    Found = true;
                                    return Leaf;
                                }
                            }
                        }
                        else
                        {
                            for (var k = ElephantOnTable[i].ElefantThinking[0].AStarGreedy[j].ElefantMidle; ElephantOnTable != null && ElephantOnTable[i] != null && ElephantOnTable[i].ElefantThinking[0] != null && k < ElephantOnTable[i].ElefantThinking[0].AStarGreedy[j].ElefantHigh; k++)
                            {
                                if (!ElephantOnTable[i].ElefantThinking[0].AStarGreedy[j].ElephantOnTableMove[k])
                                {
                                    //StoreInitMaxAStarGreedy = CurrentMaxLevel; MaxAStarGreedy = CurrentMaxLevel;
                                    Color aa = Color.Gray;
                                    if (Order * -1 == -1)
                                        aa = Color.Brown;
                                    var H = Task.Factory.StartNew(() => ElephantOnTable[i].ElefantThinking[0].AStarGreedy[j].InitiateAStarGreedyt(PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, 0, 0, aa, CloneATable(ElephantOnTable[i].ElefantThinking[0].TableListElefant[j]), Order * -1, false, false, 0));
                                    ElephantOnTable[i].ElefantThinking[0].AStarGreedy[j].AStarGreedyString = this;
                                    H.Wait();
                                    H.Dispose();
                                    Leaf = ElephantOnTable[i].ElefantThinking[0].AStarGreedy[j];
                                    Found = true;
                                    return Leaf;
                                }
                            }
                        }
                    }
                    else//deeper
                        for (var ii = 0; ii < ElephantOnTable[i].ElefantThinking[0].AStarGreedy.Count; ii++)
                            ElephantOnTable[i].ElefantThinking[0].AStarGreedy[ii].FoundOfLeafDepenOfKind(ref Leaf, ref Found, Order * -1, LeafDeep++, ik, jk, iii, jjj);

                }
                return Leaf;
            }
        }
        public AllDraw FoundOfLeafDepenOfKindHourse(int i, ref AllDraw Leaf, ref bool Found, int Order, int LeafDeep, int ik, int jk, int iii, int jjj)
        {
            Object a = new Object();
            lock (a)
            {
                //when found return recursive
                if (Found)
                    return Leaf;
                for (var j = 0; HoursesOnTable != null && HoursesOnTable[i] != null && HoursesOnTable[i].HourseThinking[0] != null && j < HoursesOnTable[i].HourseThinking[0].TableListHourse.Count; j++)
                {
                    bool ac = false;
                    var ah = Task.Factory.StartNew(() => ac = IsSupHuTrue(i, j, 0, 3));
                    ah.Wait();
                    ah.Dispose();
                    if (ac)
                        continue;
                    //when leaf found set refer bool and alldraw refer objects
                    if ((!HoursesOnTableMove[i]) && HoursesOnTable[i].HourseThinking[0].AStarGreedy.Count > j// && Kind == 1
                    )
                    {

                        if (Order == 1)
                        {
                            for (var k = 0; HoursesOnTable != null && HoursesOnTable[i] != null && HoursesOnTable[i].HourseThinking[0] != null && k < HoursesOnTable[i].HourseThinking[0].AStarGreedy[j].HourseMidle; k++)
                            {
                                if (!HoursesOnTable[i].HourseThinking[0].AStarGreedy[j].HoursesOnTableMove[k])
                                {
                                    //StoreInitMaxAStarGreedy = CurrentMaxLevel; MaxAStarGreedy = CurrentMaxLevel;
                                    Color aa = Color.Gray;
                                    if (Order * -1 == -1)
                                        aa = Color.Brown;
                                    var H = Task.Factory.StartNew(() => HoursesOnTable[i].HourseThinking[0].AStarGreedy[j].InitiateAStarGreedyt(PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, 0, 0, aa, CloneATable(HoursesOnTable[i].HourseThinking[0].TableListHourse[j]), Order * -1, false, false, 0));
                                    H.Wait();
                                    H.Dispose();
                                    HoursesOnTable[i].HourseThinking[0].AStarGreedy[j].AStarGreedyString = this;
                                    Leaf = HoursesOnTable[i].HourseThinking[0].AStarGreedy[j];
                                    Found = true;
                                    return Leaf;
                                }
                            }
                        }
                        else
                        {
                            for (var k = HoursesOnTable[i].HourseThinking[0].AStarGreedy[j].HourseMidle; HoursesOnTable != null && HoursesOnTable[i] != null && HoursesOnTable[i].HourseThinking[0] != null && k < HoursesOnTable[i].HourseThinking[0].AStarGreedy[j].HourseHight; k++)
                            {
                                if (!HoursesOnTable[i].HourseThinking[0].AStarGreedy[j].HoursesOnTableMove[k])
                                {
                                    //StoreInitMaxAStarGreedy = CurrentMaxLevel; MaxAStarGreedy = CurrentMaxLevel;
                                    Color aa = Color.Gray;
                                    if (Order * -1 == -1)
                                        aa = Color.Brown;
                                    var H = Task.Factory.StartNew(() => HoursesOnTable[i].HourseThinking[0].AStarGreedy[j].InitiateAStarGreedyt(PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, 0, 0, aa, CloneATable(HoursesOnTable[i].HourseThinking[0].TableListHourse[j]), Order * -1, false, false, 0));
                                    H.Wait();
                                    H.Dispose();
                                    HoursesOnTable[i].HourseThinking[0].AStarGreedy[j].AStarGreedyString = this;
                                    Leaf = HoursesOnTable[i].HourseThinking[0].AStarGreedy[j];
                                    Found = true;
                                    return Leaf;
                                }
                            }
                        }
                    }
                    else//deeper
                        for (var ii = 0; ii < HoursesOnTable[i].HourseThinking[0].AStarGreedy.Count; ii++)
                            HoursesOnTable[i].HourseThinking[0].AStarGreedy[ii].FoundOfLeafDepenOfKind(ref Leaf, ref Found, Order * -1, LeafDeep++, ik, jk, iii, jjj);

                }


                return Leaf;
            }
        }
        public AllDraw FoundOfLeafDepenOfKindCastle(int i, ref AllDraw Leaf, ref bool Found, int Order, int LeafDeep, int ik, int jk, int iii, int jjj)
        {
            Object a = new Object();
            lock (a)
            {
                //when found return recursive
                if (Found)
                    return Leaf;
                for (var j = 0; CastlesOnTable != null && CastlesOnTable[i] != null && CastlesOnTable[i].CastleThinking[0] != null && j < CastlesOnTable[i].CastleThinking[0].TableListCastle.Count; j++)
                {
                    bool ac = false;
                    var ah = Task.Factory.StartNew(() => ac = IsSupHuTrue(i, j, 0, 4));
                    ah.Wait();
                    ah.Dispose();
                    if (ac)
                        continue;

                    //when leaf found set refer bool and alldraw refer objects
                    if ((!CastlesOnTableMove[i]) && CastlesOnTable[i].CastleThinking[0].AStarGreedy.Count > j// && Kind == 1
                    )
                    {

                        if (Order == 1)
                        {
                            for (var k = 0; CastlesOnTable != null && CastlesOnTable[i] != null && CastlesOnTable[i].CastleThinking[0] != null && k < CastlesOnTable[i].CastleThinking[0].AStarGreedy[j].CastleMidle; k++)
                            {
                                if (!CastlesOnTable[i].CastleThinking[0].AStarGreedy[j].CastlesOnTableMove[k])
                                {
                                    //StoreInitMaxAStarGreedy = CurrentMaxLevel; MaxAStarGreedy = CurrentMaxLevel;
                                    Color aa = Color.Gray;
                                    if (Order * -1 == -1)
                                        aa = Color.Brown;
                                    var H = Task.Factory.StartNew(() => CastlesOnTable[i].CastleThinking[0].AStarGreedy[j].InitiateAStarGreedyt(PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, 0, 0, aa, CloneATable(CastlesOnTable[i].CastleThinking[0].TableListCastle[j]), Order * -1, false, false, 0));
                                    H.Wait();
                                    H.Dispose();
                                    CastlesOnTable[i].CastleThinking[0].AStarGreedy[j].AStarGreedyString = this;
                                    Leaf = CastlesOnTable[i].CastleThinking[0].AStarGreedy[j];
                                    Found = true;
                                    return Leaf;
                                }
                            }
                        }
                        else
                        {
                            for (var k = CastlesOnTable[i].CastleThinking[0].AStarGreedy[j].CastleMidle; CastlesOnTable != null && CastlesOnTable[i] != null && CastlesOnTable[i].CastleThinking[0] != null && k < CastlesOnTable[i].CastleThinking[0].AStarGreedy[j].CastleHigh; k++)
                            {
                                if (!CastlesOnTable[i].CastleThinking[0].AStarGreedy[j].CastlesOnTableMove[k])
                                {
                                    //StoreInitMaxAStarGreedy = CurrentMaxLevel; MaxAStarGreedy = CurrentMaxLevel;
                                    Color aa = Color.Gray;
                                    if (Order * -1 == -1)
                                        aa = Color.Brown;
                                    var H = Task.Factory.StartNew(() => CastlesOnTable[i].CastleThinking[0].AStarGreedy[j].InitiateAStarGreedyt(PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, 0, 0, aa, CloneATable(CastlesOnTable[i].CastleThinking[0].TableListCastle[j]), Order * -1, false, false, 0));
                                    H.Wait();
                                    H.Dispose();
                                    CastlesOnTable[i].CastleThinking[0].AStarGreedy[j].AStarGreedyString = this;
                                    Leaf = CastlesOnTable[i].CastleThinking[0].AStarGreedy[j];
                                    Found = true;
                                    return Leaf;
                                }
                            }
                        }
                    }
                    else//deeper
                        for (var ii = 0; ii < CastlesOnTable[i].CastleThinking[0].AStarGreedy.Count; ii++)
                            CastlesOnTable[i].CastleThinking[0].AStarGreedy[ii].FoundOfLeafDepenOfKind(ref Leaf, ref Found, Order * -1, LeafDeep++, ik, jk, iii, jjj);
                }

                return Leaf;
            }
        }
        public AllDraw FoundOfLeafDepenOfKindMinister(int i, ref AllDraw Leaf, ref bool Found, int Order, int LeafDeep, int ik, int jk, int iii, int jjj)
        {
            Object a = new Object();
            lock (a)
            {
                //when found return recursive
                if (Found)
                    return Leaf;
                for (var j = 0; MinisterOnTable != null && MinisterOnTable[i] != null && MinisterOnTable[i].MinisterThinking[0] != null && j < MinisterOnTable[i].MinisterThinking[0].TableListMinister.Count; j++)
                {
                    bool ac = false;
                    var ah = Task.Factory.StartNew(() => ac = IsSupHuTrue(i, j, 0, 5));
                    ah.Wait();
                    ah.Dispose();
                    if (ac)
                        continue;
                    //when leaf found set refer bool and alldraw refer objects
                    if ((!MinisterOnTableMove[i]) && MinisterOnTable[i].MinisterThinking[0].AStarGreedy.Count > j// && Kind == 1
                    )
                    {

                        if (Order == 1)
                        {
                            for (var k = 0; MinisterOnTable != null && MinisterOnTable[i] != null && MinisterOnTable[i].MinisterThinking[0] != null && k < MinisterOnTable[i].MinisterThinking[0].AStarGreedy[j].MinisterMidle; k++)
                            {
                                if (!MinisterOnTable[i].MinisterThinking[0].AStarGreedy[j].MinisterOnTableMove[k])
                                {
                                    //StoreInitMaxAStarGreedy = CurrentMaxLevel; MaxAStarGreedy = CurrentMaxLevel;
                                    Color aa = Color.Gray;
                                    if (Order * -1 == -1)
                                        aa = Color.Brown;
                                    var H = Task.Factory.StartNew(() => MinisterOnTable[i].MinisterThinking[0].AStarGreedy[j].InitiateAStarGreedyt(PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, 0, 0, aa, CloneATable(MinisterOnTable[i].MinisterThinking[0].TableListMinister[j]), Order * -1, false, false, 0));
                                    H.Wait();
                                    H.Dispose();
                                    MinisterOnTable[i].MinisterThinking[0].AStarGreedy[j].AStarGreedyString = this;
                                    Leaf = MinisterOnTable[i].MinisterThinking[0].AStarGreedy[j];
                                    Found = true;
                                    return Leaf;
                                }
                            }
                        }
                        else
                        {
                            for (var k = MinisterOnTable[i].MinisterThinking[0].AStarGreedy[j].MinisterMidle; MinisterOnTable != null && MinisterOnTable[i] != null && MinisterOnTable[i].MinisterThinking[0] != null && k < MinisterOnTable[i].MinisterThinking[0].AStarGreedy[j].MinisterHigh; k++)
                            {
                                if (!MinisterOnTable[i].MinisterThinking[0].AStarGreedy[j].MinisterOnTableMove[k])
                                {
                                    //StoreInitMaxAStarGreedy = CurrentMaxLevel; MaxAStarGreedy = CurrentMaxLevel;
                                    Color aa = Color.Gray;
                                    if (Order * -1 == -1)
                                        aa = Color.Brown;
                                    var H = Task.Factory.StartNew(() => MinisterOnTable[i].MinisterThinking[0].AStarGreedy[j].InitiateAStarGreedyt(PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, 0, 0, aa, CloneATable(MinisterOnTable[i].MinisterThinking[0].TableListMinister[j]), Order * -1, false, false, 0));
                                    H.Wait();
                                    H.Dispose();
                                    MinisterOnTable[i].MinisterThinking[0].AStarGreedy[j].AStarGreedyString = this;
                                    Leaf = MinisterOnTable[i].MinisterThinking[0].AStarGreedy[j];
                                    Found = true;
                                    return Leaf;
                                }
                            }
                        }
                    }
                    else//deeper
                        for (var ii = 0; ii < MinisterOnTable[i].MinisterThinking[0].AStarGreedy.Count; ii++)
                            MinisterOnTable[i].MinisterThinking[0].AStarGreedy[ii].FoundOfLeafDepenOfKind(ref Leaf, ref Found, Order * -1, LeafDeep++, ik, jk, iii, jjj);

                }

                return Leaf;
            }
        }
        public AllDraw FoundOfLeafDepenOfKindKing(int i, ref AllDraw Leaf, ref bool Found, int Order, int LeafDeep, int ik, int jk, int iii, int jjj)
        {
            Object a = new Object();
            lock (a)
            {
                //when found return recursive
                if (Found)
                    return Leaf;
                for (var j = 0; KingOnTable != null && KingOnTable[i] != null && KingOnTable[i].KingThinking[0] != null && j < KingOnTable[i].KingThinking[0].TableListKing.Count; j++)
                {
                    bool ac = false;
                    var ah = Task.Factory.StartNew(() => ac = IsSupHuTrue(i, j, 0, 6));
                    ah.Wait();
                    ah.Dispose();
                    if (ac)
                        continue;
                    //when leaf found set refer bool and alldraw refer objects
                    if ((!KingOnTableMove[i]) && KingOnTable[i].KingThinking[0].AStarGreedy.Count > j// && Kind == 1
                    )
                    {

                        if (Order == 1)
                        {
                            for (var k = 0; KingOnTable != null && KingOnTable[i] != null && KingOnTable[i].KingThinking[0] != null && k < KingOnTable[i].KingThinking[0].AStarGreedy[j].KingMidle; k++)
                            {
                                if (!KingOnTable[i].KingThinking[0].AStarGreedy[j].KingOnTableMove[k])
                                {
                                    //StoreInitMaxAStarGreedy = CurrentMaxLevel; MaxAStarGreedy = CurrentMaxLevel;
                                    Color aa = Color.Gray;
                                    if (Order * -1 == -1)
                                        aa = Color.Brown;
                                    var H = Task.Factory.StartNew(() => KingOnTable[i].KingThinking[0].AStarGreedy[j].InitiateAStarGreedyt(PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, 0, 0, aa, CloneATable(KingOnTable[i].KingThinking[0].TableListKing[j]), Order * -1, false, false, 0));
                                    H.Wait();
                                    H.Dispose();
                                    KingOnTable[i].KingThinking[0].AStarGreedy[j].AStarGreedyString = this;
                                    Leaf = KingOnTable[i].KingThinking[0].AStarGreedy[j];
                                    Found = true;
                                    return Leaf;
                                }
                            }
                        }
                        else
                        {
                            for (var k = KingOnTable[i].KingThinking[0].AStarGreedy[j].KingMidle; KingOnTable != null && KingOnTable[i] != null && KingOnTable[i].KingThinking[0] != null && k < KingOnTable[i].KingThinking[0].AStarGreedy[j].KingHigh; k++)
                            {
                                if (!KingOnTable[i].KingThinking[0].AStarGreedy[j].KingOnTableMove[k])
                                {
                                    //StoreInitMaxAStarGreedy = CurrentMaxLevel; MaxAStarGreedy = CurrentMaxLevel;
                                    Color aa = Color.Gray;
                                    if (Order * -1 == -1)
                                        aa = Color.Brown;
                                    var H = Task.Factory.StartNew(() => KingOnTable[i].KingThinking[0].AStarGreedy[j].InitiateAStarGreedyt(PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, 0, 0, aa, CloneATable(KingOnTable[i].KingThinking[0].TableListKing[j]), Order * -1, false, false, 0));
                                    H.Wait();
                                    H.Dispose();
                                    KingOnTable[i].KingThinking[0].AStarGreedy[j].AStarGreedyString = this;
                                    Leaf = KingOnTable[i].KingThinking[0].AStarGreedy[j];
                                    Found = true;
                                    return Leaf;
                                }
                            }
                        }
                    }
                    else//deeper
                        for (var ii = 0; ii < KingOnTable[i].KingThinking[0].AStarGreedy.Count; ii++)
                            KingOnTable[i].KingThinking[0].AStarGreedy[ii].FoundOfLeafDepenOfKind(ref Leaf, ref Found, Order * -1, LeafDeep++, ik, jk, iii, jjj);

                }

                return Leaf;
            }
        }
        public AllDraw FoundOfLeafDepenOfKindCastling(int i, ref AllDraw Leaf, ref bool Found, int Order, int LeafDeep, int ik, int jk, int iii, int jjj)
        {
            Object a = new Object();
            lock (a)
            {
                //when found return recursive
                if (Found)
                    return Leaf;
                for (var j = 0; CastlingOnTable != null && CastlingOnTable[i] != null && CastlingOnTable[i].CastlingThinking[0] != null && j < CastlingOnTable[i].CastlingThinking[0].TableListCastling.Count; j++)
                {
                    bool ac = false;
                    var ah = Task.Factory.StartNew(() => ac = IsSupHuTrue(i, j, 0, 7));
                    ah.Wait();
                    ah.Dispose();
                    if (ac)
                        continue;
                    //when leaf found set refer bool and alldraw refer objects
                    if ((!CastlingOnTableMove[i]) && CastlingOnTable[i].CastlingThinking[0].AStarGreedy.Count > j// && Kind == 1
                    )
                    {

                        if (Order == 1)
                        {
                            for (var k = 0; CastlingOnTable != null && CastlingOnTable[i] != null && CastlingOnTable[i].CastlingThinking[0] != null && k < 1; k++)
                            {
                                if (!CastlingOnTable[i].CastlingThinking[0].AStarGreedy[j].CastlingOnTableMove[k])
                                {
                                    //StoreInitMaxAStarGreedy = CurrentMaxLevel; MaxAStarGreedy = CurrentMaxLevel;
                                    Color aa = Color.Gray;
                                    if (Order * -1 == -1)
                                        aa = Color.Brown;
                                    var H = Task.Factory.StartNew(() => CastlingOnTable[i].CastlingThinking[0].AStarGreedy[j].InitiateAStarGreedyt(PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, 0, 0, aa, CloneATable(CastlingOnTable[i].CastlingThinking[0].TableListCastling[j]), Order * -1, false, false, 0));
                                    H.Wait();
                                    H.Dispose();
                                    CastlingOnTable[i].CastlingThinking[0].AStarGreedy[j].AStarGreedyString = this;
                                    Leaf = CastlingOnTable[i].CastlingThinking[0].AStarGreedy[j];
                                    Found = true;
                                    return Leaf;
                                }
                            }
                        }
                        else
                        {
                            for (var k = 0; CastlingOnTable != null && CastlingOnTable[i] != null && CastlingOnTable[i].CastlingThinking[0] != null && k < 1; k++)
                            {
                                if (!CastlingOnTable[i].CastlingThinking[0].AStarGreedy[j].CastlingOnTableMove[k])
                                {
                                    //StoreInitMaxAStarGreedy = CurrentMaxLevel; MaxAStarGreedy = CurrentMaxLevel;
                                    Color aa = Color.Gray;
                                    if (Order * -1 == -1)
                                        aa = Color.Brown;
                                    var H = Task.Factory.StartNew(() => CastlingOnTable[i].CastlingThinking[0].AStarGreedy[j].InitiateAStarGreedyt(PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, 0, 0, aa, CloneATable(CastlingOnTable[i].CastlingThinking[0].TableListCastling[j]), Order * -1, false, false, 0));
                                    H.Wait();
                                    H.Dispose();
                                    CastlingOnTable[i].CastlingThinking[0].AStarGreedy[j].AStarGreedyString = this;
                                    Leaf = CastlingOnTable[i].CastlingThinking[0].AStarGreedy[j];
                                    Found = true;
                                    return Leaf;
                                }
                            }
                        }
                    }
                    else//deeper
                        for (var ii = 0; ii < CastlingOnTable[i].CastlingThinking[0].AStarGreedy.Count; ii++)
                            CastlingOnTable[i].CastlingThinking[0].AStarGreedy[ii].FoundOfLeafDepenOfKind(ref Leaf, ref Found, Order * -1, LeafDeep++, ik, jk, iii, jjj);

                }

                return Leaf;
            }
        }
        //found of leadfs of created tree depend of orderic 
        public AllDraw FoundOfLeafDepenOfKind(ref AllDraw Leaf, ref bool Found, int Order, int LeafDeep, int ik, int jk, int iii, int jjj)
        {

            Object a = new Object();
            lock (a)
            {
                // if (LeafDeep > MaxAStarGreedy)
                //  return Leaf;
                if (FullBoundryConditions(CurrentAStarGredyMax, Order, 0))
                    return Leaf;
                //LeafDeep++;
                //when found return recursive
                if (UniqueLeafDetection)
                {
                    if (Found)
                        return Leaf;
                }   //Gray
                if (Order == 1)
                {
                    for (var i = 0; i < SodierMidle; i++)
                    {
                        AllDraw le = Leaf;
                        bool fou = Found;
                        var ah = Task.Factory.StartNew(() => FoundOfLeafDepenOfKindSoldier(i, ref le, ref fou, Order, LeafDeep, ik, jk, iii, jjj));
                        ah.Wait();
                        ah.Dispose();
                        Leaf = le;
                        Found = fou;
                    }

                    if (UniqueLeafDetection)
                    {
                        if (Found)
                            return Leaf;
                    }
                    for (var i = 0; i < ElefantMidle; i++)
                    {
                        AllDraw le = Leaf;
                        bool fou = Found;
                        var ah = Task.Factory.StartNew(() => FoundOfLeafDepenOfKindElephant(i, ref le, ref fou, Order, LeafDeep, ik, jk, iii, jjj));
                        ah.Wait();
                        ah.Dispose();
                        Leaf = le;
                        Found = fou;
                    }
                    if (UniqueLeafDetection)
                    {
                        if (Found)
                            return Leaf;
                    }
                    for (var i = 0; i < HourseMidle; i++)
                    {
                        AllDraw le = Leaf;
                        bool fou = Found;
                        var ah = Task.Factory.StartNew(() => FoundOfLeafDepenOfKindHourse(i, ref le, ref fou, Order, LeafDeep, ik, jk, iii, jjj));
                        ah.Wait();
                        ah.Dispose();
                        Leaf = le;
                        Found = fou;
                    }
                    if (UniqueLeafDetection)
                    {
                        if (Found)
                            return Leaf;
                    }
                    for (var i = 0; i < CastleMidle; i++)
                    {
                        AllDraw le = Leaf;
                        bool fou = Found;
                        var ah = Task.Factory.StartNew(() => FoundOfLeafDepenOfKindCastle(i, ref le, ref fou, Order, LeafDeep, ik, jk, iii, jjj));
                        ah.Wait();
                        ah.Dispose();
                        Leaf = le;
                        Found = fou;
                    }
                    if (UniqueLeafDetection)
                    {
                        if (Found)
                            return Leaf;
                    }
                    for (var i = 0; i < MinisterMidle; i++)
                    {
                        AllDraw le = Leaf;
                        bool fou = Found;
                        var ah = Task.Factory.StartNew(() => FoundOfLeafDepenOfKindMinister(i, ref le, ref fou, Order, LeafDeep, ik, jk, iii, jjj));
                        ah.Wait();
                        ah.Dispose();
                        Leaf = le;
                        Found = fou;
                    }
                    if (UniqueLeafDetection)
                    {
                        if (Found)
                            return Leaf;
                    }
                    for (var i = 0; i < KingMidle; i++)
                    {
                        AllDraw le = Leaf;
                        bool fou = Found;
                        var ah = Task.Factory.StartNew(() => FoundOfLeafDepenOfKindKing(i, ref le, ref fou, Order, LeafDeep, ik, jk, iii, jjj));
                        ah.Wait();
                        ah.Dispose();
                        Leaf = le;
                        Found = fou;
                    }
                    if (UniqueLeafDetection)
                    {
                        if (Found)
                            return Leaf;
                    }
                    for (var i = 0; i < 1; i++)
                    {
                        AllDraw le = Leaf;
                        bool fou = Found;
                        var ah = Task.Factory.StartNew(() => FoundOfLeafDepenOfKindCastling(i, ref le, ref fou, Order, LeafDeep, ik, jk, iii, jjj));
                        ah.Wait();
                        ah.Dispose();
                        Leaf = le;
                        Found = fou;
                    }
                }
                else
                {
                    if (UniqueLeafDetection)
                    {
                        if (Found)
                            return Leaf;
                    }
                    for (var i = SodierMidle; i < SodierHigh; i++)
                    {
                        AllDraw le = Leaf;
                        bool fou = Found;
                        var ah = Task.Factory.StartNew(() => FoundOfLeafDepenOfKindSoldier(i, ref le, ref fou, Order, LeafDeep, ik, jk, iii, jjj));
                        ah.Wait();
                        ah.Dispose();
                        Leaf = le;
                        Found = fou;
                    }
                    if (UniqueLeafDetection)
                    {
                        if (Found)
                            return Leaf;
                    }
                    for (var i = ElefantMidle; i < ElefantHigh; i++)
                    {
                        AllDraw le = Leaf;
                        bool fou = Found;
                        var ah = Task.Factory.StartNew(() => FoundOfLeafDepenOfKindElephant(i, ref le, ref fou, Order, LeafDeep, ik, jk, iii, jjj));
                        ah.Wait();
                        ah.Dispose();
                        Leaf = le;
                        Found = fou;
                    }
                    if (UniqueLeafDetection)
                    {
                        if (Found)
                            return Leaf;
                    }
                    for (var i = HourseMidle; i < HourseHight; i++)
                    {
                        AllDraw le = Leaf;
                        bool fou = Found;
                        var ah = Task.Factory.StartNew(() => FoundOfLeafDepenOfKindHourse(i, ref le, ref fou, Order, LeafDeep, ik, jk, iii, jjj));
                        ah.Wait();
                        ah.Dispose();
                        Leaf = le;
                        Found = fou;
                    }
                    if (UniqueLeafDetection)
                    {
                        if (Found)
                            return Leaf;
                    }
                    for (var i = CastleMidle; i < CastleHigh; i++)
                    {
                        AllDraw le = Leaf;
                        bool fou = Found;
                        var ah = Task.Factory.StartNew(() => FoundOfLeafDepenOfKindCastle(i, ref le, ref fou, Order, LeafDeep, ik, jk, iii, jjj));
                        ah.Wait();
                        ah.Dispose();
                        Leaf = le;
                        Found = fou;
                    }
                    if (UniqueLeafDetection)
                    {
                        if (Found)
                            return Leaf;
                    }
                    for (var i = MinisterMidle; i < MinisterHigh; i++)
                    {
                        AllDraw le = Leaf;
                        bool fou = Found;
                        var ah = Task.Factory.StartNew(() => FoundOfLeafDepenOfKindMinister(i, ref le, ref fou, Order, LeafDeep, ik, jk, iii, jjj));
                        ah.Wait();
                        ah.Dispose();
                        Leaf = le;
                        Found = fou;
                    }
                    if (UniqueLeafDetection)
                    {
                        if (Found)
                            return Leaf;
                    }
                    for (var i = KingMidle; i < KingHigh; i++)
                    {
                        AllDraw le = Leaf;
                        bool fou = Found;
                        var ah = Task.Factory.StartNew(() => FoundOfLeafDepenOfKindKing(i, ref le, ref fou, Order, LeafDeep, ik, jk, iii, jjj));
                        ah.Wait();
                        ah.Dispose();
                        Leaf = le;
                        Found = fou;
                    }
                    if (UniqueLeafDetection)
                    {
                        if (Found)
                            return Leaf;
                    }
                    for (var i = 0; i < 1; i++)
                    {
                        AllDraw le = Leaf;
                        bool fou = Found;
                        var ah = Task.Factory.StartNew(() => FoundOfLeafDepenOfKindCastling(i, ref le, ref fou, Order, LeafDeep, ik, jk, iii, jjj));
                        ah.Wait();
                        ah.Dispose();
                        Leaf = le;
                        Found = fou;
                    }
                }

                return Leaf;
            }
        }
        //when leafs is vivtory target nodes return true found and set refrence
        public bool IsFoundOfLeafDepenOfKindhaveVictory(int Kind, ref bool Found, int Order)
        {

            Object a = new Object();
            lock (a)
            {
                //when found return recurve
                if (Found)
                    return true;
                //Gray
                if (Order == 1)
                {
                    //soldier
                    for (var i = 0; i < SodierMidle; i++)
                        for (var j = 0; SolderesOnTable != null && SolderesOnTable[i] != null && SolderesOnTable[i].SoldierThinking[0] != null && j < SolderesOnTable[i].SoldierThinking[0].TableListSolder.Count; j++)
                        {
                            //when is victory
                            if (SolderesOnTable[i].SoldierThinking[0].IsThereMateOfEnemy[j]// && SolderesOnTable[i].SoldierThinking[0].AStarGreedy.Count == 0 
                                && Kind == 1)
                            {
                                Found = true;

                                return true;
                            }
                            else//deeper
                                for (var ii = 0; ii < SolderesOnTable[i].SoldierThinking[0].AStarGreedy.Count; ii++)
                                {
                                    bool fou = Found;
                                    var ah = Task.Factory.StartNew(() => SolderesOnTable[i].SoldierThinking[0].AStarGreedy[ii].IsFoundOfLeafDepenOfKindhaveVictory(Kind, ref fou, Order * -1));
                                    ah.Wait();
                                    ah.Dispose();
                                    Found = fou;
                                }


                        }
                    //elephant
                    for (var i = 0; i < ElefantMidle; i++)
                        for (var j = 0; ElephantOnTable != null && ElephantOnTable[i] != null && ElephantOnTable[i].ElefantThinking[0] != null && j < ElephantOnTable[i].ElefantThinking[0].TableListElefant.Count; j++)
                        {
                            //when is victory
                            if (ElephantOnTable[i].ElefantThinking[0].IsThereMateOfEnemy[j] //&& ElephantOnTable[i].ElefantThinking[0].AStarGreedy.Count == 0 
                        && Kind == 2)
                            {
                                Found = true;

                                return true;
                            }
                            else//deeper
                                for (var ii = 0; ii < ElephantOnTable[i].ElefantThinking[0].AStarGreedy.Count; ii++)
                                {
                                    bool fou = Found;
                                    var ah = Task.Factory.StartNew(() => ElephantOnTable[i].ElefantThinking[0].AStarGreedy[ii].IsFoundOfLeafDepenOfKindhaveVictory(Kind, ref fou, Order * -1));
                                    ah.Wait();
                                    ah.Dispose();
                                    Found = fou;
                                }

                        }
                    //hourse
                    for (var i = 0; i < HourseMidle; i++)
                        for (var j = 0; HoursesOnTable != null && HoursesOnTable[i] != null && HoursesOnTable[i].HourseThinking[0] != null && j < HoursesOnTable[i].HourseThinking[0].TableListHourse.Count; j++)
                        {
                            //when is victory
                            if (HoursesOnTable[i].HourseThinking[0].IsThereMateOfEnemy[j] //&& HoursesOnTable[i].HourseThinking[0].AStarGreedy.Count == 0 
&& Kind == 3)
                            {
                                Found = true;

                                return true;
                            }
                            else//deeper
                                for (var ii = 0; ii < HoursesOnTable[i].HourseThinking[0].AStarGreedy.Count; ii++)
                                {
                                    bool fou = Found;
                                    var ah = Task.Factory.StartNew(() => HoursesOnTable[i].HourseThinking[0].AStarGreedy[ii].IsFoundOfLeafDepenOfKindhaveVictory(Kind, ref fou, Order * -1));
                                    ah.Wait();
                                    ah.Dispose();
                                    Found = fou;
                                }

                        }
                    //Castle
                    for (var i = 0; i < CastleMidle; i++)
                        for (var j = 0; CastlesOnTable != null && CastlesOnTable[i] != null && CastlesOnTable[i].CastleThinking[0] != null && j < CastlesOnTable[i].CastleThinking[0].TableListCastle.Count; j++)
                        {
                            //when is victory
                            if (CastlesOnTable[i].CastleThinking[0].IsThereMateOfEnemy[j] //&& CastlesOnTable[i].CastleThinking[0].AStarGreedy.Count == 0 
                                && Kind == 4)
                            {
                                Found = true;

                                return true;
                            }
                            else//deeper
                                for (var ii = 0; ii < CastlesOnTable[i].CastleThinking[0].AStarGreedy.Count; ii++)
                                {
                                    bool fou = Found;
                                    var ah = Task.Factory.StartNew(() => CastlesOnTable[i].CastleThinking[0].AStarGreedy[ii].IsFoundOfLeafDepenOfKindhaveVictory(Kind, ref fou, Order * -1));
                                    ah.Wait();
                                    ah.Dispose();
                                    Found = fou;
                                }

                        }
                    //minister
                    for (var i = 0; i < MinisterMidle; i++)
                        for (var j = 0; MinisterOnTable != null && MinisterOnTable[i] != null && MinisterOnTable[i].MinisterThinking[0] != null && j < MinisterOnTable[i].MinisterThinking[0].TableListMinister.Count; j++)
                        {
                            //when is victory
                            if (MinisterOnTable[i].MinisterThinking[0].IsThereMateOfEnemy[j] //&& MinisterOnTable[i].MinisterThinking[0].AStarGreedy.Count == 0 
                                && Kind == 5)
                            {
                                Found = true;

                                return true;
                            }
                            else//deeper
                                for (var ii = 0; ii < MinisterOnTable[i].MinisterThinking[0].AStarGreedy.Count; ii++)
                                {
                                    bool fou = Found;
                                    var ah = Task.Factory.StartNew(() => MinisterOnTable[i].MinisterThinking[0].AStarGreedy[ii].IsFoundOfLeafDepenOfKindhaveVictory(Kind, ref fou, Order * -1));
                                    ah.Wait();
                                    ah.Dispose();
                                    Found = fou;
                                }

                        }
                    //king
                    for (var i = 0; i < KingMidle; i++)
                        for (var j = 0; KingOnTable != null && KingOnTable[i] != null && KingOnTable[i].KingThinking[0] != null && j < KingOnTable[i].KingThinking[0].TableListKing.Count; j++)
                        {
                            //when is victory
                            if (KingOnTable[i].KingThinking[0].IsThereMateOfEnemy[j] //&& KingOnTable[i].KingThinking[0].AStarGreedy.Count == 0 
                                && Kind == 6)
                            {
                                Found = true;

                                return true;
                            }
                            else//deeper
                                for (var ii = 0; ii < KingOnTable[i].KingThinking[0].AStarGreedy.Count; ii++)
                                {
                                    bool fou = Found;
                                    var ah = Task.Factory.StartNew(() => KingOnTable[i].KingThinking[0].AStarGreedy[ii].IsFoundOfLeafDepenOfKindhaveVictory(Kind, ref fou, Order * -1));
                                    ah.Wait();
                                    ah.Dispose();
                                    Found = fou;
                                }

                        }
                    for (var i = 0; i < 1; i++)
                        for (var j = 0; CastlingOnTable != null && CastlingOnTable[i] != null && CastlingOnTable[i].CastlingThinking[0] != null && j < CastlingOnTable[i].CastlingThinking[0].TableListCastling.Count; j++)
                        {
                            //when is victory
                            if (CastlingOnTable[i].CastlingThinking[0].IsThereMateOfEnemy[j] //&& CastlingOnTable[i].CastlingThinking[0].AStarGreedy.Count == 0 
                                && (Kind == 7 || Kind == -7))
                            {
                                Found = true;

                                return true;
                            }
                            else//deeper
                                for (var ii = 0; ii < CastlingOnTable[i].CastlingThinking[0].AStarGreedy.Count; ii++)
                                {
                                    bool fou = Found;
                                    var ah = Task.Factory.StartNew(() => CastlingOnTable[i].CastlingThinking[0].AStarGreedy[ii].IsFoundOfLeafDepenOfKindhaveVictory(Kind, ref fou, Order * -1));
                                    ah.Wait();
                                    ah.Dispose();
                                    Found = fou;
                                }
                        }

                }
                else//Brown
                {
                    //soldier
                    for (var i = SodierMidle; i < SodierHigh; i++)
                        for (var j = 0; SolderesOnTable != null && SolderesOnTable[i] != null && SolderesOnTable[i].SoldierThinking != null && j < SolderesOnTable[i].SoldierThinking[0].TableListSolder.Count; j++)
                        {
                            //when is victory
                            if (SolderesOnTable[i].SoldierThinking[0].IsThereMateOfEnemy[j] //&& SolderesOnTable[i].SoldierThinking[0].AStarGreedy.Count == 0 
                                && Kind == 1)
                            {
                                Found = true;

                                return true;
                            }
                            else//deeper
                                for (var ii = 0; ii < SolderesOnTable[i].SoldierThinking[0].AStarGreedy.Count; ii++)
                                {
                                    bool fou = Found;
                                    var ah = Task.Factory.StartNew(() => SolderesOnTable[i].SoldierThinking[0].AStarGreedy[ii].IsFoundOfLeafDepenOfKindhaveVictory(Kind, ref fou, Order * -1));
                                    ah.Wait();
                                    ah.Dispose();
                                    Found = fou;
                                }
                        }
                    //elephant
                    for (var i = ElefantMidle; i < ElefantHigh; i++)
                        for (var j = 0; ElephantOnTable != null && ElephantOnTable[i] != null && ElephantOnTable[i].ElefantThinking[0] != null && j < ElephantOnTable[i].ElefantThinking[0].TableListElefant.Count; j++)
                        {
                            //when is victory
                            if (ElephantOnTable[i].ElefantThinking[0].IsThereMateOfEnemy[j] //&& ElephantOnTable[i].ElefantThinking[0].AStarGreedy.Count == 0 
                                && Kind == 2)
                            {
                                Found = true;

                                return true;
                            }
                            else//deeper
                                for (var ii = 0; ii < ElephantOnTable[i].ElefantThinking[0].AStarGreedy.Count; ii++)
                                {
                                    bool fou = Found;
                                    var ah = Task.Factory.StartNew(() => ElephantOnTable[i].ElefantThinking[0].AStarGreedy[ii].IsFoundOfLeafDepenOfKindhaveVictory(Kind, ref fou, Order * -1));
                                    ah.Wait();
                                    ah.Dispose();
                                    Found = fou;
                                }
                        }
                    //hourse
                    for (var i = HourseMidle; i < HourseHight; i++)
                        for (var j = 0; HoursesOnTable != null && HoursesOnTable[i] != null && HoursesOnTable[i].HourseThinking[0] != null && j < HoursesOnTable[i].HourseThinking[0].TableListHourse.Count; j++)
                        {
                            //when is victory
                            if (HoursesOnTable[i].HourseThinking[0].IsThereMateOfEnemy[j] //&& HoursesOnTable[i].HourseThinking[0].AStarGreedy.Count == 0 
                                && Kind == 3)
                            {
                                Found = true;

                                return true;
                            }
                            else//deeper
                                for (var ii = 0; ii < HoursesOnTable[i].HourseThinking[0].AStarGreedy.Count; ii++)
                                {
                                    bool fou = Found;
                                    var ah = Task.Factory.StartNew(() => HoursesOnTable[i].HourseThinking[0].AStarGreedy[ii].IsFoundOfLeafDepenOfKindhaveVictory(Kind, ref fou, Order * -1));
                                    ah.Wait();
                                    ah.Dispose();
                                    Found = fou;
                                }
                        }
                    //Castle
                    for (var i = CastleMidle; i < CastleHigh; i++)
                        for (var j = 0; CastlesOnTable != null && CastlesOnTable[i] != null && CastlesOnTable[i].CastleThinking[0] != null && j < CastlesOnTable[i].CastleThinking[0].TableListCastle.Count; j++)
                        {
                            //when is victory
                            if (CastlesOnTable[i].CastleThinking[0].IsThereMateOfEnemy[j] //&& CastlesOnTable[i].CastleThinking[0].AStarGreedy.Count == 0 
                                && Kind == 4)
                            {
                                Found = true;

                                return true;
                            }
                            else//deeper
                                for (var ii = 0; ii < CastlesOnTable[i].CastleThinking[0].AStarGreedy.Count; ii++)
                                {
                                    bool fou = Found;
                                    var ah = Task.Factory.StartNew(() => CastlesOnTable[i].CastleThinking[0].AStarGreedy[ii].IsFoundOfLeafDepenOfKindhaveVictory(Kind, ref fou, Order * -1));
                                    ah.Wait();
                                    ah.Dispose();
                                    Found = fou;
                                }
                        }
                    //minister
                    for (var i = MinisterMidle; i < MinisterHigh; i++)
                        for (var j = 0; MinisterOnTable != null && MinisterOnTable[i] != null && MinisterOnTable[i].MinisterThinking[0] != null && j < MinisterOnTable[i].MinisterThinking[0].TableListMinister.Count; j++)
                        {
                            //when is victory
                            if (MinisterOnTable[i].MinisterThinking[0].IsThereMateOfEnemy[j] //&& MinisterOnTable[i].MinisterThinking[0].AStarGreedy.Count == 0
                                && Kind == 5)
                            {
                                Found = true;

                                return true;
                            }
                            else//deeper
                                for (var ii = 0; ii < MinisterOnTable[i].MinisterThinking[0].AStarGreedy.Count; ii++)
                                {
                                    bool fou = Found;
                                    var ah = Task.Factory.StartNew(() => MinisterOnTable[i].MinisterThinking[0].AStarGreedy[ii].IsFoundOfLeafDepenOfKindhaveVictory(Kind, ref fou, Order * -1));
                                    ah.Wait();
                                    ah.Dispose();
                                    Found = fou;
                                }
                        }
                    //king
                    for (var i = KingMidle; i < KingHigh; i++)
                        for (var j = 0; KingOnTable != null && KingOnTable[i] != null && KingOnTable[i].KingThinking[0] != null && j < KingOnTable[i].KingThinking[0].TableListKing.Count; j++)
                        {
                            //when is victory
                            if (KingOnTable[i].KingThinking[0].IsThereMateOfEnemy[j] //&& KingOnTable[i].KingThinking[0].AStarGreedy.Count == 0 
                                && Kind == 6)
                            {
                                Found = true;

                                return true;
                            }
                            else//deeper
                                for (var ii = 0; ii < KingOnTable[i].KingThinking[0].AStarGreedy.Count; ii++)
                                {
                                    bool fou = Found;
                                    var ah = Task.Factory.StartNew(() => KingOnTable[i].KingThinking[0].AStarGreedy[ii].IsFoundOfLeafDepenOfKindhaveVictory(Kind, ref fou, Order * -1));
                                    ah.Wait();
                                    ah.Dispose();
                                    Found = fou;
                                }
                        }//king
                    for (var i = 0; i < 1; i++)
                        for (var j = 0; CastlingOnTable != null && CastlingOnTable[i] != null && CastlingOnTable[i].CastlingThinking[0] != null && j < CastlingOnTable[i].CastlingThinking[0].TableListCastling.Count; j++)
                        {
                            //when is victory
                            if (CastlingOnTable[i].CastlingThinking[0].IsThereMateOfEnemy[j] //&& CastlingOnTable[i].CastlingThinking[0].AStarGreedy.Count == 0 
                                && (Kind == 7 || Kind == -7))
                            {
                                Found = true;

                                return true;
                            }
                            else//deeper
                                for (var ii = 0; ii < CastlingOnTable[i].CastlingThinking[0].AStarGreedy.Count; ii++)
                                {
                                    bool fou = Found;
                                    var ah = Task.Factory.StartNew(() => CastlingOnTable[i].CastlingThinking[0].AStarGreedy[ii].IsFoundOfLeafDepenOfKindhaveVictory(Kind, ref fou, Order * -1));
                                    ah.Wait();
                                    ah.Dispose();
                                    Found = fou;
                                }
                        }
                }

                return Found;
            }
        }
        //Retrun determined consideration of lists of Thinking chess class list collisions.

        //3 for empty and contained compuatations
        //4 a star is not emplty and contaied computation
        int IsSuitableForInitiation(int i, int j, int Kind)
        {
            int Is = 0;
            //determine deeper have right contained
            bool a = false;
            var ah = Task.Factory.StartNew(() => a = IsNotAStarGreedyConanaied(i, j, Kind));
            ah.Wait();
            ah.Dispose();

            //determined deeper contained have computatinal list correctly.
            bool b = false;
            var ah1 = Task.Factory.StartNew(() => b = IsNotComputationsConanaiedAStarGreedy(i, j, Kind));
            ah1.Wait();
            ah1.Dispose();

            //when true
            if (a)
            {
                //when true
                if (b) Is = 2;
                else//when false
                    Is = 3;
            }
            else//when false
            {
                //when true
                if (b)
                    Is = 1;
                else//when false
                    Is = 4;
            }
            //when is 2 consider determinstic results about contanied
            if (Is == 2)
            {
                var ah2 = Task.Factory.StartNew(() => IsThereCalculatedAStarGreedyNode(i, Kind));
                ah2.Wait();
                ah2.Dispose();
            }
            return Is;
        }
        //when current side of alldraw is not contained and semi computated 
        bool IsNotAStarGreedyConanaied(int i, int j, int Kind)
        {
            bool Is = false;
            int e = 0;
            int d = 0;
            //Soldier
            if (Kind == 1)
            {
                //determine nodes is coorectly existence
                if (SolderesOnTable[i] != null && SolderesOnTable[i].SoldierThinking != null && SolderesOnTable[i].SoldierThinking[0] != null && SolderesOnTable[i].SoldierThinking[0].TableListSolder != null && SolderesOnTable[i].SoldierThinking[0].TableListSolder.Count > 0)
                {
                    //deeper count
                    e = SolderesOnTable[i].SoldierThinking[0].AStarGreedy.Count;
                    //when deeper count exist and index is not more than count of deeper
                    if (e > 0 && j < e)
                        //alldraw table list count
                        d = SolderesOnTable[i].SoldierThinking[0].AStarGreedy[j].TableList.Count;
                    //alldraw tabale list and deeper count not staisfy validity or when there is not equallity retunr true
                    if (d > 0 && e > j && (!ThinkingRefrigtzChessPortable.TableEqual(SolderesOnTable[i].SoldierThinking[0].AStarGreedy[j].TableList[0], CloneATable(SolderesOnTable[i].SoldierThinking[0].TableListSolder[j]))))
                        Is = true;
                }
            }
            else if (Kind == 2)
            {
                //determine nodes is coorectly existence
                if (ElephantOnTable[i] != null && ElephantOnTable[i].ElefantThinking != null && ElephantOnTable[i].ElefantThinking[0] != null && ElephantOnTable[i].ElefantThinking[0].TableListElefant != null && ElephantOnTable[i].ElefantThinking[0].TableListElefant.Count > 0)
                {
                    //deeper count
                    e = ElephantOnTable[i].ElefantThinking[0].AStarGreedy.Count;
                    //when deeper count exist and index is not more than count of deeper
                    if (e > 0 && j < e)
                        //alldraw table list count
                        d = ElephantOnTable[i].ElefantThinking[0].AStarGreedy[j].TableList.Count;
                    //alldraw tabale list and deeper count not staisfy validity or when there is not equallity retunr true
                    if (d > 0 && e > j && (!ThinkingRefrigtzChessPortable.TableEqual(ElephantOnTable[i].ElefantThinking[0].AStarGreedy[j].TableList[0], CloneATable(ElephantOnTable[i].ElefantThinking[0].TableListElefant[j]))))
                        Is = true;
                }
            }
            else if (Kind == 3)
            {
                //determine nodes is coorectly existence
                if (HoursesOnTable[i] != null && HoursesOnTable[i].HourseThinking != null && HoursesOnTable[i].HourseThinking[0] != null && HoursesOnTable[i].HourseThinking[0].TableListHourse != null && HoursesOnTable[i].HourseThinking[0].TableListHourse.Count > 0)
                {
                    //deeper count
                    e = HoursesOnTable[i].HourseThinking[0].AStarGreedy.Count;
                    //when deeper count exist and index is not more than count of deeper
                    if (e > 0 && j < e)
                        //alldraw table list count
                        d = HoursesOnTable[i].HourseThinking[0].AStarGreedy[j].TableList.Count;
                    //alldraw tabale list and deeper count not staisfy validity or when there is not equallity retunr true
                    if (d > 0 && e > j && (!ThinkingRefrigtzChessPortable.TableEqual(HoursesOnTable[i].HourseThinking[0].AStarGreedy[j].TableList[0], CloneATable(HoursesOnTable[i].HourseThinking[0].TableListHourse[j]))))
                        Is = true;
                }
            }
            else if (Kind == 4)
            {
                //determine nodes is coorectly existence
                if (CastlesOnTable[i] != null && CastlesOnTable[i].CastleThinking != null && CastlesOnTable[i].CastleThinking[0] != null && CastlesOnTable[i].CastleThinking[0].TableListCastle != null && CastlesOnTable[i].CastleThinking[0].TableListCastle.Count > 0)
                {
                    //deeper count
                    e = CastlesOnTable[i].CastleThinking[0].AStarGreedy.Count;
                    //when deeper count exist and index is not more than count of deeper
                    if (e > 0 && j < e)
                        //alldraw table list count
                        d = CastlesOnTable[i].CastleThinking[0].AStarGreedy[j].TableList.Count;
                    //alldraw tabale list and deeper count not staisfy validity or when there is not equallity retunr true
                    if (d > 0 && e > j && (!ThinkingRefrigtzChessPortable.TableEqual(CastlesOnTable[i].CastleThinking[0].AStarGreedy[j].TableList[0], CloneATable(CastlesOnTable[i].CastleThinking[0].TableListCastle[j]))))
                        Is = true;
                }
            }
            else if (Kind == 5)
            {
                //determine nodes is coorectly existence
                if (MinisterOnTable[i] != null && MinisterOnTable[i].MinisterThinking != null && MinisterOnTable[i].MinisterThinking[0] != null && MinisterOnTable[i].MinisterThinking[0].TableListMinister != null && MinisterOnTable[i].MinisterThinking[0].TableListMinister.Count > 0)
                {
                    //deeper count
                    e = MinisterOnTable[i].MinisterThinking[0].AStarGreedy.Count;
                    //when deeper count exist and index is not more than count of deeper
                    if (e > 0 && j < e)
                        //alldraw table list count
                        d = MinisterOnTable[i].MinisterThinking[0].AStarGreedy[j].TableList.Count;
                    //alldraw tabale list and deeper count not staisfy validity or when there is not equallity retunr true
                    if (d > 0 && e > j && (!ThinkingRefrigtzChessPortable.TableEqual(MinisterOnTable[i].MinisterThinking[0].AStarGreedy[j].TableList[0], CloneATable(MinisterOnTable[i].MinisterThinking[0].TableListMinister[j]))))
                        Is = true;
                }
            }
            else if (Kind == 6)
            {
                //determine nodes is coorectly existence
                if (KingOnTable[i] != null && KingOnTable[i].KingThinking != null && KingOnTable[i].KingThinking[0] != null && KingOnTable[i].KingThinking[0].TableListKing != null && KingOnTable[i].KingThinking[0].TableListKing.Count > 0)
                {
                    //deeper count
                    e = KingOnTable[i].KingThinking[0].AStarGreedy.Count;
                    //when deeper count exist and index is not more than count of deeper
                    if (e > 0 && j < e)
                        //alldraw table list count
                        d = KingOnTable[i].KingThinking[0].AStarGreedy[j].TableList.Count;
                    //alldraw tabale list and deeper count not staisfy validity or when there is not equallity retunr true
                    if (d > 0 && e > j && (!ThinkingRefrigtzChessPortable.TableEqual(KingOnTable[i].KingThinking[0].AStarGreedy[j].TableList[0], CloneATable(KingOnTable[i].KingThinking[0].TableListCastling[j]))))
                        Is = true;
                }
            }
            else if (Kind == 7 || Kind == -7)
            {
                //determine nodes is coorectly existence
                if (CastlingOnTable[i] != null && CastlingOnTable[i].CastlingThinking != null && CastlingOnTable[i].CastlingThinking[0] != null && CastlingOnTable[i].CastlingThinking[0].TableListCastling != null && CastlingOnTable[i].CastlingThinking[0].TableListCastling.Count > 0)
                {
                    //deeper count
                    e = CastlingOnTable[i].CastlingThinking[0].AStarGreedy.Count;
                    //when deeper count exist and index is not more than count of deeper
                    if (e > 0 && j < e)
                        //alldraw table list count
                        d = CastlingOnTable[i].CastlingThinking[0].AStarGreedy[j].TableList.Count;
                    //alldraw tabale list and deeper count not staisfy validity or when there is not equallity retunr true
                    if (d > 0 && e > j && (!ThinkingRefrigtzChessPortable.TableEqual(CastlingOnTable[i].CastlingThinking[0].AStarGreedy[j].TableList[0], CloneATable(CastlingOnTable[i].CastlingThinking[0].TableListCastling[j]))))
                        Is = true;
                }
            }

            //when deeper not exist return true
            if (e == 0)
                Is = true;
            //when current alldraw tablelist not exist return true
            if (d == 0)
                Is = true;
            return Is;

        }
        public bool IsAtLeastAllObjectIsNull()
        {
            Object o = new Object();
            lock (o)
            {
                bool Is = false;
                //Soldier
                if (SolderesOnTable == null)
                    Is = true;
                if (ElephantOnTable == null)
                    Is = true;
                if (HoursesOnTable == null)
                    Is = true;
                if (CastlesOnTable == null)
                    Is = true;
                if (MinisterOnTable == null)
                    Is = true;
                if (KingOnTable == null)
                    Is = true;
                if (CastlingOnTable == null)
                    Is = true;

                return Is;
            }

        }
        //When there is computatinoal deeper and there is colosion in lists return true otherwise return false
        bool IsNotComputationsConanaiedAStarGreedy(int i, int j, int Kind)
        {
            bool Is = false;
            int e = 0;
            //soldier
            if (Kind == 1)
            {
                if (SolderesOnTable[i] != null && SolderesOnTable[i].SoldierThinking != null && SolderesOnTable[i].SoldierThinking[0] != null && SolderesOnTable[i].SoldierThinking[0].TableListSolder != null && SolderesOnTable[i].SoldierThinking[0].TableListSolder.Count > 0)
                {
                    //lists count
                    int a = SolderesOnTable[i].SoldierThinking[0].TableListSolder.Count;
                    e = SolderesOnTable[i].SoldierThinking[0].AStarGreedy.Count;
                    //when table state exist and there is equliity between lists and deeper count
                    if (a == e && e > j && SolderesOnTable[i].SoldierThinking[0].AStarGreedy[j].TableList != null && SolderesOnTable[i].SoldierThinking[0].AStarGreedy[j].TableList.Count > 0)
                    {
                        //when tow lists tables not is equal return true
                        bool ac = false;
                        var ah2 = Task.Factory.StartNew(() => ac = ThinkingRefrigtzChessPortable.TableEqual(SolderesOnTable[i].SoldierThinking[0].AStarGreedy[j].TableList[0], CloneATable(SolderesOnTable[i].SoldierThinking[0].TableListSolder[j])));
                        ah2.Wait();
                        ah2.Dispose();
                        if (!ac)
                            Is = true;
                    }
                    else
                    {
                        //when deeper count is larger than lists count
                        if (e > a)
                        {
                            //remove extra
                            for (int h = a; h < SolderesOnTable[i].SoldierThinking[0].AStarGreedy.Count; h++)
                            {
                                SolderesOnTable[i].SoldierThinking[0].AStarGreedy.RemoveAt(h);

                            }
                        }
                        //when deeper dose not exist return true
                        if (a == 0)
                            Is = true;
                    }
                }
            }
            else if (Kind == 2)//elephant
            {
                if (ElephantOnTable[i] != null && ElephantOnTable[i].ElefantThinking != null && ElephantOnTable[i].ElefantThinking[0] != null && ElephantOnTable[i].ElefantThinking[0].TableListElefant != null && ElephantOnTable[i].ElefantThinking[0].TableListElefant.Count > 0)
                {
                    //lists count
                    int a = ElephantOnTable[i].ElefantThinking[0].TableListElefant.Count;
                    e = ElephantOnTable[i].ElefantThinking[0].AStarGreedy.Count;
                    //when table state exist and there is equliity between lists and deeper count
                    if (a == e && e > j && ElephantOnTable[i].ElefantThinking[0].AStarGreedy[j].TableList != null && ElephantOnTable[i].ElefantThinking[0].AStarGreedy[j].TableList.Count > 0)
                    {
                        //when tow lists tables not is equal return true
                        bool ac = false;
                        var ah2 = Task.Factory.StartNew(() => ac = ThinkingRefrigtzChessPortable.TableEqual(ElephantOnTable[i].ElefantThinking[0].AStarGreedy[j].TableList[0], CloneATable(ElephantOnTable[i].ElefantThinking[0].TableListElefant[j])));
                        ah2.Wait();
                        ah2.Dispose();
                        if (!ac)
                            Is = true;
                    }
                    else
                    {
                        //when deeper count is larger than lists count
                        if (e > a)
                        {
                            //remove extra
                            for (int h = a; h < ElephantOnTable[i].ElefantThinking[0].AStarGreedy.Count; h++)
                            {
                                ElephantOnTable[i].ElefantThinking[0].AStarGreedy.RemoveAt(h);
                            }
                        }
                        //when deeper dose not exist return true
                        if (a == 0)
                            Is = true;
                    }
                }
            }
            else if (Kind == 3)//hourse
            {
                if (HoursesOnTable[i] != null && HoursesOnTable[i].HourseThinking != null && HoursesOnTable[i].HourseThinking[0] != null && HoursesOnTable[i].HourseThinking[0].TableListHourse != null && HoursesOnTable[i].HourseThinking[0].TableListHourse.Count > 0)
                {
                    //lists count
                    int a = HoursesOnTable[i].HourseThinking[0].TableListHourse.Count;
                    e = HoursesOnTable[i].HourseThinking[0].AStarGreedy.Count;
                    //when table state exist and there is equliity between lists and deeper count
                    if (a == e && e > j && HoursesOnTable[i].HourseThinking[0].AStarGreedy[j].TableList != null && HoursesOnTable[i].HourseThinking[0].AStarGreedy[j].TableList.Count > 0)
                    {
                        //when tow lists tables not is equal return true
                        bool ac = false;
                        var ah2 = Task.Factory.StartNew(() => ac = ThinkingRefrigtzChessPortable.TableEqual(HoursesOnTable[i].HourseThinking[0].AStarGreedy[j].TableList[0], CloneATable(HoursesOnTable[i].HourseThinking[0].TableListHourse[j])));
                        ah2.Wait();
                        ah2.Dispose();
                        if (!ac)
                            Is = true;
                    }
                    else
                    {
                        //when deeper count is larger than lists count
                        if (e > a)
                        {
                            //remove extra
                            for (int h = a; h < HoursesOnTable[i].HourseThinking[0].AStarGreedy.Count; h++)
                            {
                                HoursesOnTable[i].HourseThinking[0].AStarGreedy.RemoveAt(h);
                            }
                        }
                        //when deeper dose not exist return true
                        if (a == 0)
                            Is = true;
                    }
                }
            }
            else if (Kind == 4)//Castle
            {
                if (CastlesOnTable[i] != null && CastlesOnTable[i].CastleThinking != null && CastlesOnTable[i].CastleThinking[0] != null && CastlesOnTable[i].CastleThinking[0].TableListCastle != null && CastlesOnTable[i].CastleThinking[0].TableListCastle.Count > 0)
                {
                    //lists count
                    int a = CastlesOnTable[i].CastleThinking[0].TableListCastle.Count;
                    e = CastlesOnTable[i].CastleThinking[0].AStarGreedy.Count;
                    //when table state exist and there is equliity between lists and deeper count
                    if (a == e && e > j && CastlesOnTable[i].CastleThinking[0].AStarGreedy[j].TableList != null && CastlesOnTable[i].CastleThinking[0].AStarGreedy[j].TableList.Count > 0)
                    {
                        //when tow lists tables not is equal return true
                        bool ac = false;
                        var ah2 = Task.Factory.StartNew(() => ac = ThinkingRefrigtzChessPortable.TableEqual(CastlesOnTable[i].CastleThinking[0].AStarGreedy[j].TableList[0], CloneATable(CastlesOnTable[i].CastleThinking[0].TableListCastle[j])));
                        ah2.Wait();
                        ah2.Dispose();
                        if (!ac)
                            Is = true;
                    }
                    else
                    {
                        //when deeper count is larger than lists count
                        if (e > a)
                        {
                            //remove extra
                            for (int h = a; h < CastlesOnTable[i].CastleThinking[0].AStarGreedy.Count; h++)
                            {
                                CastlesOnTable[i].CastleThinking[0].AStarGreedy.RemoveAt(h);
                            }
                        }
                        //when deeper dose not exist return true
                        if (a == 0)
                            Is = true;
                    }
                }
            }
            else if (Kind == 5)//minister
            {
                if (MinisterOnTable[i] != null && MinisterOnTable[i].MinisterThinking != null && MinisterOnTable[i].MinisterThinking[0] != null && MinisterOnTable[i].MinisterThinking[0].TableListMinister != null && MinisterOnTable[i].MinisterThinking[0].TableListMinister.Count > 0)
                {
                    //lists count
                    int a = MinisterOnTable[i].MinisterThinking[0].TableListMinister.Count;
                    e = MinisterOnTable[i].MinisterThinking[0].AStarGreedy.Count;
                    //when table state exist and there is equliity between lists and deeper count
                    if (a == e && e > j && MinisterOnTable[i].MinisterThinking[0].AStarGreedy[j].TableList != null && MinisterOnTable[i].MinisterThinking[0].AStarGreedy[j].TableList.Count > 0)
                    {
                        //when tow lists tables not is equal return true
                        bool ac = false;
                        var ah2 = Task.Factory.StartNew(() => ac = ThinkingRefrigtzChessPortable.TableEqual(MinisterOnTable[i].MinisterThinking[0].AStarGreedy[j].TableList[0], CloneATable(MinisterOnTable[i].MinisterThinking[0].TableListMinister[j])));
                        ah2.Wait();
                        ah2.Dispose();
                        if (!ac)
                            Is = true;
                    }
                    else
                    {
                        //when deeper count is larger than lists count
                        if (e > a)
                        {
                            //remove extra
                            for (int h = a; h < MinisterOnTable[i].MinisterThinking[0].AStarGreedy.Count; h++)
                            {
                                MinisterOnTable[i].MinisterThinking[0].AStarGreedy.RemoveAt(h);
                            }
                        }
                        //when deeper dose not exist return true
                        if (a == 0)
                            Is = true;
                    }
                }
            }
            else if (Kind == 6)//king
            {
                if (KingOnTable[i] != null && KingOnTable[i].KingThinking != null && KingOnTable[i].KingThinking[0] != null && KingOnTable[i].KingThinking[0].TableListKing != null && KingOnTable[i].KingThinking[0].TableListKing.Count > 0)
                {
                    //lists count
                    int a = KingOnTable[i].KingThinking[0].TableListKing.Count;
                    e = KingOnTable[i].KingThinking[0].AStarGreedy.Count;
                    //when table state exist and there is equliity between lists and deeper count
                    if (a == e && e > j && KingOnTable[i].KingThinking[0].AStarGreedy[j].TableList != null && KingOnTable[i].KingThinking[0].AStarGreedy[j].TableList.Count > 0)
                    {
                        //when tow lists tables not is equal return true
                        bool ac = false;
                        var ah2 = Task.Factory.StartNew(() => ac = ThinkingRefrigtzChessPortable.TableEqual(KingOnTable[i].KingThinking[0].AStarGreedy[j].TableList[0], CloneATable(KingOnTable[i].KingThinking[0].TableListKing[j])));
                        ah2.Wait();
                        ah2.Dispose();
                        if (!ac)
                            Is = true;
                    }
                    else
                    {
                        //when deeper count is larger than lists count
                        if (e > a)
                        {
                            //remove extra
                            for (int h = a; h < KingOnTable[i].KingThinking[0].AStarGreedy.Count; h++)
                            {
                                KingOnTable[i].KingThinking[0].AStarGreedy.RemoveAt(h);
                            }
                        }
                        //when deeper dose not exist return true
                        if (a == 0)
                            Is = true;
                    }
                }
            }
            else if (Kind == 7 || Kind == -7)
            {
                if (CastlingOnTable[i] != null && CastlingOnTable[i].CastlingThinking != null && CastlingOnTable[i].CastlingThinking[0] != null && CastlingOnTable[i].CastlingThinking[0].TableListCastling != null && CastlingOnTable[i].CastlingThinking[0].TableListCastling.Count > 0)
                {
                    //lists count
                    int a = CastlingOnTable[i].CastlingThinking[0].TableListKing.Count;
                    e = CastlingOnTable[i].CastlingThinking[0].AStarGreedy.Count;
                    //when table state exist and there is equliity between lists and deeper count
                    if (a == e && e > j && CastlingOnTable[i].CastlingThinking[0].AStarGreedy[j].TableList != null && CastlingOnTable[i].CastlingThinking[0].AStarGreedy[j].TableList.Count > 0)
                    {
                        //when tow lists tables not is equal return true
                        bool ac = false;
                        var ah2 = Task.Factory.StartNew(() => ac = ThinkingRefrigtzChessPortable.TableEqual(CastlingOnTable[i].CastlingThinking[0].AStarGreedy[j].TableList[0], CloneATable(CastlingOnTable[i].CastlingThinking[0].TableListCastling[j])));
                        ah2.Wait();
                        ah2.Dispose();
                        if (!ac)
                            Is = true;
                    }
                    else
                    {
                        //when deeper count is larger than lists count
                        if (e > a)
                        {
                            //remove extra
                            for (int h = a; h < CastlingOnTable[i].CastlingThinking[0].AStarGreedy.Count; h++)
                            {
                                CastlingOnTable[i].CastlingThinking[0].AStarGreedy.RemoveAt(h);
                            }
                        }
                        //when deeper dose not exist return true
                        if (a == 0)
                            Is = true;
                    }
                }
            }
            //when deeper count is less than index deeper return true
            if (e < j)
                Is = true;
            return Is;

        }
        //deeper leaf found 
        public void FoundOfLeafDepenOfKindFullGameSoldeir(Color a, ref bool FullGameFound, int[,] Table, int Order, int iAStarGreedy, int ii, int jj, int i, int jjj, bool FOUND, int LeafAStarGreedy)
        {
            Object P = new Object();
            lock (P)
            {
                for (var j = 0; SolderesOnTable != null && SolderesOnTable[i] != null && SolderesOnTable[i].SoldierThinking != null && SolderesOnTable[i].SoldierThinking[0] != null && j < SolderesOnTable[i].SoldierThinking[0].TableListSolder.Count && SolderesOnTable[i].SoldierThinking[0].TableListSolder != null
                         ; j++)
                {
                    Object OOOOO = new Object();
                    lock (OOOOO)
                    {
                        bool ac = false;
                        var ah = Task.Factory.StartNew(() => ac = IsSupHuTrue(i, j, 0, 1));
                        ah.Wait();
                        ah.Dispose();
                        if (ac)
                            continue;
                        //when search finished stop and return
                        var ah1 = Task.Factory.StartNew(() => ac = FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy));
                        ah1.Wait();
                        ah1.Dispose();
                        if (ac)
                            return;
                    }
                    //determine about validity of list on current and deeper return true when successfull
                    bool IA = false;
                    var ah2 = Task.Factory.StartNew(() => IA = IsNonValidityAllTablesHeuristicsAndMore(1, Order, i, j));
                    ah2.Wait();
                    ah2.Dispose();
                    //determine about situation of deeper against other lists computation in 4 state
                    int Is = 0;
                    var ah3 = Task.Factory.StartNew(() => Is = IsSuitableForInitiation(i, j, 1));
                    ah3.Wait();
                    ah3.Dispose();
                    if (!IA)
                        Is = 4;
                    //when is suitable for computational operation on lists
                    if (Is == 4)
                    {
                        Object OOOO = new Object();
                        lock (OOOO)
                        {
                            //when search finished stop and return
                            bool ac = false;
                            var ah1 = Task.Factory.StartNew(() => ac = FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy));
                            ah1.Wait();
                            ah1.Dispose();
                            if (ac)
                                return;
                        }
                        FullGameFound = true;

                        //StoreInitMaxAStarGreedy = CurrentMaxLevel; MaxAStarGreedy = CurrentMaxLevel;
                        var H = Task.Factory.StartNew(() => InitiateAStarGreedyt(PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ii, jj, a, CloneATable(Table), Order, false, false, LeafAStarGreedy));
                        H.Wait();
                        H.Dispose();
                        for (int h = 0; h < SolderesOnTable[i].SoldierThinking[0].AStarGreedy.Count && SolderesOnTable[i].SoldierThinking[0].AStarGreedy != null; h++)
                        {
                            SolderesOnTable[i].SoldierThinking[0].AStarGreedy[h].AStarGreedyString = this;
                            SolderesOnTable[i].WinOcuuredatChiled += SumOfObjects(SolderesOnTable[i].SoldierThinking[0].AStarGreedy[h], Order * -1);
                        }
                        for (int h = 0; h < SolderesOnTable[i].SoldierThinking[0].AStarGreedy.Count && SolderesOnTable[i].SoldierThinking[0].AStarGreedy != null; h++)
                            SolderesOnTable[i].LoseOcuuredatChiled[0] += SumMinusOfObjects(SolderesOnTable[i].SoldierThinking[0].AStarGreedy[h], Order * -1);
                    }
                    else
                    {
                        //when is suitable for leafer 
                        if (Is == 2)
                        {
                            for (var iii = 0; iii < SolderesOnTable[i].SoldierThinking[0].AStarGreedy.Count && SolderesOnTable[i].SoldierThinking[0].AStarGreedy[iii].TableList != null && SolderesOnTable[i].SoldierThinking[0].AStarGreedy[iii].TableList.Count > 0; iii++)
                            {
                                Object OOOO = new Object();
                                lock (OOOO)
                                {
                                    FirstTraversalTree = false;

                                    //when search finished stop and return
                                    bool ac = false;
                                    var ah1 = Task.Factory.StartNew(() => ac = FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy));
                                    ah1.Wait();
                                    ah1.Dispose();
                                    if (ac)
                                        return;
                                }


                                SolderesOnTable[i].SoldierThinking[0].AStarGreedy[iii].FoundOfLeafDepenOfKindFullGame(CloneATable(SolderesOnTable[i].SoldierThinking[0].AStarGreedy[iii].TableList[0]), Order * -1, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ii, jj, i, jjj, FOUND, LeafAStarGreedy);
                                SolderesOnTable[i].SoldierThinking[0].AStarGreedy[iii].AStarGreedyString = this;
                            }
                            for (int h = 0; h < SolderesOnTable[i].SoldierThinking[0].AStarGreedy.Count && SolderesOnTable[i].SoldierThinking[0].AStarGreedy != null; h++)
                                SolderesOnTable[i].WinOcuuredatChiled += SumOfObjects(SolderesOnTable[i].SoldierThinking[0].AStarGreedy[h], Order * -1);
                            for (int h = 0; h < SolderesOnTable[i].SoldierThinking[0].AStarGreedy.Count && SolderesOnTable[i].SoldierThinking[0].AStarGreedy != null; h++)
                                SolderesOnTable[i].LoseOcuuredatChiled[0] += SumMinusOfObjects(SolderesOnTable[i].SoldierThinking[0].AStarGreedy[h], Order * -1);
                        }
                        else if (Is == 3)//when deeper is suitable and  computational not
                        {
                            Object OOOO = new Object();
                            lock (OOOO)
                            {
                                //when search finished stop and return
                                bool ac = false;
                                var ah1 = Task.Factory.StartNew(() => ac = FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy));
                                ah1.Wait();
                                ah1.Dispose();
                                if (ac)
                                    return;
                            }

                            Object O1 = new Object();
                            lock (O1)
                            {
                                int Ord = Order, ii1 = ii, jj1 = jj, i1 = i, j1 = j;
                                //StoreInitMaxAStarGreedy = CurrentMaxLevel; MaxAStarGreedy = CurrentMaxLevel;
                                var H = Task.Factory.StartNew(() => InitiateAStarGreedyt(PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ii, jj, a, CloneATable(Table), Order, false, false, LeafAStarGreedy));
                                H.Wait();
                                H.Dispose();
                                for (int h = 0; h < SolderesOnTable[i].SoldierThinking[0].AStarGreedy.Count && SolderesOnTable[i].SoldierThinking[0].AStarGreedy != null; h++)
                                {
                                    SolderesOnTable[i].SoldierThinking[0].AStarGreedy[h].AStarGreedyString = this;
                                    SolderesOnTable[i].WinOcuuredatChiled += SumOfObjects(SolderesOnTable[i].SoldierThinking[0].AStarGreedy[h], Order * -1);
                                }
                                for (int h = 0; h < SolderesOnTable[i].SoldierThinking[0].AStarGreedy.Count && SolderesOnTable[i].SoldierThinking[0].AStarGreedy != null; h++)
                                    SolderesOnTable[i].LoseOcuuredatChiled[0] += SumMinusOfObjects(SolderesOnTable[i].SoldierThinking[0].AStarGreedy[h], Order * -1);
                            }
                        }
                        else//otherwise
                        {
                            Object OOOO = new Object();
                            lock (OOOO)
                            {
                                //when search finished stop and return
                                bool ac = false;
                                var ah1 = Task.Factory.StartNew(() => ac = FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy));
                                ah1.Wait();
                                ah1.Dispose();
                                if (ac)
                                    return;
                            }
                            Object OO1 = new Object();
                            lock (OO1)
                            {
                                FullGameFound = true;

                                a = Color.Gray;
                                if (Order == -1)
                                    a = Color.Brown;

                                Object OOO = new Object();
                                lock (OOO)
                                {
                                    FirstTraversalTree = false;

                                    //when search finished stop and return
                                    bool ac = false;
                                    var ah1 = Task.Factory.StartNew(() => ac = FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy));
                                    ah1.Wait();
                                    ah1.Dispose();
                                    if (ac)
                                        return;
                                }
                                var ah4 = Task.Factory.StartNew(() => this.FullGameThinkingTree(Order, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ii, jj, i, jjj, FOUND, LeafAStarGreedy));
                                ah4.Wait();
                                ah4.Dispose();

                            }
                        }
                    }
                }
            }
        }
        //deeper leaf found 
        public void FoundOfLeafDepenOfKindFullGameElepahnt(Color a, ref bool FullGameFound, int[,] Table, int Order, int iAStarGreedy, int ii, int jj, int i, int jjj, bool FOUND, int LeafAStarGreedy)
        {
            Object P = new Object();
            lock (P)
            {
                for (var j = 0; ElephantOnTable != null && ElephantOnTable[i] != null && ElephantOnTable[i].ElefantThinking != null && ElephantOnTable[i].ElefantThinking[0] != null && j < ElephantOnTable[i].ElefantThinking[0].TableListElefant.Count && ElephantOnTable[i].ElefantThinking[0].TableListElefant != null
            ; j++)
                {
                    Object OOOOO = new Object();
                    lock (OOOOO)
                    {
                        bool ac = false;
                        var ah = Task.Factory.StartNew(() => ac = IsSupHuTrue(i, j, 0, 2));
                        ah.Wait();
                        ah.Dispose();
                        if (ac)
                            continue;
                        //when search finished stop and return
                        var ah1 = Task.Factory.StartNew(() => ac = FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy));
                        ah1.Wait();
                        ah1.Dispose();
                        if (ac)
                            return;

                    }
                    //determine about validity of list on current and deeper return true when successfull
                    bool IA = false;
                    var ah2 = Task.Factory.StartNew(() => IA = IsNonValidityAllTablesHeuristicsAndMore(2, Order, i, j));
                    ah2.Wait();
                    ah2.Dispose();
                    //determine about situation of deeper against other lists computation in 4 state
                    int Is = 0;
                    var ah3 = Task.Factory.StartNew(() => Is = IsSuitableForInitiation(i, j, 2));
                    ah3.Wait();
                    ah3.Dispose();
                    if (!IA)
                        Is = 4;

                    //when is suitable for computational operation on lists
                    if (Is == 4)
                    {
                        Object OOOO = new Object();
                        lock (OOOO)
                        {
                            //when search finished stop and return
                            bool ac = false;
                            var ah1 = Task.Factory.StartNew(() => ac = FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy));
                            ah1.Wait();
                            ah1.Dispose();
                            if (ac)
                                return;
                        }
                        FullGameFound = true;

                        //StoreInitMaxAStarGreedy = CurrentMaxLevel; MaxAStarGreedy = CurrentMaxLevel;
                        var H = Task.Factory.StartNew(() => InitiateAStarGreedyt(PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ii, jj, a, CloneATable(Table), Order, false, false, LeafAStarGreedy));
                        H.Wait();
                        H.Dispose();
                        for (int h = 0; h < ElephantOnTable[i].ElefantThinking[0].AStarGreedy.Count && ElephantOnTable[i].ElefantThinking[0].AStarGreedy != null; h++)
                        {
                            ElephantOnTable[i].ElefantThinking[0].AStarGreedy[h].AStarGreedyString = this;
                            ElephantOnTable[i].WinOcuuredatChiled += SumOfObjects(ElephantOnTable[i].ElefantThinking[0].AStarGreedy[h], Order * -1);
                        }
                        for (int h = 0; h < ElephantOnTable[i].ElefantThinking[0].AStarGreedy.Count && ElephantOnTable[i].ElefantThinking[0].AStarGreedy != null; h++)
                            ElephantOnTable[i].LoseOcuuredatChiled[0] += SumMinusOfObjects(ElephantOnTable[i].ElefantThinking[0].AStarGreedy[h], Order * -1);
                    }
                    else
                    {
                        //when is suitable for leafer 
                        if (Is == 2)
                        {
                            for (var iii = 0; iii < ElephantOnTable[i].ElefantThinking[0].AStarGreedy.Count && ElephantOnTable[i].ElefantThinking[0].AStarGreedy[iii].TableList != null && ElephantOnTable[i].ElefantThinking[0].AStarGreedy[iii].TableList.Count > 0; iii++)
                            {
                                Object OOOO = new Object();
                                lock (OOOO)
                                {
                                    FirstTraversalTree = false;
                                    //when search finished stop and return
                                    bool ac = false;
                                    var ah1 = Task.Factory.StartNew(() => ac = FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy));
                                    ah1.Wait();
                                    ah1.Dispose();
                                    if (ac)
                                        return;
                                }


                                ElephantOnTable[i].ElefantThinking[0].AStarGreedy[iii].FoundOfLeafDepenOfKindFullGame(CloneATable(ElephantOnTable[i].ElefantThinking[0].AStarGreedy[iii].TableList[0]), Order * -1, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ii, jj, i, jjj, FOUND, LeafAStarGreedy);
                                ElephantOnTable[i].ElefantThinking[0].AStarGreedy[iii].AStarGreedyString = this;
                            }
                            for (int h = 0; h < ElephantOnTable[i].ElefantThinking[0].AStarGreedy.Count && ElephantOnTable[i].ElefantThinking[0].AStarGreedy != null; h++)
                                ElephantOnTable[i].WinOcuuredatChiled += SumOfObjects(ElephantOnTable[i].ElefantThinking[0].AStarGreedy[h], Order * -1);
                            for (int h = 0; h < ElephantOnTable[i].ElefantThinking[0].AStarGreedy.Count && ElephantOnTable[i].ElefantThinking[0].AStarGreedy != null; h++)
                                ElephantOnTable[i].LoseOcuuredatChiled[0] += SumMinusOfObjects(ElephantOnTable[i].ElefantThinking[0].AStarGreedy[h], Order * -1);
                        }
                        else if (Is == 3)//when is suitable for deeper
                        {
                            Object OOOO = new Object();
                            lock (OOOO)
                            {
                                //when search finished stop and return
                                bool ac = false;
                                var ah1 = Task.Factory.StartNew(() => ac = FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy));
                                ah1.Wait();
                                ah1.Dispose();
                                if (ac)
                                    return;
                            }

                            Object O1 = new Object();
                            lock (O1)
                            {
                                int Ord = Order, ii1 = ii, jj1 = jj, i1 = i, j1 = j;
                                //StoreInitMaxAStarGreedy = CurrentMaxLevel; MaxAStarGreedy = CurrentMaxLevel;
                                var H = Task.Factory.StartNew(() => InitiateAStarGreedyt(PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ii, jj, a, CloneATable(Table), Order, false, false, LeafAStarGreedy));
                                H.Wait();
                                H.Dispose();
                                for (int h = 0; h < ElephantOnTable[i].ElefantThinking[0].AStarGreedy.Count && ElephantOnTable[i].ElefantThinking[0].AStarGreedy != null; h++)
                                {
                                    ElephantOnTable[i].ElefantThinking[0].AStarGreedy[h].AStarGreedyString = this;
                                    ElephantOnTable[i].WinOcuuredatChiled += SumOfObjects(ElephantOnTable[i].ElefantThinking[0].AStarGreedy[h], Order * -1);
                                }
                                for (int h = 0; h < ElephantOnTable[i].ElefantThinking[0].AStarGreedy.Count && ElephantOnTable[i].ElefantThinking[0].AStarGreedy != null; h++)
                                    ElephantOnTable[i].LoseOcuuredatChiled[0] += SumMinusOfObjects(ElephantOnTable[i].ElefantThinking[0].AStarGreedy[h], Order * -1);
                            }
                        }
                        else//otherwise
                        {
                            Object OOOO = new Object();
                            lock (OOOO)
                            {
                                //when search finished stop and return
                                bool ac = false;
                                var ah1 = Task.Factory.StartNew(() => ac = FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy));
                                ah1.Wait();
                                ah1.Dispose();
                                if (ac)
                                    return;
                            }
                            Object OO1 = new Object();
                            lock (OO1)
                            {

                                a = Color.Gray;
                                if (Order == -1)
                                    a = Color.Brown;

                                var ah4 = Task.Factory.StartNew(() => this.FullGameThinkingTree(Order, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ii, jj, i, jjj, FOUND, LeafAStarGreedy));
                                ah4.Wait();
                                ah4.Dispose();

                            }
                        }
                    }
                }
            }
        }
        //deeper leaf found 
        public void FoundOfLeafDepenOfKindFullGameHourse(Color a, ref bool FullGameFound, int[,] Table, int Order, int iAStarGreedy, int ii, int jj, int i, int jjj, bool FOUND, int LeafAStarGreedy)
        {
            Object P = new Object();
            lock (P)
            {
                for (var j = 0; HoursesOnTable != null && HoursesOnTable[i] != null && HoursesOnTable[i].HourseThinking != null && HoursesOnTable[i].HourseThinking[0] != null && j < HoursesOnTable[i].HourseThinking[0].TableListHourse.Count && HoursesOnTable[i].HourseThinking[0].TableListHourse != null
           ; j++)
                {
                    Object OOOOO = new Object();
                    lock (OOOOO)
                    {
                        bool ac = false;
                        var ah = Task.Factory.StartNew(() => ac = IsSupHuTrue(i, j, 0, 3));
                        ah.Wait();
                        ah.Dispose();
                        if (ac)
                            continue;
                        //when search finished stop and return
                        var ah1 = Task.Factory.StartNew(() => ac = FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy));
                        ah1.Wait();
                        ah1.Dispose();
                        if (ac)
                            return;
                    }
                    //determine about validity of list on current and deeper return true when successfull
                    bool IA = false;
                    var ah2 = Task.Factory.StartNew(() => IA = IsNonValidityAllTablesHeuristicsAndMore(3, Order, i, j));
                    ah2.Wait();
                    ah2.Dispose();
                    //determine about situation of deeper against other lists computation in 4 state
                    int Is = 0;
                    var ah3 = Task.Factory.StartNew(() => Is = IsSuitableForInitiation(i, j, 3));
                    ah3.Wait();
                    ah3.Dispose();
                    if (!IA)
                        Is = 4;

                    //when is suitable for computational operation on lists
                    if (Is == 4)
                    {
                        Object OOOO = new Object();
                        lock (OOOO)
                        {
                            //when search finished stop and return
                            bool ac = false;
                            var ah1 = Task.Factory.StartNew(() => ac = FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy));
                            ah1.Wait();
                            ah1.Dispose();
                            if (ac)
                                return;
                        }
                        FullGameFound = true;
                        //StoreInitMaxAStarGreedy = CurrentMaxLevel; MaxAStarGreedy = CurrentMaxLevel;

                        var H = Task.Factory.StartNew(() => InitiateAStarGreedyt(PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ii, jj, a, CloneATable(Table), Order, false, false, LeafAStarGreedy));
                        H.Wait();
                        H.Dispose();
                        for (int h = 0; h < HoursesOnTable[i].HourseThinking[0].AStarGreedy.Count && HoursesOnTable[i].HourseThinking[0].AStarGreedy != null; h++)
                        {
                            HoursesOnTable[i].HourseThinking[0].AStarGreedy[h].AStarGreedyString = this;
                            HoursesOnTable[i].WinOcuuredatChiled += SumOfObjects(HoursesOnTable[i].HourseThinking[0].AStarGreedy[h], Order * -1);
                        }
                        for (int h = 0; h < HoursesOnTable[i].HourseThinking[0].AStarGreedy.Count && HoursesOnTable[i].HourseThinking[0].AStarGreedy != null; h++)
                            HoursesOnTable[i].LoseOcuuredatChiled[0] += SumMinusOfObjects(HoursesOnTable[i].HourseThinking[0].AStarGreedy[h], Order * -1);
                    }
                    else
                    {
                        //when is suitable for leafer 
                        if (Is == 2)
                        {
                            for (var iii = 0; iii < HoursesOnTable[i].HourseThinking[0].AStarGreedy.Count && HoursesOnTable[i].HourseThinking[0].AStarGreedy[iii].TableList != null && HoursesOnTable[i].HourseThinking[0].AStarGreedy[iii].TableList.Count > 0; iii++)
                            {
                                Object OOOO = new Object();
                                lock (OOOO)
                                {
                                    FirstTraversalTree = false;
                                    //when search finished stop and return
                                    bool ac = false;
                                    var ah1 = Task.Factory.StartNew(() => ac = FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy));
                                    ah1.Wait();
                                    ah1.Dispose();
                                    if (ac)
                                        return;
                                }


                                HoursesOnTable[i].HourseThinking[0].AStarGreedy[iii].FoundOfLeafDepenOfKindFullGame(CloneATable(HoursesOnTable[i].HourseThinking[0].AStarGreedy[iii].TableList[0]), Order * -1, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ii, jj, i, jjj, FOUND, LeafAStarGreedy);
                                HoursesOnTable[i].HourseThinking[0].AStarGreedy[iii].AStarGreedyString = this;
                            }
                            for (int h = 0; h < HoursesOnTable[i].HourseThinking[0].AStarGreedy.Count && HoursesOnTable[i].HourseThinking[0].AStarGreedy != null; h++)
                                HoursesOnTable[i].WinOcuuredatChiled += SumOfObjects(HoursesOnTable[i].HourseThinking[0].AStarGreedy[h], Order * -1);
                            for (int h = 0; h < HoursesOnTable[i].HourseThinking[0].AStarGreedy.Count && HoursesOnTable[i].HourseThinking[0].AStarGreedy != null; h++)
                                HoursesOnTable[i].LoseOcuuredatChiled[0] += SumMinusOfObjects(HoursesOnTable[i].HourseThinking[0].AStarGreedy[h], Order * -1);
                        }
                        else if (Is == 3)//when is suitable for deeper
                        {
                            Object OOOO = new Object();
                            lock (OOOO)
                            {
                                //when search finished stop and return
                                bool ac = false;
                                var ah1 = Task.Factory.StartNew(() => ac = FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy));
                                ah1.Wait();
                                ah1.Dispose();
                                if (ac)
                                    return;
                            }

                            Object O1 = new Object();
                            lock (O1)
                            {
                                //StoreInitMaxAStarGreedy = CurrentMaxLevel; MaxAStarGreedy = CurrentMaxLevel;
                                var H = Task.Factory.StartNew(() => InitiateAStarGreedyt(PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ii, jj, a, CloneATable(Table), Order, false, false, LeafAStarGreedy));
                                H.Wait();
                                H.Dispose();
                                for (int h = 0; h < HoursesOnTable[i].HourseThinking[0].AStarGreedy.Count && HoursesOnTable[i].HourseThinking[0].AStarGreedy != null; h++)
                                {
                                    HoursesOnTable[i].HourseThinking[0].AStarGreedy[h].AStarGreedyString = this;
                                    HoursesOnTable[i].WinOcuuredatChiled += SumOfObjects(HoursesOnTable[i].HourseThinking[0].AStarGreedy[h], Order * -1);
                                }
                                for (int h = 0; h < HoursesOnTable[i].HourseThinking[0].AStarGreedy.Count && HoursesOnTable[i].HourseThinking[0].AStarGreedy != null; h++)
                                    HoursesOnTable[i].LoseOcuuredatChiled[0] += SumMinusOfObjects(HoursesOnTable[i].HourseThinking[0].AStarGreedy[h], Order * -1);
                            }
                        }
                        else//otherwise
                        {
                            Object OOOO = new Object();
                            lock (OOOO)
                            {
                                //when search finished stop and return
                                bool ac = false;
                                var ah1 = Task.Factory.StartNew(() => ac = FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy));
                                ah1.Wait();
                                ah1.Dispose();
                                if (ac)
                                    return;
                            }
                            Object OO1 = new Object();
                            lock (OO1)
                            {
                                int Ord = Order, iAStarGreedy1 = 0, ii1 = ii, jj1 = jj, i1 = i, j1 = j;
                                a = Color.Gray;
                                if (Order == -1)
                                    a = Color.Brown;

                                var ah4 = Task.Factory.StartNew(() => this.FullGameThinkingTree(Order, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ii, jj, i, jjj, FOUND, LeafAStarGreedy));
                                ah4.Wait();
                                ah4.Dispose();

                            }
                        }
                    }


                }
            }
        }
        //deeper leaf found 
        public void FoundOfLeafDepenOfKindFullGameCastle(Color a, ref bool FullGameFound, int[,] Table, int Order, int iAStarGreedy, int ii, int jj, int i, int jjj, bool FOUND, int LeafAStarGreedy)
        {
            Object P = new Object();
            lock (P)
            {
                for (var j = 0; CastlesOnTable != null && CastlesOnTable[i] != null && CastlesOnTable[i].CastleThinking != null && CastlesOnTable[i].CastleThinking[0] != null && j < CastlesOnTable[i].CastleThinking[0].TableListCastle.Count
                                  ; j++)
                {
                    bool ac = false;
                    var ah = Task.Factory.StartNew(() => ac = IsSupHuTrue(i, j, 0, 4));
                    ah.Wait();
                    ah.Dispose();
                    if (ac)
                        continue;
                    Object OOOOO = new Object();
                    lock (OOOOO)
                    {
                        //when search finished stop and return
                        var ah1 = Task.Factory.StartNew(() => ac = FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy));
                        ah1.Wait();
                        ah1.Dispose();
                        if (ac)
                            return;
                    }
                    //determine about validity of list on current and deeper return true when successfull
                    bool IA = false;
                    var ah2 = Task.Factory.StartNew(() => IA = IsNonValidityAllTablesHeuristicsAndMore(4, Order, i, j));
                    ah2.Wait();
                    ah2.Dispose();

                    //determine about situation of deeper against other lists computation in 4 state
                    int Is = 0;
                    var ah3 = Task.Factory.StartNew(() => Is = IsSuitableForInitiation(i, j, 4));
                    ah3.Wait();
                    ah3.Dispose();
                    if (!IA)
                        Is = 4;
                    //when is suitable for computational operation on lists
                    if (Is == 4)
                    {
                        Object OOOO = new Object();
                        lock (OOOO)
                        {
                            //when search finished stop and return
                            var ah1 = Task.Factory.StartNew(() => ac = FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy));
                            ah1.Wait();
                            ah1.Dispose();
                            if (ac)
                                return;
                        }
                        FullGameFound = true;
                        //StoreInitMaxAStarGreedy = CurrentMaxLevel; MaxAStarGreedy = CurrentMaxLevel;

                        var H = Task.Factory.StartNew(() => InitiateAStarGreedyt(PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ii, jj, a, CloneATable(Table), Order, false, false, LeafAStarGreedy));
                        H.Wait();
                        H.Dispose();
                        for (int h = 0; h < CastlesOnTable[i].CastleThinking[0].AStarGreedy.Count && CastlesOnTable[i].CastleThinking[0].AStarGreedy != null; h++)
                        {
                            CastlesOnTable[i].CastleThinking[0].AStarGreedy[h].AStarGreedyString = this;
                            CastlesOnTable[i].WinOcuuredatChiled += SumOfObjects(CastlesOnTable[i].CastleThinking[0].AStarGreedy[h], Order * -1);
                        }
                        for (int h = 0; h < CastlesOnTable[i].CastleThinking[0].AStarGreedy.Count && CastlesOnTable[i].CastleThinking[0].AStarGreedy != null; h++)
                            CastlesOnTable[i].LoseOcuuredatChiled[0] += SumMinusOfObjects(CastlesOnTable[i].CastleThinking[0].AStarGreedy[h], Order * -1);
                    }
                    else
                    {
                        //when is suitable for deeper
                        if (Is == 2)
                        {
                            for (var iii = 0; iii < CastlesOnTable[i].CastleThinking[0].AStarGreedy.Count && CastlesOnTable[i].CastleThinking[0].AStarGreedy[iii].TableList != null && CastlesOnTable[i].CastleThinking[0].AStarGreedy[iii].TableList.Count > 0; iii++)
                            {
                                Object OOOO = new Object();
                                lock (OOOO)
                                {
                                    FirstTraversalTree = false;
                                    //when search finished stop and return
                                    var ah1 = Task.Factory.StartNew(() => ac = FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy));
                                    ah1.Wait();
                                    ah1.Dispose();
                                    if (ac)
                                        return;
                                }


                                CastlesOnTable[i].CastleThinking[0].AStarGreedy[iii].FoundOfLeafDepenOfKindFullGame(CloneATable(CastlesOnTable[i].CastleThinking[0].AStarGreedy[iii].TableList[0]), Order * -1, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ii, jj, i, jjj, FOUND, LeafAStarGreedy);
                                CastlesOnTable[i].CastleThinking[0].AStarGreedy[iii].AStarGreedyString = this;
                            }
                            for (int h = 0; h < CastlesOnTable[i].CastleThinking[0].AStarGreedy.Count && CastlesOnTable[i].CastleThinking[0].AStarGreedy != null; h++)
                                CastlesOnTable[i].WinOcuuredatChiled += SumOfObjects(CastlesOnTable[i].CastleThinking[0].AStarGreedy[h], Order * -1);
                            for (int h = 0; h < CastlesOnTable[i].CastleThinking[0].AStarGreedy.Count && CastlesOnTable[i].CastleThinking[0].AStarGreedy != null; h++)
                                CastlesOnTable[i].LoseOcuuredatChiled[0] += SumMinusOfObjects(CastlesOnTable[i].CastleThinking[0].AStarGreedy[h], Order * -1);
                        }
                        else if (Is == 3)  //when is suitable for leafer 
                        {
                            Object OOOO = new Object();
                            lock (OOOO)
                            {
                                //when search finished stop and return
                                var ah1 = Task.Factory.StartNew(() => ac = FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy));
                                ah1.Wait();
                                ah1.Dispose();
                                if (ac)
                                    return;
                            }

                            Object O1 = new Object();
                            lock (O1)
                            {
                                //StoreInitMaxAStarGreedy = CurrentMaxLevel; MaxAStarGreedy = CurrentMaxLevel;
                                var H = Task.Factory.StartNew(() => InitiateAStarGreedyt(PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ii, jj, a, CloneATable(Table), Order, false, false, LeafAStarGreedy));
                                H.Wait();
                                H.Dispose();
                                for (int h = 0; h < CastlesOnTable[i].CastleThinking[0].AStarGreedy.Count && CastlesOnTable[i].CastleThinking[0].AStarGreedy != null; h++)
                                {
                                    CastlesOnTable[i].CastleThinking[0].AStarGreedy[h].AStarGreedyString = this;
                                    CastlesOnTable[i].WinOcuuredatChiled += SumOfObjects(CastlesOnTable[i].CastleThinking[0].AStarGreedy[h], Order * -1);
                                }
                                for (int h = 0; h < CastlesOnTable[i].CastleThinking[0].AStarGreedy.Count && CastlesOnTable[i].CastleThinking[0].AStarGreedy != null; h++)
                                    CastlesOnTable[i].LoseOcuuredatChiled[0] += SumMinusOfObjects(CastlesOnTable[i].CastleThinking[0].AStarGreedy[h], Order * -1);
                            }
                        }
                        else//otherwise
                        {
                            Object OOOO = new Object();
                            lock (OOOO)
                            {
                                //when search finished stop and return
                                var ah1 = Task.Factory.StartNew(() => ac = FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy));
                                ah1.Wait();
                                ah1.Dispose();
                                if (ac)
                                    return;
                            }
                            Object OO1 = new Object();
                            lock (OO1)
                            {
                                FullGameFound = true;

                                a = Color.Gray;
                                if (Order == -1)
                                    a = Color.Brown;
                                int Ord = Order, iAStarGreedy1 = 0, ii1 = ii, jj1 = jj, i1 = i, j1 = j;

                                var ah4 = Task.Factory.StartNew(() => this.FullGameThinkingTree(Order, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ii, jj, i, jjj, FOUND, LeafAStarGreedy));
                                ah4.Wait();
                                ah4.Dispose();

                            }
                        }
                    }

                }
            }
        }
        //deeper leaf found 
        public void FoundOfLeafDepenOfKindFullGameMinister(Color a, ref bool FullGameFound, int[,] Table, int Order, int iAStarGreedy, int ii, int jj, int i, int jjj, bool FOUND, int LeafAStarGreedy)
        {
            Object P = new Object();
            lock (P)
            {
                for (var j = 0; MinisterOnTable != null && MinisterOnTable[i] != null && MinisterOnTable[i].MinisterThinking != null && MinisterOnTable[i].MinisterThinking[0] != null && j < MinisterOnTable[i].MinisterThinking[0].TableListMinister.Count && MinisterOnTable[i].MinisterThinking[0].TableListMinister != null
                  ; j++)
                {
                    bool ac = false;
                    var ah = Task.Factory.StartNew(() => ac = IsSupHuTrue(i, j, 0, 5));
                    ah.Wait();
                    ah.Dispose();
                    if (ac)
                        continue;
                    Object OOOOO = new Object();
                    lock (OOOOO)
                    {
                        //when search finished stop and return
                        var ah1 = Task.Factory.StartNew(() => ac = FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy));
                        ah1.Wait();
                        ah1.Dispose();
                        if (ac)
                            return;
                    }
                    //determine about validity of list on current and deeper return true when successfull
                    bool IA = false;
                    var ah2 = Task.Factory.StartNew(() => IA = IsNonValidityAllTablesHeuristicsAndMore(5, Order, i, j));
                    ah2.Wait();
                    ah2.Dispose();

                    //determine about situation of deeper against other lists computation in 4 state
                    int Is = 0;
                    var ah3 = Task.Factory.StartNew(() => Is = IsSuitableForInitiation(i, j, 5));
                    ah3.Wait();
                    ah3.Dispose();
                    if (!IA)
                        Is = 4;
                    //when is suitable for computational operation on lists
                    if (Is == 4)
                    {
                        Object OOOO = new Object();
                        lock (OOOO)
                        {
                            //when search finished stop and return
                            var ah1 = Task.Factory.StartNew(() => ac = FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy));
                            ah1.Wait();
                            ah1.Dispose();
                            if (ac)
                                return;
                        }
                        FullGameFound = true;

                        //StoreInitMaxAStarGreedy = CurrentMaxLevel; MaxAStarGreedy = CurrentMaxLevel;
                        var H = Task.Factory.StartNew(() => InitiateAStarGreedyt(PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ii, jj, a, CloneATable(Table), Order, false, false, LeafAStarGreedy));
                        H.Wait();
                        H.Dispose();
                        for (int h = 0; h < MinisterOnTable[i].MinisterThinking[0].AStarGreedy.Count && MinisterOnTable[i].MinisterThinking[0].AStarGreedy != null; h++)
                        {
                            MinisterOnTable[i].MinisterThinking[0].AStarGreedy[h].AStarGreedyString = this;
                            MinisterOnTable[i].WinOcuuredatChiled += SumOfObjects(MinisterOnTable[i].MinisterThinking[0].AStarGreedy[h], Order * -1);
                        }
                        for (int h = 0; h < MinisterOnTable[i].MinisterThinking[0].AStarGreedy.Count && MinisterOnTable[i].MinisterThinking[0].AStarGreedy != null; h++)
                            MinisterOnTable[i].LoseOcuuredatChiled[0] += SumMinusOfObjects(MinisterOnTable[i].MinisterThinking[0].AStarGreedy[h], Order * -1);
                    }
                    else
                    {
                        //when is suitable for leafer 
                        if (Is == 2)
                        {
                            for (var iii = 0; iii < MinisterOnTable[i].MinisterThinking[0].AStarGreedy.Count && MinisterOnTable[i].MinisterThinking[0].AStarGreedy[iii].TableList != null && MinisterOnTable[i].MinisterThinking[0].AStarGreedy[iii].TableList.Count > 0; iii++)
                            {
                                Object OOOO = new Object();
                                lock (OOOO)
                                {
                                    FirstTraversalTree = false;
                                    //when search finished stop and return
                                    var ah1 = Task.Factory.StartNew(() => ac = FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy));
                                    ah1.Wait();
                                    ah1.Dispose();
                                    if (ac)
                                        return;
                                }


                                MinisterOnTable[i].MinisterThinking[0].AStarGreedy[iii].FoundOfLeafDepenOfKindFullGame(CloneATable(MinisterOnTable[i].MinisterThinking[0].AStarGreedy[iii].TableList[0]), Order * -1, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ii, jj, i, jjj, FOUND, LeafAStarGreedy);
                                MinisterOnTable[i].MinisterThinking[0].AStarGreedy[iii].AStarGreedyString = this;
                            }
                            for (int h = 0; h < MinisterOnTable[i].MinisterThinking[0].AStarGreedy.Count && MinisterOnTable[i].MinisterThinking[0].AStarGreedy != null; h++)
                                MinisterOnTable[i].WinOcuuredatChiled += SumOfObjects(MinisterOnTable[i].MinisterThinking[0].AStarGreedy[h], Order * -1);
                            for (int h = 0; h < MinisterOnTable[i].MinisterThinking[0].AStarGreedy.Count && MinisterOnTable[i].MinisterThinking[0].AStarGreedy != null; h++)
                                MinisterOnTable[i].LoseOcuuredatChiled[0] += SumMinusOfObjects(MinisterOnTable[i].MinisterThinking[0].AStarGreedy[h], Order * -1);
                        }
                        else if (Is == 3)//when is suitable for deeper
                        {
                            Object OOOO = new Object();
                            lock (OOOO)
                            {
                                //when search finished stop and return
                                var ah1 = Task.Factory.StartNew(() => ac = FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy));
                                ah1.Wait();
                                ah1.Dispose();
                                if (ac)
                                    return;
                            }


                            var H = Task.Factory.StartNew(() => InitiateAStarGreedyt(PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ii, jj, a, CloneATable(Table), Order, false, false, LeafAStarGreedy));
                            H.Wait();
                            H.Dispose();
                            for (int h = 0; h < MinisterOnTable[i].MinisterThinking[0].AStarGreedy.Count && MinisterOnTable[i].MinisterThinking[0].AStarGreedy != null; h++)
                            {
                                MinisterOnTable[i].MinisterThinking[0].AStarGreedy[h].AStarGreedyString = this;
                                MinisterOnTable[i].WinOcuuredatChiled += SumOfObjects(MinisterOnTable[i].MinisterThinking[0].AStarGreedy[h], Order * -1);
                            }
                            for (int h = 0; h < MinisterOnTable[i].MinisterThinking[0].AStarGreedy.Count && MinisterOnTable[i].MinisterThinking[0].AStarGreedy != null; h++)
                                MinisterOnTable[i].LoseOcuuredatChiled[0] += SumMinusOfObjects(MinisterOnTable[i].MinisterThinking[0].AStarGreedy[h], Order * -1);

                        }
                        else//otherwise
                        {
                            Object OOOO = new Object();
                            lock (OOOO)
                            {
                                //when search finished stop and return
                                var ah1 = Task.Factory.StartNew(() => ac = FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy));
                                ah1.Wait();
                                ah1.Dispose();
                                if (ac)
                                    return;
                            }
                            Object OO1 = new Object();
                            lock (OO1)
                            {
                                FullGameFound = true;

                                a = Color.Gray;
                                if (Order == -1)
                                    a = Color.Brown;

                                var ah4 = Task.Factory.StartNew(() => this.FullGameThinkingTree(Order, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ii, jj, i, jjj, FOUND, LeafAStarGreedy));
                                ah4.Wait();
                                ah4.Dispose();

                            }
                        }
                    }
                }
            }
        }
        //deeper leaf found 
        public void FoundOfLeafDepenOfKindFullGameKing(Color a, ref bool FullGameFound, int[,] Table, int Order, int iAStarGreedy, int ii, int jj, int i, int jjj, bool FOUND, int LeafAStarGreedy)
        {
            Object P = new Object();
            lock (P)
            {
                for (var j = 0; KingOnTable != null && KingOnTable[i] != null && KingOnTable[i].KingThinking != null && KingOnTable[i].KingThinking[0] != null && j < KingOnTable[i].KingThinking[0].TableListKing.Count && KingOnTable[i].KingThinking[0].TableListKing != null
           ; j++)
                {
                    Object OOOOO = new Object();
                    lock (OOOOO)
                    {
                        bool ac = false;
                        var ah = Task.Factory.StartNew(() => ac = IsSupHuTrue(i, j, 0, 6));
                        ah.Wait();
                        ah.Dispose();
                        if (ac)
                            continue;
                        //when search finished stop and return
                        var ah1 = Task.Factory.StartNew(() => ac = FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy));
                        ah1.Wait();
                        ah1.Dispose();
                        if (ac)
                            return;
                    }
                    //determine about validity of list on current and deeper return true when successfull
                    bool IA = false;
                    var ah2 = Task.Factory.StartNew(() => IA = IsNonValidityAllTablesHeuristicsAndMore(6, Order, i, j));
                    ah2.Wait();
                    ah2.Dispose();

                    //determine about situation of deeper against other lists computation in 4 state
                    int Is = 0;
                    var ah3 = Task.Factory.StartNew(() => Is = IsSuitableForInitiation(i, j, 6));
                    ah3.Wait();
                    ah3.Dispose();
                    if (!IA)
                        Is = 4;
                    //when is suitable for computational operation on lists
                    if (Is == 4)
                    {
                        Object OOOO = new Object();
                        lock (OOOO)
                        {
                            //when search finished stop and return
                            bool ac = false;
                            var ah1 = Task.Factory.StartNew(() => ac = FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy));
                            ah1.Wait();
                            ah1.Dispose();
                            if (ac)
                                return;
                        }
                        FullGameFound = true;


                        var H = Task.Factory.StartNew(() => InitiateAStarGreedyt(PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ii, jj, a, CloneATable(Table), Order, false, false, LeafAStarGreedy));
                        H.Wait();
                        H.Dispose();
                        for (int h = 0; h < KingOnTable[i].KingThinking[0].AStarGreedy.Count && KingOnTable[i].KingThinking[0].AStarGreedy != null; h++)
                        {
                            KingOnTable[i].KingThinking[0].AStarGreedy[h].AStarGreedyString = this;
                            KingOnTable[i].WinOcuuredatChiled += SumOfObjects(KingOnTable[i].KingThinking[0].AStarGreedy[h], Order * -1);
                        }
                        for (int h = 0; h < KingOnTable[i].KingThinking[0].AStarGreedy.Count && KingOnTable[i].KingThinking[0].AStarGreedy != null; h++)
                            KingOnTable[i].LoseOcuuredatChiled[0] += SumMinusOfObjects(KingOnTable[i].KingThinking[0].AStarGreedy[h], Order * -1);
                    }
                    else
                    {
                        //when is suitable for leafer 
                        if (Is == 2)
                        {
                            for (var iii = 0; iii < KingOnTable[i].KingThinking[0].AStarGreedy.Count && KingOnTable[i].KingThinking[0].AStarGreedy[iii].TableList != null && KingOnTable[i].KingThinking[0].AStarGreedy[iii].TableList.Count > 0; iii++)
                            {
                                Object OOOO = new Object();
                                lock (OOOO)
                                {
                                    FirstTraversalTree = false;

                                    //when search finished stop and return
                                    bool ac = false;
                                    var ah1 = Task.Factory.StartNew(() => ac = FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy));
                                    ah1.Wait();
                                    ah1.Dispose();
                                    if (ac)
                                        return;
                                }


                                KingOnTable[i].KingThinking[0].AStarGreedy[iii].FoundOfLeafDepenOfKindFullGame(CloneATable(KingOnTable[i].KingThinking[0].AStarGreedy[iii].TableList[0]), Order * -1, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ii, jj, i, jjj, FOUND, LeafAStarGreedy);
                                KingOnTable[i].KingThinking[0].AStarGreedy[iii].AStarGreedyString = this;
                            }
                            for (int h = 0; h < KingOnTable[i].KingThinking[0].AStarGreedy.Count && KingOnTable[i].KingThinking[0].AStarGreedy != null; h++)
                                KingOnTable[i].WinOcuuredatChiled += SumOfObjects(KingOnTable[i].KingThinking[0].AStarGreedy[h], Order * -1);
                            for (int h = 0; h < KingOnTable[i].KingThinking[0].AStarGreedy.Count && KingOnTable[i].KingThinking[0].AStarGreedy != null; h++)
                                KingOnTable[i].LoseOcuuredatChiled[0] += SumMinusOfObjects(KingOnTable[i].KingThinking[0].AStarGreedy[h], Order * -1);

                        }
                        else if (Is == 3)//when is suitable for deeper
                        {
                            Object OOOO = new Object();
                            lock (OOOO)
                            {
                                //when search finished stop and return
                                bool ac = false;
                                var ah1 = Task.Factory.StartNew(() => ac = FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy));
                                ah1.Wait();
                                ah1.Dispose();
                                if (ac)
                                    return;
                            }

                            Object O1 = new Object();
                            lock (O1)
                            {
                                int Ord = Order, ii1 = ii, jj1 = jj, i1 = i, j1 = j;
                                //StoreInitMaxAStarGreedy = CurrentMaxLevel; MaxAStarGreedy = CurrentMaxLevel;
                                var H = Task.Factory.StartNew(() => InitiateAStarGreedyt(PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ii, jj, a, CloneATable(Table), Order, false, false, LeafAStarGreedy));
                                H.Wait();
                                H.Dispose();
                                for (int h = 0; h < KingOnTable[i].KingThinking[0].AStarGreedy.Count && KingOnTable[i].KingThinking[0].AStarGreedy != null; h++)
                                {
                                    KingOnTable[i].KingThinking[0].AStarGreedy[h].AStarGreedyString = this;
                                    KingOnTable[i].WinOcuuredatChiled += SumOfObjects(KingOnTable[i].KingThinking[0].AStarGreedy[h], Order * -1);
                                }
                                for (int h = 0; h < KingOnTable[i].KingThinking[0].AStarGreedy.Count && KingOnTable[i].KingThinking[0].AStarGreedy != null; h++)
                                    KingOnTable[i].LoseOcuuredatChiled[0] += SumMinusOfObjects(KingOnTable[i].KingThinking[0].AStarGreedy[h], Order * -1);
                            }
                        }
                        else//otherwise
                        {
                            Object OOOO = new Object();
                            lock (OOOO)
                            {
                                //when search finished stop and return
                                bool ac = false;
                                var ah1 = Task.Factory.StartNew(() => ac = FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy));
                                ah1.Wait();
                                ah1.Dispose();
                                if (ac)
                                    return;
                            }
                            Object OO1 = new Object();
                            lock (OO1)
                            {

                                a = Color.Gray;
                                if (Order == -1)
                                    a = Color.Brown;

                                var ah4 = Task.Factory.StartNew(() => this.FullGameThinkingTree(Order, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ii, jj, i, jjj, FOUND, LeafAStarGreedy));
                                ah4.Wait();
                                ah4.Dispose();

                            }
                        }
                    }
                }
            }
        }
        //deeper leaf found 
        public void FoundOfLeafDepenOfKindFullGameCastling(Color a, ref bool FullGameFound, int[,] Table, int Order, int iAStarGreedy, int ii, int jj, int i, int jjj, bool FOUND, int LeafAStarGreedy)
        {
            Object P = new Object();
            lock (P)
            {
                for (var j = 0; CastlingOnTable != null && CastlingOnTable[i] != null && CastlingOnTable[i].CastlingThinking != null && CastlingOnTable[i].CastlingThinking[0] != null && j < CastlingOnTable[i].CastlingThinking[0].TableListCastling.Count && CastlingOnTable[i].CastlingThinking[0].TableListCastling != null
           ; j++)
                {
                    Object OOOOO = new Object();
                    lock (OOOOO)
                    {
                        bool ac = false;
                        var ah = Task.Factory.StartNew(() => ac = IsSupHuTrue(i, j, 0, 7));
                        ah.Wait();
                        ah.Dispose();
                        if (ac)
                            continue;
                        //when search finished stop and return
                        var ah1 = Task.Factory.StartNew(() => ac = FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy));
                        ah1.Wait();
                        ah1.Dispose();
                        if (ac)
                            return;
                    }
                    //determine about validity of list on current and deeper return true when successfull
                    bool IA = false;
                    var ah2 = Task.Factory.StartNew(() => IA = IsNonValidityAllTablesHeuristicsAndMore(7, Order, i, j));
                    ah2.Wait();
                    ah2.Dispose();

                    //determine about situation of deeper against other lists computation in 4 state
                    int Is = 0;
                    var ah3 = Task.Factory.StartNew(() => Is = IsSuitableForInitiation(i, j, 7));
                    ah3.Wait();
                    ah3.Dispose();
                    if (!IA)
                        Is = 4;
                    //when is suitable for computational operation on lists
                    if (Is == 4)
                    {
                        Object OOOO = new Object();
                        lock (OOOO)
                        {
                            //when search finished stop and return
                            bool ac = false;
                            var ah1 = Task.Factory.StartNew(() => ac = FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy));
                            ah1.Wait();
                            ah1.Dispose();
                            if (ac)
                                return;
                        }
                        FullGameFound = true;

                        //StoreInitMaxAStarGreedy = CurrentMaxLevel; MaxAStarGreedy = CurrentMaxLevel;
                        var H = Task.Factory.StartNew(() => InitiateAStarGreedyt(PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ii, jj, a, CloneATable(Table), Order, false, false, LeafAStarGreedy));
                        H.Wait();
                        H.Dispose();
                        for (int h = 0; h < CastlingOnTable[i].CastlingThinking[0].AStarGreedy.Count && CastlingOnTable[i].CastlingThinking[0].AStarGreedy != null; h++)
                        {
                            CastlingOnTable[i].CastlingThinking[0].AStarGreedy[h].AStarGreedyString = this;
                            CastlingOnTable[i].WinOcuuredatChiled += SumOfObjects(CastlingOnTable[i].CastlingThinking[0].AStarGreedy[h], Order * -1);
                        }
                        for (int h = 0; h < CastlingOnTable[i].CastlingThinking[0].AStarGreedy.Count && CastlingOnTable[i].CastlingThinking[0].AStarGreedy != null; h++)
                            CastlingOnTable[i].LoseOcuuredatChiled[0] += SumMinusOfObjects(CastlingOnTable[i].CastlingThinking[0].AStarGreedy[h], Order * -1);
                    }
                    else
                    {
                        //when is suitable for leafer 
                        if (Is == 2)
                        {
                            for (var iii = 0; iii < CastlingOnTable[i].CastlingThinking[0].AStarGreedy.Count && CastlingOnTable[i].CastlingThinking[0].AStarGreedy[iii].TableList != null && CastlingOnTable[i].CastlingThinking[0].AStarGreedy[iii].TableList.Count > 0; iii++)
                            {
                                Object OOOO = new Object();
                                lock (OOOO)
                                {
                                    FirstTraversalTree = false;

                                    //when search finished stop and return
                                    bool ac = false;
                                    var ah1 = Task.Factory.StartNew(() => ac = FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy));
                                    ah1.Wait();
                                    ah1.Dispose();
                                    if (ac)
                                        return;
                                }


                                CastlingOnTable[i].CastlingThinking[0].AStarGreedy[iii].FoundOfLeafDepenOfKindFullGame(CloneATable(CastlingOnTable[i].CastlingThinking[0].AStarGreedy[iii].TableList[0]), Order * -1, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ii, jj, i, jjj, FOUND, LeafAStarGreedy);
                                CastlingOnTable[i].CastlingThinking[0].AStarGreedy[iii].AStarGreedyString = this;
                            }
                            for (int h = 0; h < CastlingOnTable[i].CastlingThinking[0].AStarGreedy.Count && CastlingOnTable[i].CastlingThinking[0].AStarGreedy != null; h++)
                                CastlingOnTable[i].WinOcuuredatChiled += SumOfObjects(CastlingOnTable[i].CastlingThinking[0].AStarGreedy[h], Order * -1);
                            for (int h = 0; h < CastlingOnTable[i].CastlingThinking[0].AStarGreedy.Count && CastlingOnTable[i].CastlingThinking[0].AStarGreedy != null; h++)
                                CastlingOnTable[i].LoseOcuuredatChiled[0] += SumMinusOfObjects(CastlingOnTable[i].CastlingThinking[0].AStarGreedy[h], Order * -1);

                        }
                        else if (Is == 3)//when is suitable for deeper
                        {
                            Object OOOO = new Object();
                            lock (OOOO)
                            {
                                //when search finished stop and return
                                bool ac = false;
                                var ah1 = Task.Factory.StartNew(() => ac = FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy));
                                ah1.Wait();
                                ah1.Dispose();
                                if (ac)
                                    return;
                            }

                            Object O1 = new Object();
                            lock (O1)
                            {
                                int Ord = Order, ii1 = ii, jj1 = jj, i1 = i, j1 = j;
                                //StoreInitMaxAStarGreedy = CurrentMaxLevel; MaxAStarGreedy = CurrentMaxLevel;
                                var H = Task.Factory.StartNew(() => InitiateAStarGreedyt(PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ii, jj, a, CloneATable(Table), Order, false, false, LeafAStarGreedy));
                                H.Wait();
                                H.Dispose();
                                for (int h = 0; h < CastlingOnTable[i].CastlingThinking[0].AStarGreedy.Count && CastlingOnTable[i].CastlingThinking[0].AStarGreedy != null; h++)
                                {
                                    CastlingOnTable[i].CastlingThinking[0].AStarGreedy[h].AStarGreedyString = this;
                                    CastlingOnTable[i].WinOcuuredatChiled += SumOfObjects(CastlingOnTable[i].CastlingThinking[0].AStarGreedy[h], Order * -1);
                                }
                                for (int h = 0; h < CastlingOnTable[i].CastlingThinking[0].AStarGreedy.Count && CastlingOnTable[i].CastlingThinking[0].AStarGreedy != null; h++)
                                    CastlingOnTable[i].LoseOcuuredatChiled[0] += SumMinusOfObjects(CastlingOnTable[i].CastlingThinking[0].AStarGreedy[h], Order * -1);
                            }
                        }
                        else//otherwise
                        {
                            Object OOOO = new Object();
                            lock (OOOO)
                            {
                                //when search finished stop and return
                                bool ac = false;
                                var ah1 = Task.Factory.StartNew(() => ac = FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy));
                                ah1.Wait();
                                ah1.Dispose();
                                if (ac)
                                    return;
                            }
                            Object OO1 = new Object();
                            lock (OO1)
                            {

                                a = Color.Gray;
                                if (Order == -1)
                                    a = Color.Brown;

                                var ah4 = Task.Factory.StartNew(() => this.FullGameThinkingTree(Order, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ii, jj, i, jjj, FOUND, LeafAStarGreedy));
                                ah4.Wait();
                                ah4.Dispose();

                            }
                        }
                    }
                }
            }
        }
        public void FoundOfLeafDepenOfKindFullGame(int[,] Table, int Order, int iAStarGreedy, int ii, int jj, int ik, int jjj, bool FOUND, int LeafAStarGreedy)
        {
            LeafSemaphoreIndex = true;

            Object a1 = new Object();
            lock (a1)
            {
                //heigth justice math and logic
                /*   if (MaxAStarGreedy < MaxAStarGreedy + CurrentMaxLevel + (PlatformHelper.ProcessorCount - iAStarGreedy))
                   {
                       MaxAStarGreedy = MaxAStarGreedy + CurrentMaxLevel + (PlatformHelper.ProcessorCount - iAStarGreedy);
                   }
                   */
                if (
                     /*(MaxAStarGreedy <= CurrentMaxLevel + PlatformHelper.ProcessorCount) &&*/
                     ((MaxAStarGreedy < StoreInitMaxAStarGreedy + PlatformHelper.ProcessorCount) || SStopInitMaxAStarGreedy))// if (MaxAStarGreedy < indexStep * PlatformHelper.ProcessorCount)
                {
                    MaxAStarGreedy = CurrentMaxLevel;
                }
                else
                    //if (CurrentMaxLevel >= MaxAStarGreedy)
                    return;
                Object Omm1 = new Object();
                lock (Omm1)
                {
                    /*//if (CurrentMaxLevel >= MaxAStarGreedy)
                        return;
                    else
                    {
                        //if (CurrentMaxLevel < CurrentMaxLevel + (PlatformHelper.ProcessorCount - iAStarGreedy))
                        //CurrentMaxLevel = CurrentMaxLevel + 1;
                        if (CurrentMaxLevel < CurrentMaxLevel + (PlatformHelper.ProcessorCount - iAStarGreedy))
                             CurrentMaxLevel = CurrentMaxLevel + (PlatformHelper.ProcessorCount - iAStarGreedy);
                    
                    }*/
                    /* if (iAStarGreedy < 0 //&& iAStarGreedy < MaxDuringLevelThinkingCreation
                )
                     {
                         IS = true;
                     }*/
                }
                bool FullGameFound = false;
                Object O = new Object();
                lock (O)
                {
                    //Gray
                    if (Order == 1)
                    {
                        //parallel full game all deeper foundation
                        Color a = Color.Gray;
                        var output = Task.Factory.StartNew(() =>
                        {
                            //if (!feedCancellationTokenSource.IsCancellationRequested)
                            {
                                ParallelOptions po = new ParallelOptions(); po.MaxDegreeOfParallelism = System.Threading.PlatformHelper.ProcessorCount; Parallel.Invoke(() =>
         {
            //soldier
            for (var i = 0; i < SodierMidle; i++)
             {
                 Object OOOO = new Object();
                 lock (OOOO)
                 {
                    //when search finished stop and return
                    bool ac = false;
                     var ah1 = Task.Factory.StartNew(() => ac = FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy));
                     ah1.Wait();
                     ah1.Dispose();
                     if (ac)
                         return;
                 }
                 Object P = new Object();
                 lock (P)
                 {
                     var ah = Task.Factory.StartNew(() => FoundOfLeafDepenOfKindFullGameSoldeir(a, ref FullGameFound, CloneATable(Table), Order, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ii, jj, i, jjj, FOUND, LeafAStarGreedy));
                     ah.Wait();
                     ah.Dispose();


                 }
             }
         }, () =>
         {
            //elephant
            for (var i = 0; i < ElefantMidle; i++)
             {
                 Object OOOO = new Object();
                 lock (OOOO)
                 {
                    //when search finished stop and return
                    bool ac = false;
                     var ah1 = Task.Factory.StartNew(() => ac = FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy));
                     ah1.Wait();
                     ah1.Dispose();
                     if (ac)
                         return;
                 }
                 Object P = new Object();
                 lock (P)
                 {
                     var ah = Task.Factory.StartNew(() => FoundOfLeafDepenOfKindFullGameElepahnt(a, ref FullGameFound, CloneATable(Table), Order, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ii, jj, i, jjj, FOUND, LeafAStarGreedy));
                     ah.Wait();
                     ah.Dispose();

                 }
             }
         }, () =>
         {
            //hourse
            for (var i = 0; i < HourseMidle; i++)
             {
                 Object OOOO = new Object();
                 lock (OOOO)
                 {
                    //when search finished stop and return
                    bool ac = false;
                     var ah1 = Task.Factory.StartNew(() => ac = FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy));
                     ah1.Wait();
                     ah1.Dispose();
                     if (ac)
                         return;
                 }
                 Object P = new Object();
                 lock (P)
                 {
                     var ah = Task.Factory.StartNew(() => FoundOfLeafDepenOfKindFullGameHourse(a, ref FullGameFound, CloneATable(Table), Order, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ii, jj, i, jjj, FOUND, LeafAStarGreedy));
                     ah.Wait();
                     ah.Dispose();

                 }
             }
         }, () =>
         {
            //Castle
            for (var i = 0; i < CastleMidle; i++)
             {
                 Object OOOO = new Object();
                 lock (OOOO)
                 {
                    //when search finished stop and return
                    bool ac = false;
                     var ah1 = Task.Factory.StartNew(() => ac = FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy));
                     ah1.Wait();
                     ah1.Dispose();
                     if (ac)
                         return;
                 }
                 Object P = new Object();
                 lock (P)
                 {
                     var ah = Task.Factory.StartNew(() => FoundOfLeafDepenOfKindFullGameCastle(a, ref FullGameFound, CloneATable(Table), Order, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ii, jj, i, jjj, FOUND, LeafAStarGreedy));
                     ah.Wait();
                     ah.Dispose();

                 }
             }
         }, () =>
         {
            //minister
            for (var i = 0; i < MinisterMidle; i++)
             {
                 Object OOOO = new Object();
                 lock (OOOO)
                 {
                    //when search finished stop and return
                    bool ac = false;
                     var ah1 = Task.Factory.StartNew(() => ac = FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy));
                     ah1.Wait();
                     ah1.Dispose();
                     if (ac)
                         return;
                 }
                 Object P = new Object();
                 lock (P)
                 {
                     var ah = Task.Factory.StartNew(() => FoundOfLeafDepenOfKindFullGameMinister(a, ref FullGameFound, CloneATable(Table), Order, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ii, jj, i, jjj, FOUND, LeafAStarGreedy));
                     ah.Wait();
                     ah.Dispose();

                 }
             }
         }, () =>
         {
            //king
            for (var i = 0; i < KingMidle; i++)
             {
                 Object OOOO = new Object();
                 lock (OOOO)
                 {
                    //when search finished stop and return
                    bool ac = false;
                     var ah1 = Task.Factory.StartNew(() => ac = FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy));
                     ah1.Wait();
                     ah1.Dispose();
                     if (ac)
                         return;
                 }
                 Object P = new Object();
                 lock (P)
                 {
                     var ah = Task.Factory.StartNew(() => FoundOfLeafDepenOfKindFullGameKing(a, ref FullGameFound, CloneATable(Table), Order, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ii, jj, i, jjj, FOUND, LeafAStarGreedy));
                     ah.Wait();
                     ah.Dispose();

                 }
             }
         }, () =>
         {
            //king
            for (var i = 0; i < 1; i++)
             {
                 Object OOOO = new Object();
                 lock (OOOO)
                 {
                    //when search finished stop and return
                    bool ac = false;
                     var ah1 = Task.Factory.StartNew(() => ac = FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy));
                     ah1.Wait();
                     ah1.Dispose();
                     if (ac)
                         return;
                 }
                 Object P = new Object();
                 lock (P)
                 {
                     var ah = Task.Factory.StartNew(() => FoundOfLeafDepenOfKindFullGameCastling(a, ref FullGameFound, CloneATable(Table), Order, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ii, jj, i, jjj, FOUND, LeafAStarGreedy));
                     ah.Wait();
                     ah.Dispose();

                 }
             }
         });
                            }
                        });
                        output.Wait(); output.Dispose();

                    }
                    else//Brown
                    {
                        Color a = Color.Brown;
                        var output = Task.Factory.StartNew(() =>
                        {
                            //if (!feedCancellationTokenSource.IsCancellationRequested)
                            {
                                ParallelOptions po = new ParallelOptions(); po.MaxDegreeOfParallelism = System.Threading.PlatformHelper.ProcessorCount; Parallel.Invoke(() =>
         {
            //soldier
            for (var i = SodierMidle; i < SodierHigh; i++)
             {
                 Object OOOO = new Object();
                 lock (OOOO)
                 {
                    //when search finished stop and return
                    bool ac = false;
                     var ah1 = Task.Factory.StartNew(() => ac = FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy));
                     ah1.Wait();
                     ah1.Dispose();
                     if (ac)
                         return;
                 }
                 Object P = new Object();
                 lock (P)
                 {
                     var ah = Task.Factory.StartNew(() => FoundOfLeafDepenOfKindFullGameSoldeir(a, ref FullGameFound, CloneATable(Table), Order, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ii, jj, i, jjj, FOUND, LeafAStarGreedy));
                     ah.Wait();
                     ah.Dispose();

                 }
             }
         }, () =>
         {
            //elephant
            for (var i = ElefantMidle; i < ElefantHigh; i++)
             {
                 Object OOOO = new Object();
                 lock (OOOO)
                 {
                    //when search finished stop and return
                    bool ac = false;
                     var ah1 = Task.Factory.StartNew(() => ac = FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy));
                     ah1.Wait();
                     ah1.Dispose();
                     if (ac)
                         return;
                 }
                 Object P = new Object();
                 lock (P)
                 {
                     var ah = Task.Factory.StartNew(() => FoundOfLeafDepenOfKindFullGameElepahnt(a, ref FullGameFound, CloneATable(Table), Order, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ii, jj, i, jjj, FOUND, LeafAStarGreedy));
                     ah.Wait();
                     ah.Dispose();

                 }
             }
         }, () =>
         {
            //hourse
            for (var i = HourseMidle; i < HourseHight; i++)
             {
                 Object OOOO = new Object();
                 lock (OOOO)
                 {
                    //when search finished stop and return
                    bool ac = false;
                     var ah1 = Task.Factory.StartNew(() => ac = FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy));
                     ah1.Wait();
                     ah1.Dispose();
                     if (ac)
                         return;
                 }
                 Object P = new Object();
                 lock (P)
                 {
                     var ah = Task.Factory.StartNew(() => FoundOfLeafDepenOfKindFullGameHourse(a, ref FullGameFound, CloneATable(Table), Order, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ii, jj, i, jjj, FOUND, LeafAStarGreedy));
                     ah.Wait();
                     ah.Dispose();
                 }
             }
         }, () =>
         {
            //Castle
            for (var i = CastleMidle; i < CastleHigh; i++)
             {
                 Object OOOO = new Object();
                 lock (OOOO)
                 {
                    //when search finished stop and return
                    bool ac = false;
                     var ah1 = Task.Factory.StartNew(() => ac = FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy));
                     ah1.Wait();
                     ah1.Dispose();
                     if (ac)
                         return;
                 }
                 Object P = new Object();
                 lock (P)
                 {
                     var ah = Task.Factory.StartNew(() => FoundOfLeafDepenOfKindFullGameCastle(a, ref FullGameFound, CloneATable(Table), Order, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ii, jj, i, jjj, FOUND, LeafAStarGreedy));
                     ah.Wait();
                     ah.Dispose();

                 }
             }
         }, () =>
         {
            //minister
            for (var i = MinisterMidle; i < MinisterHigh; i++)
             {
                 Object OOOO = new Object();
                 lock (OOOO)
                 {
                    //when search finished stop and return
                    bool ac = false;
                     var ah1 = Task.Factory.StartNew(() => ac = FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy));
                     ah1.Wait();
                     ah1.Dispose();
                     if (ac)
                         return;
                 }
                 Object P = new Object();
                 lock (P)
                 {
                     var ah = Task.Factory.StartNew(() => FoundOfLeafDepenOfKindFullGameMinister(a, ref FullGameFound, CloneATable(Table), Order, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ii, jj, i, jjj, FOUND, LeafAStarGreedy));
                     ah.Wait();
                     ah.Dispose();

                 }
             }
         }, () =>
         {
            //king
            for (var i = KingMidle; i < KingHigh; i++)
             {
                 Object OOOO = new Object();
                 lock (OOOO)
                 {
                    //when search finished stop and return
                    bool ac = false;
                     var ah1 = Task.Factory.StartNew(() => ac = FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy));
                     ah1.Wait();
                     ah1.Dispose();
                     if (ac)
                         return;
                 }
                 Object P = new Object();
                 lock (P)
                 {
                     var ah = Task.Factory.StartNew(() => FoundOfLeafDepenOfKindFullGameKing(a, ref FullGameFound, CloneATable(Table), Order, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ii, jj, i, jjj, FOUND, LeafAStarGreedy));
                     ah.Wait();
                     ah.Dispose();

                 }
             }
         }, () =>
         {
            //king
            for (var i = 0; i < 1; i++)
             {
                 Object OOOO = new Object();
                 lock (OOOO)
                 {
                    //when search finished stop and return
                    bool ac = false;
                     var ah1 = Task.Factory.StartNew(() => ac = FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy));
                     ah1.Wait();
                     ah1.Dispose();
                     if (ac)
                         return;
                 }
                 Object P = new Object();
                 lock (P)
                 {
                     var ah = Task.Factory.StartNew(() => FoundOfLeafDepenOfKindFullGameCastling(a, ref FullGameFound, CloneATable(Table), Order, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ii, jj, i, jjj, FOUND, LeafAStarGreedy));
                     ah.Wait();
                     ah.Dispose();

                 }
             }
         });
                            }
                        });
                        output.Wait(); output.Dispose();
                    }
                }
                //when not occured untile now computational op
                if (!FullGameFound)
                {
                    Object O1 = new Object();
                    lock (O1)
                    {
                        //when search finished stop and return
                        bool ac = false;
                        var ah1 = Task.Factory.StartNew(() => ac = FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy));
                        ah1.Wait();
                        ah1.Dispose();
                        if (ac)
                            return;
                        //StoreInitMaxAStarGreedy = CurrentMaxLevel; MaxAStarGreedy = CurrentMaxLevel;
                        Color a = Color.Gray;
                        if (Order == -1)
                            a = Color.Brown;
                        var H = Task.Factory.StartNew(() => InitiateAStarGreedyt(AllDraw.MaxAStarGreedy, ii, jj, a, CloneATable(Table), Order, false, false, LeafAStarGreedy));
                        H.Wait();
                        H.Dispose();

                    }
                }

                return;
            }
        }
        //for regard all branches of leaf victory node
        public void MakeRegardAllCheckMateBranches(AllDraw A, int Order)
        {

            Object a = new Object();
            lock (a)
            {
                int COrder = Order;
                int CDummy = ChessRules.CurrentOrder;
                //Gray
                if (Order == 1)
                {
                    //soldier
                    for (var i = 0; i < SodierMidle; i++)
                        for (var j = 0; A.SolderesOnTable != null && SolderesOnTable[i] != null && A.SolderesOnTable[i].SoldierThinking[0] != null && j < A.SolderesOnTable[i].SoldierThinking[0].TableListSolder.Count; j++)
                        {
                            //make regard
                            var ah = Task.Factory.StartNew(() => A.SolderesOnTable[i].SoldierThinking[0].PenaltyRegardListSolder[i].LearningAlgorithmRegard());
                            ah.Wait();
                            ah.Dispose();

                            Order *= -1; ChessRules.CurrentOrder *= -1;
                            //deeper call
                            for (var ii = 0; A.SolderesOnTable != null && SolderesOnTable[i] != null && A.SolderesOnTable[i].SoldierThinking[0] != null && ii < A.SolderesOnTable[i].SoldierThinking[0].AStarGreedy.Count; ii++)
                            {
                                var ah1 = Task.Factory.StartNew(() => MakeRegardAllCheckMateBranches(A.SolderesOnTable[i].SoldierThinking[0].AStarGreedy[ii], Order));
                                ah1.Wait();
                                ah1.Dispose();

                            }
                            Order = COrder; ChessRules.CurrentOrder = CDummy;
                        }
                    //elephant
                    for (var i = 0; i < ElefantMidle; i++)
                        for (var j = 0; A.ElephantOnTable != null && ElephantOnTable[i] != null && A.ElephantOnTable[i].ElefantThinking[0] != null && j < A.ElephantOnTable[i].ElefantThinking[0].TableListElefant.Count; j++)
                        {

                            //make regard
                            var ah = Task.Factory.StartNew(() => A.ElephantOnTable[i].ElefantThinking[0].PenaltyRegardListElefant[j].LearningAlgorithmRegard());
                            ah.Wait();
                            ah.Dispose();

                            Order *= -1; ChessRules.CurrentOrder *= -1;
                            //deeper call
                            for (var ii = 0; A.ElephantOnTable != null && ElephantOnTable[i] != null && A.ElephantOnTable[i].ElefantThinking[0] != null && ii < A.ElephantOnTable[i].ElefantThinking[0].AStarGreedy.Count; ii++)
                            {
                                var ah1 = Task.Factory.StartNew(() => MakeRegardAllCheckMateBranches(A.ElephantOnTable[i].ElefantThinking[0].AStarGreedy[ii], Order));
                                ah1.Wait();
                                ah1.Dispose();

                            }
                            Order = COrder; ChessRules.CurrentOrder = CDummy;
                        }
                    //hourse
                    for (var i = 0; i < HourseMidle; i++)
                        for (var j = 0; A.HoursesOnTable != null && HoursesOnTable[i] != null && A.HoursesOnTable[i].HourseThinking[0] != null && j < A.HoursesOnTable[i].HourseThinking[0].TableListHourse.Count; j++)
                        {
                            //make regard
                            var ah = Task.Factory.StartNew(() => A.HoursesOnTable[i].HourseThinking[0].PenaltyRegardListHourse[j].LearningAlgorithmRegard());
                            ah.Wait();
                            ah.Dispose();

                            Order *= -1; ChessRules.CurrentOrder *= -1;
                            //deeper call
                            for (var ii = 0; A.HoursesOnTable != null && HoursesOnTable[i] != null && A.HoursesOnTable[i].HourseThinking[0] != null && ii < A.HoursesOnTable[i].HourseThinking[0].AStarGreedy.Count; ii++)
                            {
                                var ah1 = Task.Factory.StartNew(() => MakeRegardAllCheckMateBranches(A.HoursesOnTable[i].HourseThinking[0].AStarGreedy[ii], Order));
                                ah1.Wait();
                                ah1.Dispose();

                            }
                            Order = COrder; ChessRules.CurrentOrder = CDummy;
                        }
                    //Castle
                    for (var i = 0; i < CastleMidle; i++)
                        for (var j = 0; A.CastlesOnTable != null && CastlesOnTable[i] != null && A.CastlesOnTable[i].CastleThinking[0] != null && j < A.CastlesOnTable[i].CastleThinking[0].TableListCastle.Count; j++)
                        {
                            //make regard
                            var ah = Task.Factory.StartNew(() => A.CastlesOnTable[i].CastleThinking[0].PenaltyRegardListCastle[j].LearningAlgorithmRegard());
                            ah.Wait();
                            ah.Dispose();

                            Order *= -1; ChessRules.CurrentOrder *= -1;
                            //deeper call
                            for (var ii = 0; A.CastlesOnTable != null && CastlesOnTable[i] != null && A.CastlesOnTable[i].CastleThinking[0] != null && ii < A.CastlesOnTable[i].CastleThinking[0].AStarGreedy.Count; ii++)
                            {
                                var ah1 = Task.Factory.StartNew(() => MakeRegardAllCheckMateBranches(A.CastlesOnTable[i].CastleThinking[0].AStarGreedy[ii], Order));
                                ah1.Wait();
                                ah1.Dispose();

                            }
                            Order = COrder; ChessRules.CurrentOrder = CDummy;
                        }
                    //minister
                    for (var i = 0; i < MinisterMidle; i++)
                        for (var j = 0; A.MinisterOnTable != null && MinisterOnTable[i] != null && A.MinisterOnTable[i].MinisterThinking[0] != null && j < A.MinisterOnTable[i].MinisterThinking[0].TableListMinister.Count; j++)
                        {
                            //make regard
                            var ah = Task.Factory.StartNew(() => A.MinisterOnTable[i].MinisterThinking[0].PenaltyRegardListMinister[j].LearningAlgorithmRegard());
                            ah.Wait();
                            ah.Dispose();

                            Order *= -1; ChessRules.CurrentOrder *= -1;
                            //deeper call
                            for (var ii = 0; A.MinisterOnTable != null && MinisterOnTable[i] != null && A.MinisterOnTable[i].MinisterThinking[0] != null && ii < A.MinisterOnTable[i].MinisterThinking[0].AStarGreedy.Count; ii++)
                            {
                                var ah1 = Task.Factory.StartNew(() => MakeRegardAllCheckMateBranches(A.MinisterOnTable[i].MinisterThinking[0].AStarGreedy[ii], Order));
                                ah1.Wait();
                                ah1.Dispose();
                            }
                            Order = COrder; ChessRules.CurrentOrder = CDummy;
                        }
                    //king
                    for (var i = 0; i < KingMidle; i++)
                        for (var j = 0; A.KingOnTable != null && KingOnTable[i] != null && A.KingOnTable[i].KingThinking[0] != null && j < A.KingOnTable[i].KingThinking[0].TableListKing.Count; j++)
                        {
                            //make regard
                            var ah = Task.Factory.StartNew(() => A.KingOnTable[i].KingThinking[0].PenaltyRegardListKing[j].LearningAlgorithmRegard());
                            ah.Wait();
                            ah.Dispose();
                            Order *= -1; ChessRules.CurrentOrder *= -1;
                            //deeper call
                            for (var ii = 0; A.KingOnTable != null && KingOnTable[i] != null && A.KingOnTable[i].KingThinking[0] != null && ii < A.KingOnTable[i].KingThinking[0].AStarGreedy.Count; ii++)
                            {
                                var ah1 = Task.Factory.StartNew(() => MakeRegardAllCheckMateBranches(A.KingOnTable[i].KingThinking[0].AStarGreedy[ii], Order));
                                ah1.Wait();
                                ah1.Dispose();
                            }
                            Order = COrder; ChessRules.CurrentOrder = CDummy;
                        }
                    for (var i = 0; i < 1; i++)
                        for (var j = 0; A.CastlingOnTable != null && CastlingOnTable[i] != null && A.CastlingOnTable[i].CastlingThinking[0] != null && j < A.CastlingOnTable[i].CastlingThinking[0].TableListCastling.Count; j++)
                        {
                            //make regard
                            var ah = Task.Factory.StartNew(() => A.CastlingOnTable[i].CastlingThinking[0].PenaltyRegardListCastling[j].LearningAlgorithmRegard());
                            ah.Wait();
                            ah.Dispose();
                            Order *= -1; ChessRules.CurrentOrder *= -1;
                            //deeper call
                            for (var ii = 0; A.CastlingOnTable != null && CastlingOnTable[i] != null && A.CastlingOnTable[i].CastlingThinking[0] != null && ii < A.CastlingOnTable[i].CastlingThinking[0].AStarGreedy.Count; ii++)
                            {
                                var ah1 = Task.Factory.StartNew(() => MakeRegardAllCheckMateBranches(A.CastlingOnTable[i].CastlingThinking[0].AStarGreedy[ii], Order));
                                ah1.Wait();
                                ah1.Dispose();
                            }
                            Order = COrder; ChessRules.CurrentOrder = CDummy;
                        }
                }
                else//Brown
                {
                    //soldier
                    for (var i = SodierMidle; i < SodierHigh; i++)
                        for (var j = 0; A.SolderesOnTable != null && SolderesOnTable[i] != null && A.SolderesOnTable[i].SoldierThinking[0] != null && j < A.SolderesOnTable[i].SoldierThinking[0].TableListSolder.Count; j++)
                        {
                            //make regard
                            var ah = Task.Factory.StartNew(() => A.SolderesOnTable[i].SoldierThinking[0].PenaltyRegardListSolder[i].LearningAlgorithmRegard());
                            ah.Wait();
                            ah.Dispose();

                            Order *= -1; ChessRules.CurrentOrder *= -1;
                            //deeper call
                            for (var ii = 0; A.SolderesOnTable != null && SolderesOnTable[i] != null && A.SolderesOnTable[i].SoldierThinking[0] != null && ii < A.SolderesOnTable[i].SoldierThinking[0].AStarGreedy.Count; ii++)
                            {
                                var ah1 = Task.Factory.StartNew(() => MakeRegardAllCheckMateBranches(A.SolderesOnTable[i].SoldierThinking[0].AStarGreedy[ii], Order));
                                ah1.Wait();
                                ah1.Dispose();

                            }
                            Order = COrder; ChessRules.CurrentOrder = CDummy;
                        }
                    //elephant
                    for (var i = ElefantMidle; i < ElefantHigh; i++)
                        for (var j = 0; A.ElephantOnTable != null && ElephantOnTable[i] != null && A.ElephantOnTable[i].ElefantThinking[0] != null && j < A.ElephantOnTable[i].ElefantThinking[0].TableListElefant.Count; j++)
                        {
                            //make regard
                            var ah = Task.Factory.StartNew(() => A.ElephantOnTable[i].ElefantThinking[0].PenaltyRegardListElefant[j].LearningAlgorithmRegard());
                            ah.Wait();
                            ah.Dispose();

                            Order *= -1; ChessRules.CurrentOrder *= -1;
                            //deeper call
                            for (var ii = 0; A.ElephantOnTable != null && ElephantOnTable[i] != null && A.ElephantOnTable[i].ElefantThinking[0] != null && ii < A.ElephantOnTable[i].ElefantThinking[0].AStarGreedy.Count; ii++)
                            {
                                var ah1 = Task.Factory.StartNew(() => MakeRegardAllCheckMateBranches(A.ElephantOnTable[i].ElefantThinking[0].AStarGreedy[ii], Order));
                                ah1.Wait();
                                ah1.Dispose();

                            }
                            Order = COrder; ChessRules.CurrentOrder = CDummy;
                        }
                    //hourse
                    for (var i = HourseMidle; i < HourseHight; i++)
                        for (var j = 0; A.HoursesOnTable != null && HoursesOnTable[i] != null && A.HoursesOnTable[i].HourseThinking[0] != null && j < A.HoursesOnTable[i].HourseThinking[0].TableListHourse.Count; j++)
                        {
                            //make regard
                            var ah = Task.Factory.StartNew(() => A.HoursesOnTable[i].HourseThinking[0].PenaltyRegardListHourse[j].LearningAlgorithmRegard());
                            ah.Wait();
                            ah.Dispose();

                            Order *= -1; ChessRules.CurrentOrder *= -1;
                            //deeper call
                            for (var ii = 0; A.HoursesOnTable != null && HoursesOnTable[i] != null && A.HoursesOnTable[i].HourseThinking[0] != null && ii < A.HoursesOnTable[i].HourseThinking[0].AStarGreedy.Count; ii++)
                            {
                                var ah1 = Task.Factory.StartNew(() => MakeRegardAllCheckMateBranches(A.HoursesOnTable[i].HourseThinking[0].AStarGreedy[ii], Order));
                                ah1.Wait();
                                ah1.Dispose();

                            }
                            Order = COrder; ChessRules.CurrentOrder = CDummy;
                        }
                    //Castle
                    for (var i = CastleMidle; i < CastleHigh; i++)
                        for (var j = 0; A.CastlesOnTable != null && CastlesOnTable[i] != null && A.CastlesOnTable[i].CastleThinking[0] != null && j < A.CastlesOnTable[i].CastleThinking[0].TableListCastle.Count; j++)
                        {
                            //make regard
                            var ah = Task.Factory.StartNew(() => A.CastlesOnTable[i].CastleThinking[0].PenaltyRegardListCastle[j].LearningAlgorithmRegard());
                            ah.Wait();
                            ah.Dispose();

                            Order *= -1; ChessRules.CurrentOrder *= -1;
                            //deeper call
                            for (var ii = 0; A.CastlesOnTable != null && CastlesOnTable[i] != null && A.CastlesOnTable[i].CastleThinking[0] != null && ii < A.CastlesOnTable[i].CastleThinking[0].AStarGreedy.Count; ii++)
                            {
                                var ah1 = Task.Factory.StartNew(() => MakeRegardAllCheckMateBranches(A.CastlesOnTable[i].CastleThinking[0].AStarGreedy[ii], Order));
                                ah1.Wait();
                                ah1.Dispose();

                            }
                            Order = COrder; ChessRules.CurrentOrder = CDummy;
                        }
                    //minister
                    for (var i = MinisterMidle; i < MinisterHigh; i++)
                        for (var j = 0; A.MinisterOnTable != null && MinisterOnTable[i] != null && A.MinisterOnTable[i].MinisterThinking[0] != null && j < A.MinisterOnTable[i].MinisterThinking[0].TableListMinister.Count; j++)
                        {
                            //make regard
                            var ah = Task.Factory.StartNew(() => A.MinisterOnTable[i].MinisterThinking[0].PenaltyRegardListMinister[j].LearningAlgorithmRegard());
                            ah.Wait();
                            ah.Dispose();

                            Order *= -1; ChessRules.CurrentOrder *= -1;
                            //deeper call
                            for (var ii = 0; A.MinisterOnTable != null && MinisterOnTable[i] != null && A.MinisterOnTable[i].MinisterThinking[0] != null && ii < A.MinisterOnTable[i].MinisterThinking[0].AStarGreedy.Count; ii++)
                            {
                                var ah1 = Task.Factory.StartNew(() => MakeRegardAllCheckMateBranches(A.MinisterOnTable[i].MinisterThinking[0].AStarGreedy[ii], Order));
                                ah1.Wait();
                                ah1.Dispose();
                            }
                            Order = COrder; ChessRules.CurrentOrder = CDummy;
                        }
                    //king
                    for (var i = KingMidle; i < MinisterHigh; i++)
                        for (var j = 0; A.KingOnTable != null && KingOnTable[i] != null && A.KingOnTable[i].KingThinking[0] != null && j < A.KingOnTable[i].KingThinking[0].TableListKing.Count; j++)
                        {
                            //make regard
                            var ah = Task.Factory.StartNew(() => A.KingOnTable[i].KingThinking[0].PenaltyRegardListKing[j].LearningAlgorithmRegard());
                            ah.Wait();
                            ah.Dispose();
                            A.KingOnTable[i].KingThinking[0].PenaltyRegardListKing[j].LearningAlgorithmRegard();
                            Order *= -1; ChessRules.CurrentOrder *= -1;
                            //deeper call
                            for (var ii = 0; A.KingOnTable != null && KingOnTable[i] != null && A.KingOnTable[i].KingThinking[0] != null && ii < A.KingOnTable[i].KingThinking[0].AStarGreedy.Count; ii++)
                            {
                                var ah1 = Task.Factory.StartNew(() => MakeRegardAllCheckMateBranches(A.KingOnTable[i].KingThinking[0].AStarGreedy[ii], Order));
                                ah1.Wait();
                                ah1.Dispose();
                            }
                            Order = COrder; ChessRules.CurrentOrder = CDummy;
                        }
                    for (var i = 0; i < 1; i++)
                        for (var j = 0; A.CastlingOnTable != null && CastlingOnTable[i] != null && A.CastlingOnTable[i].CastlingThinking[0] != null && j < A.CastlingOnTable[i].CastlingThinking[0].TableListCastling.Count; j++)
                        {
                            //make regard
                            var ah = Task.Factory.StartNew(() => A.CastlingOnTable[i].CastlingThinking[0].PenaltyRegardListCastling[j].LearningAlgorithmRegard());
                            ah.Wait();
                            ah.Dispose();
                            Order *= -1; ChessRules.CurrentOrder *= -1;
                            //deeper call
                            for (var ii = 0; A.CastlingOnTable != null && CastlingOnTable[i] != null && A.CastlingOnTable[i].CastlingThinking[0] != null && ii < A.CastlingOnTable[i].CastlingThinking[0].AStarGreedy.Count; ii++)
                            {
                                var ah1 = Task.Factory.StartNew(() => MakeRegardAllCheckMateBranches(A.CastlingOnTable[i].CastlingThinking[0].AStarGreedy[ii], Order));
                                ah1.Wait();
                                ah1.Dispose();
                            }
                            Order = COrder; ChessRules.CurrentOrder = CDummy;
                        }
                }
            }

        }
        //when all branches of root is lose and close ignore of learning autamata option  
        /*   int[,] HeuristicAStarGreadySearchPenalties(int AStarGreedyi, Color a, int Order, bool CurrentTableHeuristic, ref bool Act)
           {

               Object a1 = new Object();
               lock (a1)
               {
                   ChessRules AB = null;
                   int ToCheckMate = -1, ForCheckMate = -1, j, i;
                   List<int> Founded = new List<int>();
                   int DummyOrder = Order;
                   int DummyCurrentOrder = ChessRules.CurrentOrder;
                   bool AA = false;
                   int Do = 0;
                   int[,] TableHeuristic = new int[8, 8];
                   //For Every Soldeir
                   for (i = 0; i < SodierMidle; i++)
                   {

                       //For Every Soldier Movments AStarGreedy.
                       for (int k = 0; k < AllDraw.SodierMovments; k++)
                           //When There is an Movment in such situation.
                           for (j = 0; SolderesOnTable != null && SolderesOnTable[i] != null && SolderesOnTable != null && SolderesOnTable[i] != null && SolderesOnTable[i].SoldierThinking[k] != null && SolderesOnTable[i].SoldierThinking[k] != null && j < SolderesOnTable[i].SoldierThinking[k].TableListSolder.Count; j++)
                           {
                               {
                                   //For Penalty Reagrad Mechanisam of Current Check CheckMate Current Movments.
                                   int CDummy = ChessRules.CurrentOrder;
                                   int COrder = Order;
                                   ChessRules.CurrentOrder *= -1;
                                   Order *= -1;
                                   Do = 0;
                                   if (UsePenaltyRegardMechnisamT)
                                   {
                                       for (int ij = 0; ij < SolderesOnTable[i].SoldierThinking[k].AStarGreedy.Count - 1; ij++)
                                       {
                                           int D = Do;
                                           var ah = Task.Factory.StartNew(() => SolderesOnTable[i].SoldierThinking[k].AStarGreedy[ij].IsPenaltyRegardCheckMateAtBranch(Order, ref D, SolderesOnTable[i].SoldierThinking[k].AStarGreedy[ij]));
                                           ah.Wait();
                                           ah.Dispose();
                                           Do = D;
                                       }

                                       Order = COrder;
                                       ChessRules.CurrentOrder = CDummy;
                                       ToCheckMate = -1; ForCheckMate = -1; AA = IsToCheckMateHasLessDeeperThanForCheckMate(this, Order, ref ToCheckMate, ref ForCheckMate, 0); if (Do == -1)
                                           continue;
                                   }
                                   Order = COrder;
                                   ChessRules.CurrentOrder = CDummy;
                                   if ((SolderesOnTable[i].SoldierThinking[k].PenaltyRegardListSolder[j].IsPenaltyAction() != 0 && SolderesOnTable[i].SoldierThinking[k].PenaltyRegardListSolder[j].IsRewardAction() == 1 && AStarGreedyi == 1) || ((Do == 1 || AA) && UsePenaltyRegardMechnisamT) || SolderesOnTable[i].WinOcuuredatChiled >= 1 || SolderesOnTable[i].WinOcuuredatChiled >= 2 || SolderesOnTable[i].WinOcuuredatChiled >= 3)
                                   {
                                       //Set Table and Heuristic Value and Syntax.
                                       Act = true;
                                       Object On = new Object();
                                       lock (On)
                                       {
                                           AllDraw.LastRow = SolderesOnTable[i].SoldierThinking[k].Row;
                                           AllDraw.LastColumn = SolderesOnTable[i].SoldierThinking[k].Column;
                                           AllDraw.NextRow = SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][0];
                                           AllDraw.NextColumn = SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][1];

                                           Less = SolderesOnTable[i].SoldierThinking[k].NumberOfPenalties;
                                       }

                                       TableHeuristic = SolderesOnTable[i].SoldierThinking[k].TableListSolder[j];

                                       Object O = new Object();
                                       lock (O)
                                       {
                                           ThingsConverter.ActOfClickEqualTow = true;
                                       }
                                       SolderesOnTable[i].ConvertOperation(SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][0], SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][1], a, SolderesOnTable[i].SoldierThinking[k].TableListSolder[j], Order, false, i);
                                       int Sign = 1;
                                       if (a == Color.Brown)
                                           Sign = -1;

                                       //If there is Soldier Convert.
                                       if (SolderesOnTable[i].Convert)
                                       {
                                           if (SolderesOnTable[i].ConvertedToMinister)
                                               TableHeuristic[SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][0], SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][1]] = 5 * Sign;
                                           else if (SolderesOnTable[i].ConvertedToCastle)
                                               TableHeuristic[SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][0], SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][1]] = 4 * Sign;
                                           else if (SolderesOnTable[i].ConvertedToHourse)
                                               TableHeuristic[SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][0], SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][1]] = 3 * Sign;
                                           else if (SolderesOnTable[i].ConvertedToElefant)
                                               TableHeuristic[SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][0], SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][1]] = 2 * Sign;


                                       }
                                       RegardOccurred = true;
                                       continue;
                                   }
                                   //When There is No Movments in Such Order Enemy continue.
                                   Object ol = new Object();
                                   lock (ol)
                                   {
                                       if (Order != AllDraw.OrderPlateDraw)
                                           if (SolderesOnTable[i].SoldierThinking[0].NumberOfPenalties < Less)
                                               continue;
                                       //When There is greater Heuristic Movments.
                                       if (SolderesOnTable[i].SoldierThinking[0].NumberOfPenalties < Less)
                                       {

                                           //retrive table of current Heuristic.
                                           int[,] TableS = SolderesOnTable[i].SoldierThinking[k].TableListSolder[j];
                                           int[,] TableSS = SolderesOnTable[i].SoldierThinking[k].TableListSolder[j];
                                           //checked for Legal Movments ArgumentOutOfRangeException curnt game.
                                           if (DynamicAStarGreedytPrograming && !CurrentTableHeuristic && AStarGreedyi == 1)
                                           {
                                               if (!IsEnemyThingsinStable(CloneATable(TableS), AllDraw.TableListAction[AllDraw.TableListAction.Count - 1], AllDraw.OrderPlate))
                                                   continue;

                                           }
                                           //When there is not Penalty regard mechanism.
                                           AB = new ChessRules(CurrentAStarGredyMax, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged, 1, CloneATable(TableS), Order, SolderesOnTable[i].SoldierThinking[k].Row, SolderesOnTable[i].SoldierThinking[k].Column);
                                           //If there is kish or kshachamaz Order.
                                           if (AB.Check(CloneATable(TableS), Order))
                                           {
                                               //When Order is Gray.
                                               if (Order == 1)
                                               {
                                                   //Continue When is kish CheckObjectDangour and AStarGreadyFirstSearch .
                                                   if (AB.CheckGray)
                                                       continue;
                                               }
                                               else
                                               {
                                                   //Continue when CheckBrown and AStarGreadyFirstSearch. 
                                                   if (AB.CheckBrown)
                                                       continue;
                                               }
                                           }
                                           //Sodleirs Initiate.
                                           RW1 = i;
                                           CL1 = k;
                                           Ki1 = j;
                                           RW2 = -1;
                                           CL2 = -1;
                                           Ki2 = -1;
                                           RW3 = -1;
                                           CL3 = -1;
                                           Ki3 = -1;
                                           RW4 = -1;
                                           CL4 = -1;
                                           Ki4 = -1;
                                           RW5 = -1;
                                           CL5 = -1;
                                           Ki5 = -1;
                                           RW6 = -1;
                                           CL6 = -1;
                                           Ki6 = -1;
                                           //Set Max of Soldier.
                                           MaxLess1 = (SolderesOnTable[RW1].SoldierThinking[CL1].NumberOfPenalties
                                               );
                                           //When Soldeirs is Greater than Others these Set Max.
                                           if (MaxLess1 > MaxLess2)
                                               MaxLess2 = -1;
                                           if (MaxLess1 > MaxLess3)
                                               MaxLess3 = -1;
                                           if (MaxLess1 > MaxLess4)
                                               MaxLess4 = -1;
                                           if (MaxLess1 > MaxLess5)
                                               MaxLess5 = -1;
                                           if (MaxLess1 > MaxLess6)
                                               MaxLess6 = -1;
                                           if (AStarGreedyi == 1)
                                           {
                                               Object O = new Object();
                                               lock (O)
                                               {
                                                   if (Order == 1)
                                                   {

                                                   }
                                                   else//If Order is Brown.
                                                   {

                                                   }
                                               }
                                               //Set Table and Heuristic Value and Syntax.
                                               Act = true;
                                               Object On = new Object();
                                               lock (On)
                                               {
                                                   AllDraw.LastRow = SolderesOnTable[i].SoldierThinking[k].Row;
                                                   AllDraw.LastColumn = SolderesOnTable[i].SoldierThinking[k].Column;
                                                   AllDraw.NextRow = SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][0];
                                                   AllDraw.NextColumn = SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][1];
                                               }
                                               Less = SolderesOnTable[i].SoldierThinking[k].NumberOfPenalties;

                                               TableHeuristic = SolderesOnTable[i].SoldierThinking[k].TableListSolder[j];

                                               Object O1 = new Object();
                                               lock (O1)
                                               {
                                                   ThingsConverter.ActOfClickEqualTow = true;
                                               }
                                               SolderesOnTable[i].ConvertOperation(SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][0], SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][1], a, SolderesOnTable[i].SoldierThinking[k].TableListSolder[j], Order, false, i);
                                               int Sign = 1;
                                               if (a == Color.Brown)
                                                   Sign = -1;
                                               //If there is Soldier Convert.
                                               if (SolderesOnTable[i].Convert)
                                               {
                                                   if (SolderesOnTable[i].ConvertedToMinister)
                                                       TableHeuristic[SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][0], SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][1]] = 5 * Sign;
                                                   else if (SolderesOnTable[i].ConvertedToCastle)
                                                       TableHeuristic[SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][0], SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][1]] = 4 * Sign;
                                                   else if (SolderesOnTable[i].ConvertedToHourse)
                                                       TableHeuristic[SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][0], SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][1]] = 3 * Sign;
                                                   else if (SolderesOnTable[i].ConvertedToElefant)
                                                       TableHeuristic[SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][0], SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][1]] = 2 * Sign;


                                               }
                                           }

                                       }
                                       else
                                       {
                                           //Set Table and Heuristic Value and Syntax.
                                           if (AStarGreedyi == 1)
                                           {
                                               //Found of Max Non Probable Movments.
                                               Founded.Clear();
                                               int LessB = Int32.MinValue;
                                               BeginIndexFoundingMaxLessofMaxList(0, Founded, ref LessB);
                                               RW1 = (int)MaxHeuristicAStarGreedytBackWard[0][(int)Founded[0]];
                                               CL1 = (int)MaxHeuristicAStarGreedytBackWard[0][(int)Founded[0] + 1];
                                               Ki1 = (int)MaxHeuristicAStarGreedytBackWard[0][(int)Founded[0] + 2];
                                               if (Founded[0] != MaxSoldeirFounded)
                                                   continue;
                                               Act = true;
                                               Object On = new Object();
                                               lock (On)
                                               {
                                                   AllDraw.LastRow = SolderesOnTable[RW1].SoldierThinking[CL1].Row;
                                                   AllDraw.LastColumn = SolderesOnTable[RW1].SoldierThinking[CL1].Column;
                                                   AllDraw.NextRow = SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][0];
                                                   AllDraw.NextColumn = SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][1];
                                               }
                                               Less = SolderesOnTable[RW1].SoldierThinking[CL1].ReturnHeuristic(RW1, Ki1, Order, false, ref HaveKilled);

                                               TableHeuristic = SolderesOnTable[RW1].SoldierThinking[CL1].TableListSolder[Ki1];

                                               Object O1 = new Object();
                                               lock (O1)
                                               {
                                                   ThingsConverter.ActOfClickEqualTow = true;
                                               }
                                               SolderesOnTable[RW1].ConvertOperation(SolderesOnTable[RW1].SoldierThinking[CL1].RowColumnSoldier[Ki1][0], SolderesOnTable[RW1].SoldierThinking[CL1].RowColumnSoldier[Ki1][1], a, SolderesOnTable[RW1].SoldierThinking[CL1].TableListSolder[Ki1], Order, false, i);
                                               int Sign = 1;
                                               if (a == Color.Brown)
                                                   Sign = -1;
                                               //If there is Soldier Convert.
                                               if (SolderesOnTable[RW1].Convert)
                                               {
                                                   if (SolderesOnTable[RW1].ConvertedToMinister)
                                                       TableHeuristic[SolderesOnTable[RW1].SoldierThinking[CL1].RowColumnSoldier[Ki1][0], SolderesOnTable[RW1].SoldierThinking[CL1].RowColumnSoldier[Ki1][1]] = 5 * Sign;
                                                   else if (SolderesOnTable[RW1].ConvertedToCastle)
                                                       TableHeuristic[SolderesOnTable[RW1].SoldierThinking[CL1].RowColumnSoldier[Ki1][0], SolderesOnTable[RW1].SoldierThinking[CL1].RowColumnSoldier[Ki1][1]] = 4 * Sign;
                                                   else if (SolderesOnTable[RW1].ConvertedToHourse)
                                                       TableHeuristic[SolderesOnTable[RW1].SoldierThinking[CL1].RowColumnSoldier[Ki1][0], SolderesOnTable[RW1].SoldierThinking[CL1].RowColumnSoldier[Ki1][1]] = 3 * Sign;
                                                   else if (SolderesOnTable[RW1].ConvertedToElefant)
                                                       TableHeuristic[SolderesOnTable[RW1].SoldierThinking[CL1].RowColumnSoldier[Ki1][0], SolderesOnTable[RW1].SoldierThinking[CL1].RowColumnSoldier[Ki1][1]] = 2 * Sign;


                                               }
                                               Object O = new Object();
                                               lock (O)
                                               {
                                                   if (Order == 1)
                                                   {

                                                   }
                                                   else//If Order is Brown.
                                                   {

                                                   }
                                               }
                                           }
                                       }
                                   }

                               }
                           }

                       Order = DummyOrder;
                       ChessRules.CurrentOrder = DummyCurrentOrder;

                       Order = DummyOrder;
                       ChessRules.CurrentOrder = DummyCurrentOrder;
                   }
                   //Do For Remaining Objects same as Soldeir Documentation.
                   for (i = 0; i < ElefantMidle; i++)
                   {
                       for (int k = 0; k < AllDraw.ElefantMovments; k++)
                           for (j = 0; ElephantOnTable != null && ElephantOnTable[i] != null && ElephantOnTable != null && ElephantOnTable[i] != null && ElephantOnTable[i].ElefantThinking[k] != null && ElephantOnTable[i].ElefantThinking[k] != null && j < ElephantOnTable[i].ElefantThinking[k].TableListElefant.Count; j++)
                           {
                               {
                                   //For Penalty Reagrad Mechanisam of Current Check CheckMate Current Movments.
                                   int CDummy = ChessRules.CurrentOrder;
                                   int COrder = Order;
                                   ChessRules.CurrentOrder *= -1;
                                   Order *= -1;
                                   Do = 0;
                                   if (UsePenaltyRegardMechnisamT)
                                   {
                                       for (int ij = 0; ij < ElephantOnTable[i].ElefantThinking[0].AStarGreedy.Count - 1; ij++)
                                       {
                                           int D = Do;
                                           var ah = Task.Factory.StartNew(() => ElephantOnTable[i].ElefantThinking[k].AStarGreedy[ij].IsPenaltyRegardCheckMateAtBranch(Order, ref D, SolderesOnTable[i].SoldierThinking[k].AStarGreedy[ij]));
                                           ah.Wait();
                                           ah.Dispose();
                                           Do = D;
                                       }
                                       Order = COrder;
                                       ChessRules.CurrentOrder = CDummy;
                                       ToCheckMate = -1; ForCheckMate = -1; AA = IsToCheckMateHasLessDeeperThanForCheckMate(this, Order, ref ToCheckMate, ref ForCheckMate, 0); if (Do == -1)
                                           continue;
                                   }
                                   Order = COrder;
                                   ChessRules.CurrentOrder = CDummy;
                                   if ((ElephantOnTable[i].ElefantThinking[k].PenaltyRegardListElefant[j].IsPenaltyAction() != 0 && ElephantOnTable[i].ElefantThinking[k].PenaltyRegardListElefant[j].IsRewardAction() == 1 && AStarGreedyi == 1) || ((Do == 1 || AA) && UsePenaltyRegardMechnisamT) || ElephantOnTable[i].WinOcuuredatChiled >= 1 || ElephantOnTable[i].WinOcuuredatChiled >= 2 || ElephantOnTable[i].WinOcuuredatChiled >= 3)
                                   {
                                       Object On = new Object();
                                       lock (On)
                                       {
                                           AllDraw.LastRow = ElephantOnTable[i].ElefantThinking[k].Row;
                                           AllDraw.LastColumn = ElephantOnTable[i].ElefantThinking[k].Column;
                                           AllDraw.NextRow = ElephantOnTable[i].ElefantThinking[k].RowColumnElefant[j][0];
                                           AllDraw.NextColumn = ElephantOnTable[i].ElefantThinking[k].RowColumnElefant[j][1];

                                           Act = true;
                                           Less = ElephantOnTable[i].ElefantThinking[k].NumberOfPenalties;
                                       }
                                       TableHeuristic = ElephantOnTable[i].ElefantThinking[k].TableListElefant[j];
                                       RegardOccurred = true;
                                       continue;
                                   }
                                   Object ol = new Object();
                                   lock (ol)
                                   {
                                       //When There is No Movments in Such Order Enemy continue.
                                       if (Order != AllDraw.OrderPlateDraw)
                                           if (ElephantOnTable[i].ElefantThinking[0].NumberOfPenalties < Less)
                                               continue;
                                       //When There is greater Heuristic Movments.
                                       if (ElephantOnTable[i].ElefantThinking[0].NumberOfPenalties < Less)
                                       {

                                           //retrive table of current Heuristic.
                                           int[,] TableS = ElephantOnTable[i].ElefantThinking[k].TableListElefant[j];
                                           int[,] TableSS = ElephantOnTable[i].ElefantThinking[k].TableListElefant[j];
                                           //checked for Legal Movments ArgumentOutOfRangeException curnt game.
                                           if (DynamicAStarGreedytPrograming && !CurrentTableHeuristic && AStarGreedyi == 1)
                                           {
                                               if (!IsEnemyThingsinStable(CloneATable(TableS), AllDraw.TableListAction[AllDraw.TableListAction.Count - 1], AllDraw.OrderPlate))
                                                   continue;

                                           }
                                           //When there is not Penalty regard mechanism.
                                           AB = new ChessRules(CurrentAStarGredyMax, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged, 2, CloneATable(TableS), Order, -1, -1);
                                           //If there is kish or kshachamaz Order.
                                           if (AB.Check(CloneATable(TableS), Order))
                                           {
                                               //When Order is Gray.
                                               if (Order == 1)
                                               {
                                                   //Continue When is kish CheckObjectDangour and AStarGreadyFirstSearch .
                                                   if (AB.CheckGray)
                                                       continue;
                                               }
                                               else
                                               {
                                                   //Continue when CheckBrown and AStarGreadyFirstSearch. 
                                                   if (AB.CheckBrown)
                                                       continue;
                                               }
                                           }
                                           RW2 = i;
                                           CL2 = k;
                                           Ki2 = j;
                                           RW1 = -1;
                                           CL1 = -1;
                                           Ki1 = -1;
                                           RW3 = -1;
                                           CL3 = -1;
                                           Ki3 = -1;
                                           RW4 = -1;
                                           CL4 = -1;
                                           Ki4 = -1;
                                           RW5 = -1;
                                           CL5 = -1;
                                           Ki5 = -1;
                                           RW6 = -1;
                                           CL6 = -1;
                                           Ki6 = -1;
                                           MaxLess2 = (ElephantOnTable[RW2].ElefantThinking[CL2].NumberOfPenalties);
                                           if (MaxLess2 > MaxLess1)
                                               MaxLess1 = -1;
                                           if (MaxLess2 > MaxLess3)
                                               MaxLess3 = -1;
                                           if (MaxLess2 > MaxLess4)
                                               MaxLess4 = -1;
                                           if (MaxLess2 > MaxLess5)
                                               MaxLess5 = -1;
                                           if (MaxLess2 > MaxLess6)
                                               MaxLess6 = -1;
                                           if (AStarGreedyi == 1)
                                           {
                                               Object O = new Object();
                                               lock (O)
                                               {
                                                   if (Order == 1)
                                                   {

                                                   }
                                                   else//If Order is Brown.
                                                   {

                                                   }
                                               }
                                               Object On = new Object();
                                               lock (On)
                                               {
                                                   AllDraw.LastRow = ElephantOnTable[i].ElefantThinking[k].Row;
                                                   AllDraw.LastColumn = ElephantOnTable[i].ElefantThinking[k].Column;
                                                   AllDraw.NextRow = ElephantOnTable[i].ElefantThinking[k].RowColumnElefant[j][0];
                                                   AllDraw.NextColumn = ElephantOnTable[i].ElefantThinking[k].RowColumnElefant[j][1];
                                               }
                                               Act = true;
                                               Less = ElephantOnTable[i].ElefantThinking[k].NumberOfPenalties;
                                               TableHeuristic = ElephantOnTable[i].ElefantThinking[k].TableListElefant[j];
                                           }
                                       }
                                       else
                                       {

                                           if (AStarGreedyi == 1)
                                           {
                                               //Found of Max Non Probable Movments.
                                               Founded.Clear();
                                               int LessB = Int32.MinValue;
                                               BeginIndexFoundingMaxLessofMaxList(0, Founded, ref LessB);
                                               RW2 = (int)MaxHeuristicAStarGreedytBackWard[0][(int)Founded[0]];
                                               CL2 = (int)MaxHeuristicAStarGreedytBackWard[0][(int)Founded[0] + 1];
                                               Ki2 = (int)MaxHeuristicAStarGreedytBackWard[0][(int)Founded[0] + 2];
                                               if (Founded[0] != MaxElephntFounded)
                                                   continue;
                                               Object On = new Object();
                                               lock (On)
                                               {
                                                   AllDraw.LastRow = ElephantOnTable[RW2].ElefantThinking[CL2].Row;
                                                   AllDraw.LastColumn = ElephantOnTable[RW2].ElefantThinking[CL2].Column;
                                                   AllDraw.NextRow = ElephantOnTable[i].ElefantThinking[k].RowColumnElefant[j][0];
                                                   AllDraw.NextColumn = ElephantOnTable[i].ElefantThinking[k].RowColumnElefant[j][1];
                                               }
                                               Act = true;
                                               Less = ElephantOnTable[RW2].ElefantThinking[CL2].ReturnHeuristic(RW2, Ki2, Order, false, ref HaveKilled);
                                               TableHeuristic = ElephantOnTable[RW2].ElefantThinking[CL2].TableListElefant[Ki2];
                                               Object O = new Object();
                                               lock (O)
                                               {
                                                   if (Order == 1)
                                                   {

                                                   }
                                                   else//If Order is Brown.
                                                   {

                                                   }
                                               }
                                           }
                                       }
                                   }
                               }
                           }

                       Order = DummyOrder;
                       ChessRules.CurrentOrder = DummyCurrentOrder;
                   }
                   //hourse
                   for (i = 0; i < HourseMidle; i++)
                   {
                       for (int k = 0; k < AllDraw.HourseMovments; k++)
                           for (j = 0; HoursesOnTable != null && HoursesOnTable[i] != null && HoursesOnTable != null && HoursesOnTable[i] != null && HoursesOnTable[i].HourseThinking[k] != null && HoursesOnTable[i].HourseThinking[k] != null && j < HoursesOnTable[i].HourseThinking[k].TableListHourse.Count; j++)
                           {
                               {
                                   //For Penalty Reagrad Mechanisam of Current Check CheckMate Current Movments.
                                   int CDummy = ChessRules.CurrentOrder;
                                   int COrder = Order;
                                   ChessRules.CurrentOrder *= -1;
                                   Order *= -1;
                                   Do = 0;
                                   if (UsePenaltyRegardMechnisamT)
                                   {
                                       for (int ij = 0; ij < HoursesOnTable[i].HourseThinking[k].AStarGreedy.Count - 1; ij++)
                                       {
                                           int D = Do;
                                           var ah = Task.Factory.StartNew(() => HoursesOnTable[i].HourseThinking[k].AStarGreedy[ij].IsPenaltyRegardCheckMateAtBranch(Order, ref D, SolderesOnTable[i].SoldierThinking[k].AStarGreedy[ij]));
                                           ah.Wait();
                                           ah.Dispose();
                                           Do = D;
                                       }
                                       Order = COrder;
                                       ChessRules.CurrentOrder = CDummy;
                                       ToCheckMate = -1; ForCheckMate = -1; AA = IsToCheckMateHasLessDeeperThanForCheckMate(this, Order, ref ToCheckMate, ref ForCheckMate, 0); if (Do == -1)
                                           continue;
                                   }

                                   Order = COrder;
                                   ChessRules.CurrentOrder = CDummy;
                                   if ((HoursesOnTable[i].HourseThinking[k].PenaltyRegardListHourse[j].IsPenaltyAction() != 0 && HoursesOnTable[i].HourseThinking[k].PenaltyRegardListHourse[j].IsRewardAction() == 1 && AStarGreedyi == 1) || ((Do == 1 || AA) && UsePenaltyRegardMechnisamT) || HoursesOnTable[i].WinOcuuredatChiled >= 1 || HoursesOnTable[i].WinOcuuredatChiled >= 2 || HoursesOnTable[i].WinOcuuredatChiled >= 3)
                                   {
                                       Object On = new Object();
                                       lock (On)
                                       {
                                           AllDraw.LastRow = HoursesOnTable[i].HourseThinking[k].Row;
                                           AllDraw.LastColumn = HoursesOnTable[i].HourseThinking[k].Column;
                                           AllDraw.NextRow = HoursesOnTable[i].HourseThinking[k].RowColumnHourse[j][0];
                                           AllDraw.NextColumn = HoursesOnTable[i].HourseThinking[k].RowColumnHourse[j][1];
                                           Act = true;
                                           Less = HoursesOnTable[i].HourseThinking[k].NumberOfPenalties;
                                       }
                                       TableHeuristic = HoursesOnTable[i].HourseThinking[k].TableListHourse[j];
                                       RegardOccurred = true;
                                       continue;
                                   }
                                   Object ol = new Object();
                                   lock (ol)
                                   {
                                       //When There is No Movments in Such Order Enemy continue.
                                       if (Order != AllDraw.OrderPlateDraw)
                                           if (HoursesOnTable[i].HourseThinking[0].NumberOfPenalties < Less)
                                               continue;
                                       //When There is greater Heuristic Movments.
                                       if (HoursesOnTable[i].HourseThinking[0].NumberOfPenalties < Less)
                                       {
                                           //retrive table of current Heuristic.
                                           int[,] TableS = HoursesOnTable[i].HourseThinking[k].TableListHourse[j];
                                           int[,] TableSS = HoursesOnTable[i].HourseThinking[k].TableListHourse[j];
                                           {
                                               //checked for Legal Movments ArgumentOutOfRangeException curnt game.
                                               if (DynamicAStarGreedytPrograming && !CurrentTableHeuristic && AStarGreedyi == 1)
                                               {
                                                   if (!IsEnemyThingsinStable(CloneATable(TableS), AllDraw.TableListAction[AllDraw.TableListAction.Count - 1], AllDraw.OrderPlate))
                                                       continue;

                                               }
                                               //When there is not Penalty regard mechanism.
                                               AB = new ChessRules(CurrentAStarGredyMax, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged, 3, CloneATable(TableS), Order, HoursesOnTable[i].HourseThinking[k].Row, HoursesOnTable[i].HourseThinking[k].Column);
                                               //If there is kish or kshachamaz Order.
                                               if (AB.Check(CloneATable(TableS), Order))
                                               {
                                                   //When Order is Gray.
                                                   if (Order == 1)
                                                   {
                                                       //Continue When is kish CheckObjectDangour and AStarGreadyFirstSearch .
                                                       if (AB.CheckGray)
                                                           continue;
                                                   }
                                                   else
                                                   {
                                                       //Continue when CheckBrown and AStarGreadyFirstSearch. 
                                                       if (AB.CheckBrown)
                                                           continue;
                                                   }
                                               }
                                           }
                                           RW3 = i;
                                           CL3 = k;
                                           Ki3 = j;
                                           RW1 = -1;
                                           CL1 = -1;
                                           Ki1 = -1;
                                           RW2 = -1;
                                           CL2 = -1;
                                           Ki2 = -1;
                                           RW4 = -1;
                                           CL4 = -1;
                                           Ki4 = -1;
                                           RW5 = -1;
                                           CL5 = -1;
                                           Ki5 = -1;
                                           RW6 = -1;
                                           CL6 = -1;
                                           Ki6 = -1;
                                           MaxLess3 = (HoursesOnTable[RW3].HourseThinking[CL3].NumberOfPenalties);
                                           if (MaxLess3 > MaxLess1)
                                               MaxLess1 = -1;
                                           if (MaxLess3 > MaxLess2)
                                               MaxLess2 = -1;
                                           if (MaxLess3 > MaxLess4)
                                               MaxLess4 = -1;
                                           if (MaxLess3 > MaxLess5)
                                               MaxLess5 = -1;
                                           if (MaxLess3 > MaxLess6)
                                               MaxLess6 = -1;
                                           if (AStarGreedyi == 1)
                                           {
                                               Object O = new Object();
                                               lock (O)
                                               {
                                                   if (Order == 1)
                                                   {

                                                   }
                                                   else//If Order is Brown.
                                                   {

                                                   }
                                               }
                                               //Set Table and Heuristic Value and Syntax.
                                               Object On = new Object();
                                               lock (On)
                                               {
                                                   AllDraw.LastRow = HoursesOnTable[i].HourseThinking[k].Row;
                                                   AllDraw.LastColumn = HoursesOnTable[i].HourseThinking[k].Column;
                                                   AllDraw.NextRow = HoursesOnTable[i].HourseThinking[k].RowColumnHourse[j][0];
                                                   AllDraw.NextColumn = HoursesOnTable[i].HourseThinking[k].RowColumnHourse[j][1];
                                               }
                                               Act = true;
                                               Less = HoursesOnTable[i].HourseThinking[k].NumberOfPenalties;
                                               TableHeuristic = HoursesOnTable[i].HourseThinking[k].TableListHourse[j];
                                           }
                                       }
                                       else
                                       //Set Table and Heuristic Value and Syntax.
                                       if (AStarGreedyi == 1)
                                       {

                                           //Found of Max Non Probable Movments.
                                           Founded.Clear();
                                           int LessB = Int32.MinValue;
                                           BeginIndexFoundingMaxLessofMaxList(0, Founded, ref LessB);
                                           RW3 = (int)MaxHeuristicAStarGreedytBackWard[0][(int)Founded[0]];
                                           CL3 = (int)MaxHeuristicAStarGreedytBackWard[0][(int)Founded[0] + 1];
                                           Ki3 = (int)MaxHeuristicAStarGreedytBackWard[0][(int)Founded[0] + 2];
                                           if (Founded[0] != MaxHourseFounded)
                                               continue;
                                           Object On = new Object();
                                           lock (On)
                                           {
                                               AllDraw.LastRow = HoursesOnTable[RW3].HourseThinking[CL3].Row;
                                               AllDraw.LastColumn = HoursesOnTable[RW3].HourseThinking[CL3].Column;
                                               AllDraw.NextRow = HoursesOnTable[i].HourseThinking[k].RowColumnHourse[j][0];
                                               AllDraw.NextColumn = HoursesOnTable[i].HourseThinking[k].RowColumnHourse[j][1];
                                           }
                                           Act = true;
                                           Less = HoursesOnTable[RW3].HourseThinking[CL3].ReturnHeuristic(RW3, Ki3, Order, false, ref HaveKilled);
                                           TableHeuristic = HoursesOnTable[RW3].HourseThinking[CL3].TableListHourse[Ki3];
                                           Object O = new Object();
                                           lock (O)
                                           {
                                               if (Order == 1)
                                               {

                                               }
                                               else//If Order is Brown.
                                               {

                                               }
                                           }
                                       }
                                   }
                               }
                           }


                       Order = DummyOrder;
                       ChessRules.CurrentOrder = DummyCurrentOrder;

                   }
                   //Castle
                   for (i = 0; i < CastleMidle; i++)
                   {
                       for (int k = 0; k < AllDraw.CastleMovments; k++)
                           for (j = 0; CastlesOnTable != null && CastlesOnTable[i] != null && CastlesOnTable != null && CastlesOnTable[i] != null && CastlesOnTable[i].CastleThinking[k] != null && CastlesOnTable[i].CastleThinking[k] != null && j < CastlesOnTable[i].CastleThinking[k].TableListCastle.Count; j++)
                           {
                               {
                                   //For Penalty Reagrad Mechanisam of Current Check CheckMate Current Movments.
                                   int CDummy = ChessRules.CurrentOrder;
                                   int COrder = Order;
                                   ChessRules.CurrentOrder *= -1;
                                   Order *= -1;
                                   Do = 0;
                                   if (UsePenaltyRegardMechnisamT)
                                   {
                                       for (int ij = 0; ij < CastlesOnTable[i].CastleThinking[k].AStarGreedy.Count - 1; ij++)
                                       {
                                           int D = Do;
                                           var ah = Task.Factory.StartNew(() => CastlesOnTable[i].CastleThinking[k].AStarGreedy[ij].IsPenaltyRegardCheckMateAtBranch(Order, ref D, SolderesOnTable[i].SoldierThinking[k].AStarGreedy[ij]));
                                           ah.Wait();
                                           ah.Dispose();
                                           Do = D;
                                       }
                                       Order = COrder;
                                       ChessRules.CurrentOrder = CDummy;
                                       ToCheckMate = -1; ForCheckMate = -1; AA = IsToCheckMateHasLessDeeperThanForCheckMate(this, Order, ref ToCheckMate, ref ForCheckMate, 0); if (Do == -1)
                                           continue;
                                   }

                                   Order = COrder;
                                   ChessRules.CurrentOrder = CDummy;
                                   if ((CastlesOnTable[i].CastleThinking[k].PenaltyRegardListCastle[j].IsPenaltyAction() != 0 && CastlesOnTable[i].CastleThinking[k].PenaltyRegardListCastle[j].IsRewardAction() == 1 && AStarGreedyi == 1) || ((Do == 1 || AA) && UsePenaltyRegardMechnisamT) || CastlesOnTable[i].WinOcuuredatChiled >= 1 || CastlesOnTable[i].WinOcuuredatChiled >= 2 || CastlesOnTable[i].WinOcuuredatChiled >= 3)
                                   {
                                       Object On = new Object();
                                       lock (On)
                                       {
                                           AllDraw.LastRow = CastlesOnTable[i].CastleThinking[k].Row;
                                           AllDraw.LastColumn = CastlesOnTable[i].CastleThinking[k].Column;
                                           AllDraw.NextRow = CastlesOnTable[i].CastleThinking[k].RowColumnCastle[j][0];
                                           AllDraw.NextColumn = CastlesOnTable[i].CastleThinking[k].RowColumnCastle[j][1];
                                           Act = true;
                                           Less = CastlesOnTable[i].CastleThinking[k].NumberOfPenalties;
                                       }
                                       TableHeuristic = CastlesOnTable[i].CastleThinking[k].TableListCastle[j];
                                       RegardOccurred = true;
                                       continue;
                                   }
                                   Object ol = new Object();
                                   lock (ol)
                                   {
                                       //When There is No Movments in Such Order Enemy continue.
                                       if (Order != AllDraw.OrderPlateDraw)
                                           if (CastlesOnTable[i].CastleThinking[0].NumberOfPenalties < Less) continue;
                                       //When There is greater Heuristic Movments.
                                       if (CastlesOnTable[i].CastleThinking[0].NumberOfPenalties < Less)
                                       {
                                           //retrive table of current Heuristic.
                                           int[,] TableS = CastlesOnTable[i].CastleThinking[k].TableListCastle[j];
                                           int[,] TableSS = CastlesOnTable[i].CastleThinking[k].TableListCastle[j];
                                           //checked for Legal Movments ArgumentOutOfRangeException curnt game.
                                           if (DynamicAStarGreedytPrograming && !CurrentTableHeuristic && AStarGreedyi == 1)
                                           {
                                               if (!IsEnemyThingsinStable(CloneATable(TableS), AllDraw.TableListAction[AllDraw.TableListAction.Count - 1], AllDraw.OrderPlate))
                                                   continue;

                                           }
                                           //When there is not Penalty regard mechanism.
                                           AB = new ChessRules(CurrentAStarGredyMax, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged, 4, CloneATable(TableS), Order, CastlesOnTable[i].CastleThinking[k].Row, CastlesOnTable[i].CastleThinking[k].Column);
                                           //If there is kish or kshachamaz Order.
                                           if (AB.Check(CloneATable(TableS), Order))
                                           {
                                               //When Order is Gray.
                                               if (Order == 1)
                                               {
                                                   //Continue When is kish CheckObjectDangour and AStarGreadyFirstSearch .
                                                   if (AB.CheckGray)
                                                       continue;
                                               }
                                               else
                                               {
                                                   //Continue when CheckBrown and AStarGreadyFirstSearch. 
                                                   if (AB.CheckBrown)
                                                       continue;
                                               }
                                           }
                                           RW4 = i;
                                           CL4 = k;
                                           Ki4 = j;
                                           RW1 = -1;
                                           CL1 = -1;
                                           Ki1 = -1;
                                           RW2 = -1;
                                           CL2 = -1;
                                           Ki2 = -1;
                                           RW3 = -1;
                                           CL3 = -1;
                                           Ki3 = -1;
                                           RW5 = -1;
                                           CL5 = -1;
                                           Ki5 = -1;
                                           RW6 = -1;
                                           CL6 = -1;
                                           Ki6 = -1;
                                           MaxLess4 = (CastlesOnTable[RW4].CastleThinking[CL4].NumberOfPenalties);
                                           if (MaxLess4 > MaxLess1)
                                               MaxLess1 = -1;
                                           if (MaxLess4 > MaxLess2)
                                               MaxLess2 = -1;
                                           if (MaxLess4 > MaxLess3)
                                               MaxLess3 = -1;
                                           if (MaxLess4 > MaxLess5)
                                               MaxLess5 = -1;
                                           if (MaxLess4 > MaxLess6)
                                               MaxLess6 = -1;

                                           if (AStarGreedyi == 1)
                                           {
                                               Object O = new Object();
                                               lock (O)
                                               {
                                                   if (Order == 1)
                                                   {

                                                   }
                                                   else//If Order is Brown.
                                                   {

                                                   }
                                               }
                                               Object On = new Object();
                                               lock (On)
                                               {
                                                   AllDraw.LastRow = CastlesOnTable[i].CastleThinking[k].Row;
                                                   AllDraw.LastColumn = CastlesOnTable[i].CastleThinking[k].Column;
                                                   AllDraw.NextRow = CastlesOnTable[i].CastleThinking[k].RowColumnCastle[j][0];
                                                   AllDraw.NextColumn = CastlesOnTable[i].CastleThinking[k].RowColumnCastle[j][1];
                                               }
                                               Act = true;
                                               Less = CastlesOnTable[i].CastleThinking[k].NumberOfPenalties;
                                               TableHeuristic = CastlesOnTable[i].CastleThinking[k].TableListCastle[j];
                                           }
                                       }
                                       else//Set Table and Heuristic Value and Syntax.
                                       {
                                           if (AStarGreedyi == 1)
                                           {
                                               //Found of Max Non Probable Movments.
                                               Founded.Clear();
                                               int LessB = Int32.MinValue;
                                               BeginIndexFoundingMaxLessofMaxList(0, Founded, ref LessB);
                                               RW4 = (int)MaxHeuristicAStarGreedytBackWard[0][(int)Founded[0]];
                                               CL4 = (int)MaxHeuristicAStarGreedytBackWard[0][(int)Founded[0] + 1];
                                               Ki4 = (int)MaxHeuristicAStarGreedytBackWard[0][(int)Founded[0] + 2];
                                               if (Founded[0] != MaxCastlesFounded)
                                                   continue;
                                               Object On = new Object();
                                               lock (On)
                                               {
                                                   AllDraw.LastRow = CastlesOnTable[RW4].CastleThinking[CL4].Row;
                                                   AllDraw.LastColumn = CastlesOnTable[RW4].CastleThinking[CL4].Column;
                                                   AllDraw.NextRow = CastlesOnTable[i].CastleThinking[k].RowColumnCastle[j][0];
                                                   AllDraw.NextColumn = CastlesOnTable[i].CastleThinking[k].RowColumnCastle[j][1];
                                               }
                                               Act = true;
                                               Less = CastlesOnTable[RW4].CastleThinking[CL4].ReturnHeuristic(RW4, Ki4, Order, false, ref HaveKilled);
                                               TableHeuristic = CastlesOnTable[RW4].CastleThinking[CL4].TableListCastle[Ki4];
                                               Object O = new Object();
                                               lock (O)
                                               {
                                                   if (Order == 1)
                                                   {

                                                   }
                                                   else//If Order is Brown.
                                                   {

                                                   }
                                               }
                                           }
                                       }
                                   }
                               }
                           }

                       Order = DummyOrder;
                       ChessRules.CurrentOrder = DummyCurrentOrder;

                       Order = DummyOrder;
                       ChessRules.CurrentOrder = DummyCurrentOrder;
                   }
                   //minister
                   for (i = 0; i < MinisterMidle; i++)
                   {
                       for (int k = 0; k < AllDraw.MinisterMovments; k++)
                           for (j = 0; MinisterOnTable != null && MinisterOnTable[i] != null && MinisterOnTable != null && MinisterOnTable[i] != null && MinisterOnTable[i].MinisterThinking[k] != null && MinisterOnTable[i].MinisterThinking[k] != null && j < MinisterOnTable[i].MinisterThinking[k].TableListMinister.Count; j++)
                           {
                               {
                                   //For Penalty Reagrad Mechanisam of Current Check CheckMate Current Movments.
                                   int CDummy = ChessRules.CurrentOrder;
                                   int COrder = Order;
                                   ChessRules.CurrentOrder *= -1;
                                   Order *= -1;
                                   Do = 0;
                                   if (UsePenaltyRegardMechnisamT)
                                   {
                                       for (int ij = 0; ij < MinisterOnTable[i].MinisterThinking[k].AStarGreedy.Count - 1; ij++)
                                       {
                                           int D = Do;
                                           var ah = Task.Factory.StartNew(() => MinisterOnTable[i].MinisterThinking[k].AStarGreedy[ij].IsPenaltyRegardCheckMateAtBranch(Order, ref D, SolderesOnTable[i].SoldierThinking[k].AStarGreedy[ij]));
                                           ah.Wait();
                                           ah.Dispose();
                                           Do = D;
                                       }
                                       Order = COrder;
                                       ChessRules.CurrentOrder = CDummy;
                                       ToCheckMate = -1; ForCheckMate = -1; AA = IsToCheckMateHasLessDeeperThanForCheckMate(this, Order, ref ToCheckMate, ref ForCheckMate, 0); if (Do == -1)
                                           continue;
                                   }

                                   Order = COrder;
                                   ChessRules.CurrentOrder = CDummy;
                                   if ((MinisterOnTable[i].MinisterThinking[k].PenaltyRegardListMinister[j].IsPenaltyAction() != 0 && MinisterOnTable[i].MinisterThinking[k].PenaltyRegardListMinister[j].IsRewardAction() == 1 && AStarGreedyi == 1) || ((Do == 1 || AA) && UsePenaltyRegardMechnisamT) || MinisterOnTable[i].WinOcuuredatChiled >= 1 || MinisterOnTable[i].WinOcuuredatChiled >= 2 || MinisterOnTable[i].WinOcuuredatChiled >= 3)
                                   {
                                       Object On = new Object();
                                       lock (On)
                                       {
                                           AllDraw.LastRow = MinisterOnTable[i].MinisterThinking[k].Row;
                                           AllDraw.LastColumn = MinisterOnTable[i].MinisterThinking[k].Column;
                                           AllDraw.NextRow = MinisterOnTable[i].MinisterThinking[k].RowColumnMinister[j][0];
                                           AllDraw.NextColumn = MinisterOnTable[i].MinisterThinking[k].RowColumnMinister[j][1];
                                           Act = true;
                                           Less = MinisterOnTable[i].MinisterThinking[k].NumberOfPenalties;
                                       }
                                       TableHeuristic = MinisterOnTable[i].MinisterThinking[k].TableListMinister[j];
                                       RegardOccurred = true;
                                       continue;
                                   }
                                   Object ol = new Object();
                                   lock (ol)
                                   {
                                       if (Order != AllDraw.OrderPlateDraw)
                                           if (MinisterOnTable[i].MinisterThinking[0].NumberOfPenalties < Less)
                                               continue;
                                       if (MinisterOnTable[i].MinisterThinking[0].NumberOfPenalties < Less)
                                       {
                                           //retrive table of current Heuristic.
                                           //retrive table of current Heuristic.
                                           int[,] TableS = MinisterOnTable[i].MinisterThinking[k].TableListMinister[j];
                                           int[,] TableSS = MinisterOnTable[i].MinisterThinking[k].TableListMinister[j];
                                           //checked for Legal Movments ArgumentOutOfRangeException curnt game.
                                           if (DynamicAStarGreedytPrograming && !CurrentTableHeuristic && AStarGreedyi == 1)
                                           {
                                               if (!IsEnemyThingsinStable(CloneATable(TableS), AllDraw.TableListAction[AllDraw.TableListAction.Count - 1], AllDraw.OrderPlate))
                                                   continue;

                                           }
                                           //When there is not Penalty regard mechanism.
                                           AB = new ChessRules(CurrentAStarGredyMax, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged, 5, CloneATable(TableS), Order, MinisterOnTable[i].MinisterThinking[k].Row, MinisterOnTable[i].MinisterThinking[k].Column);
                                           //If there is kish or kshachamaz Order.
                                           if (AB.Check(CloneATable(TableS), Order))
                                           {
                                               //When Order is Gray.
                                               if (Order == 1)
                                               {
                                                   //Continue When is kish CheckObjectDangour and AStarGreadyFirstSearch .
                                                   if (AB.CheckGray)
                                                       continue;
                                               }
                                               else
                                               {
                                                   //Continue when CheckBrown and AStarGreadyFirstSearch. 
                                                   if (AB.CheckBrown)
                                                       continue;
                                               }
                                           }

                                           RW5 = i;
                                           CL5 = k;
                                           Ki5 = j;
                                           RW1 = -1;
                                           CL1 = -1;
                                           Ki1 = -1;
                                           RW2 = -1;
                                           CL2 = -1;
                                           Ki2 = -1;
                                           RW3 = -1;
                                           CL3 = -1;
                                           Ki3 = -1;
                                           RW4 = -1;
                                           CL4 = -1;
                                           Ki4 = -1;
                                           RW6 = -1;
                                           CL6 = -1;
                                           Ki6 = -1;
                                           MaxLess5 = (MinisterOnTable[RW5].MinisterThinking[CL5].NumberOfPenalties);
                                           if (MaxLess5 > MaxLess1)
                                               MaxLess1 = -1;
                                           if (MaxLess5 > MaxLess2)
                                               MaxLess2 = -1;
                                           if (MaxLess5 > MaxLess3)
                                               MaxLess3 = -1;
                                           if (MaxLess5 > MaxLess4)
                                               MaxLess4 = -1;
                                           if (MaxLess5 > MaxLess6)
                                               MaxLess6 = -1;

                                           if (AStarGreedyi == 1)
                                           {
                                               Object O = new Object();
                                               lock (O)
                                               {
                                                   if (Order == 1)
                                                   {

                                                   }
                                                   else//If Order is Brown.
                                                   {

                                                   }   //Set Table and Heuristic Value and Syntax.
                                               }
                                               Object On = new Object();
                                               lock (On)
                                               {
                                                   AllDraw.LastRow = MinisterOnTable[i].MinisterThinking[k].Row;
                                                   AllDraw.LastColumn = MinisterOnTable[i].MinisterThinking[k].Column;
                                                   AllDraw.NextRow = MinisterOnTable[i].MinisterThinking[k].RowColumnMinister[j][0];
                                                   AllDraw.NextColumn = MinisterOnTable[i].MinisterThinking[k].RowColumnMinister[j][1];
                                               }
                                               Act = true;
                                               Less = MinisterOnTable[i].MinisterThinking[k].NumberOfPenalties;
                                               TableHeuristic = MinisterOnTable[i].MinisterThinking[k].TableListMinister[j];
                                           }
                                       }
                                       else//Set Table and Heuristic Value and Syntax.
                                       {
                                           if (AStarGreedyi == 1)
                                           {
                                               //Found of Max Non Probable Movments.
                                               Founded.Clear();
                                               int LessB = Int32.MinValue;
                                               BeginIndexFoundingMaxLessofMaxList(0, Founded, ref LessB);
                                               RW5 = (int)MaxHeuristicAStarGreedytBackWard[0][(int)Founded[0]];
                                               CL5 = (int)MaxHeuristicAStarGreedytBackWard[0][(int)Founded[0] + 1];
                                               Ki5 = (int)MaxHeuristicAStarGreedytBackWard[0][(int)Founded[0] + 2];
                                               if (Founded[0] != MaxMinisterFounded)
                                                   continue;
                                               Object On = new Object();
                                               lock (On)
                                               {
                                                   AllDraw.LastRow = MinisterOnTable[RW5].MinisterThinking[CL5].Row;
                                                   AllDraw.LastColumn = MinisterOnTable[RW5].MinisterThinking[CL5].Column;
                                                   AllDraw.NextRow = MinisterOnTable[i].MinisterThinking[k].RowColumnMinister[j][0];
                                                   AllDraw.NextColumn = MinisterOnTable[i].MinisterThinking[k].RowColumnMinister[j][1];
                                               }
                                               Act = true;
                                               Less = MinisterOnTable[RW5].MinisterThinking[CL5].ReturnHeuristic(RW5, Ki5, Order, false, ref HaveKilled);
                                               TableHeuristic = MinisterOnTable[RW5].MinisterThinking[CL5].TableListMinister[Ki5];
                                               Object O = new Object();
                                               lock (O)
                                               {
                                                   if (Order == 1)
                                                   {

                                                   }
                                                   else//If Order is Brown.
                                                   {

                                                   }
                                               }
                                           }
                                       }
                                   }
                               }
                           }

                       Order = DummyOrder;
                       ChessRules.CurrentOrder = DummyCurrentOrder;

                       Order = DummyOrder;
                       ChessRules.CurrentOrder = DummyCurrentOrder;
                   }
                   //king
                   for (i = 0; i < KingMidle; i++)
                   {
                       for (int k = 0; k < AllDraw.KingMovments; k++)
                           for (j = 0; KingOnTable != null && KingOnTable[i] != null && KingOnTable != null && KingOnTable[i] != null && KingOnTable[i].KingThinking[k] != null && KingOnTable[i].KingThinking[k] != null && j < KingOnTable[i].KingThinking[k].TableListKing.Count; j++)
                           {
                               {
                                   //For Penalty Reagrad Mechanisam of Current Check CheckMate Current Movments.
                                   int CDummy = ChessRules.CurrentOrder;
                                   int COrder = Order;
                                   ChessRules.CurrentOrder *= -1;
                                   Order *= -1;
                                   Do = 0;
                                   if (UsePenaltyRegardMechnisamT)
                                   {
                                       for (int ij = 0; ij < KingOnTable[i].KingThinking[k].AStarGreedy.Count - 1; ij++)
                                       {
                                           int D = Do;
                                           var ah = Task.Factory.StartNew(() => KingOnTable[i].KingThinking[k].AStarGreedy[ij].IsPenaltyRegardCheckMateAtBranch(Order, ref D, SolderesOnTable[i].SoldierThinking[k].AStarGreedy[ij]));
                                           ah.Wait();
                                           ah.Dispose();
                                           Do = D;
                                       }
                                       Order = COrder;
                                       ChessRules.CurrentOrder = CDummy;
                                       ToCheckMate = -1; ForCheckMate = -1; AA = IsToCheckMateHasLessDeeperThanForCheckMate(this, Order, ref ToCheckMate, ref ForCheckMate, 0); if (Do == -1)
                                           continue;
                                   }

                                   Order = COrder;
                                   ChessRules.CurrentOrder = CDummy;
                                   //if (AllDraw.OrderPlate == Order && AStarGreedyi == 1 //&& UsePenaltyRegardMechnisamT
                                   //)
                                   if ((KingOnTable[i].KingThinking[k].PenaltyRegardListKing[j].IsPenaltyAction() != 0 && KingOnTable[i].KingThinking[k].PenaltyRegardListKing[j].IsRewardAction() == 1 && AStarGreedyi == 1) || ((Do == 1 || AA) && UsePenaltyRegardMechnisamT) || KingOnTable[i].WinOcuuredatChiled >= 1 || KingOnTable[i].WinOcuuredatChiled >= 2 || KingOnTable[i].WinOcuuredatChiled >= 3)
                                   {
                                       Object On = new Object();
                                       lock (On)
                                       {
                                           AllDraw.LastRow = KingOnTable[i].KingThinking[k].Row;
                                           AllDraw.LastColumn = KingOnTable[i].KingThinking[k].Column;
                                           AllDraw.NextRow = KingOnTable[i].KingThinking[k].RowColumnKing[j][0];
                                           AllDraw.NextColumn = KingOnTable[i].KingThinking[k].RowColumnKing[j][1];
                                           Act = true;
                                           Less = KingOnTable[i].KingThinking[k].NumberOfPenalties;
                                       }
                                       TableHeuristic = KingOnTable[i].KingThinking[k].TableListKing[j];
                                       RegardOccurred = true;
                                       continue;
                                   }
                                   Object ol = new Object();
                                   lock (ol)
                                   {
                                       //When There is No Movments in Such Order Enemy continue.
                                       if (Order != AllDraw.OrderPlateDraw)
                                           if (KingOnTable[i].KingThinking[0].NumberOfPenalties < Less)
                                               continue;
                                       //When There is greater Heuristic Movments.
                                       if (KingOnTable[i].KingThinking[0].NumberOfPenalties < Less)
                                       {
                                           //retrive table of current Heuristic.
                                           int[,] TableS = KingOnTable[i].KingThinking[k].TableListKing[j];
                                           int[,] TableSS = KingOnTable[i].KingThinking[k].TableListKing[j];
                                           //checked for Legal Movments ArgumentOutOfRangeException curnt game.
                                           if (DynamicAStarGreedytPrograming && !CurrentTableHeuristic && AStarGreedyi == 1)
                                           {
                                               if (!IsEnemyThingsinStable(CloneATable(TableS), AllDraw.TableListAction[AllDraw.TableListAction.Count - 1], AllDraw.OrderPlate))
                                                   continue;
                                           }
                                           //When there is not Penalty regard mechanism.
                                           AB = new ChessRules(CurrentAStarGredyMax, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged, 6, CloneATable(TableS), Order, KingOnTable[i].KingThinking[k].Row, KingOnTable[i].KingThinking[k].Column);
                                           //If there is kish or kshachamaz Order.
                                           if (AB.Check(CloneATable(TableS), Order))
                                           {
                                               //When Order is Gray.
                                               if (Order == 1)
                                               {
                                                   //Continue When is kish CheckObjectDangour and AStarGreadyFirstSearch .
                                                   if (AB.CheckGray)
                                                       continue;
                                               }
                                               else
                                               {
                                                   //Continue when CheckBrown and AStarGreadyFirstSearch. 
                                                   if (AB.CheckBrown)
                                                       continue;
                                               }
                                           }

                                           RW6 = i;
                                           CL6 = k;
                                           Ki6 = j;
                                           RW1 = -1;
                                           CL1 = -1;
                                           Ki1 = -1;
                                           RW2 = -1;
                                           CL2 = -1;
                                           Ki2 = -1;
                                           RW3 = -1;
                                           CL3 = -1;
                                           Ki3 = -1;
                                           RW4 = -1;
                                           CL4 = -1;
                                           Ki4 = -1;
                                           RW5 = -1;
                                           CL5 = -1;
                                           Ki5 = -1;
                                           MaxLess6 = (KingOnTable[RW6].KingThinking[CL6].NumberOfPenalties);
                                           if (MaxLess6 > MaxLess1)
                                               MaxLess1 = -1;
                                           if (MaxLess6 > MaxLess2)
                                               MaxLess2 = -1;
                                           if (MaxLess6 > MaxLess3)
                                               MaxLess3 = -1;
                                           if (MaxLess6 > MaxLess4)
                                               MaxLess4 = -1;
                                           if (MaxLess6 > MaxLess5)
                                               MaxLess5 = -1;

                                           if (AStarGreedyi == 1)
                                           {
                                               Object O = new Object();
                                               lock (O)
                                               {
                                                   if (Order == 1)
                                                   {

                                                   }
                                                   else//If Order is Brown.
                                                   {

                                                   }
                                               }
                                               Object On = new Object();
                                               lock (On)
                                               {
                                                   AllDraw.LastRow = KingOnTable[i].KingThinking[k].Row;
                                                   AllDraw.LastColumn = KingOnTable[i].KingThinking[k].Column;
                                                   AllDraw.NextRow = KingOnTable[i].KingThinking[k].RowColumnKing[j][0];
                                                   AllDraw.NextColumn = KingOnTable[i].KingThinking[k].RowColumnKing[j][1];
                                               }
                                               Act = true;
                                               Less = KingOnTable[i].KingThinking[k].NumberOfPenalties;
                                               TableHeuristic = KingOnTable[i].KingThinking[k].TableListKing[j];
                                           }

                                       }
                                       else//Set Table and Heuristic Value and Syntax.
                                       {
                                           if (AStarGreedyi == 1)
                                           {
                                               //Found of Max Non Probable Movments.
                                               Founded.Clear();
                                               int LessB = Int32.MinValue;
                                               BeginIndexFoundingMaxLessofMaxList(0, Founded, ref LessB);
                                               RW6 = (int)MaxHeuristicAStarGreedytBackWard[0][(int)Founded[0]];
                                               CL6 = (int)MaxHeuristicAStarGreedytBackWard[0][(int)Founded[0] + 1];
                                               Ki6 = (int)MaxHeuristicAStarGreedytBackWard[0][(int)Founded[0] + 2];
                                               if (Founded[0] != MaxKingFounded)
                                                   continue;
                                               Object On = new Object();
                                               lock (On)
                                               {
                                                   AllDraw.LastRow = KingOnTable[RW6].KingThinking[CL6].Row;
                                                   AllDraw.LastColumn = KingOnTable[RW6].KingThinking[CL6].Column;
                                                   AllDraw.NextRow = KingOnTable[i].KingThinking[k].RowColumnKing[j][0];
                                                   AllDraw.NextColumn = KingOnTable[i].KingThinking[k].RowColumnKing[j][1];
                                               }
                                               Act = true;
                                               Less = KingOnTable[RW6].KingThinking[CL6].ReturnHeuristic(RW6, Ki6, Order, false, ref HaveKilled);
                                               TableHeuristic = KingOnTable[RW6].KingThinking[CL6].TableListKing[Ki6];
                                               Object O = new Object();
                                               lock (O)
                                               {
                                                   if (Order == 1)
                                                   {

                                                   }
                                                   else//If Order is Brown.
                                                   {

                                                   }
                                               }
                                           }
                                       }
                                   }
                               }
                           }

                       Order = DummyOrder;
                       ChessRules.CurrentOrder = DummyCurrentOrder;

                       Order = DummyOrder;
                       ChessRules.CurrentOrder = DummyCurrentOrder;
                   }

                   return TableHeuristic;
               }
           }
          */ //method for monitor of main Heuristic found best movment (action string)
        void StringHeuristics(int Obj, int Sec, bool AA, int Do, int WinOcuuredatChiled, int[] LoseOcuuredatChiled)
        {

            String SOut = "";
            if (Obj == 1)
            {
                SOut = "Soldier ";
            }
            else
                if (Obj == 2)
            {
                SOut = "Elephant ";
            }
            else
                if (Obj == 3)
            {
                SOut = "Hourse ";
            }
            else
                if (Obj == 4)
            {
                SOut = "Castle ";
            }
            else
                if (Obj == 5)
            {
                SOut = "Minister ";
            }
            else
                    if (Obj == 6)
            {
                SOut = "King ";
            }
            SOut += "AStar Heuristics ";
            if (Sec == 1)
                SOut += " -Initiatetion- ";
            if (Sec == 2)
                SOut += " -Regard- ";
            if (Sec == 3)
                SOut += " -Foundation Greatest- ";
            if (WinOcuuredatChiled >= 1)
                SOut += " At -WinKing Checked Mate- is active For Eneter Regard- ";
            if (LoseOcuuredatChiled[0] <= -1)
                SOut += " At -LoseKing Checked Mate- is active For Eneter Penelty- ";
            if (AA)
                SOut += " '-AA-' is Active due to Regard Enter- ";
            if (Do == 1)
                SOut += " '-Do-' is Active due to Regard Enter- ";
            SOut += " With Heuristic Count " + AllDraw.Less;
            Object O = new Object();
            lock (O)
            {

            }

        }
        bool IsSupHuTrue(int i, int j, int k, int Kind)
        {
            //HarasAlphaBeta(i, k, Kind);

            bool Is = false;
            if (!AllowedSupTrue)
            {
                if (Kind == 1)
                    Is = SolderesOnTable[i].SoldierThinking[0].IsSupHu[j];
                else
       if (Kind == 2)
                    Is = ElephantOnTable[i].ElefantThinking[0].IsSupHu[j];
                else
       if (Kind == 3)
                    Is = HoursesOnTable[i].HourseThinking[0].IsSupHu[j];
                else
       if (Kind == 4)
                    Is = CastlesOnTable[i].CastleThinking[0].IsSupHu[j];
                else
       if (Kind == 5)
                    Is = MinisterOnTable[i].MinisterThinking[0].IsSupHu[j];
                else
       if (Kind == 6)
                    Is = KingOnTable[i].KingThinking[0].IsSupHu[j];
                else
                if (Math.Abs(Kind) == 7)
                    Is = CastlingOnTable[i].CastlingThinking[0].IsSupHu[j];
            }
            else
            {
                if (Kind == 1)
                    Is = SolderesOnTable[i].SoldierThinking[0].IsSup[j];
                else
   if (Kind == 2)
                    Is = ElephantOnTable[i].ElefantThinking[0].IsSup[j];
                else
   if (Kind == 3)
                    Is = HoursesOnTable[i].HourseThinking[0].IsSup[j];
                else
   if (Kind == 4)
                    Is = CastlesOnTable[i].CastleThinking[0].IsSup[j];
                else
   if (Kind == 5)
                    Is = MinisterOnTable[i].MinisterThinking[0].IsSup[j];
                else
   if (Kind == 6)
                    Is = KingOnTable[i].KingThinking[0].IsSup[j];
                else
                if (Math.Abs(Kind) == 7)
                    Is = CastlingOnTable[i].CastlingThinking[0].IsSup[j];
            }
            return Is;
        }
        //method for return index base calculated Heuristic specified and clear
        void SaveLess(int i, int j, int k, int Kind, ref int Less, bool AA, int Order)
        {

            //soldier
            if (Kind == 1)
            {
                Less = SolderesOnTable[i].SoldierThinking[k].ReturnHeuristic(i, j, Order, AA, ref HaveKilled);
            }
            else//elephant
        if (Kind == 2)
            {
                Less = ElephantOnTable[i].ElefantThinking[k].ReturnHeuristic(i, j, Order, AA, ref HaveKilled);
            }
            else//hourse
        if (Kind == 3)
            {
                Less = HoursesOnTable[i].HourseThinking[k].ReturnHeuristic(i, j, Order, AA, ref HaveKilled);
            }
            else//Castle
        if (Kind == 4)
            {
                Less = CastlesOnTable[i].CastleThinking[k].ReturnHeuristic(i, j, Order, AA, ref HaveKilled);
            }
            else//minister
        if (Kind == 5)
            {
                Less = MinisterOnTable[i].MinisterThinking[k].ReturnHeuristic(i, j, Order, AA, ref HaveKilled);
            }
            else//king
        if (Kind == 6)
            {
                Less = KingOnTable[i].KingThinking[k].ReturnHeuristic(i, j, Order, AA, ref HaveKilled);
            }
            else//king
                if (Kind == 7 || Kind == -7)
            {
                Less = CastlingOnTable[i].CastlingThinking[k].ReturnHeuristic(i, j, Order, AA, ref HaveKilled);
            }
        }
        //index of tables that verified existence havbeen saved into refer var
        void SaveTableHeuristic(int i, int j, int k, int Kind, ref int[,] TableHeuristic)
        {
            //soldier
            if (Kind == 1)
            {
                TableHeuristic = CloneATable(SolderesOnTable[i].SoldierThinking[k].TableListSolder[j]);
            }
            else//elephant
                if (Kind == 2)
            {
                TableHeuristic = CloneATable(ElephantOnTable[i].ElefantThinking[k].TableListElefant[j]);
            }
            else//hourse
                if (Kind == 3)
            {
                TableHeuristic = CloneATable(HoursesOnTable[i].HourseThinking[k].TableListHourse[j]);
            }
            else//Castle
                if (Kind == 4)
            {
                TableHeuristic = CloneATable(CastlesOnTable[i].CastleThinking[k].TableListCastle[j]);
            }
            else//minister
                if (Kind == 5)
            {
                TableHeuristic = CloneATable(MinisterOnTable[i].MinisterThinking[k].TableListMinister[j]);
            }
            else//king
                if (Kind == 6)
            {
                TableHeuristic = CloneATable(KingOnTable[i].KingThinking[k].TableListKing[j]);
            }
            else//king
                if (Kind == 7 || Kind == -7)
            {
                TableHeuristic = CloneATable(CastlingOnTable[i].CastlingThinking[k].TableListCastling[j]);
            }
        }
        //same of befor verified existence of begin move and end move location saved in unique results of Last best movments
        void SaveBeginEndLocation(int i, int j, int k, int Kind)
        {
            //soldier
            if (Kind == 1)
            {
                AllDraw.LastRow = SolderesOnTable[i].SoldierThinking[k].Row;
                AllDraw.LastColumn = SolderesOnTable[i].SoldierThinking[k].Column;
                AllDraw.NextRow = SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][0];
                AllDraw.NextColumn = SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][1];
            }
            else//elephant
                 if (Kind == 2)
            {
                AllDraw.LastRow = ElephantOnTable[i].ElefantThinking[k].Row;
                AllDraw.LastColumn = ElephantOnTable[i].ElefantThinking[k].Column;
                AllDraw.NextRow = ElephantOnTable[i].ElefantThinking[k].RowColumnElefant[j][0];
                AllDraw.NextColumn = ElephantOnTable[i].ElefantThinking[k].RowColumnElefant[j][1];
            }
            else//hourse
                 if (Kind == 3)
            {
                AllDraw.LastRow = HoursesOnTable[i].HourseThinking[k].Row;
                AllDraw.LastColumn = HoursesOnTable[i].HourseThinking[k].Column;
                AllDraw.NextRow = HoursesOnTable[i].HourseThinking[k].RowColumnHourse[j][0];
                AllDraw.NextColumn = HoursesOnTable[i].HourseThinking[k].RowColumnHourse[j][1];
            }
            else//Castle
                 if (Kind == 4)
            {
                AllDraw.LastRow = CastlesOnTable[i].CastleThinking[k].Row;
                AllDraw.LastColumn = CastlesOnTable[i].CastleThinking[k].Column;
                AllDraw.NextRow = CastlesOnTable[i].CastleThinking[k].RowColumnCastle[j][0];
                AllDraw.NextColumn = CastlesOnTable[i].CastleThinking[k].RowColumnCastle[j][1];
            }
            else//minister
                 if (Kind == 5)
            {
                AllDraw.LastRow = MinisterOnTable[i].MinisterThinking[k].Row;
                AllDraw.LastColumn = MinisterOnTable[i].MinisterThinking[k].Column;
                AllDraw.NextRow = MinisterOnTable[i].MinisterThinking[k].RowColumnMinister[j][0];
                AllDraw.NextColumn = MinisterOnTable[i].MinisterThinking[k].RowColumnMinister[j][1];
            }
            else//king
                 if (Kind == 6)
            {
                AllDraw.LastRow = KingOnTable[i].KingThinking[k].Row;
                AllDraw.LastColumn = KingOnTable[i].KingThinking[k].Column;
                AllDraw.NextRow = KingOnTable[i].KingThinking[k].RowColumnKing[j][0];
                AllDraw.NextColumn = KingOnTable[i].KingThinking[k].RowColumnKing[j][1];
            }
            else//king
                 if (Kind == 7 || Kind == -7)
            {
                AllDraw.LastRow = CastlingOnTable[i].CastlingThinking[k].Row;
                AllDraw.LastColumn = CastlingOnTable[i].CastlingThinking[k].Column;
                AllDraw.NextRow = CastlingOnTable[i].CastlingThinking[k].RowColumnCastling[j][0];
                AllDraw.NextColumn = CastlingOnTable[i].CastlingThinking[k].RowColumnCastling[j][1];
            }
        }
        //when branches(chield) of tree has heuristic less than current found 
        bool RegardLessOptimized(int i, int j, int k, int Kind, ref int Less, bool AA, int Order)
        { //soldier
            if (Kind == 1)
            {
                bool ac = false;
                int HaKild = HaveKilled;
                int Le = Less;
                var ah = Task.Factory.StartNew(() => ac = Le < SolderesOnTable[i].SoldierThinking[k].ReturnHeuristic(i, j, Order, AA, ref HaKild));
                ah.Wait();
                ah.Dispose();
                HaveKilled = HaKild;
                Less = Le;

                if (ac)
                    return true;
            }
            else//elephant
    if (Kind == 2)
            {
                bool ac = false;
                int HaKild = HaveKilled;
                int Le = Less;
                var ah = Task.Factory.StartNew(() => ac = Le < ElephantOnTable[i].ElefantThinking[k].ReturnHeuristic(i, j, Order, AA, ref HaKild));
                ah.Wait();
                ah.Dispose();
                HaveKilled = HaKild;
                Less = Le;
                if (ac)
                    return true;
            }
            else//hourse
    if (Kind == 3)
            {
                bool ac = false;
                int HaKild = HaveKilled;
                int Le = Less;
                var ah = Task.Factory.StartNew(() => ac = Le < HoursesOnTable[i].HourseThinking[k].ReturnHeuristic(i, j, Order, AA, ref HaKild));
                ah.Wait();
                ah.Dispose();
                HaveKilled = HaKild;
                Less = Le;

                if (ac)
                    return true;
            }
            else//Castle
    if (Kind == 4)
            {
                bool ac = false;
                int HaKild = HaveKilled;
                int Le = Less;
                var ah = Task.Factory.StartNew(() => ac = Le < CastlesOnTable[i].CastleThinking[k].ReturnHeuristic(i, j, Order, AA, ref HaKild));
                ah.Wait();
                ah.Dispose();
                HaveKilled = HaKild;
                Less = Le;

                if (ac)
                    return true;
            }
            else//minister
    if (Kind == 5)
            {
                bool ac = false;
                int HaKild = HaveKilled;
                int Le = Less;
                var ah = Task.Factory.StartNew(() => ac = Le < MinisterOnTable[i].MinisterThinking[k].ReturnHeuristic(i, j, Order, AA, ref HaKild));
                ah.Wait();
                ah.Dispose();
                HaveKilled = HaKild;
                Less = Le;

                if (ac)
                    return true;
            }
            else//king
    if (Kind == 6)
            {
                bool ac = false;
                int HaKild = HaveKilled;
                int Le = Less;
                var ah = Task.Factory.StartNew(() => ac = Le < KingOnTable[i].KingThinking[k].ReturnHeuristic(i, j, Order, AA, ref HaKild));
                ah.Wait();
                ah.Dispose();
                HaveKilled = HaKild;
                Less = Le;

                if (ac)
                    return true;
            }
            else//king
    if (Kind == 7 || Kind == -7)
            {
                bool ac = false;
                int HaKild = HaveKilled;
                int Le = Less;
                var ah = Task.Factory.StartNew(() => ac = Le < CastlingOnTable[i].CastlingThinking[k].ReturnHeuristic(i, j, Order, AA, ref HaKild));
                ah.Wait();
                ah.Dispose();
                HaveKilled = HaKild;
                Less = Le;

                if (ac)
                    return true;
            }
            return false;
        }
        //regard section of main Heuristic in learning autamata section
        bool HeuristicRegardSection(int i, int j, int k, ref bool Act, ref int[,] TableHeuristic, ref bool AA, Color a, int Kind, ref int Do, int AStarGreedyi, int Order)
        {
            bool continued = false;
            if (IsSupHuTrue(i, j, k, Kind))
                return true;
            bool A = WinReturnValue(Kind, i, j);
            bool B = WinPerfromeRegardMethod(Kind, i, j);
            continued = A;
            if (!(A && B))
                return continued;
            //soldier
            if (Kind == 1)
            {
                if ((SolderesOnTable[i].SoldierThinking[k].PenaltyRegardListSolder[j].IsPenaltyAction() != 0 && SolderesOnTable[i].SoldierThinking[k].PenaltyRegardListSolder[j].IsRewardAction() == 1 && AStarGreedyi == 1) || ((((Do == 1 || AA) && UsePenaltyRegardMechnisamT)) && UsePenaltyRegardMechnisamT) || SolderesOnTable[i].WinOcuuredatChiled >= 1 || SolderesOnTable[i].WinOcuuredatChiled >= 2 || SolderesOnTable[i].WinOcuuredatChiled >= 3)
                {
                    //Set Table and Heuristic Value and Syntax.
                    Act = true;
                    Object On = new Object();
                    lock (On)
                    {
                        //if (!RegardLessOptimized(i, j, k, Kind, ref Less, AA, Order))


                        var ah = Task.Factory.StartNew(() => SaveBeginEndLocation(i, j, k, Kind));
                        ah.Wait();
                        ah.Dispose();

                        int[,] Th = TableHeuristic;
                        var ah1 = Task.Factory.StartNew(() => SaveTableHeuristic(i, j, k, Kind, ref Th));
                        ah1.Wait();
                        ah1.Dispose();
                        TableHeuristic = Th;

                        int le = Less;
                        bool AAA = AA;
                        var ah2 = Task.Factory.StartNew(() => SaveLess(i, j, k, Kind, ref le, AAA, Order));
                        ah2.Wait();
                        ah2.Dispose();
                        Less = le;
                        AA = AAA;

                    }
                    Object O = new Object();
                    lock (O)
                    {
                        ThingsConverter.ActOfClickEqualTow = true;
                    }
                    SolderesOnTable[i].ConvertOperation(SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][0], SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][1], a, SolderesOnTable[i].SoldierThinking[k].TableListSolder[j], Order, false, i);
                    int Sign = 1;
                    if (a == Color.Brown)
                        Sign = -1;
                    //If there is Soldier Convert.
                    if (SolderesOnTable[i].Convert)
                    {
                        if (SolderesOnTable[i].ConvertedToMinister)
                            TableHeuristic[SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][0], SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][1]] = 5 * Sign;
                        else if (SolderesOnTable[i].ConvertedToCastle)
                            TableHeuristic[SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][0], SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][1]] = 4 * Sign;
                        else if (SolderesOnTable[i].ConvertedToHourse)
                            TableHeuristic[SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][0], SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][1]] = 3 * Sign;
                        else if (SolderesOnTable[i].ConvertedToElefant)
                            TableHeuristic[SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][0], SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][1]] = 2 * Sign;
                    }
                    RegardOccurred = true;
                    StringHeuristics(1, 2, AA, Do, SolderesOnTable[i].WinOcuuredatChiled, SolderesOnTable[i].LoseOcuuredatChiled);
                    continued = true;
                }
            }
            else//elephant
            if (Kind == 2)
            {
                if ((ElephantOnTable[i].ElefantThinking[k].PenaltyRegardListElefant[j].IsPenaltyAction() != 0 && ElephantOnTable[i].ElefantThinking[k].PenaltyRegardListElefant[j].IsRewardAction() == 1 && AStarGreedyi == 1) || ((Do == 1 || AA) && UsePenaltyRegardMechnisamT) || ElephantOnTable[i].WinOcuuredatChiled >= 1 || ElephantOnTable[i].WinOcuuredatChiled >= 2 || ElephantOnTable[i].WinOcuuredatChiled >= 3)
                {
                    Object On = new Object();
                    lock (On)
                    {
                        //if (!RegardLessOptimized(i, j, k, Kind, ref Less, AA, Order))

                        var ah = Task.Factory.StartNew(() => SaveBeginEndLocation(i, j, k, Kind));
                        ah.Wait();
                        ah.Dispose();

                        int[,] Th = TableHeuristic;
                        var ah1 = Task.Factory.StartNew(() => SaveTableHeuristic(i, j, k, Kind, ref Th));
                        ah1.Wait();
                        ah1.Dispose();
                        TableHeuristic = Th;

                        int le = Less;
                        bool AAA = AA;
                        var ah2 = Task.Factory.StartNew(() => SaveLess(i, j, k, Kind, ref le, AAA, Order));
                        ah2.Wait();
                        ah2.Dispose();
                        Less = le;
                        AA = AAA;
                    }
                    StringHeuristics(2, 2, AA, Do, ElephantOnTable[i].WinOcuuredatChiled, ElephantOnTable[i].LoseOcuuredatChiled);
                    RegardOccurred = true;
                    continued = true;
                }
            }
            else//hourse
            if (Kind == 3)
            {
                if ((HoursesOnTable[i].HourseThinking[k].PenaltyRegardListHourse[j].IsPenaltyAction() != 0 && HoursesOnTable[i].HourseThinking[k].PenaltyRegardListHourse[j].IsRewardAction() == 1 && AStarGreedyi == 1) || ((Do == 1 || AA) && UsePenaltyRegardMechnisamT) || HoursesOnTable[i].WinOcuuredatChiled >= 1 || HoursesOnTable[i].WinOcuuredatChiled >= 2 || HoursesOnTable[i].WinOcuuredatChiled >= 3)
                {
                    Object On = new Object();
                    lock (On)
                    {
                        //if (!RegardLessOptimized(i, j, k, Kind, ref Less, AA, Order))

                        var ah = Task.Factory.StartNew(() => SaveBeginEndLocation(i, j, k, Kind));
                        ah.Wait();
                        ah.Dispose();

                        int[,] Th = TableHeuristic;
                        var ah1 = Task.Factory.StartNew(() => SaveTableHeuristic(i, j, k, Kind, ref Th));
                        ah1.Wait();
                        ah1.Dispose();
                        TableHeuristic = Th;

                        int le = Less;
                        bool AAA = AA;
                        var ah2 = Task.Factory.StartNew(() => SaveLess(i, j, k, Kind, ref le, AAA, Order));
                        ah2.Wait();
                        ah2.Dispose();
                        Less = le;
                        AA = AAA;
                    }
                    RegardOccurred = true;
                    StringHeuristics(3, 2, AA, Do, HoursesOnTable[i].WinOcuuredatChiled, HoursesOnTable[i].LoseOcuuredatChiled);
                    continued = true;
                }
            }
            else//Castle
            if (Kind == 4)
            {
                if ((CastlesOnTable[i].CastleThinking[k].PenaltyRegardListCastle[j].IsPenaltyAction() != 0 && CastlesOnTable[i].CastleThinking[k].PenaltyRegardListCastle[j].IsRewardAction() == 1 && AStarGreedyi == 1) || ((Do == 1 || AA) && UsePenaltyRegardMechnisamT) || CastlesOnTable[i].WinOcuuredatChiled >= 1 || CastlesOnTable[i].WinOcuuredatChiled >= 2 || CastlesOnTable[i].WinOcuuredatChiled >= 3)
                {
                    Object On = new Object();
                    lock (On)
                    {
                        //if (!RegardLessOptimized(i, j, k, Kind, ref Less, AA, Order))

                        var ah = Task.Factory.StartNew(() => SaveBeginEndLocation(i, j, k, Kind));
                        ah.Wait();
                        ah.Dispose();

                        int[,] Th = TableHeuristic;
                        var ah1 = Task.Factory.StartNew(() => SaveTableHeuristic(i, j, k, Kind, ref Th));
                        ah1.Wait();
                        ah1.Dispose();
                        TableHeuristic = Th;

                        int le = Less;
                        bool AAA = AA;
                        var ah2 = Task.Factory.StartNew(() => SaveLess(i, j, k, Kind, ref le, AAA, Order));
                        ah2.Wait();
                        ah2.Dispose();
                        Less = le;
                        AA = AAA;
                    }
                    RegardOccurred = true;
                    StringHeuristics(4, 2, AA, Do, CastlesOnTable[i].WinOcuuredatChiled, CastlesOnTable[i].LoseOcuuredatChiled);
                    continued = true;
                }
            }
            else//minister
                if (Kind == 5)
            {
                if ((MinisterOnTable[i].MinisterThinking[k].PenaltyRegardListMinister[j].IsPenaltyAction() != 0 && MinisterOnTable[i].MinisterThinking[k].PenaltyRegardListMinister[j].IsRewardAction() == 1 && AStarGreedyi == 1) || ((Do == 1 || AA) && UsePenaltyRegardMechnisamT) || MinisterOnTable[i].WinOcuuredatChiled >= 1 || MinisterOnTable[i].WinOcuuredatChiled >= 2 || MinisterOnTable[i].WinOcuuredatChiled >= 3)
                {
                    Object On = new Object();
                    lock (On)
                    {
                        //if (!RegardLessOptimized(i, j, k, Kind, ref Less, AA, Order))

                        var ah = Task.Factory.StartNew(() => SaveBeginEndLocation(i, j, k, Kind));
                        ah.Wait();
                        ah.Dispose();

                        int[,] Th = TableHeuristic;
                        var ah1 = Task.Factory.StartNew(() => SaveTableHeuristic(i, j, k, Kind, ref Th));
                        ah1.Wait();
                        ah1.Dispose();
                        TableHeuristic = Th;

                        int le = Less;
                        bool AAA = AA;
                        var ah2 = Task.Factory.StartNew(() => SaveLess(i, j, k, Kind, ref le, AAA, Order));
                        ah2.Wait();
                        ah2.Dispose();
                        Less = le;
                        AA = AAA;
                    }
                    TableHeuristic = MinisterOnTable[i].MinisterThinking[k].TableListMinister[j];
                    RegardOccurred = true;
                    StringHeuristics(5, 2, AA, Do, MinisterOnTable[i].WinOcuuredatChiled, MinisterOnTable[i].LoseOcuuredatChiled);
                    continued = true;
                }
            }
            else//king
            if (Kind == 6)
            {
                if ((KingOnTable[i].KingThinking[k].PenaltyRegardListKing[j].IsPenaltyAction() != 0 && KingOnTable[i].KingThinking[k].PenaltyRegardListKing[j].IsRewardAction() == 1 && AStarGreedyi == 1) || ((Do == 1 || AA) && UsePenaltyRegardMechnisamT) || KingOnTable[i].WinOcuuredatChiled >= 1 || KingOnTable[i].WinOcuuredatChiled >= 2 || KingOnTable[i].WinOcuuredatChiled >= 3)
                {
                    Object On = new Object();
                    lock (On)
                    {
                        //if (!RegardLessOptimized(i, j, k, Kind, ref Less, AA, Order))

                        var ah = Task.Factory.StartNew(() => SaveBeginEndLocation(i, j, k, Kind));
                        ah.Wait();
                        ah.Dispose();

                        int[,] Th = TableHeuristic;
                        var ah1 = Task.Factory.StartNew(() => SaveTableHeuristic(i, j, k, Kind, ref Th));
                        ah1.Wait();
                        ah1.Dispose();
                        TableHeuristic = Th;

                        int le = Less;
                        bool AAA = AA;
                        var ah2 = Task.Factory.StartNew(() => SaveLess(i, j, k, Kind, ref le, AAA, Order));
                        ah2.Wait();
                        ah2.Dispose();
                        Less = le;
                        AA = AAA;
                    }
                    RegardOccurred = true;
                    StringHeuristics(6, 2, AA, Do, KingOnTable[i].WinOcuuredatChiled, KingOnTable[i].LoseOcuuredatChiled);
                    //if (KingOnTable[i].WinOcuuredatChiled >= 1 || KingOnTable[i].WinOcuuredatChiled >= 2 || KingOnTable[i].WinOcuuredatChiled >= 3)

                    //if (((Do == 1 || AA)&&UsePenaltyRegardMechnisamT))
                    continued = true;
                }
            }
            else//king
            if (Kind == 7 || Kind == -7)
            {
                if ((CastlingOnTable[i].CastlingThinking[k].PenaltyRegardListCastling[j].IsPenaltyAction() != 0 && CastlingOnTable[i].CastlingThinking[k].PenaltyRegardListCastling[j].IsRewardAction() == 1 && AStarGreedyi == 1) || ((Do == 1 || AA) && UsePenaltyRegardMechnisamT) || CastlingOnTable[i].WinOcuuredatChiled >= 1 || CastlingOnTable[i].WinOcuuredatChiled >= 2 || CastlingOnTable[i].WinOcuuredatChiled >= 3)
                {
                    Object On = new Object();
                    lock (On)
                    {
                        //if (!RegardLessOptimized(i, j, k, Kind, ref Less, AA, Order))

                        var ah = Task.Factory.StartNew(() => SaveBeginEndLocation(i, j, k, Kind));
                        ah.Wait();
                        ah.Dispose();

                        int[,] Th = TableHeuristic;
                        var ah1 = Task.Factory.StartNew(() => SaveTableHeuristic(i, j, k, Kind, ref Th));
                        ah1.Wait();
                        ah1.Dispose();
                        TableHeuristic = Th;

                        int le = Less;
                        bool AAA = AA;
                        var ah2 = Task.Factory.StartNew(() => SaveLess(i, j, k, Kind, ref le, AAA, Order));
                        ah2.Wait();
                        ah2.Dispose();
                        Less = le;
                        AA = AAA;
                    }
                    RegardOccurred = true;
                    StringHeuristics(7, 2, AA, Do, CastlingOnTable[i].WinOcuuredatChiled, CastlingOnTable[i].LoseOcuuredatChiled);
                    //if (KingOnTable[i].WinOcuuredatChiled >= 1 || KingOnTable[i].WinOcuuredatChiled >= 2 || KingOnTable[i].WinOcuuredatChiled >= 3)

                    //if (((Do == 1 || AA)&&UsePenaltyRegardMechnisamT))
                    continued = true;
                }
            }
            if (continued)
                OnlyWin = true;
            return continued;
        }
        //initiate deterministic vars of orderic Heuristic value
        void InitiateVars(int i, int j, int k, int Kind)
        {

            RW1 = -1;
            CL1 = -1;
            Ki1 = -1;
            RW2 = -1;
            CL2 = -1;
            Ki2 = -1;
            RW3 = -1;
            CL3 = -1;
            Ki3 = -1;
            RW4 = -1;
            CL4 = -1;
            Ki4 = -1;
            RW5 = -1;
            CL5 = -1;
            Ki5 = -1;
            RW6 = -1;
            CL6 = -1;
            Ki6 = -1;
            RW7 = -1;
            CL7 = -1;
            Ki7 = -1;
            //Sodleirs 
            if (Kind == 1)
            {
                RW1 = i;
                CL1 = k;
                Ki1 = j;
            }
            else//elephant
                if (Kind == 2)
            {
                RW2 = i;
                CL2 = k;
                Ki2 = j;
            }
            else//hourse
                if (Kind == 3)
            {
                RW3 = i;
                CL3 = k;
                Ki3 = j;
            }
            else//Castle
                if (Kind == 4)
            {
                RW4 = i;
                CL4 = k;
                Ki4 = j;
            }
            else//minister
                if (Kind == 5)
            {
                RW5 = i;
                CL5 = k;
                Ki5 = j;
            }
            else//king
                if (Kind == 6)
            {
                RW6 = i;
                CL6 = k;
                Ki6 = j;
            }
            else//king
                if (Kind == 7 || Kind == -7)
            {
                RW7 = i;
                CL7 = k;
                Ki7 = j;
            }

        }
        //deterministic of checke of movments occured for ignore
        bool CheckeHuristci(int[,] TableS, int Order, int i, int j, int k)
        {

            bool continued = false;
            ChessRules AB = new ChessRules(CurrentAStarGredyMax, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged, 1, CloneATable(TableS), Order, SolderesOnTable[i].SoldierThinking[k].Row, SolderesOnTable[i].SoldierThinking[k].Column);
            //If there is kish or kshachamaz Order.
            bool ac = false;
            var ah = Task.Factory.StartNew(() => ac = AB.Check(CloneATable(TableS), Order));
            ah.Wait();
            ah.Dispose();

            if (ac)
            {
                //When Order is Gray.
                if (Order == 1)
                {
                    //Continue When is kish CheckObjectDangour and AStarGreadyFirstSearch .
                    if (AB.CheckGray)
                        continued = true;
                }
                else
                {
                    //Continue when CheckBrown and AStarGreadyFirstSearch. 
                    if (AB.CheckBrown)
                        continued = true;
                }
            }

            return continued;
        }
        //minitoring of Heuristic output
        void OutputHeuristic(int Order)
        {

            Object O1 = new Object();
            lock (O1)
            {
                if (Order == 1)
                {

                }
                else//If Order is Brown.
                {

                }
            }

        }
        //main method of Heuristic
        bool HeuristicMainBody(int i, int j, int k, ref bool Act, ref int[,] TableHeuristic, ref bool CurrentTableHeuristic, ref bool AA, Color a, int Kind, ref int Do, int AStarGreedyi, int Order)
        {

            bool continued = false;
            if (IsSupHuTrue(i, j, k, Kind))
                return true;
            if (Kind == 1)
            {
                bool ac = false;
                bool AAA = AA;
                int Le = Less;
                int Havk = HaveKilled;
                var ah = Task.Factory.StartNew(() => ac = SolderesOnTable[i].SoldierThinking[0].ReturnHeuristic(i, j, Order, AAA, ref Havk) > Le);
                ah.Wait();
                ah.Dispose();
                AA = AAA;
                Less = Le;
                HaveKilled = Havk;
                if (ac)
                {

                    Object O11 = new Object();
                    lock (O11)
                    {
                        int[,] TableS = SolderesOnTable[i].SoldierThinking[k].TableListSolder[j];
                        //checked for Legal Movments ArgumentOutOfRangeException curnt game.
                        if (DynamicAStarGreedytPrograming && !CurrentTableHeuristic && AStarGreedyi == 1)
                        {
                            if (!IsEnemyThingsinStable(CloneATable(TableS), AllDraw.TableListAction[AllDraw.TableListAction.Count - 1], AllDraw.OrderPlate))
                            {
                                //if (Order == 1)

                                //else

                                return true;
                            }

                        }
                        //When there is not Penalty regard mechanism.
                        var ah1 = Task.Factory.StartNew(() => ac = CheckeHuristci(CloneATable(TableS), Order, i, j, k));
                        ah1.Wait();
                        ah1.Dispose();
                        if (ac)
                            return true;

                        var ah2 = Task.Factory.StartNew(() => InitiateVars(i, j, k, Kind));
                        ah2.Wait();
                        ah2.Dispose();

                        //Set Max of Soldier.
                        AAA = AA;
                        Havk = HaveKilled;
                        var ah3 = Task.Factory.StartNew(() => MaxLess1 = SolderesOnTable[RW1].SoldierThinking[CL1].ReturnHeuristic(i, j, Order, AAA, ref Havk));
                        ah3.Wait();
                        ah3.Dispose();
                        AA = AAA;
                        HaveKilled = Havk;

                        if (ThinkingRefrigtzChessPortable.IsAtLeastOneKillerAtDraw)
                        {
                            if ((!KiilledForce(ref HaveKilled)) && (HaveKilled < 0))
                                return true;
                        }
                        if (!KillerForce(ref HaveKilled))
                            return true;
                        //When Soldeirs is Greater than Others these Set Max.
                        if (MaxLess1 > MaxLess2)
                            MaxLess2 = -1;
                        if (MaxLess1 > MaxLess3)
                            MaxLess3 = -1;
                        if (MaxLess1 > MaxLess4)
                            MaxLess4 = -1;
                        if (MaxLess1 > MaxLess5)
                            MaxLess5 = -1;
                        if (MaxLess2 > MaxLess6)
                            MaxLess6 = -1;
                        if (MaxLess2 > MaxLess7)
                            MaxLess7 = -1;
                        if (AStarGreedyi == 1)
                        {
                            OutputHeuristic(Order);
                            //Set Table and Heuristic Value and Syntax.
                            Act = true;
                            Object On = new Object();
                            lock (On)
                            {
                                var ah4 = Task.Factory.StartNew(() => SaveBeginEndLocation(i, j, k, Kind));
                                ah4.Wait();
                                ah4.Dispose();

                                int[,] Th = TableHeuristic;
                                var ah5 = Task.Factory.StartNew(() => SaveTableHeuristic(i, j, k, Kind, ref Th));
                                ah5.Wait();
                                ah5.Dispose();
                                TableHeuristic = Th;

                                int le = Less;
                                AAA = AA;
                                var ah6 = Task.Factory.StartNew(() => SaveLess(i, j, k, Kind, ref le, AAA, Order));
                                ah6.Wait();
                                ah6.Dispose();
                                Less = le;
                                AA = AAA;
                            }
                            StringHeuristics(1, 3, AA, Do, SolderesOnTable[i].WinOcuuredatChiled, SolderesOnTable[i].LoseOcuuredatChiled);

                            Object O1 = new Object();
                            lock (O1)
                            {
                                ThingsConverter.ActOfClickEqualTow = true;
                            }
                            SolderesOnTable[i].ConvertOperation(SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][0], SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][1], a, SolderesOnTable[i].SoldierThinking[k].TableListSolder[j], Order, false, i);
                            int Sign = 1;
                            if (a == Color.Brown)
                                Sign = -1;
                            //If there is Soldier Convert.
                            if (SolderesOnTable[i].Convert)
                            {
                                if (SolderesOnTable[i].ConvertedToMinister)
                                    TableHeuristic[SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][0], SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][1]] = 5 * Sign;
                                else if (SolderesOnTable[i].ConvertedToCastle)
                                    TableHeuristic[SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][0], SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][1]] = 4 * Sign;
                                else if (SolderesOnTable[i].ConvertedToHourse)
                                    TableHeuristic[SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][0], SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][1]] = 3 * Sign;
                                else if (SolderesOnTable[i].ConvertedToElefant)
                                    TableHeuristic[SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][0], SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][1]] = 2 * Sign;
                            }
                        }
                    }
                }
            }
            else if (Kind == 2)
            {
                bool ac = false;
                bool AAA = AA;
                int Le = Less;
                int Havk = HaveKilled;
                var ah = Task.Factory.StartNew(() => ac = ElephantOnTable[i].ElefantThinking[0].ReturnHeuristic(i, j, Order, AAA, ref Havk) > Le);
                ah.Wait();
                ah.Dispose();
                AA = AAA;
                Less = Le;
                HaveKilled = Havk;
                if (ac)
                {
                    Object O = new Object();
                    lock (O)
                    {

                    }
                    //retrive table of current Heuristic.
                    int[,] TableS = ElephantOnTable[i].ElefantThinking[k].TableListElefant[j];
                    //checked for Legal Movments ArgumentOutOfRangeException curnt game.
                    if (DynamicAStarGreedytPrograming && !CurrentTableHeuristic && AStarGreedyi == 1)
                    {
                        if (!IsEnemyThingsinStable(CloneATable(TableS), AllDraw.TableListAction[AllDraw.TableListAction.Count - 1], AllDraw.OrderPlate))
                        {
                            //if (Order == 1)

                            //else

                            return true;
                        }

                    }
                    //When there is not Penalty regard mechanism.
                    var ah1 = Task.Factory.StartNew(() => ac = CheckeHuristci(CloneATable(TableS), Order, i, j, k));
                    ah1.Wait();
                    ah1.Dispose();
                    if (ac)
                        return true;

                    var ah2 = Task.Factory.StartNew(() => InitiateVars(i, j, k, Kind));
                    ah2.Wait();
                    ah2.Dispose();

                    AAA = AA;
                    Havk = HaveKilled;
                    var ah3 = Task.Factory.StartNew(() => MaxLess2 = ElephantOnTable[RW2].ElefantThinking[CL2].ReturnHeuristic(i, j, Order, AAA, ref Havk));
                    ah3.Wait();
                    ah3.Dispose();
                    AA = AAA;
                    HaveKilled = Havk;

                    if (ThinkingRefrigtzChessPortable.IsAtLeastOneKillerAtDraw)
                    {
                        if ((!KiilledForce(ref HaveKilled)) && (HaveKilled < 0))
                            return true;
                    }
                    if (!KillerForce(ref HaveKilled))
                        return true;
                    if (MaxLess2 > MaxLess1)
                        MaxLess1 = -1;
                    if (MaxLess2 > MaxLess3)
                        MaxLess3 = -1;
                    if (MaxLess2 > MaxLess4)
                        MaxLess4 = -1;
                    if (MaxLess2 > MaxLess5)
                        MaxLess5 = -1;
                    if (MaxLess2 > MaxLess6)
                        MaxLess6 = -1;
                    if (MaxLess2 > MaxLess7)
                        MaxLess7 = -1;
                    if (AStarGreedyi == 1)
                    {
                        OutputHeuristic(Order);
                        //Set Table and Heuristic Value and Syntax.
                        Object On = new Object();
                        lock (On)
                        {
                            var ah4 = Task.Factory.StartNew(() => SaveBeginEndLocation(i, j, k, Kind));
                            ah4.Wait();
                            ah4.Dispose();

                            int[,] Th = TableHeuristic;
                            var ah5 = Task.Factory.StartNew(() => SaveTableHeuristic(i, j, k, Kind, ref Th));
                            ah5.Wait();
                            ah5.Dispose();
                            TableHeuristic = Th;

                            int le = Less;
                            AAA = AA;
                            var ah6 = Task.Factory.StartNew(() => SaveLess(i, j, k, Kind, ref le, AAA, Order));
                            ah6.Wait();
                            ah6.Dispose();
                            Less = le;
                            AA = AAA;
                        }
                        Act = true;
                        StringHeuristics(2, 3, AA, Do, ElephantOnTable[i].WinOcuuredatChiled, ElephantOnTable[i].LoseOcuuredatChiled);

                    }
                }
            }
            else if (Kind == 3)
            {
                bool ac = false;
                bool AAA = AA;
                int Le = Less;
                int Havk = HaveKilled;
                var ah = Task.Factory.StartNew(() => ac = HoursesOnTable[i].HourseThinking[0].ReturnHeuristic(i, j, Order, AAA, ref Havk) > Le);
                ah.Wait();
                ah.Dispose();
                AA = AAA;
                Less = Le;
                HaveKilled = Havk;
                if (ac)
                {
                    Object O = new Object();
                    lock (O)
                    {

                    }
                    //retrive table of current Heuristic.
                    int[,] TableS = HoursesOnTable[i].HourseThinking[k].TableListHourse[j];
                    //checked for Legal Movments ArgumentOutOfRangeException curnt game.
                    if (DynamicAStarGreedytPrograming && !CurrentTableHeuristic && AStarGreedyi == 1)
                    {
                        if (!IsEnemyThingsinStable(CloneATable(TableS), AllDraw.TableListAction[AllDraw.TableListAction.Count - 1], AllDraw.OrderPlate))
                        {
                            if (Order == 1)
                            {

                            }
                            else
                            {

                                return true;
                            }
                        }
                    }
                    //When there is not Penalty regard mechanism.
                    var ah1 = Task.Factory.StartNew(() => ac = CheckeHuristci(CloneATable(TableS), Order, i, j, k));
                    ah1.Wait();
                    ah1.Dispose();
                    if (ac)
                        return true;

                    var ah2 = Task.Factory.StartNew(() => InitiateVars(i, j, k, Kind));
                    ah2.Wait();
                    ah2.Dispose();

                    AAA = AA;
                    Havk = HaveKilled;
                    var ah3 = Task.Factory.StartNew(() => MaxLess3 = HoursesOnTable[RW3].HourseThinking[CL3].ReturnHeuristic(i, j, Order, AAA, ref Havk));
                    ah3.Wait();
                    ah3.Dispose();
                    AA = AAA;
                    HaveKilled = Havk;

                    if (ThinkingRefrigtzChessPortable.IsAtLeastOneKillerAtDraw)
                    {
                        if ((!KiilledForce(ref HaveKilled)) && (HaveKilled < 0))
                            return true;
                    }
                    if (!KillerForce(ref HaveKilled))
                        return true;
                    if (MaxLess3 > MaxLess1)
                        MaxLess1 = -1;
                    if (MaxLess3 > MaxLess2)
                        MaxLess2 = -1;
                    if (MaxLess3 > MaxLess4)
                        MaxLess4 = -1;
                    if (MaxLess3 > MaxLess5)
                        MaxLess5 = -1;
                    if (MaxLess3 > MaxLess6)
                        MaxLess6 = -1;
                    if (MaxLess3 > MaxLess7)
                        MaxLess7 = -1;
                    if (AStarGreedyi == 1)
                    {
                        OutputHeuristic(Order);
                        //Set Table and Heuristic Value and Syntax.
                        Object On = new Object();
                        lock (On)
                        {
                            var ah4 = Task.Factory.StartNew(() => SaveBeginEndLocation(i, j, k, Kind));
                            ah4.Wait();
                            ah4.Dispose();

                            int[,] Th = TableHeuristic;
                            var ah5 = Task.Factory.StartNew(() => SaveTableHeuristic(i, j, k, Kind, ref Th));
                            ah5.Wait();
                            ah5.Dispose();
                            TableHeuristic = Th;

                            int le = Less;
                            AAA = AA;
                            var ah6 = Task.Factory.StartNew(() => SaveLess(i, j, k, Kind, ref le, AAA, Order));
                            ah6.Wait();
                            ah6.Dispose();
                            Less = le;
                            AA = AAA;
                        }
                        Act = true;
                        StringHeuristics(3, 3, AA, Do, HoursesOnTable[i].WinOcuuredatChiled, HoursesOnTable[i].LoseOcuuredatChiled);
                    }
                }
            }
            else if (Kind == 4)
            {
                bool ac = false;
                bool AAA = AA;
                int Le = Less;
                int Havk = HaveKilled;
                var ah = Task.Factory.StartNew(() => ac = CastlesOnTable[i].CastleThinking[0].ReturnHeuristic(i, j, Order, AAA, ref Havk) > Le);
                ah.Wait();
                ah.Dispose();
                AA = AAA;
                Less = Le;
                HaveKilled = Havk;
                if (ac)
                {
                    Object O = new Object();
                    lock (O)
                    {

                    }
                    //retrive table of current Heuristic.
                    //retrive table of current Heuristic.
                    int[,] TableS = CastlesOnTable[i].CastleThinking[k].TableListCastle[j];
                    //checked for Legal Movments ArgumentOutOfRangeException curnt game.
                    if (DynamicAStarGreedytPrograming && !CurrentTableHeuristic && AStarGreedyi == 1)
                    {
                        if (!IsEnemyThingsinStable(CloneATable(TableS), AllDraw.TableListAction[AllDraw.TableListAction.Count - 1], AllDraw.OrderPlate))
                        {
                            //if (Order == 1)

                            //else

                            return true;
                        }

                    }
                    //When there is not Penalty regard mechanism.
                    var ah1 = Task.Factory.StartNew(() => ac = CheckeHuristci(CloneATable(TableS), Order, i, j, k));
                    ah1.Wait();
                    ah1.Dispose();
                    if (ac)
                        return true;

                    var ah2 = Task.Factory.StartNew(() => InitiateVars(i, j, k, Kind));
                    ah2.Wait();
                    ah2.Dispose();

                    AAA = AA;
                    Havk = HaveKilled;
                    var ah3 = Task.Factory.StartNew(() => MaxLess4 = CastlesOnTable[RW4].CastleThinking[CL4].ReturnHeuristic(i, j, Order, AAA, ref Havk));
                    ah3.Wait();
                    ah3.Dispose();
                    AA = AAA;
                    HaveKilled = Havk;

                    if (ThinkingRefrigtzChessPortable.IsAtLeastOneKillerAtDraw)
                    {
                        if ((!KiilledForce(ref HaveKilled)) && (HaveKilled < 0))
                            return true;
                    }
                    if (!KillerForce(ref HaveKilled))
                        return true;
                    if (MaxLess4 > MaxLess1)
                        MaxLess1 = -1;
                    if (MaxLess4 > MaxLess2)
                        MaxLess2 = -1;
                    if (MaxLess4 > MaxLess3)
                        MaxLess3 = -1;
                    if (MaxLess4 > MaxLess5)
                        MaxLess5 = -1;
                    if (MaxLess4 > MaxLess6)
                        MaxLess6 = -1;
                    if (MaxLess4 > MaxLess7)
                        MaxLess7 = -1;

                    if (AStarGreedyi == 1)
                    {
                        OutputHeuristic(Order);
                        //Set Table and Heuristic Value and Syntax.
                        Object On = new Object();
                        lock (On)
                        {
                            var ah4 = Task.Factory.StartNew(() => SaveBeginEndLocation(i, j, k, Kind));
                            ah4.Wait();
                            ah4.Dispose();

                            int[,] Th = TableHeuristic;
                            var ah5 = Task.Factory.StartNew(() => SaveTableHeuristic(i, j, k, Kind, ref Th));
                            ah5.Wait();
                            ah5.Dispose();
                            TableHeuristic = Th;

                            int le = Less;
                            AAA = AA;
                            var ah6 = Task.Factory.StartNew(() => SaveLess(i, j, k, Kind, ref le, AAA, Order));
                            ah6.Wait();
                            ah6.Dispose();
                            Less = le;
                            AA = AAA;
                        }
                        Act = true;
                        StringHeuristics(4, 3, AA, Do, CastlesOnTable[i].WinOcuuredatChiled, CastlesOnTable[i].LoseOcuuredatChiled);
                    }
                }
                else//Set Table and Heuristic Value and Syntax.
                {
                }
            }
            else if (Kind == 5)
            {
                bool ac = false;
                bool AAA = AA;
                int Le = Less;
                int Havk = HaveKilled;
                var ah = Task.Factory.StartNew(() => ac = MinisterOnTable[i].MinisterThinking[0].ReturnHeuristic(i, j, Order, AAA, ref Havk) > Le);
                ah.Wait();
                ah.Dispose();
                AA = AAA;
                Less = Le;
                HaveKilled = Havk;
                if (ac)
                {
                    Object O = new Object();
                    lock (O)
                    {

                    }
                    //retrive table of current Heuristic.
                    //retrive table of current Heuristic.
                    int[,] TableS = MinisterOnTable[i].MinisterThinking[k].TableListMinister[j];
                    //checked for Legal Movments ArgumentOutOfRangeException curnt game.
                    if (DynamicAStarGreedytPrograming && !CurrentTableHeuristic && AStarGreedyi == 1)
                    {
                        if (!IsEnemyThingsinStable(CloneATable(TableS), AllDraw.TableListAction[AllDraw.TableListAction.Count - 1], AllDraw.OrderPlate))
                        {
                            //if (Order == 1)

                            //else 

                            return true;
                        }
                    }
                    //When there is not Penalty regard mechanism.
                    var ah1 = Task.Factory.StartNew(() => ac = CheckeHuristci(CloneATable(TableS), Order, i, j, k));
                    ah1.Wait();
                    ah1.Dispose();
                    if (ac)
                        return true;

                    var ah2 = Task.Factory.StartNew(() => InitiateVars(i, j, k, Kind));
                    ah2.Wait();
                    ah2.Dispose();

                    AAA = AA;
                    Havk = HaveKilled;
                    var ah3 = Task.Factory.StartNew(() => MaxLess5 = MinisterOnTable[RW5].MinisterThinking[CL5].ReturnHeuristic(i, j, Order, AAA, ref Havk));
                    ah3.Wait();
                    ah3.Dispose();
                    AA = AAA;
                    HaveKilled = Havk;

                    if (ThinkingRefrigtzChessPortable.IsAtLeastOneKillerAtDraw)
                    {
                        if ((!KiilledForce(ref HaveKilled)) && (HaveKilled < 0))
                            return true;
                    }
                    if (!KillerForce(ref HaveKilled))
                        return true;

                    if (MaxLess5 > MaxLess1)
                        MaxLess1 = -1;
                    if (MaxLess5 > MaxLess2)
                        MaxLess2 = -1;
                    if (MaxLess5 > MaxLess3)
                        MaxLess3 = -1;
                    if (MaxLess5 > MaxLess4)
                        MaxLess4 = -1;
                    if (MaxLess5 > MaxLess6)
                        MaxLess6 = -1;
                    if (MaxLess5 > MaxLess7)
                        MaxLess7 = -1;

                    if (AStarGreedyi == 1)
                    {
                        OutputHeuristic(Order);
                        //Set Table and Heuristic Value and Syntax.
                        Object On = new Object();
                        lock (On)
                        {
                            var ah4 = Task.Factory.StartNew(() => SaveBeginEndLocation(i, j, k, Kind));
                            ah4.Wait();
                            ah4.Dispose();

                            int[,] Th = TableHeuristic;
                            var ah5 = Task.Factory.StartNew(() => SaveTableHeuristic(i, j, k, Kind, ref Th));
                            ah5.Wait();
                            ah5.Dispose();
                            TableHeuristic = Th;

                            int le = Less;
                            AAA = AA;
                            var ah6 = Task.Factory.StartNew(() => SaveLess(i, j, k, Kind, ref le, AAA, Order));
                            ah6.Wait();
                            ah6.Dispose();
                            Less = le;
                            AA = AAA;
                        }
                        Act = true;
                        StringHeuristics(5, 3, AA, Do, MinisterOnTable[i].WinOcuuredatChiled, MinisterOnTable[i].LoseOcuuredatChiled);
                    }
                }
            }
            else if (Kind == 6)
            {
                bool ac = false;
                bool AAA = AA;
                int Le = Less;
                int Havk = HaveKilled;
                var ah = Task.Factory.StartNew(() => ac = KingOnTable[i].KingThinking[0].ReturnHeuristic(i, j, Order, AAA, ref Havk) > Le);
                ah.Wait();
                ah.Dispose();
                AA = AAA;
                Less = Le;
                HaveKilled = Havk;
                if (ac)
                {
                    Object OO = new Object();
                    lock (OO)
                    {

                    }
                    //retrive table of current Heuristic.
                    //retrive table of current Heuristic.
                    int[,] TableS = KingOnTable[i].KingThinking[k].TableListKing[j];
                    //checked for Legal Movments ArgumentOutOfRangeException curnt game.
                    if (DynamicAStarGreedytPrograming && !CurrentTableHeuristic && AStarGreedyi == 1)
                    {
                        if (!IsEnemyThingsinStable(CloneATable(TableS), AllDraw.TableListAction[AllDraw.TableListAction.Count - 1], AllDraw.OrderPlate))
                        {
                            //if (Order == 1)

                            //else

                            return true;
                        }
                    }
                    //When there is not Penalty regard mechanism.
                    var ah1 = Task.Factory.StartNew(() => ac = CheckeHuristci(CloneATable(TableS), Order, i, j, k));
                    ah1.Wait();
                    ah1.Dispose();
                    if (ac)
                        return true;

                    var ah2 = Task.Factory.StartNew(() => InitiateVars(i, j, k, Kind));
                    ah2.Wait();
                    ah2.Dispose();

                    AAA = AA;
                    Havk = HaveKilled;
                    var ah3 = Task.Factory.StartNew(() => MaxLess6 = KingOnTable[RW6].KingThinking[CL6].ReturnHeuristic(i, j, Order, AAA, ref Havk));
                    ah3.Wait();
                    ah3.Dispose();
                    AA = AAA;
                    HaveKilled = Havk;

                    if (ThinkingRefrigtzChessPortable.IsAtLeastOneKillerAtDraw)
                    {
                        if ((!KiilledForce(ref HaveKilled)) && (HaveKilled < 0))
                            return true;
                    }
                    if (!KillerForce(ref HaveKilled))
                        return true;
                    if (MaxLess6 > MaxLess1)
                        MaxLess1 = -1;
                    if (MaxLess6 > MaxLess2)
                        MaxLess2 = -1;
                    if (MaxLess6 > MaxLess3)
                        MaxLess3 = -1;
                    if (MaxLess6 > MaxLess4)
                        MaxLess4 = -1;
                    if (MaxLess6 > MaxLess5)
                        MaxLess5 = -1;
                    if (MaxLess6 > MaxLess7)
                        MaxLess7 = -1;

                    if (AStarGreedyi == 1)
                    {
                        OutputHeuristic(Order);
                        //Set Table and Heuristic Value and Syntax.
                        Object On = new Object();
                        lock (On)
                        {
                            var ah4 = Task.Factory.StartNew(() => SaveBeginEndLocation(i, j, k, Kind));
                            ah4.Wait();
                            ah4.Dispose();

                            int[,] Th = TableHeuristic;
                            var ah5 = Task.Factory.StartNew(() => SaveTableHeuristic(i, j, k, Kind, ref Th));
                            ah5.Wait();
                            ah5.Dispose();
                            TableHeuristic = Th;

                            int le = Less;
                            AAA = AA;
                            var ah6 = Task.Factory.StartNew(() => SaveLess(i, j, k, Kind, ref le, AAA, Order));
                            ah6.Wait();
                            ah6.Dispose();
                            Less = le;
                            AA = AAA;
                        }
                        Act = true;
                        StringHeuristics(6, 3, AA, Do, KingOnTable[i].WinOcuuredatChiled, KingOnTable[i].LoseOcuuredatChiled);
                    }

                }
                else//Set Table and Heuristic Value and Syntax.
                {
                }
            }
            else if (Kind == 7 || Kind == -7)
            {
                bool ac = false;
                bool AAA = AA;
                int Le = Less;
                int Havk = HaveKilled;
                var ah = Task.Factory.StartNew(() => ac = CastlingOnTable[i].CastlingThinking[0].ReturnHeuristic(i, j, Order, AAA, ref Havk) > Le);
                ah.Wait();
                ah.Dispose();
                AA = AAA;
                Less = Le;
                HaveKilled = Havk;
                if (ac)
                {
                    Object OO = new Object();
                    lock (OO)
                    {

                    }
                    //retrive table of current Heuristic.
                    //retrive table of current Heuristic.
                    int[,] TableS = CastlingOnTable[i].CastlingThinking[k].TableListCastling[j];
                    //checked for Legal Movments ArgumentOutOfRangeException curnt game.
                    if (DynamicAStarGreedytPrograming && !CurrentTableHeuristic && AStarGreedyi == 1)
                    {
                        if (!IsEnemyThingsinStable(CloneATable(TableS), AllDraw.TableListAction[AllDraw.TableListAction.Count - 1], AllDraw.OrderPlate))
                        {
                            //if (Order == 1)

                            //else

                            return true;
                        }
                    }
                    //When there is not Penalty regard mechanism.
                    var ah1 = Task.Factory.StartNew(() => ac = CheckeHuristci(CloneATable(TableS), Order, i, j, k));
                    ah1.Wait();
                    ah1.Dispose();
                    if (ac)
                        return true;

                    var ah2 = Task.Factory.StartNew(() => InitiateVars(i, j, k, Kind));
                    ah2.Wait();
                    ah2.Dispose();

                    AAA = AA;
                    Havk = HaveKilled;
                    var ah3 = Task.Factory.StartNew(() => MaxLess7 = CastlingOnTable[RW7].CastlingThinking[CL7].ReturnHeuristic(i, j, Order, AAA, ref Havk));
                    ah3.Wait();
                    ah3.Dispose();
                    AA = AAA;
                    HaveKilled = Havk;

                    if (ThinkingRefrigtzChessPortable.IsAtLeastOneKillerAtDraw)
                    {
                        if ((!KiilledForce(ref HaveKilled)) && (HaveKilled < 0))
                            return true;
                    }
                    if (!KillerForce(ref HaveKilled))
                        return true;
                    if (MaxLess7 > MaxLess1)
                        MaxLess1 = -1;
                    if (MaxLess7 > MaxLess2)
                        MaxLess2 = -1;
                    if (MaxLess7 > MaxLess3)
                        MaxLess3 = -1;
                    if (MaxLess7 > MaxLess4)
                        MaxLess4 = -1;
                    if (MaxLess7 > MaxLess5)
                        MaxLess5 = -1;
                    if (MaxLess7 > MaxLess5)
                        MaxLess6 = -1;

                    if (AStarGreedyi == 1)
                    {
                        OutputHeuristic(Order);
                        //Set Table and Heuristic Value and Syntax.
                        Object On = new Object();
                        lock (On)
                        {
                            var ah4 = Task.Factory.StartNew(() => SaveBeginEndLocation(i, j, k, Kind));
                            ah4.Wait();
                            ah4.Dispose();

                            int[,] Th = TableHeuristic;
                            var ah5 = Task.Factory.StartNew(() => SaveTableHeuristic(i, j, k, Kind, ref Th));
                            ah5.Wait();
                            ah5.Dispose();
                            TableHeuristic = Th;

                            int le = Less;
                            AAA = AA;
                            var ah6 = Task.Factory.StartNew(() => SaveLess(i, j, k, Kind, ref le, AAA, Order));
                            ah6.Wait();
                            ah6.Dispose();
                            Less = le;
                            AA = AAA;
                        }
                        Act = true;
                        StringHeuristics(7, 3, AA, Do, CastlingOnTable[i].WinOcuuredatChiled, CastlingOnTable[i].LoseOcuuredatChiled);
                    }

                }
                else//Set Table and Heuristic Value and Syntax.
                {
                }
            }


            return continued;
        }
        //determined verified victom occured
        bool KiilledForce(ref int HaveKiller)
        {
            if (ThinkingRefrigtzChessPortable.IsAtLeastOneKillerAtDraw)
            {
                if (HaveKiller > 0)
                {
                    HaveKiller = 0;
                    return true;
                }
            }
            return false;
        }
        //detrmined verfied ingured occured
        bool KillerForce(ref int HaveKiller)
        {
            bool s = ((ThinkingRefrigtzChessPortable.IsAtLeastOneKillerAtDraw) || (!(HaveKiller > 0)));
            HaveKiller = 0;
            return s;
        }
        //determine when there is lose or checked self
        bool Lose(int Kind, int i, int j, int Order)
        {
            bool Is = false;
            //HarasAlphaBeta(i, j, Kind);
            if (Kind == 1)
            {

                if ((SolderesOnTable[i].SoldierThinking[0].LoseChiled[j] <= -1 || SolderesOnTable[i].SoldierThinking[0].LoseChiled[j] <= -2 || SolderesOnTable[i].SoldierThinking[0].LoseChiled[j] <= -3) && UniqueCapableMoveIsTruSup(Kind, Order, i, j) != -1)
                    return true;
                if (!AllowedSupTrue)
                {
                    if ((SolderesOnTable[i].LoseOcuuredatChiled[0] <= -1 || SolderesOnTable[i].LoseOcuuredatChiled[0] <= -2 || SolderesOnTable[i].LoseOcuuredatChiled[0] <= -3) && UniqueCapableMoveIsTruSup(Kind, Order, i, j) != -1)
                        return true;
                }
            }
            else
        if (Kind == 2)
            {

                if ((ElephantOnTable[i].ElefantThinking[0].LoseChiled[j] <= -1 || ElephantOnTable[i].ElefantThinking[0].LoseChiled[j] <= -2 || ElephantOnTable[i].ElefantThinking[0].LoseChiled[j] <= -3) && UniqueCapableMoveIsTruSup(Kind, Order, i, j) != -1)
                    return true;

                if (!AllowedSupTrue)
                {
                    if ((ElephantOnTable[i].LoseOcuuredatChiled[0] <= -1 || ElephantOnTable[i].LoseOcuuredatChiled[0] <= -2 || ElephantOnTable[i].LoseOcuuredatChiled[0] <= -3) && UniqueCapableMoveIsTruSup(Kind, Order, i, j) != -1)
                        return true;
                }
            }
            else
        if (Kind == 3)
            {

                if ((HoursesOnTable[i].HourseThinking[0].LoseChiled[j] <= -1 || HoursesOnTable[i].HourseThinking[0].LoseChiled[j] <= -2 || HoursesOnTable[i].HourseThinking[0].LoseChiled[j] <= -3) && UniqueCapableMoveIsTruSup(Kind, Order, i, j) != -1)
                    return true;

                if (!AllowedSupTrue)
                {
                    if ((HoursesOnTable[i].LoseOcuuredatChiled[0] <= -1 || HoursesOnTable[i].LoseOcuuredatChiled[0] <= -2 || HoursesOnTable[i].LoseOcuuredatChiled[0] <= -3) && UniqueCapableMoveIsTruSup(Kind, Order, i, j) != -1)
                        return true;
                }
            }
            else
        if (Kind == 4)
            {

                if ((CastlesOnTable[i].CastleThinking[0].LoseChiled[j] <= -1 || CastlesOnTable[i].CastleThinking[0].LoseChiled[j] <= -2 || CastlesOnTable[i].CastleThinking[0].LoseChiled[j] <= -3) && UniqueCapableMoveIsTruSup(Kind, Order, i, j) != -1)
                    return true;

                if (!AllowedSupTrue)
                {
                    if ((CastlesOnTable[i].LoseOcuuredatChiled[0] <= -1 || CastlesOnTable[i].LoseOcuuredatChiled[0] <= -2 || CastlesOnTable[i].LoseOcuuredatChiled[0] <= -3) && UniqueCapableMoveIsTruSup(Kind, Order, i, j) != -1)
                        return true;
                }
            }
            else
        if (Kind == 5)
            {

                if ((MinisterOnTable[i].MinisterThinking[0].LoseChiled[j] <= -1 || MinisterOnTable[i].MinisterThinking[0].LoseChiled[j] <= -2 || MinisterOnTable[i].MinisterThinking[0].LoseChiled[j] <= -3) && UniqueCapableMoveIsTruSup(Kind, Order, i, j) != -1)
                    return true;
                if (!AllowedSupTrue)
                {
                    if ((MinisterOnTable[i].LoseOcuuredatChiled[0] <= -1 || MinisterOnTable[i].LoseOcuuredatChiled[0] <= -2 || MinisterOnTable[i].LoseOcuuredatChiled[0] <= -3) && UniqueCapableMoveIsTruSup(Kind, Order, i, j) != -1)
                        return true;
                }
            }
            else
        if (Kind == 6)
            {

                if ((KingOnTable[i].KingThinking[0].LoseChiled[j] <= -1 || KingOnTable[i].KingThinking[0].LoseChiled[j] <= -2 || KingOnTable[i].KingThinking[0].LoseChiled[j] <= -3) && UniqueCapableMoveIsTruSup(Kind, Order, i, j) != -1)
                    return true;

                if (!AllowedSupTrue)
                {
                    if ((KingOnTable[i].LoseOcuuredatChiled[0] <= -1 || KingOnTable[i].LoseOcuuredatChiled[0] <= -2 || KingOnTable[i].LoseOcuuredatChiled[0] <= -3) && UniqueCapableMoveIsTruSup(Kind, Order, i, j) != -1)
                        return true;
                }
            }
            else
       if (Kind == 7 || Kind == -7)
            {

                if ((CastlingOnTable[i].CastlingThinking[0].LoseChiled[j] <= -1 || CastlingOnTable[i].CastlingThinking[0].LoseChiled[j] <= -2 || CastlingOnTable[i].CastlingThinking[0].LoseChiled[j] <= -3) && UniqueCapableMoveIsTruSup(Kind, Order, i, j) != -1)
                    return true;

                if (!AllowedSupTrue)
                {
                    if ((CastlingOnTable[i].LoseOcuuredatChiled[0] <= -1 || CastlingOnTable[i].LoseOcuuredatChiled[0] <= -2 || CastlingOnTable[i].LoseOcuuredatChiled[0] <= -3) && UniqueCapableMoveIsTruSup(Kind, Order, i, j) != -1)
                        return true;
                }
            }
            return Is;
        }
        bool WinReturnValue(int Kind, int i, int j)
        {
            bool Is = false;
            if (Kind == 1)
            {



                bool B = SolderesOnTable[i].WinOcuuredatChiled >= 1 || SolderesOnTable[i].WinOcuuredatChiled >= 2 || SolderesOnTable[i].WinOcuuredatChiled >= 3;
                Is = B;
            }
            else
      if (Kind == 2)
            {



                bool B = ElephantOnTable[i].WinOcuuredatChiled >= 1 || ElephantOnTable[i].WinOcuuredatChiled >= 2 || ElephantOnTable[i].WinOcuuredatChiled >= 3;
                Is = B;
            }
            else
      if (Kind == 3)
            {



                bool B = HoursesOnTable[i].WinOcuuredatChiled >= 1 || HoursesOnTable[i].WinOcuuredatChiled >= 2 || HoursesOnTable[i].WinOcuuredatChiled >= 3;
                Is = B;
            }
            else
      if (Kind == 4)
            {



                bool B = CastlesOnTable[i].WinOcuuredatChiled >= 1 || CastlesOnTable[i].WinOcuuredatChiled >= 2 || CastlesOnTable[i].WinOcuuredatChiled >= 3;
                Is = B;
            }
            else
      if (Kind == 5)
            {



                bool B = MinisterOnTable[i].WinOcuuredatChiled >= 1 || MinisterOnTable[i].WinOcuuredatChiled >= 2 || MinisterOnTable[i].WinOcuuredatChiled >= 3;
                Is = B;
            }
            else
      if (Kind == 6)
            {



                bool B = KingOnTable[i].WinOcuuredatChiled >= 1 || KingOnTable[i].WinOcuuredatChiled >= 2 || KingOnTable[i].WinOcuuredatChiled >= 3;
                Is = B;
            }
            else
       if (Kind == 7 || Kind == -7)
            {



                bool B = CastlingOnTable[i].WinOcuuredatChiled >= 1 || CastlingOnTable[i].WinOcuuredatChiled >= 2 || CastlingOnTable[i].WinOcuuredatChiled >= 3;
                Is = B;
            }
            return Is;
        }
        bool WinPerfromeRegardMethod(int Kind, int i, int j)
        {
            bool Is = false;
            if (Kind == 1)
            {
                bool A = false;

                A = A || SolderesOnTable[i].SoldierThinking[0].WinChiled[j] >= 1 || SolderesOnTable[i].SoldierThinking[0].WinChiled[j] >= 2 || SolderesOnTable[i].SoldierThinking[0].WinChiled[j] >= 3;

                Is = A;
            }
            else
    if (Kind == 2)
            {
                bool A = false;

                A = A || ElephantOnTable[i].ElefantThinking[0].WinChiled[j] >= 1 || ElephantOnTable[i].ElefantThinking[0].WinChiled[j] >= 2 || ElephantOnTable[i].ElefantThinking[0].WinChiled[j] >= 3;

                Is = A;

            }
            else
    if (Kind == 3)
            {
                bool A = false;

                A = A || HoursesOnTable[i].HourseThinking[0].WinChiled[j] >= 1 || HoursesOnTable[i].HourseThinking[0].WinChiled[j] >= 2 || HoursesOnTable[i].HourseThinking[0].WinChiled[j] >= 3;

                Is = A;

            }
            else
    if (Kind == 4)
            {
                bool A = false;

                A = A || CastlesOnTable[i].CastleThinking[0].WinChiled[j] >= 1 || CastlesOnTable[i].CastleThinking[0].WinChiled[j] >= 2 || CastlesOnTable[i].CastleThinking[0].WinChiled[j] >= 3;

                Is = A;

            }
            else
    if (Kind == 5)
            {
                bool A = false;

                A = A || MinisterOnTable[i].MinisterThinking[0].WinChiled[j] >= 1 || MinisterOnTable[i].MinisterThinking[0].WinChiled[j] >= 2 || MinisterOnTable[i].MinisterThinking[0].WinChiled[j] >= 3;

                Is = A;

            }
            else
    if (Kind == 6)
            {
                bool A = false;

                A = A || KingOnTable[i].KingThinking[0].WinChiled[j] >= 1 || KingOnTable[i].KingThinking[0].WinChiled[j] >= 2 || KingOnTable[i].KingThinking[0].WinChiled[j] >= 3;

                Is = A;

            }
            else
    if (Kind == 7 || Kind == -7)
            {
                bool A = false;

                A = A || CastlingOnTable[i].CastlingThinking[0].WinChiled[j] >= 1 || CastlingOnTable[i].CastlingThinking[0].WinChiled[j] >= 2 || CastlingOnTable[i].CastlingThinking[0].WinChiled[j] >= 3;

                Is = A;

            }
            return Is;
        }
        //soldier Heuristic
        int[,] HeuristicAStarGreadySearchSoldier(ref int[,] TableHeuristic, int i, int AStarGreedyi, Color a, int Order, bool CurrentTableHeuristic, ref bool Act)
        {


            Object a1 = new Object();
            lock (a1)
            {

                int j;
                List<int> Founded = new List<int>();
                int DummyOrder = Order;
                int DummyCurrentOrder = ChessRules.CurrentOrder;
                bool AA = false;
                int Do = 0;

                //For Every Soldier Movments AStarGreedy.
                for (int k = 0; k < AllDraw.SodierMovments; k++)
                //When There is an Movment in such situation.
                {
                    for (j = 0; SolderesOnTable != null && SolderesOnTable[i] != null && SolderesOnTable != null && SolderesOnTable[i] != null && SolderesOnTable[i].SoldierThinking != null && SolderesOnTable[i].SoldierThinking[k] != null && j < SolderesOnTable[i].SoldierThinking[k].TableListSolder.Count; j++)
                    {
                        bool ac = false;
                        var ah1 = Task.Factory.StartNew(() => ac = IsSupHuTrue(i, j, 0, 1));
                        ah1.Wait();
                        ah1.Dispose();
                        if (ac)
                            continue;
                        {
                            //For Penalty Reagrad Mechanisam of Current Check CheckMate Current Movments.
                            //if (AllDraw.OrderPlate == Order && AStarGreedyi == 1 //&& UsePenaltyRegardMechnisamT
                            //)
                            if (SolderesOnTable[i].SoldierThinking[k].PenaltyRegardListSolder[j].IsPenaltyAction() == 0)
                                continue;
                            int CDummy = ChessRules.CurrentOrder;
                            int COrder = Order;
                            if (SolderesOnTable[i].SoldierThinking[k].AStarGreedy.Count > j && SolderesOnTable[i].SoldierThinking[k].AStarGreedy[j] != null)
                            {
                                bool AAAA = AA;
                                var ah = Task.Factory.StartNew(() => SolderesOnTable[i].SoldierThinking[k].AStarGreedy[j].IsFoundOfLeafDepenOfKindhaveVictory(1, ref AAAA, Order * -1));
                                ah.Wait();
                                ah.Dispose();
                                AA = AAAA;
                            }
                            ChessRules.CurrentOrder *= -1;
                            Order *= -1;
                            Do = 0;

                            StringHeuristics(1, 1, AA, Do, SolderesOnTable[i].WinOcuuredatChiled, SolderesOnTable[i].LoseOcuuredatChiled);
                            /* var ah3 = Task.Factory.StartNew(() => ac = Lose(1, i, j, Order));
                           ah3.Wait();
                           ah3.Dispose();
                           if (ac)
                               continue;*/
                            Order = COrder;
                            ChessRules.CurrentOrder = CDummy;
                            //if (AllDraw.OrderPlate == Order && AStarGreedyi == 1 //&& UsePenaltyRegardMechnisamT
                            //)

                            bool Ac = Act;
                            int[,] Ta = TableHeuristic;
                            bool AAA = AA;
                            int D = Do;
                            var ah4 = Task.Factory.StartNew(() => ac = HeuristicRegardSection(i, j, k, ref Ac, ref Ta, ref AAA, a, 1, ref D, AStarGreedyi, Order));
                            ah4.Wait();
                            ah4.Dispose();
                            Act = ac;
                            TableHeuristic = Ta;
                            AA = AAA;
                            if (ac)
                                continue;
                            //When There is No Movments in Such Order Enemy continue.
                            Object ol = new Object();
                            lock (ol)
                            {
                                if (Order != AllDraw.OrderPlateDraw)
                                    if (SolderesOnTable[i].SoldierThinking[0].ReturnHeuristic(i, j, Order, AA, ref HaveKilled) > Less)
                                        continue;
                                //When There is greater Heuristic Movments.
                                Ac = Act;
                                Ta = TableHeuristic;
                                bool CuTH = CurrentTableHeuristic;
                                AAA = AA;
                                D = Do;
                                var ah5 = Task.Factory.StartNew(() => ac = HeuristicMainBody(i, j, k, ref Ac, ref Ta, ref CuTH, ref AAA, a, 1, ref D, AStarGreedyi, Order));
                                ah5.Wait();
                                ah5.Dispose();
                                Act = ac;
                                TableHeuristic = Ta;
                                CurrentTableHeuristic = CuTH;
                                AA = AAA;
                                if (ac) continue;
                            }
                        }
                    }
                }

                Order = DummyOrder;
                ChessRules.CurrentOrder = DummyCurrentOrder;

                return TableHeuristic;
            }
        }
        //Gray section of soldier Heuristic
        int[,] HeuristicAStarGreadySearchSoldierGray(ref int[,] TableHeuristic, int AStarGreedyi, Color a, int Order, bool CurrentTableHeuristic, ref bool Act)
        {

            Object a1 = new Object();
            lock (a1)
            {
                if (SodierMidle != 0)
                {
                    for (var i = 0; i < SodierMidle; i++)
                    {
                        int[,] Ta = TableHeuristic;
                        bool Ac = Act;
                        var ah = Task.Factory.StartNew(() => Ta = HeuristicAStarGreadySearchSoldier(ref Ta, i, AStarGreedyi, a, Order, CurrentTableHeuristic, ref Ac));
                        ah.Wait();
                        ah.Dispose();
                        Act = Ac;
                        TableHeuristic = Ta;

                    }
                }
                //else


                return TableHeuristic;
            }
        }
        //Brown section of soldier Heuristic
        int[,] HeuristicAStarGreadySearchSoldierBrown(ref int[,] TableHeuristic, int AStarGreedyi, Color a, int Order, bool CurrentTableHeuristic, ref bool Act)
        {

            Object a1 = new Object();
            lock (a1)
            {
                if (SodierMidle != SodierHigh)
                {
                    for (var i = SodierMidle; i < SodierHigh; i++)
                    {
                        int[,] Ta = TableHeuristic;
                        bool Ac = Act;
                        var ah = Task.Factory.StartNew(() => Ta = HeuristicAStarGreadySearchSoldier(ref Ta, i, AStarGreedyi, a, Order, CurrentTableHeuristic, ref Ac));
                        ah.Wait();
                        ah.Dispose();
                        Act = Ac;
                        TableHeuristic = Ta;

                    }
                }
                //else


                return TableHeuristic;
            }
        }
        //Gray section of elephant Heuristic
        int[,] HeuristicAStarGreadySearchElephantGray(ref int[,] TableHeuristic, int AStarGreedyi, Color a, int Order, bool CurrentTableHeuristic, ref bool Act)
        {

            Object a1 = new Object();
            lock (a1)
            {
                if (0 != ElefantMidle)
                {
                    //Do For Remaining Objects same as Soldeir Documentation.
                    for (var i = 0; i < ElefantMidle; i++)
                    {
                        int[,] Ta = TableHeuristic;
                        bool Ac = Act;
                        var ah = Task.Factory.StartNew(() => Ta = HeuristicAStarGreadySearchElephant(ref Ta, i, AStarGreedyi, a, Order, CurrentTableHeuristic, ref Ac));
                        ah.Wait();
                        ah.Dispose();
                        Act = Ac;
                        TableHeuristic = Ta;

                    }
                }
                //else


                return TableHeuristic;
            }
        }
        //Brown section of elephant Heuristic
        int[,] HeuristicAStarGreadySearchElephantBrown(ref int[,] TableHeuristic, int AStarGreedyi, Color a, int Order, bool CurrentTableHeuristic, ref bool Act)
        {

            Object a1 = new Object();
            lock (a1)
            {
                if (ElefantHigh != ElefantMidle)
                {
                    //Do For Remaining Objects same as Soldeir Documentation.
                    for (var i = ElefantMidle; i < ElefantHigh; i++)
                    {
                        int[,] Ta = TableHeuristic;
                        bool Ac = Act;
                        var ah = Task.Factory.StartNew(() => Ta = HeuristicAStarGreadySearchElephant(ref Ta, i, AStarGreedyi, a, Order, CurrentTableHeuristic, ref Ac));
                        ah.Wait();
                        ah.Dispose();
                        Act = Ac;
                        TableHeuristic = Ta;

                    }
                }
                //else


                return TableHeuristic;
            }
        }
        //main section of elephant Heuristic
        int[,] HeuristicAStarGreadySearchElephant(ref int[,] TableHeuristic, int i, int AStarGreedyi, Color a, int Order, bool CurrentTableHeuristic, ref bool Act)
        {

            Object a1 = new Object();
            lock (a1)
            {

                int j;
                List<int> Founded = new List<int>();
                int DummyOrder = Order;
                int DummyCurrentOrder = ChessRules.CurrentOrder;
                bool AA = false;
                int Do = 0;
                for (int k = 0; k < AllDraw.ElefantMovments; k++)
                {
                    for (j = 0; ElephantOnTable != null && ElephantOnTable[i] != null && ElephantOnTable != null && ElephantOnTable[i] != null && ElephantOnTable[i].ElefantThinking != null && ElephantOnTable[i].ElefantThinking[k] != null && j < ElephantOnTable[i].ElefantThinking[k].TableListElefant.Count; j++)
                    {
                        bool ac = false;
                        var ah1 = Task.Factory.StartNew(() => ac = IsSupHuTrue(i, j, 0, 2));
                        ah1.Wait();
                        ah1.Dispose();
                        if (ac)
                            continue;
                        {
                            //For Penalty Reagrad Mechanisam of Current Check CheckMate Current Movments.
                            //if (AllDraw.OrderPlate == Order && AStarGreedyi == 1 //&& UsePenaltyRegardMechnisamT
                            //)
                            if (ElephantOnTable[i].ElefantThinking[k].PenaltyRegardListElefant[j].IsPenaltyAction() == 0)
                                continue;
                            int CDummy = ChessRules.CurrentOrder;
                            int COrder = Order;
                            if (ElephantOnTable[i].ElefantThinking[0].AStarGreedy.Count > j && ElephantOnTable[i].ElefantThinking[0].AStarGreedy[j] != null)
                            {
                                bool AAAA = AA;
                                var ah = Task.Factory.StartNew(() => ElephantOnTable[i].ElefantThinking[0].AStarGreedy[j].IsFoundOfLeafDepenOfKindhaveVictory(1, ref AAAA, Order * -1));
                                ah.Wait();
                                ah.Dispose();
                                AA = AAAA;
                            }
                            ChessRules.CurrentOrder *= -1;
                            Order *= -1;
                            Do = 0;

                            StringHeuristics(2, 1, AA, Do, ElephantOnTable[i].WinOcuuredatChiled, ElephantOnTable[i].LoseOcuuredatChiled);
                            /* var ah3 = Task.Factory.StartNew(() => ac = Lose(2, i, j, Order));
                          ah3.Wait();
                          ah3.Dispose();
                          if (ac)
                              continue;*/
                            Order = COrder;
                            ChessRules.CurrentOrder = CDummy;
                            //if (AllDraw.OrderPlate == Order && AStarGreedyi == 1 //&& UsePenaltyRegardMechnisamT
                            //)
                            bool Ac = Act;
                            int[,] Ta = TableHeuristic;
                            bool AAA = AA;
                            int D = Do;
                            var ah4 = Task.Factory.StartNew(() => ac = HeuristicRegardSection(i, j, k, ref Ac, ref Ta, ref AAA, a, 2, ref D, AStarGreedyi, Order));
                            ah4.Wait();
                            ah4.Dispose();
                            Act = ac;
                            TableHeuristic = Ta;
                            AA = AAA;
                            if (ac)
                                continue;

                            Object ol = new Object();
                            lock (ol)
                            {
                                //When There is No Movments in Such Order Enemy continue.
                                if (Order != AllDraw.OrderPlateDraw)
                                    if (ElephantOnTable[i].ElefantThinking[0].ReturnHeuristic(i, j, Order, AA, ref HaveKilled) > Less)
                                        continue;
                                //When There is greater Heuristic Movments.
                                Ac = Act;
                                Ta = TableHeuristic;
                                bool CuTH = CurrentTableHeuristic;
                                AAA = AA;
                                D = Do;
                                var ah5 = Task.Factory.StartNew(() => ac = HeuristicMainBody(i, j, k, ref Ac, ref Ta, ref CuTH, ref AAA, a, 2, ref D, AStarGreedyi, Order));
                                ah5.Wait();
                                ah5.Dispose();
                                Act = ac;
                                TableHeuristic = Ta;
                                CurrentTableHeuristic = CuTH;
                                AA = AAA;
                                if (ac) continue;

                            }

                        }
                    }
                }
                Order = DummyOrder;
                ChessRules.CurrentOrder = DummyCurrentOrder;

                return TableHeuristic;
            }

        }
        //Gray section of hourse Heuristic
        int[,] HeuristicAStarGreadySearchHourseGray(ref int[,] TableHeuristic, int AStarGreedyi, Color a, int Order, bool CurrentTableHeuristic, ref bool Act)
        {

            Object a1 = new Object();
            lock (a1)
            {
                if (0 != HourseMidle)
                {
                    //For Every Soldeir
                    for (var i = 0; i < HourseMidle; i++)
                    {
                        int[,] Ta = TableHeuristic;
                        bool Ac = Act;
                        var ah = Task.Factory.StartNew(() => Ta = HeuristicAStarGreadySearchHourse(ref Ta, i, AStarGreedyi, a, Order, CurrentTableHeuristic, ref Ac));
                        ah.Wait();
                        ah.Dispose();
                        Act = Ac;
                        TableHeuristic = Ta;

                    }
                }
                // else


                return TableHeuristic;
            }
        }
        //Brown section of hourse Heuristic
        int[,] HeuristicAStarGreadySearchHourseBrown(ref int[,] TableHeuristic, int AStarGreedyi, Color a, int Order, bool CurrentTableHeuristic, ref bool Act)
        {

            Object a1 = new Object();
            lock (a1)
            {
                if (HourseHight != HourseMidle)
                {
                    //For Every Soldeir
                    for (var i = HourseMidle; i < HourseHight; i++)
                    {
                        int[,] Ta = TableHeuristic;
                        bool Ac = Act;
                        var ah = Task.Factory.StartNew(() => Ta = HeuristicAStarGreadySearchHourse(ref Ta, i, AStarGreedyi, a, Order, CurrentTableHeuristic, ref Ac));
                        ah.Wait();
                        ah.Dispose();
                        Act = Ac;
                        TableHeuristic = Ta;

                    }
                }
                //else


                return TableHeuristic;
            }
        }
        //main section of hourse Heuristic
        int[,] HeuristicAStarGreadySearchHourse(ref int[,] TableHeuristic, int i, int AStarGreedyi, Color a, int Order, bool CurrentTableHeuristic, ref bool Act)
        {

            Object a1 = new Object();
            lock (a1)
            {

                int j;
                List<int> Founded = new List<int>();
                int DummyOrder = Order;
                int DummyCurrentOrder = ChessRules.CurrentOrder;
                bool AA = false;
                int Do = 0;

                for (int k = 0; k < AllDraw.HourseMovments; k++)
                {
                    for (j = 0; HoursesOnTable != null && HoursesOnTable[i] != null && HoursesOnTable != null && HoursesOnTable[i] != null && HoursesOnTable[i].HourseThinking != null && HoursesOnTable[i].HourseThinking[k] != null && j < HoursesOnTable[i].HourseThinking[k].TableListHourse.Count; j++)
                    {
                        bool ac = false;
                        var ah1 = Task.Factory.StartNew(() => ac = IsSupHuTrue(i, j, 0, 3));
                        ah1.Wait();
                        ah1.Dispose();
                        if (ac)
                            continue;
                        {
                            //For Penalty Reagrad Mechanisam of Current Check CheckMate Current Movments.
                            //if (AllDraw.OrderPlate == Order && AStarGreedyi == 1 //&& UsePenaltyRegardMechnisamT
                            //)
                            if (HoursesOnTable[i].HourseThinking[k].PenaltyRegardListHourse[j].IsPenaltyAction() == 0)
                                continue;
                            int CDummy = ChessRules.CurrentOrder;
                            int COrder = Order;
                            if (HoursesOnTable[i].HourseThinking[0].AStarGreedy.Count > j && HoursesOnTable[i].HourseThinking[0].AStarGreedy[j] != null)
                            {
                                bool AAAA = AA;
                                var ah = Task.Factory.StartNew(() => HoursesOnTable[i].HourseThinking[0].AStarGreedy[j].IsFoundOfLeafDepenOfKindhaveVictory(1, ref AAAA, Order * -1));
                                ah.Wait();
                                ah.Dispose();
                                AA = AAAA;
                            }
                            ChessRules.CurrentOrder *= -1;
                            Order *= -1;
                            Do = 0;
                            StringHeuristics(3, 1, AA, Do, HoursesOnTable[i].WinOcuuredatChiled, HoursesOnTable[i].LoseOcuuredatChiled);
                            /* var ah3 = Task.Factory.StartNew(() => ac = Lose(3, i, j, Order));
                        ah3.Wait();
                        ah3.Dispose();
                        if (ac)
                            continue;*/

                            Order = COrder;
                            ChessRules.CurrentOrder = CDummy;
                            //if (AllDraw.OrderPlate == Order && AStarGreedyi == 1 //&& UsePenaltyRegardMechnisamT
                            //)
                            bool Ac = Act;
                            int[,] Ta = TableHeuristic;
                            bool AAA = AA;
                            int D = Do;
                            var ah4 = Task.Factory.StartNew(() => ac = HeuristicRegardSection(i, j, k, ref Ac, ref Ta, ref AAA, a, 3, ref D, AStarGreedyi, Order));
                            ah4.Wait();
                            ah4.Dispose();
                            Act = ac;
                            TableHeuristic = Ta;
                            AA = AAA;
                            if (ac)
                                continue;
                            Object ol = new Object();
                            lock (ol)
                            {
                                //When There is No Movments in Such Order Enemy continue.
                                if (Order != AllDraw.OrderPlateDraw)
                                    if (HoursesOnTable[i].HourseThinking[0].ReturnHeuristic(i, j, Order, AA, ref HaveKilled) > Less)
                                        continue;
                                //When There is greater Heuristic Movments.
                                Ac = Act;
                                Ta = TableHeuristic;
                                bool CuTH = CurrentTableHeuristic;
                                AAA = AA;
                                D = Do;
                                var ah5 = Task.Factory.StartNew(() => ac = HeuristicMainBody(i, j, k, ref Ac, ref Ta, ref CuTH, ref AAA, a, 3, ref D, AStarGreedyi, Order));
                                ah5.Wait();
                                ah5.Dispose();
                                Act = ac;
                                TableHeuristic = Ta;
                                CurrentTableHeuristic = CuTH;
                                AA = AAA;
                                if (ac) continue;

                            }
                        }
                    }
                }
                Order = DummyOrder;
                ChessRules.CurrentOrder = DummyCurrentOrder;

                return TableHeuristic;
            }
        }
        //Gray section of Castle Heuristic
        int[,] HeuristicAStarGreadySearchCastleGray(ref int[,] TableHeuristic, int AStarGreedyi, Color a, int Order, bool CurrentTableHeuristic, ref bool Act)
        {

            Object O = new Object();
            lock (O)
            {
                if (0 != HourseMidle)
                {
                    for (var i = 0; i < CastleMidle; i++)
                    {
                        int[,] Ta = TableHeuristic;
                        bool Ac = Act;
                        var ah = Task.Factory.StartNew(() => Ta = HeuristicAStarGreadySearchCastle(ref Ta, i, AStarGreedyi, a, Order, CurrentTableHeuristic, ref Ac));
                        ah.Wait();
                        ah.Dispose();
                        Act = Ac;
                        TableHeuristic = Ta;

                    }
                }
                //else


                return TableHeuristic;
            }
        }
        //main Brown section of Castle Heuristic
        int[,] HeuristicAStarGreadySearchCastleBrown(ref int[,] TableHeuristic, int AStarGreedyi, Color a, int Order, bool CurrentTableHeuristic, ref bool Act)
        {

            Object O = new Object();
            lock (O)
            {

                if (CastleMidle != CastleHigh)
                {
                    for (var i = CastleMidle; i < CastleHigh; i++)
                    {
                        int[,] Ta = TableHeuristic;
                        bool Ac = Act;
                        var ah = Task.Factory.StartNew(() => Ta = HeuristicAStarGreadySearchCastle(ref Ta, i, AStarGreedyi, a, Order, CurrentTableHeuristic, ref Ac));
                        ah.Wait();
                        ah.Dispose();
                        Act = Ac;
                        TableHeuristic = Ta;

                    }
                }
                //else


                return TableHeuristic;
            }
        }
        //main section of Castle Heuristic
        int[,] HeuristicAStarGreadySearchCastle(ref int[,] TableHeuristic, int i, int AStarGreedyi, Color a, int Order, bool CurrentTableHeuristic, ref bool Act)
        {

            Object O1 = new Object();
            lock (O1)
            {


                int j;
                List<int> Founded = new List<int>();
                int DummyOrder = Order;
                int DummyCurrentOrder = ChessRules.CurrentOrder;
                bool AA = false;
                int Do = 0;
                for (int k = 0; k < AllDraw.CastleMovments; k++)
                {
                    for (j = 0; CastlesOnTable != null && CastlesOnTable[i] != null && CastlesOnTable != null && CastlesOnTable[i] != null && CastlesOnTable[i].CastleThinking != null && CastlesOnTable[i].CastleThinking[k] != null && j < CastlesOnTable[i].CastleThinking[k].TableListCastle.Count; j++)
                    {
                        bool ac = false;
                        var ah1 = Task.Factory.StartNew(() => ac = IsSupHuTrue(i, j, 0, 4));
                        ah1.Wait();
                        ah1.Dispose();
                        if (ac)
                            continue;
                        {
                            //For Penalty Reagrad Mechanisam of Current Check CheckMate Current Movments.
                            //if (AllDraw.OrderPlate == Order && AStarGreedyi == 1 //&& UsePenaltyRegardMechnisamT
                            //)
                            if (CastlesOnTable[i].CastleThinking[k].PenaltyRegardListCastle[j].IsPenaltyAction() == 0)
                                continue;
                            int CDummy = ChessRules.CurrentOrder;
                            int COrder = Order;
                            if (CastlesOnTable[i].CastleThinking[0].AStarGreedy.Count > j && CastlesOnTable[i].CastleThinking[0].AStarGreedy[j] != null)
                            {
                                bool AAAA = AA;
                                var ah = Task.Factory.StartNew(() => CastlesOnTable[i].CastleThinking[0].AStarGreedy[j].IsFoundOfLeafDepenOfKindhaveVictory(1, ref AAAA, Order * -1));
                                ah.Wait();
                                ah.Dispose();
                                AA = AAAA;
                            }
                            ChessRules.CurrentOrder *= -1;
                            Order *= -1;
                            Order = COrder;
                            StringHeuristics(4, 1, AA, Do, CastlesOnTable[i].WinOcuuredatChiled, CastlesOnTable[i].LoseOcuuredatChiled);
                            /* var ah3 = Task.Factory.StartNew(() => ac = Lose(4, i, j, Order));
                         ah3.Wait();
                         ah3.Dispose();
                         if (ac)
                             continue;*/
                            ChessRules.CurrentOrder = CDummy;
                            //if (AllDraw.OrderPlate == Order && AStarGreedyi == 1 //&& UsePenaltyRegardMechnisamT
                            //)

                            bool Ac = Act;
                            int[,] Ta = TableHeuristic;
                            bool AAA = AA;
                            int D = Do;
                            var ah4 = Task.Factory.StartNew(() => ac = HeuristicRegardSection(i, j, k, ref Ac, ref Ta, ref AAA, a, 4, ref D, AStarGreedyi, Order));
                            ah4.Wait();
                            ah4.Dispose();
                            Act = ac;
                            TableHeuristic = Ta;
                            AA = AAA;
                            if (ac)
                                continue;

                            Object ol = new Object();
                            lock (ol)
                            {
                                //When There is No Movments in Such Order Enemy continue.
                                if (Order != AllDraw.OrderPlateDraw)
                                    if (CastlesOnTable[i].CastleThinking[0].ReturnHeuristic(i, j, Order, AA, ref HaveKilled) > Less)
                                        continue;
                                //When There is greater Heuristic Movments.
                                Ac = Act;
                                Ta = TableHeuristic;
                                bool CuTH = CurrentTableHeuristic;
                                AAA = AA;
                                D = Do;
                                var ah5 = Task.Factory.StartNew(() => ac = HeuristicMainBody(i, j, k, ref Ac, ref Ta, ref CuTH, ref AAA, a, 4, ref D, AStarGreedyi, Order));
                                ah5.Wait();
                                ah5.Dispose();
                                Act = ac;
                                TableHeuristic = Ta;
                                CurrentTableHeuristic = CuTH;
                                AA = AAA;
                                if (ac)
                                    continue;
                            }
                        }
                    }

                }

                Order = DummyOrder;
                ChessRules.CurrentOrder = DummyCurrentOrder;

                return TableHeuristic;
            }
        }
        //main section of minister Heuristic
        int[,] HeuristicAStarGreadySearchMinsisterGray(ref int[,] TableHeuristic, int AStarGreedyi, Color a, int Order, bool CurrentTableHeuristic, ref bool Act)
        {

            Object O = new Object();
            lock (O)
            {
                if (0 != MinisterMidle)
                {
                    for (var i = 0; i < MinisterMidle; i++)
                    {
                        int[,] Ta = TableHeuristic;
                        bool Ac = Act;
                        var ah = Task.Factory.StartNew(() => Ta = HeuristicAStarGreadySearchMinsister(ref Ta, i, AStarGreedyi, a, Order, CurrentTableHeuristic, ref Ac));
                        ah.Wait();
                        ah.Dispose();
                        Act = Ac;
                        TableHeuristic = Ta;

                    }
                }
                //else


                return TableHeuristic;
            }
        }
        //Brown main section of minister Heuristic
        int[,] HeuristicAStarGreadySearchMinsisterBrown(ref int[,] TableHeuristic, int AStarGreedyi, Color a, int Order, bool CurrentTableHeuristic, ref bool Act)
        {

            Object O = new Object();
            lock (O)
            {
                if (MinisterHigh != MinisterMidle)
                {
                    for (var i = MinisterMidle; i < MinisterHigh; i++)
                    {
                        int[,] Ta = TableHeuristic;
                        bool Ac = Act;
                        var ah = Task.Factory.StartNew(() => Ta = HeuristicAStarGreadySearchMinsister(ref Ta, i, AStarGreedyi, a, Order, CurrentTableHeuristic, ref Ac));
                        ah.Wait();
                        ah.Dispose();
                        Act = Ac;
                        TableHeuristic = Ta;

                    }
                }
                //else


                return TableHeuristic;
            }
        }
        //main section of minister Heuristic
        int[,] HeuristicAStarGreadySearchMinsister(ref int[,] TableHeuristic, int i, int AStarGreedyi, Color a, int Order, bool CurrentTableHeuristic, ref bool Act)
        {

            Object O3 = new Object();
            lock (O3)
            {

                int j;
                List<int> Founded = new List<int>();
                int DummyOrder = Order;
                int DummyCurrentOrder = ChessRules.CurrentOrder;
                bool AA = false;
                int Do = 0;
                for (int k = 0; k < AllDraw.MinisterMovments; k++)
                {
                    for (j = 0; MinisterOnTable != null && MinisterOnTable[i] != null && MinisterOnTable != null && MinisterOnTable[i] != null && MinisterOnTable[i].MinisterThinking != null && MinisterOnTable[i].MinisterThinking[k] != null && j < MinisterOnTable[i].MinisterThinking[k].TableListMinister.Count; j++)
                    {
                        bool ac = false;
                        var ah1 = Task.Factory.StartNew(() => ac = IsSupHuTrue(i, j, 0, 5));
                        ah1.Wait();
                        ah1.Dispose();
                        if (ac)
                            continue;
                        {
                            //For Penalty Reagrad Mechanisam of Current Check CheckMate Current Movments.
                            //if (AllDraw.OrderPlate == Order && AStarGreedyi == 1 //&& UsePenaltyRegardMechnisamT
                            //)
                            if (MinisterOnTable[i].MinisterThinking[k].PenaltyRegardListMinister[j].IsPenaltyAction() == 0)
                                continue;
                            int CDummy = ChessRules.CurrentOrder;
                            int COrder = Order;
                            if (MinisterOnTable[i].MinisterThinking[0].AStarGreedy.Count > j && MinisterOnTable[i].MinisterThinking[0].AStarGreedy[j] != null)
                            {
                                bool AAAA = AA;
                                var ah = Task.Factory.StartNew(() => MinisterOnTable[i].MinisterThinking[0].AStarGreedy[j].IsFoundOfLeafDepenOfKindhaveVictory(1, ref AAAA, Order * -1));
                                ah.Wait();
                                ah.Dispose();
                                AA = AAAA;
                            }
                            ChessRules.CurrentOrder *= -1;
                            Order *= -1;
                            Do = 0;
                            StringHeuristics(5, 1, AA, Do, MinisterOnTable[i].WinOcuuredatChiled, MinisterOnTable[i].LoseOcuuredatChiled);
                            /* var ah3 = Task.Factory.StartNew(() => ac = Lose(5, i, j, Order));
                         ah3.Wait();
                         ah3.Dispose();
                         if (ac)
                             continue;*/
                            Order = COrder;
                            ChessRules.CurrentOrder = CDummy;
                            //if (AllDraw.OrderPlate == Order && AStarGreedyi == 1 //&& UsePenaltyRegardMechnisamT
                            //)

                            bool Ac = Act;
                            int[,] Ta = TableHeuristic;
                            bool AAA = AA;
                            int D = Do;
                            var ah4 = Task.Factory.StartNew(() => ac = HeuristicRegardSection(i, j, k, ref Ac, ref Ta, ref AAA, a, 5, ref D, AStarGreedyi, Order));
                            ah4.Wait();
                            ah4.Dispose();
                            Act = ac;
                            TableHeuristic = Ta;
                            AA = AAA;
                            if (ac)
                                continue;
                            Object ol = new Object();
                            lock (ol)
                            {
                                if (Order != AllDraw.OrderPlateDraw)
                                    if (MinisterOnTable[i].MinisterThinking[0].ReturnHeuristic(i, j, Order, AA, ref HaveKilled) > Less)
                                        continue;
                                Ac = Act;
                                Ta = TableHeuristic;
                                bool CuTH = CurrentTableHeuristic;
                                AAA = AA;
                                D = Do;
                                var ah5 = Task.Factory.StartNew(() => ac = HeuristicMainBody(i, j, k, ref Ac, ref Ta, ref CuTH, ref AAA, a, 5, ref D, AStarGreedyi, Order));
                                ah5.Wait();
                                ah5.Dispose();
                                Act = ac;
                                TableHeuristic = Ta;
                                CurrentTableHeuristic = CuTH;
                                AA = AAA;
                                if (ac) continue;
                            }
                        }
                    }

                }
                Order = DummyOrder;
                ChessRules.CurrentOrder = DummyCurrentOrder;

                return TableHeuristic;
            }
        }
        //main Gray section of king Heuristic
        int[,] HeuristicAStarGreadySearchKingGray(ref int[,] TableHeuristic, int AStarGreedyi, Color a, int Order, bool CurrentTableHeuristic, ref bool Act)
        {

            Object O = new Object();
            lock (O)
            {
                if (0 != KingMidle)
                {
                    for (var i = 0; i < KingMidle; i++)
                    {
                        int[,] Ta = TableHeuristic;
                        bool Ac = Act;
                        var ah = Task.Factory.StartNew(() => Ta = HeuristicAStarGreadySearchKing(ref Ta, i, AStarGreedyi, a, Order, CurrentTableHeuristic, ref Ac));
                        ah.Wait();
                        ah.Dispose();
                        Act = Ac;
                        TableHeuristic = Ta;

                    }
                }
                // else


                return TableHeuristic;
            }
        }
        int[,] HeuristicAStarGreadySearchCastlingGray(ref int[,] TableHeuristic, int AStarGreedyi, Color a, int Order, bool CurrentTableHeuristic, ref bool Act)
        {

            Object O = new Object();
            lock (O)
            {
                if (0 != 1)
                {
                    for (var i = 0; i < 1; i++)
                    {
                        int[,] Ta = TableHeuristic;
                        bool Ac = Act;
                        var ah = Task.Factory.StartNew(() => Ta = HeuristicAStarGreadySearchCastling(ref Ta, i, AStarGreedyi, a, Order, CurrentTableHeuristic, ref Ac));
                        ah.Wait();
                        ah.Dispose();
                        Act = Ac;
                        TableHeuristic = Ta;

                    }
                }
                // else


                return TableHeuristic;
            }
        }
        //main Brown section of king Heuristic
        int[,] HeuristicAStarGreadySearchKingBrown(ref int[,] TableHeuristic, int AStarGreedyi, Color a, int Order, bool CurrentTableHeuristic, ref bool Act)
        {

            Object O = new Object();
            lock (O)
            {
                if (KingHigh != KingMidle)
                {
                    for (var i = KingMidle; i < KingHigh; i++)
                    {
                        int[,] Ta = TableHeuristic;
                        bool Ac = Act;
                        var ah = Task.Factory.StartNew(() => Ta = HeuristicAStarGreadySearchKing(ref Ta, i, AStarGreedyi, a, Order, CurrentTableHeuristic, ref Ac));
                        ah.Wait();
                        ah.Dispose();
                        Act = Ac;
                        TableHeuristic = Ta;

                    }
                }
                // else


                return TableHeuristic;
            }
        }
        int[,] HeuristicAStarGreadySearchCastlingBrown(ref int[,] TableHeuristic, int AStarGreedyi, Color a, int Order, bool CurrentTableHeuristic, ref bool Act)
        {

            Object O = new Object();
            lock (O)
            {
                if (0 != 1)
                {
                    for (var i = 0; i < 1; i++)
                    {
                        int[,] Ta = TableHeuristic;
                        bool Ac = Act;
                        var ah = Task.Factory.StartNew(() => Ta = HeuristicAStarGreadySearchCastling(ref Ta, i, AStarGreedyi, a, Order, CurrentTableHeuristic, ref Ac));
                        ah.Wait();
                        ah.Dispose();
                        Act = Ac;
                        TableHeuristic = Ta;

                    }
                }
                // else


                return TableHeuristic;
            }
        }
        //main section of king Heuristic
        int[,] HeuristicAStarGreadySearchCastling(ref int[,] TableHeuristic, int i, int AStarGreedyi, Color a, int Order, bool CurrentTableHeuristic, ref bool Act)
        {

            Object O = new Object();
            lock (O)
            {

                int j;
                List<int> Founded = new List<int>();
                int DummyOrder = Order;
                int DummyCurrentOrder = ChessRules.CurrentOrder;
                bool AA = false;
                int Do = 0;
                for (int k = 0; k < 1; k++)
                {
                    for (j = 0; CastlingOnTable != null && CastlingOnTable[i] != null && CastlingOnTable != null && CastlingOnTable[i] != null && CastlingOnTable[i].CastlingThinking[k] != null && CastlingOnTable[i].CastlingThinking != null && j < CastlingOnTable[i].CastlingThinking[k].TableListCastling.Count; j++)
                    {
                        bool ac = false;
                        var ah1 = Task.Factory.StartNew(() => ac = IsSupHuTrue(i, j, 0, 7));
                        ah1.Wait();
                        ah1.Dispose();
                        if (ac)
                            continue;
                        {
                            //For Penalty Reagrad Mechanisam of Current Check CheckMate Current Movments.
                            //if (AllDraw.OrderPlate == Order && AStarGreedyi == 1 //&& UsePenaltyRegardMechnisamT
                            //)
                            if (CastlingOnTable[i].CastlingThinking[k].PenaltyRegardListCastling[j].IsPenaltyAction() == 0)
                                continue;
                            int CDummy = ChessRules.CurrentOrder;
                            int COrder = Order;
                            if (CastlingOnTable[i].CastlingThinking[0].AStarGreedy.Count > j && CastlingOnTable[i].CastlingThinking[0].AStarGreedy[j] != null)
                            {
                                bool AAAA = AA;
                                var ah = Task.Factory.StartNew(() => CastlingOnTable[i].CastlingThinking[0].AStarGreedy[j].IsFoundOfLeafDepenOfKindhaveVictory(1, ref AAAA, Order * -1));
                                ah.Wait();
                                ah.Dispose();
                                AA = AAAA;
                            }
                            ChessRules.CurrentOrder *= -1;
                            Order *= -1;
                            Do = 0;
                            StringHeuristics(6, 1, AA, Do, CastlingOnTable[i].WinOcuuredatChiled, CastlingOnTable[i].LoseOcuuredatChiled);

                            /* var ah3 = Task.Factory.StartNew(() => ac = Lose(7, i, j, Order));
                            ah3.Wait();
                            ah3.Dispose();
                            if (ac)
                                continue;*/
                            Order = COrder;
                            ChessRules.CurrentOrder = CDummy;
                            //if (AllDraw.OrderPlate == Order && AStarGreedyi == 1 //&& UsePenaltyRegardMechnisamT
                            //)

                            bool Ac = Act;
                            int[,] Ta = TableHeuristic;
                            bool AAA = AA;
                            int D = Do;
                            var ah4 = Task.Factory.StartNew(() => ac = HeuristicRegardSection(i, j, k, ref Ac, ref Ta, ref AAA, a, 6, ref D, AStarGreedyi, Order));
                            ah4.Wait();
                            ah4.Dispose();
                            Act = ac;
                            TableHeuristic = Ta;
                            AA = AAA;
                            if (ac)
                                continue;
                            Object ol = new Object();
                            lock (ol)
                            {
                                //When There is No Movments in Such Order Enemy continue.
                                if (Order != AllDraw.OrderPlateDraw)
                                    if (CastlingOnTable[i].CastlingThinking[0].ReturnHeuristic(i, j, Order, AA, ref HaveKilled) > Less)
                                        continue;
                                //When There is greater Heuristic Movments.
                                Ac = Act;
                                Ta = TableHeuristic;
                                bool CuTH = CurrentTableHeuristic;
                                AAA = AA;
                                D = Do;
                                var ah5 = Task.Factory.StartNew(() => ac = HeuristicMainBody(i, j, k, ref Ac, ref Ta, ref CuTH, ref AAA, a, 7, ref D, AStarGreedyi, Order));
                                ah5.Wait();
                                ah5.Dispose();
                                Act = ac;
                                TableHeuristic = Ta;
                                CurrentTableHeuristic = CuTH;
                                AA = AAA;
                                if (ac) continue;
                            }
                        }
                    }
                }
                Order = DummyOrder;
                ChessRules.CurrentOrder = DummyCurrentOrder;

                return TableHeuristic;
            }
        }
        //main section of king Heuristic
        int[,] HeuristicAStarGreadySearchKing(ref int[,] TableHeuristic, int i, int AStarGreedyi, Color a, int Order, bool CurrentTableHeuristic, ref bool Act)
        {

            Object O = new Object();
            lock (O)
            {

                int j;
                List<int> Founded = new List<int>();
                int DummyOrder = Order;
                int DummyCurrentOrder = ChessRules.CurrentOrder;
                bool AA = false;
                int Do = 0;
                for (int k = 0; k < AllDraw.KingMovments; k++)
                {
                    for (j = 0; KingOnTable != null && KingOnTable[i] != null && KingOnTable != null && KingOnTable[i] != null && KingOnTable[i].KingThinking[k] != null && KingOnTable[i].KingThinking != null && j < KingOnTable[i].KingThinking[k].TableListKing.Count; j++)
                    {
                        bool ac = false;
                        var ah1 = Task.Factory.StartNew(() => ac = IsSupHuTrue(i, j, 0, 6));
                        ah1.Wait();
                        ah1.Dispose();
                        if (ac)
                            continue;
                        {
                            //For Penalty Reagrad Mechanisam of Current Check CheckMate Current Movments.
                            //if (AllDraw.OrderPlate == Order && AStarGreedyi == 1 //&& UsePenaltyRegardMechnisamT
                            //)
                            if (KingOnTable[i].KingThinking[k].PenaltyRegardListKing[j].IsPenaltyAction() == 0)
                                continue;
                            int CDummy = ChessRules.CurrentOrder;
                            int COrder = Order;
                            if (KingOnTable[i].KingThinking[0].AStarGreedy.Count > j && KingOnTable[i].KingThinking[0].AStarGreedy[j] != null)
                            {
                                bool AAAA = AA;
                                var ah = Task.Factory.StartNew(() => KingOnTable[i].KingThinking[0].AStarGreedy[j].IsFoundOfLeafDepenOfKindhaveVictory(1, ref AAAA, Order * -1));
                                ah.Wait();
                                ah.Dispose();
                                AA = AAAA;
                            }
                            ChessRules.CurrentOrder *= -1;
                            Order *= -1;
                            Do = 0;
                            StringHeuristics(6, 1, AA, Do, KingOnTable[i].WinOcuuredatChiled, KingOnTable[i].LoseOcuuredatChiled);

                            /* var ah3 = Task.Factory.StartNew(() => ac = Lose(6, i, j, Order));
                        ah3.Wait();
                        ah3.Dispose();
                        if (ac)
                            continue;*/
                            Order = COrder;
                            ChessRules.CurrentOrder = CDummy;
                            //if (AllDraw.OrderPlate == Order && AStarGreedyi == 1 //&& UsePenaltyRegardMechnisamT
                            //)

                            bool Ac = Act;
                            int[,] Ta = TableHeuristic;
                            bool AAA = AA;
                            int D = Do;
                            var ah4 = Task.Factory.StartNew(() => ac = HeuristicRegardSection(i, j, k, ref Ac, ref Ta, ref AAA, a, 6, ref D, AStarGreedyi, Order));
                            ah4.Wait();
                            ah4.Dispose();
                            Act = ac;
                            TableHeuristic = Ta;
                            AA = AAA;
                            if (ac)
                                continue;
                            Object ol = new Object();
                            lock (ol)
                            {
                                //When There is No Movments in Such Order Enemy continue.
                                if (Order != AllDraw.OrderPlateDraw)
                                    if (KingOnTable[i].KingThinking[0].ReturnHeuristic(i, j, Order, AA, ref HaveKilled) > Less)
                                        continue;
                                //When There is greater Heuristic Movments.
                                Ac = Act;
                                Ta = TableHeuristic;
                                bool CuTH = CurrentTableHeuristic;
                                AAA = AA;
                                D = Do;
                                var ah5 = Task.Factory.StartNew(() => ac = HeuristicMainBody(i, j, k, ref Ac, ref Ta, ref CuTH, ref AAA, a, 6, ref D, AStarGreedyi, Order));
                                ah5.Wait();
                                ah5.Dispose();
                                Act = ac;
                                TableHeuristic = Ta;
                                CurrentTableHeuristic = CuTH;
                                AA = AAA;
                                if (ac) continue;
                            }
                        }
                    }
                }
                Order = DummyOrder;
                ChessRules.CurrentOrder = DummyCurrentOrder;

                return TableHeuristic;
            }
        }
        //main section of king Heuristic
        int[,] HeuristicAStarGreadySearchCastling(int kin, ref int[,] TableHeuristic, int i, int AStarGreedyi, Color a, int Order, bool CurrentTableHeuristic, ref bool Act)
        {

            Object O = new Object();
            lock (O)
            {

                int j;
                List<int> Founded = new List<int>();
                int DummyOrder = Order;
                int DummyCurrentOrder = ChessRules.CurrentOrder;
                bool AA = false;
                int Do = 0;
                for (int k = 0; k < 1; k++)
                {
                    for (j = 0; CastlingOnTable != null && CastlingOnTable[i] != null && CastlingOnTable != null && CastlingOnTable[i] != null && CastlingOnTable[i].CastlingThinking[k] != null && CastlingOnTable[i].CastlingThinking != null && j < CastlingOnTable[i].CastlingThinking[k].TableListCastling.Count; j++)
                    {
                        bool ac = false;
                        var ah1 = Task.Factory.StartNew(() => ac = IsSupHuTrue(i, j, 0, kin));
                        ah1.Wait();
                        ah1.Dispose();
                        if (ac)
                            continue;
                        {
                            //For Penalty Reagrad Mechanisam of Current Check CheckMate Current Movments.
                            //if (AllDraw.OrderPlate == Order && AStarGreedyi == 1 //&& UsePenaltyRegardMechnisamT
                            //)
                            if (CastlingOnTable[i].CastlingThinking[k].PenaltyRegardListCastling[j].IsPenaltyAction() == 0)
                                continue;
                            int CDummy = ChessRules.CurrentOrder;
                            int COrder = Order;
                            if (CastlingOnTable[i].CastlingThinking[0].AStarGreedy.Count > j && CastlingOnTable[i].CastlingThinking[0].AStarGreedy[j] != null)
                            {
                                bool AAAA = AA;
                                var ah = Task.Factory.StartNew(() => CastlingOnTable[i].CastlingThinking[0].AStarGreedy[j].IsFoundOfLeafDepenOfKindhaveVictory(1, ref AAAA, Order * -1));
                                ah.Wait();
                                ah.Dispose();
                                AA = AAAA;
                            }
                            ChessRules.CurrentOrder *= -1;
                            Order *= -1;
                            Do = 0;
                            StringHeuristics(kin, 1, AA, Do, CastlingOnTable[i].WinOcuuredatChiled, CastlingOnTable[i].LoseOcuuredatChiled);

                            var ah3 = Task.Factory.StartNew(() => ac = Lose(kin, i, j, Order));
                            ah3.Wait();
                            ah3.Dispose();
                            if (ac)
                                continue;
                            Order = COrder;
                            ChessRules.CurrentOrder = CDummy;
                            //if (AllDraw.OrderPlate == Order && AStarGreedyi == 1 //&& UsePenaltyRegardMechnisamT
                            //)

                            bool Ac = Act;
                            int[,] Ta = TableHeuristic;
                            bool AAA = AA;
                            int D = Do;
                            var ah4 = Task.Factory.StartNew(() => ac = HeuristicRegardSection(i, j, k, ref Ac, ref Ta, ref AAA, a, kin, ref D, AStarGreedyi, Order));
                            ah4.Wait();
                            ah4.Dispose();
                            Act = ac;
                            TableHeuristic = Ta;
                            AA = AAA;
                            if (ac)
                                continue;
                            Object ol = new Object();
                            lock (ol)
                            {
                                //When There is No Movments in Such Order Enemy continue.
                                if (Order != AllDraw.OrderPlateDraw)
                                    if (CastlingOnTable[i].CastlingThinking[0].ReturnHeuristic(i, j, Order, AA, ref HaveKilled) > Less)
                                        continue;
                                //When There is greater Heuristic Movments.
                                Ac = Act;
                                Ta = TableHeuristic;
                                bool CuTH = CurrentTableHeuristic;
                                AAA = AA;
                                D = Do;
                                var ah5 = Task.Factory.StartNew(() => ac = HeuristicMainBody(i, j, k, ref Ac, ref Ta, ref CuTH, ref AAA, a, kin, ref D, AStarGreedyi, Order));
                                ah5.Wait();
                                ah5.Dispose();
                                Act = ac;
                                TableHeuristic = Ta;
                                CurrentTableHeuristic = CuTH;
                                AA = AAA;
                                if (ac) continue;
                            }
                        }
                    }
                }
                Order = DummyOrder;
                ChessRules.CurrentOrder = DummyCurrentOrder;

                return TableHeuristic;
            }
        }
        //main Gray section of  Heuristic
        int[,] HeuristicAStarGreadySearchGray(int AStarGreedyi, Color a, int Order, bool CurrentTableHeuristic, ref bool Act)
        {

            Object O = new Object();
            lock (O)
            {
                int[,] TableHeuristic = new int[8, 8];
                bool Ac = Act;
                int[,] Ta = TableHeuristic;
                var ah = Task.Factory.StartNew(() => HeuristicAStarGreadySearchSoldierGray(ref Ta, AStarGreedyi, a, Order, CurrentTableHeuristic, ref Ac));
                ah.Wait();
                ah.Dispose();
                Act = Ac;
                TableHeuristic = Ta;

                if (!OnlyWin)
                {
                    Ac = Act;
                    Ta = TableHeuristic;
                    var ah1 = Task.Factory.StartNew(() => HeuristicAStarGreadySearchElephantGray(ref Ta, AStarGreedyi, a, Order, CurrentTableHeuristic, ref Ac));
                    ah1.Wait();
                    ah1.Dispose();
                    Act = Ac;
                    TableHeuristic = Ta;
                }
                if (!OnlyWin)
                {
                    Ac = Act;
                    Ta = TableHeuristic;
                    var ah1 = Task.Factory.StartNew(() => HeuristicAStarGreadySearchHourseGray(ref Ta, AStarGreedyi, a, Order, CurrentTableHeuristic, ref Ac));
                    ah1.Wait();
                    ah1.Dispose();
                    Act = Ac;
                    TableHeuristic = Ta;
                }

                if (!OnlyWin)
                {
                    Ac = Act;
                    Ta = TableHeuristic;
                    var ah1 = Task.Factory.StartNew(() => HeuristicAStarGreadySearchCastleGray(ref Ta, AStarGreedyi, a, Order, CurrentTableHeuristic, ref Ac));
                    ah1.Wait();
                    ah1.Dispose();
                    Act = Ac;
                    TableHeuristic = Ta;
                }
                if (!OnlyWin)
                {
                    Ac = Act;
                    Ta = TableHeuristic;
                    var ah1 = Task.Factory.StartNew(() => HeuristicAStarGreadySearchMinsisterGray(ref Ta, AStarGreedyi, a, Order, CurrentTableHeuristic, ref Ac));
                    ah1.Wait();
                    ah1.Dispose();
                    Act = Ac;
                    TableHeuristic = Ta;
                }
                if (!OnlyWin)
                {
                    Ac = Act;
                    Ta = TableHeuristic;
                    var ah1 = Task.Factory.StartNew(() => HeuristicAStarGreadySearchKingGray(ref Ta, AStarGreedyi, a, Order, CurrentTableHeuristic, ref Ac));
                    ah1.Wait();
                    ah1.Dispose();
                    Act = Ac;
                    TableHeuristic = Ta;
                }
                if (!OnlyWin)
                {
                    Ac = Act;
                    Ta = TableHeuristic;
                    var ah1 = Task.Factory.StartNew(() => HeuristicAStarGreadySearchCastlingGray(ref Ta, AStarGreedyi, a, Order, CurrentTableHeuristic, ref Ac));
                    ah1.Wait();
                    ah1.Dispose();
                    Act = Ac;
                    TableHeuristic = Ta;
                }
                return TableHeuristic;
            }
        }
        //main Brown section of Heuristic
        int[,] HeuristicAStarGreadySearchBrown(int AStarGreedyi, Color a, int Order, bool CurrentTableHeuristic, ref bool Act)
        {

            Object O = new Object();
            lock (O)
            {
                int[,] TableHeuristic = new int[8, 8];
                bool Ac = Act;
                int[,] Ta = TableHeuristic;
                var ah = Task.Factory.StartNew(() => HeuristicAStarGreadySearchSoldierBrown(ref Ta, AStarGreedyi, a, Order, CurrentTableHeuristic, ref Ac));
                ah.Wait();
                ah.Dispose();
                Act = Ac;
                TableHeuristic = Ta;

                if (!OnlyWin)
                {
                    Ac = Act;
                    Ta = TableHeuristic;
                    var ah1 = Task.Factory.StartNew(() => HeuristicAStarGreadySearchElephantBrown(ref Ta, AStarGreedyi, a, Order, CurrentTableHeuristic, ref Ac));
                    ah1.Wait();
                    ah1.Dispose();
                    Act = Ac;
                    TableHeuristic = Ta;
                }
                if (!OnlyWin)
                {
                    Ac = Act;
                    Ta = TableHeuristic;
                    var ah1 = Task.Factory.StartNew(() => HeuristicAStarGreadySearchHourseBrown(ref Ta, AStarGreedyi, a, Order, CurrentTableHeuristic, ref Ac));
                    ah1.Wait();
                    ah1.Dispose();
                    Act = Ac;
                    TableHeuristic = Ta;
                }

                if (!OnlyWin)
                {
                    Ac = Act;
                    Ta = TableHeuristic;
                    var ah1 = Task.Factory.StartNew(() => HeuristicAStarGreadySearchCastleBrown(ref Ta, AStarGreedyi, a, Order, CurrentTableHeuristic, ref Ac));
                    ah1.Wait();
                    ah1.Dispose();
                    Act = Ac;
                    TableHeuristic = Ta;
                }
                if (!OnlyWin)
                {
                    Ac = Act;
                    Ta = TableHeuristic;
                    var ah1 = Task.Factory.StartNew(() => HeuristicAStarGreadySearchMinsisterBrown(ref Ta, AStarGreedyi, a, Order, CurrentTableHeuristic, ref Ac));
                    ah1.Wait();
                    ah1.Dispose();
                    Act = Ac;
                    TableHeuristic = Ta;
                }
                if (!OnlyWin)
                {
                    Ac = Act;
                    Ta = TableHeuristic;
                    var ah1 = Task.Factory.StartNew(() => HeuristicAStarGreadySearchKingBrown(ref Ta, AStarGreedyi, a, Order, CurrentTableHeuristic, ref Ac));
                    ah1.Wait();
                    ah1.Dispose();
                    Act = Ac;
                    TableHeuristic = Ta;
                }
                if (!OnlyWin)
                {
                    Ac = Act;
                    Ta = TableHeuristic;
                    var ah1 = Task.Factory.StartNew(() => HeuristicAStarGreadySearchCastlingBrown(ref Ta, AStarGreedyi, a, Order, CurrentTableHeuristic, ref Ac));
                    ah1.Wait();
                    ah1.Dispose();
                    Act = Ac;
                    TableHeuristic = Ta;
                }
                return TableHeuristic;
            }
        }
        //Brown section of penalty Heuristic
        /*int[,] BrownHeuristicAStarGreaedySearchPenalites(int AStarGreedyi, Color a, int Order, bool CurrentTableHeuristic, ref bool Act)
        {

            Object O = new Object();
            lock (O)
            {
                ChessRules AB = null;
                int ToCheckMate = -1, ForCheckMate = -1, j, i;
                List<int> Founded = new List<int>();
                int DummyOrder = Order;
                int DummyCurrentOrder = ChessRules.CurrentOrder;
                bool AA = false;
                int Do = 0;
                int[,] TableHeuristic = new int[8, 8];
                //For Every Soldeir
                for (i = SodierMidle; i < SodierHigh; i++)
                {
                    //For Every Soldier Movments AStarGreedy.
                    for (int k = 0; k < AllDraw.SodierMovments; k++)
                        //When There is an Movment in such situation.
                        for (j = 0; SolderesOnTable != null && SolderesOnTable[i] != null && SolderesOnTable != null && SolderesOnTable[i] != null && SolderesOnTable[i].SoldierThinking[k] != null && SolderesOnTable[i].SoldierThinking[k] != null && j < SolderesOnTable[i].SoldierThinking[k].TableListSolder.Count; j++)
                        {
                            //For Penalty Reagrad Mechanisam of Current Check CheckMate Current Movments.
                            int CDummy = ChessRules.CurrentOrder;
                            int COrder = Order;
                            ChessRules.CurrentOrder *= -1;
                            Order *= -1;
                            Do = 0;
                            if (UsePenaltyRegardMechnisamT)
                            {
                                for (int ij = 0; ij < SolderesOnTable[i].SoldierThinking[k].AStarGreedy.Count - 1; ij++)
                                    SolderesOnTable[i].SoldierThinking[k].AStarGreedy[ij].IsPenaltyRegardCheckMateAtBranch(Order, ref Do, SolderesOnTable[i].SoldierThinking[k].AStarGreedy[ij]);
                                Order = COrder;
                                ChessRules.CurrentOrder = CDummy;
                                ToCheckMate = -1; ForCheckMate = -1; AA = IsToCheckMateHasLessDeeperThanForCheckMate(this, Order, ref ToCheckMate, ref ForCheckMate, 0); if (Do == -1)
                                    continue;
                            }

                            Order = COrder;
                            ChessRules.CurrentOrder = CDummy;
                            if ((SolderesOnTable[i].SoldierThinking[k].PenaltyRegardListSolder[j].IsPenaltyAction() != 0 && SolderesOnTable[i].SoldierThinking[k].PenaltyRegardListSolder[j].IsRewardAction() == 1 && AStarGreedyi == 1) || ((Do == 1 || AA) && UsePenaltyRegardMechnisamT))
                            {
                                //Set Table and Heuristic Value and Syntax.
                                Act = true;
                                Object o1l = new Object();
                                lock (o1l)
                                {
                                    AllDraw.LastRow = SolderesOnTable[i].SoldierThinking[k].Row;
                                    AllDraw.LastColumn = SolderesOnTable[i].SoldierThinking[k].Column;
                                    AllDraw.NextRow = SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][0];
                                    AllDraw.NextColumn = SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][1];
                                    Less = SolderesOnTable[i].SoldierThinking[k].NumberOfPenalties;
                                }

                                TableHeuristic = SolderesOnTable[i].SoldierThinking[k].TableListSolder[j];

                                Object OO = new Object();
                                lock (OO)
                                {
                                    ThingsConverter.ActOfClickEqualTow = true;
                                }
                                SolderesOnTable[i].ConvertOperation(SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][0], SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][1], a, SolderesOnTable[i].SoldierThinking[k].TableListSolder[j], Order, false, i);
                                int Sign = 1;
                                if (a == Color.Brown)
                                    Sign = -1;
                                //If there is Soldier Convert.
                                if (SolderesOnTable[i].Convert)
                                {
                                    if (SolderesOnTable[i].ConvertedToMinister)
                                        TableHeuristic[SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][0], SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][1]] = 5 * Sign;
                                    else if (SolderesOnTable[i].ConvertedToCastle)
                                        TableHeuristic[SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][0], SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][1]] = 4 * Sign;
                                    else if (SolderesOnTable[i].ConvertedToHourse)
                                        TableHeuristic[SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][0], SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][1]] = 3 * Sign;
                                    else if (SolderesOnTable[i].ConvertedToElefant)
                                        TableHeuristic[SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][0], SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][1]] = 2 * Sign;


                                    RegardOccurred = true;
                                    continue;
                                }
                            }
                            Object ol = new Object();
                            lock (ol)
                            {
                                //When There is No Movments in Such Order Enemy continue.
                                if (Order != AllDraw.OrderPlateDraw)
                                    if (SolderesOnTable[i].SoldierThinking[0].NumberOfPenalties < Less)
                                        continue;
                                //When There is greater Heuristic Movments.
                                if (SolderesOnTable[i].SoldierThinking[0].NumberOfPenalties < Less)
                                {
                                    //retrive table of current Heuristic.
                                    int[,] TableS = SolderesOnTable[i].SoldierThinking[k].TableListSolder[j];
                                    //checked for Legal Movments ArgumentOutOfRangeException curnt game.
                                    if (DynamicAStarGreedytPrograming && !CurrentTableHeuristic && AStarGreedyi == 1)
                                    {
                                        if (!IsEnemyThingsinStable(CloneATable(TableS), AllDraw.TableListAction[AllDraw.TableListAction.Count - 1], AllDraw.OrderPlate))
                                            continue;
                                    }
                                    //When there is not Penalty regard mechanism.
                                    AB = new ChessRules(CurrentAStarGredyMax, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged, 1, CloneATable(TableS), Order, SolderesOnTable[i].SoldierThinking[k].Row, SolderesOnTable[i].SoldierThinking[k].Column);
                                    //If there is kish or kshachamaz Order.
                                    if (AB.Check(CloneATable(TableS), Order))
                                    {
                                        //When Order is Gray.
                                        if (Order == 1)
                                        {
                                            //Continue When is kish CheckObjectDangour and AStarGreadyFirstSearch .
                                            if (AB.CheckGray)
                                                continue;
                                        }
                                        else
                                        {
                                            //Continue when CheckBrown and AStarGreadyFirstSearch. 
                                            if (AB.CheckBrown)
                                                continue;
                                        }
                                    }
                                    RW1 = i;
                                    CL1 = k;
                                    Ki1 = j;
                                    RW2 = -1;
                                    CL2 = -1;
                                    Ki2 = -1;
                                    RW3 = -1;
                                    CL3 = -1;
                                    Ki3 = -1;
                                    RW4 = -1;
                                    CL4 = -1;
                                    Ki4 = -1;
                                    RW5 = -1;
                                    CL5 = -1;
                                    Ki5 = -1;
                                    RW6 = -1;
                                    CL6 = -1;
                                    Ki6 = -1;
                                    MaxLess1 = SolderesOnTable[RW1].SoldierThinking[CL1].NumberOfPenalties;
                                    if (MaxLess1 > MaxLess2)
                                        MaxLess2 = -1;
                                    if (MaxLess1 > MaxLess3)
                                        MaxLess3 = -1;
                                    if (MaxLess1 > MaxLess4)
                                        MaxLess4 = -1;
                                    if (MaxLess1 > MaxLess5)
                                        MaxLess5 = -1;
                                    if (MaxLess1 > MaxLess6)
                                        MaxLess6 = -1;
                                    //Set Table and Heuristic Value and Syntax.
                                    if (AStarGreedyi == 1)
                                    {
                                        Object OO = new Object();
                                        lock (OO)
                                        {
                                            if (Order == 1)
                                            {

                                            }
                                            else//If Order is Brown.
                                            {

                                            }
                                        }
                                        //Set Table and Heuristic Value and Syntax.
                                        Act = true;
                                        Object On = new Object();
                                        lock (On)
                                        {
                                            AllDraw.LastRow = SolderesOnTable[i].SoldierThinking[k].Row;
                                            AllDraw.LastColumn = SolderesOnTable[i].SoldierThinking[k].Column;
                                            AllDraw.NextRow = SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][0];
                                            AllDraw.NextColumn = SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][1];
                                        }
                                        Less = SolderesOnTable[i].SoldierThinking[k].NumberOfPenalties;

                                        TableHeuristic = SolderesOnTable[i].SoldierThinking[k].TableListSolder[j];

                                        Object O1 = new Object();
                                        lock (O1)
                                        {
                                            ThingsConverter.ActOfClickEqualTow = true;
                                        }
                                        SolderesOnTable[i].ConvertOperation(SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][0], SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][1], a, SolderesOnTable[i].SoldierThinking[k].TableListSolder[j], Order, false, i);
                                        int Sign = 1;
                                        if (a == Color.Brown)
                                            Sign = -1;
                                        //If there is Soldier Convert.
                                        if (SolderesOnTable[i].Convert)
                                        {
                                            if (SolderesOnTable[i].ConvertedToMinister)
                                                TableHeuristic[SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][0], SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][1]] = 5 * Sign;
                                            else if (SolderesOnTable[i].ConvertedToCastle)
                                                TableHeuristic[SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][0], SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][1]] = 4 * Sign;
                                            else if (SolderesOnTable[i].ConvertedToHourse)
                                                TableHeuristic[SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][0], SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][1]] = 3 * Sign;
                                            else if (SolderesOnTable[i].ConvertedToElefant)
                                                TableHeuristic[SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][0], SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][1]] = 2 * Sign;


                                        }
                                    }
                                    else
                                    {  //Set Table and Heuristic Value and Syntax.
                                        if (AStarGreedyi == 1)
                                        {
                                            //Found of Max Non Probable Movments.
                                            Founded.Clear();
                                            int LessB = Int32.MinValue;
                                            BeginIndexFoundingMaxLessofMaxList(0, Founded, ref LessB);
                                            RW1 = (int)MaxHeuristicAStarGreedytBackWard[0][(int)Founded[0]];
                                            CL1 = (int)MaxHeuristicAStarGreedytBackWard[0][(int)Founded[0] + 1];
                                            Ki1 = (int)MaxHeuristicAStarGreedytBackWard[0][(int)Founded[0] + 2];
                                            if (Founded[0] != MaxSoldeirFounded)
                                                continue;
                                            Act = true;
                                            Object On = new Object();
                                            lock (On)
                                            {
                                                AllDraw.LastRow = SolderesOnTable[RW1].SoldierThinking[CL1].Row;
                                                AllDraw.LastColumn = SolderesOnTable[RW1].SoldierThinking[CL1].Column;
                                                AllDraw.NextRow = SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][0];
                                                AllDraw.NextColumn = SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][1];
                                            }
                                            Less = SolderesOnTable[RW1].SoldierThinking[CL1].ReturnHeuristic(RW1, Ki1, Order, false, ref HaveKilled);

                                            TableHeuristic = SolderesOnTable[RW1].SoldierThinking[CL1].TableListSolder[Ki1];

                                            Object O1 = new Object();
                                            lock (O1)
                                            {
                                                ThingsConverter.ActOfClickEqualTow = true;
                                            }
                                            SolderesOnTable[RW1].ConvertOperation(SolderesOnTable[RW1].SoldierThinking[CL1].RowColumnSoldier[Ki1][0], SolderesOnTable[RW1].SoldierThinking[CL1].RowColumnSoldier[Ki1][1], a, SolderesOnTable[RW1].SoldierThinking[CL1].TableListSolder[Ki1], Order, false, i);
                                            int Sign = 1;
                                            if (a == Color.Brown)
                                                Sign = -1;
                                            //If there is Soldier Convert.
                                            if (SolderesOnTable[RW1].Convert)
                                            {
                                                if (SolderesOnTable[RW1].ConvertedToMinister)
                                                    TableHeuristic[SolderesOnTable[RW1].SoldierThinking[CL1].RowColumnSoldier[Ki1][0], SolderesOnTable[RW1].SoldierThinking[CL1].RowColumnSoldier[Ki1][1]] = 5 * Sign;
                                                else if (SolderesOnTable[RW1].ConvertedToCastle)
                                                    TableHeuristic[SolderesOnTable[RW1].SoldierThinking[CL1].RowColumnSoldier[Ki1][0], SolderesOnTable[RW1].SoldierThinking[CL1].RowColumnSoldier[Ki1][1]] = 4 * Sign;
                                                else if (SolderesOnTable[RW1].ConvertedToHourse)
                                                    TableHeuristic[SolderesOnTable[RW1].SoldierThinking[CL1].RowColumnSoldier[Ki1][0], SolderesOnTable[RW1].SoldierThinking[CL1].RowColumnSoldier[Ki1][1]] = 3 * Sign;
                                                else if (SolderesOnTable[RW1].ConvertedToElefant)
                                                    TableHeuristic[SolderesOnTable[RW1].SoldierThinking[CL1].RowColumnSoldier[Ki1][0], SolderesOnTable[RW1].SoldierThinking[CL1].RowColumnSoldier[Ki1][1]] = 2 * Sign;


                                            }
                                            Object OO = new Object();
                                            lock (OO)
                                            {
                                                if (Order == 1)
                                                {

                                                }
                                                else//If Order is Brown.
                                                {

                                                }
                                            }
                                        }

                                    }
                                }
                            }
                        }
                    Order = DummyOrder;
                    ChessRules.CurrentOrder = DummyCurrentOrder;

                    Order = DummyOrder;
                    ChessRules.CurrentOrder = DummyCurrentOrder;
                }
                //Do For Remaining Objects same as Soldeir Documentation.
                for (i = ElefantMidle; i < ElefantHigh; i++)
                {
                    for (int k = 0; k < AllDraw.ElefantMovments; k++)
                        for (j = 0; ElephantOnTable != null && ElephantOnTable[i] != null && ElephantOnTable != null && ElephantOnTable[i] != null && ElephantOnTable[i].ElefantThinking[k] != null && ElephantOnTable[i].ElefantThinking[k] != null && j < ElephantOnTable[i].ElefantThinking[k].TableListElefant.Count; j++)
                        {
                            //For Penalty Reagrad Mechanisam of Current Check CheckMate Current Movments.
                            ////if (AllDraw.OrderPlate == Order && AStarGreedyi == 1 //&& UsePenaltyRegardMechnisamT)
                            //   if (ElephantOnTable[i].ElefantThinking[k].PenaltyRegardListElefant[j].IsPenaltyAction() == 0)

                            int CDummy = ChessRules.CurrentOrder;
                            int COrder = Order;
                            ChessRules.CurrentOrder *= -1;
                            Order *= -1;
                            Do = 0;
                            if (UsePenaltyRegardMechnisamT)
                            {
                                for (int ij = 0; ij < ElephantOnTable[i].ElefantThinking[k].AStarGreedy.Count - 1; ij++)
                                    ElephantOnTable[i].ElefantThinking[k].AStarGreedy[ij].IsPenaltyRegardCheckMateAtBranch(Order, ref Do, ElephantOnTable[i].ElefantThinking[k].AStarGreedy[ij]);
                                Order = COrder;
                                ChessRules.CurrentOrder = CDummy;
                                ToCheckMate = -1; ForCheckMate = -1; AA = IsToCheckMateHasLessDeeperThanForCheckMate(this, Order, ref ToCheckMate, ref ForCheckMate, 0); if (Do == -1)
                                    continue;
                            }

                            Order = COrder;
                            ChessRules.CurrentOrder = CDummy;
                            //if (AllDraw.OrderPlate == Order && AStarGreedyi == 1 //&& UsePenaltyRegardMechnisamT
                            //)
                            if ((ElephantOnTable[i].ElefantThinking[k].PenaltyRegardListElefant[j].IsPenaltyAction() != 0 && ElephantOnTable[i].ElefantThinking[k].PenaltyRegardListElefant[j].IsRewardAction() == 1 && AStarGreedyi == 1) || ((Do == 1 || AA) && UsePenaltyRegardMechnisamT))
                            {
                                Object On = new Object();
                                lock (On)
                                {
                                    AllDraw.LastRow = ElephantOnTable[i].ElefantThinking[k].Row;
                                    AllDraw.LastColumn = ElephantOnTable[i].ElefantThinking[k].Column;
                                    AllDraw.NextRow = ElephantOnTable[i].ElefantThinking[k].RowColumnElefant[j][0];
                                    AllDraw.NextColumn = ElephantOnTable[i].ElefantThinking[k].RowColumnElefant[j][1];

                                    Act = true;
                                    Less = ElephantOnTable[i].ElefantThinking[k].NumberOfPenalties;
                                }
                                TableHeuristic = ElephantOnTable[i].ElefantThinking[k].TableListElefant[j];
                                RegardOccurred = true;
                                //if (((Do == 1 || AA)&&UsePenaltyRegardMechnisamT))

                                continue;
                            }
                            //When There is No Movments in Such Order Enemy continue.
                            if (ElephantOnTable[i].ElefantThinking[k].PenaltyRegardListElefant[j].IsPenaltyAction() == 0)
                                continue;
                            Object ol = new Object();
                            lock (ol)
                            {
                                //When There is No Movments in Such Order Enemy continue.
                                if (Order != AllDraw.OrderPlateDraw)
                                    if (ElephantOnTable[i].ElefantThinking[0].NumberOfPenalties < Less)
                                        continue;
                                //When There is greater Heuristic Movments.
                                if (ElephantOnTable[i].ElefantThinking[0].NumberOfPenalties < Less)
                                {
                                    //retrive table of current Heuristic.
                                    //if (CheckG || CheckB)
                                    //{
                                    //retrive table of current Heuristic.
                                    int[,] TableS = ElephantOnTable[i].ElefantThinking[k].TableListElefant[j];
                                    //checked for Legal Movments ArgumentOutOfRangeException curnt game.
                                    if (DynamicAStarGreedytPrograming && !CurrentTableHeuristic && AStarGreedyi == 1)
                                    {
                                        if (!IsEnemyThingsinStable(CloneATable(TableS), AllDraw.TableListAction[AllDraw.TableListAction.Count - 1], AllDraw.OrderPlate))
                                            continue;
                                    }
                                    //When there is not Penalty regard mechanism.
                                    //if (!UsePenaltyRegardMechnisamT)
                                    {
                                        AB = new ChessRules(CurrentAStarGredyMax, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged, 2, CloneATable(TableS), Order, ElephantOnTable[i].ElefantThinking[k].Row, ElephantOnTable[i].ElefantThinking[k].Column);
                                        //If there is kish or kshachamaz Order.
                                        if (AB.Check(CloneATable(TableS), Order))
                                        {
                                            //When Order is Gray.
                                            if (Order == 1)
                                            {
                                                //Continue When is kish CheckObjectDangour and AStarGreadyFirstSearch .
                                                if (AB.CheckGray)
                                                    continue;
                                            }
                                            else
                                            {
                                                //Continue when CheckBrown and AStarGreadyFirstSearch. 
                                                if (AB.CheckBrown)
                                                    continue;
                                            }
                                        }
                                        else
                                        {
                                        }

                                    }
                                    RW2 = i;
                                    CL2 = k;
                                    Ki2 = j;
                                    RW1 = -1;
                                    CL1 = -1;
                                    Ki1 = -1;
                                    RW3 = -1;
                                    CL3 = -1;
                                    Ki3 = -1;
                                    RW4 = -1;
                                    CL4 = -1;
                                    Ki4 = -1;
                                    RW5 = -1;
                                    CL5 = -1;
                                    Ki5 = -1;
                                    RW6 = -1;
                                    CL6 = -1;
                                    Ki6 = -1;
                                    MaxLess2 = (ElephantOnTable[RW2].ElefantThinking[CL2].NumberOfPenalties);
                                    MaxLess1 = -1;
                                    if (MaxLess2 > MaxLess3)
                                        MaxLess3 = -1;
                                    if (MaxLess2 > MaxLess4)
                                        MaxLess4 = -1;
                                    if (MaxLess2 > MaxLess5)
                                        MaxLess5 = -1;
                                    if (MaxLess2 > MaxLess6)
                                        MaxLess6 = -1;
                                    if (AStarGreedyi == 1)
                                    {
                                        Object OO = new Object();
                                        lock (OO)
                                        {
                                            if (Order == 1)
                                            {

                                            }
                                            else//If Order is Brown.
                                            {

                                            }
                                        }
                                        Object On = new Object();
                                        lock (On)
                                        {
                                            AllDraw.LastRow = ElephantOnTable[i].ElefantThinking[k].Row;
                                            AllDraw.LastColumn = ElephantOnTable[i].ElefantThinking[k].Column;
                                            AllDraw.NextRow = ElephantOnTable[i].ElefantThinking[k].RowColumnElefant[j][0];
                                            AllDraw.NextColumn = ElephantOnTable[i].ElefantThinking[k].RowColumnElefant[j][1];
                                        }
                                        Act = true;
                                        Less = ElephantOnTable[i].ElefantThinking[k].NumberOfPenalties;
                                        TableHeuristic = ElephantOnTable[i].ElefantThinking[k].TableListElefant[j];
                                    }
                                }
                                else//Set Table and Heuristic Value and Syntax.
                                {
                                    if (AStarGreedyi == 1)
                                    {

                                        //Found of Max Non Probable Movments.
                                        Founded.Clear();
                                        int LessB = Int32.MinValue;
                                        BeginIndexFoundingMaxLessofMaxList(0, Founded, ref LessB);
                                        RW2 = (int)MaxHeuristicAStarGreedytBackWard[0][(int)Founded[0]];
                                        CL2 = (int)MaxHeuristicAStarGreedytBackWard[0][(int)Founded[0] + 1];
                                        Ki2 = (int)MaxHeuristicAStarGreedytBackWard[0][(int)Founded[0] + 2];
                                        if (Founded[0] != MaxElephntFounded)
                                            continue;
                                        Object On = new Object();
                                        lock (On)
                                        {
                                            AllDraw.LastRow = ElephantOnTable[RW2].ElefantThinking[CL2].Row;
                                            AllDraw.LastColumn = ElephantOnTable[RW2].ElefantThinking[CL2].Column;
                                            AllDraw.NextRow = ElephantOnTable[i].ElefantThinking[k].RowColumnElefant[j][0];
                                            AllDraw.NextColumn = ElephantOnTable[i].ElefantThinking[k].RowColumnElefant[j][1];
                                        }
                                        Act = true;
                                        Less = ElephantOnTable[RW2].ElefantThinking[CL2].ReturnHeuristic(RW2, Ki2, Order, false, ref HaveKilled);
                                        TableHeuristic = ElephantOnTable[RW2].ElefantThinking[CL2].TableListElefant[Ki2];
                                        Object OO = new Object();
                                        lock (OO)
                                        {
                                            if (Order == 1)
                                            {

                                            }
                                            else//If Order is Brown.
                                            {

                                            }
                                        }
                                    }

                                }
                            }
                        }

                    Order = DummyOrder;
                    ChessRules.CurrentOrder = DummyCurrentOrder;

                    Order = DummyOrder;
                    ChessRules.CurrentOrder = DummyCurrentOrder;
                }
                for (i = HourseMidle; i < HourseHight; i++)
                {
                    for (int k = 0; k < AllDraw.HourseMovments; k++)
                        for (j = 0; HoursesOnTable != null && HoursesOnTable[i] != null && HoursesOnTable != null && HoursesOnTable[i] != null && HoursesOnTable[i].HourseThinking[k] != null && HoursesOnTable[i].HourseThinking[k] != null && j < HoursesOnTable[i].HourseThinking[k].TableListHourse.Count; j++)
                        {
                            //For Penalty Reagrad Mechanisam of Current Check CheckMate Current Movments.
                            ////if (AllDraw.OrderPlate == Order && AStarGreedyi == 1 //&& UsePenaltyRegardMechnisamT)
                            //    if (HoursesOnTable[i].HourseThinking[k].PenaltyRegardListHourse[j].IsPenaltyAction() == 0)

                            int CDummy = ChessRules.CurrentOrder;
                            int COrder = Order;
                            ChessRules.CurrentOrder *= -1;
                            Order *= -1;
                            Do = 0;
                            if (UsePenaltyRegardMechnisamT)
                            {
                                for (int ij = 0; ij < HoursesOnTable[i].HourseThinking[k].AStarGreedy.Count - 1; ij++)
                                    HoursesOnTable[i].HourseThinking[k].AStarGreedy[ij].IsPenaltyRegardCheckMateAtBranch(Order, ref Do, HoursesOnTable[i].HourseThinking[k].AStarGreedy[ij]);
                                Order = COrder;
                                ChessRules.CurrentOrder = CDummy;
                                ToCheckMate = -1; ForCheckMate = -1; AA = IsToCheckMateHasLessDeeperThanForCheckMate(this, Order, ref ToCheckMate, ref ForCheckMate, 0); if (Do == -1)
                                    continue;
                            }

                            Order = COrder;
                            ChessRules.CurrentOrder = CDummy;
                            //if (AllDraw.OrderPlate == Order && AStarGreedyi == 1 //&& UsePenaltyRegardMechnisamT
                            //)
                            if ((HoursesOnTable[i].HourseThinking[k].PenaltyRegardListHourse[j].IsPenaltyAction() != 0 && HoursesOnTable[i].HourseThinking[k].PenaltyRegardListHourse[j].IsRewardAction() == 1 && AStarGreedyi == 1) || ((Do == 1 || AA) && UsePenaltyRegardMechnisamT))
                            {
                                Object On = new Object();
                                lock (On)
                                {
                                    AllDraw.LastRow = HoursesOnTable[i].HourseThinking[k].Row;
                                    AllDraw.LastColumn = HoursesOnTable[i].HourseThinking[k].Column;
                                    AllDraw.NextRow = HoursesOnTable[i].HourseThinking[k].RowColumnHourse[j][0];
                                    AllDraw.NextColumn = HoursesOnTable[i].HourseThinking[k].RowColumnHourse[j][1];

                                    Act = true;
                                    Less = HoursesOnTable[i].HourseThinking[k].NumberOfPenalties;
                                }
                                TableHeuristic = HoursesOnTable[i].HourseThinking[k].TableListHourse[j];
                                RegardOccurred = true;
                                //if (((Do == 1 || AA)&&UsePenaltyRegardMechnisamT))

                                continue;
                            }
                            Object ol = new Object();
                            lock (ol)
                            {
                                //When There is No Movments in Such Order Enemy continue.
                                if (Order != AllDraw.OrderPlateDraw)
                                    if (HoursesOnTable[i].HourseThinking[0].NumberOfPenalties < Less)
                                        continue;
                                //When There is greater Heuristic Movments.
                                if (HoursesOnTable[i].HourseThinking[0].NumberOfPenalties < Less)
                                {
                                    //retrive table of current Heuristic.
                                    //retrive table of current Heuristic.
                                    int[,] TableS = HoursesOnTable[i].HourseThinking[k].TableListHourse[j];
                                    {
                                        //checked for Legal Movments ArgumentOutOfRangeException curnt game.
                                        if (DynamicAStarGreedytPrograming && !CurrentTableHeuristic && AStarGreedyi == 1)
                                        {
                                            if (!IsEnemyThingsinStable(CloneATable(TableS), AllDraw.TableListAction[AllDraw.TableListAction.Count - 1], AllDraw.OrderPlate))
                                                continue;

                                        }
                                        //When there is not Penalty regard mechanism.
                                        //if (!UsePenaltyRegardMechnisamT)
                                        {
                                            AB = new ChessRules(CurrentAStarGredyMax, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged, 3, CloneATable(TableS), Order, HoursesOnTable[i].HourseThinking[k].Row, HoursesOnTable[i].HourseThinking[k].Column);
                                            //If there is kish or kshachamaz Order.
                                            if (AB.Check(CloneATable(TableS), Order))
                                            {
                                                //When Order is Gray.
                                                if (Order == 1)
                                                {
                                                    //Continue When is kish CheckObjectDangour and AStarGreadyFirstSearch .
                                                    if (AB.CheckGray)
                                                        continue;
                                                }
                                                else
                                                {
                                                    //Continue when CheckBrown and AStarGreadyFirstSearch. 
                                                    if (AB.CheckBrown)
                                                        continue;
                                                }
                                            }
                                            else
                                            {
                                            }
                                        }

                                    }
                                    RW1 = -1;
                                    CL1 = -1;
                                    Ki1 = -1;
                                    RW2 = -1;
                                    CL2 = -1;
                                    Ki2 = -1;
                                    RW3 = i;
                                    CL3 = k;
                                    Ki3 = j;
                                    RW4 = -1;
                                    CL4 = -1;
                                    Ki4 = -1;
                                    RW5 = -1;
                                    CL5 = -1;
                                    Ki5 = -1;
                                    RW6 = -1;
                                    CL6 = -1;
                                    Ki6 = -1;
                                    MaxLess3 = HoursesOnTable[RW3].HourseThinking[CL3].NumberOfPenalties;
                                    if (MaxLess3 > MaxLess1)
                                        MaxLess1 = -1;
                                    if (MaxLess3 > MaxLess2)
                                        MaxLess2 = -1;
                                    if (MaxLess3 > MaxLess4)
                                        MaxLess4 = -1;
                                    if (MaxLess3 > MaxLess5)
                                        MaxLess5 = -1;
                                    if (MaxLess3 > MaxLess6)
                                        MaxLess6 = -1;
                                    if (AStarGreedyi == 1)
                                    {
                                        Object OO = new Object();
                                        lock (OO)
                                        {
                                            if (Order == 1)
                                            {

                                            }
                                            else//If Order is Brown.
                                            {

                                            }
                                        }
                                        //Set Table and Heuristic Value and Syntax.
                                        Object On = new Object();
                                        lock (On)
                                        {
                                            AllDraw.LastRow = HoursesOnTable[i].HourseThinking[k].Row;
                                            AllDraw.LastColumn = HoursesOnTable[i].HourseThinking[k].Column;
                                            AllDraw.NextRow = HoursesOnTable[i].HourseThinking[k].RowColumnHourse[j][0];
                                            AllDraw.NextColumn = HoursesOnTable[i].HourseThinking[k].RowColumnHourse[j][1];
                                        }
                                        Act = true;
                                        Less = HoursesOnTable[i].HourseThinking[k].NumberOfPenalties;
                                        TableHeuristic = HoursesOnTable[i].HourseThinking[k].TableListHourse[j];
                                    }
                                }
                                else//Set Table and Heuristic Value and Syntax.
                                {
                                    if (AStarGreedyi == 1)
                                    {

                                        //Found of Max Non Probable Movments.
                                        Founded.Clear();
                                        int LessB = Int32.MinValue;
                                        BeginIndexFoundingMaxLessofMaxList(0, Founded, ref LessB);
                                        RW3 = (int)MaxHeuristicAStarGreedytBackWard[0][(int)Founded[0]];
                                        CL3 = (int)MaxHeuristicAStarGreedytBackWard[0][(int)Founded[0] + 1];
                                        Ki3 = (int)MaxHeuristicAStarGreedytBackWard[0][(int)Founded[0] + 2];
                                        if (Founded[0] != MaxHourseFounded)
                                            continue;
                                        Object On = new Object();
                                        lock (On)
                                        {
                                            AllDraw.LastRow = HoursesOnTable[RW3].HourseThinking[CL3].Row;
                                            AllDraw.LastColumn = HoursesOnTable[RW3].HourseThinking[CL3].Column;
                                            AllDraw.NextRow = HoursesOnTable[i].HourseThinking[k].RowColumnHourse[j][0];
                                            AllDraw.NextColumn = HoursesOnTable[i].HourseThinking[k].RowColumnHourse[j][1];
                                        }
                                        Act = true;
                                        Less = HoursesOnTable[RW3].HourseThinking[CL3].ReturnHeuristic(RW3, Ki3, Order, false, ref HaveKilled);
                                        TableHeuristic = HoursesOnTable[RW3].HourseThinking[CL3].TableListHourse[Ki3];
                                        Object OO = new Object();
                                        lock (OO)
                                        {
                                            if (Order == 1)
                                            {

                                            }
                                            else//If Order is Brown.
                                            {

                                            }
                                        }
                                    }

                                }
                            }
                        }

                    Order = DummyOrder;
                    ChessRules.CurrentOrder = DummyCurrentOrder;

                    Order = DummyOrder;
                    ChessRules.CurrentOrder = DummyCurrentOrder;
                }
                for (i = CastleMidle; i < CastleHigh; i++)
                {
                    for (int k = 0; k < AllDraw.CastleMovments; k++)
                        for (j = 0; CastlesOnTable != null && CastlesOnTable[i] != null && CastlesOnTable != null && CastlesOnTable[i] != null && CastlesOnTable[i].CastleThinking[k] != null && CastlesOnTable[i].CastleThinking[k] != null && j < CastlesOnTable[i].CastleThinking[k].TableListCastle.Count; j++)
                        {
                            //For Penalty Reagrad Mechanisam of Current Check CheckMate Current Movments.
                            ////if (AllDraw.OrderPlate == Order && AStarGreedyi == 1 //&& UsePenaltyRegardMechnisamT)
                            ///   if (CastlesOnTable[i].CastleThinking[k].PenaltyRegardListCastle[j].IsPenaltyAction() == 0)

                            int CDummy = ChessRules.CurrentOrder;
                            int COrder = Order;
                            ChessRules.CurrentOrder *= -1;
                            Order *= -1;
                            Do = 0;
                            if (UsePenaltyRegardMechnisamT)
                            {
                                for (int ij = 0; ij < CastlesOnTable[i].CastleThinking[k].AStarGreedy.Count - 1; ij++)
                                    CastlesOnTable[i].CastleThinking[k].AStarGreedy[ij].IsPenaltyRegardCheckMateAtBranch(Order, ref Do, CastlesOnTable[i].CastleThinking[k].AStarGreedy[ij]);
                                Order = COrder;
                                ChessRules.CurrentOrder = CDummy;
                                ToCheckMate = -1; ForCheckMate = -1; AA = IsToCheckMateHasLessDeeperThanForCheckMate(this, Order, ref ToCheckMate, ref ForCheckMate, 0); if (Do == -1)
                                    continue;
                            }

                            Order = COrder;
                            ChessRules.CurrentOrder = CDummy;
                            //if (AllDraw.OrderPlate == Order && AStarGreedyi == 1 //&& UsePenaltyRegardMechnisamT
                            //)
                            if ((CastlesOnTable[i].CastleThinking[k].PenaltyRegardListCastle[j].IsPenaltyAction() != 0 && CastlesOnTable[i].CastleThinking[k].PenaltyRegardListCastle[j].IsRewardAction() == 1 && AStarGreedyi == 1) || ((Do == 1 || AA) && UsePenaltyRegardMechnisamT))
                            {
                                Object On = new Object();
                                lock (On)
                                {
                                    AllDraw.LastRow = CastlesOnTable[i].CastleThinking[k].Row;
                                    AllDraw.LastColumn = CastlesOnTable[i].CastleThinking[k].Column;
                                    AllDraw.NextRow = CastlesOnTable[i].CastleThinking[k].RowColumnCastle[j][0];
                                    AllDraw.NextColumn = CastlesOnTable[i].CastleThinking[k].RowColumnCastle[j][1];
                                    Act = true;
                                    Less = CastlesOnTable[i].CastleThinking[k].NumberOfPenalties;
                                }
                                TableHeuristic = CastlesOnTable[i].CastleThinking[k].TableListCastle[j];
                                RegardOccurred = true;
                                //if (((Do == 1 || AA)&&UsePenaltyRegardMechnisamT))

                                continue;
                            }
                            Object ol = new Object();
                            lock (ol)
                            {
                                if (Order != AllDraw.OrderPlateDraw)
                                    if (CastlesOnTable[i].CastleThinking[0].NumberOfPenalties < Less)
                                        continue;
                                //When There is greater Heuristic Movments.
                                if (CastlesOnTable[i].CastleThinking[0].NumberOfPenalties < Less)
                                {
                                    //retrive table of current Heuristic.
                                    //retrive table of current Heuristic.
                                    int[,] TableS = CastlesOnTable[i].CastleThinking[k].TableListCastle[j];
                                    //checked for Legal Movments ArgumentOutOfRangeException curnt game.
                                    if (DynamicAStarGreedytPrograming && !CurrentTableHeuristic && AStarGreedyi == 1)
                                    {
                                        if (!IsEnemyThingsinStable(CloneATable(TableS), AllDraw.TableListAction[AllDraw.TableListAction.Count - 1], AllDraw.OrderPlate))
                                            continue;

                                    }
                                    //When there is not Penalty regard mechanism.
                                    //if (!UsePenaltyRegardMechnisamT)
                                    {
                                        AB = new ChessRules(CurrentAStarGredyMax, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged, 4, CloneATable(TableS), Order, CastlesOnTable[i].CastleThinking[k].Row, CastlesOnTable[i].CastleThinking[k].Column);
                                        //If there is kish or kshachamaz Order.
                                        if (AB.Check(CloneATable(TableS), Order))
                                        {
                                            //When Order is Gray.
                                            if (Order == 1)
                                            {
                                                //Continue When is kish CheckObjectDangour and AStarGreadyFirstSearch .
                                                if (AB.CheckGray)
                                                    continue;
                                            }
                                            else
                                            {
                                                //Continue when CheckBrown and AStarGreadyFirstSearch. 
                                                if (AB.CheckBrown)
                                                    continue;
                                            }
                                        }
                                        else
                                        {
                                        }
                                    }
                                    RW4 = i;
                                    CL4 = k;
                                    Ki4 = j;
                                    RW1 = -1;
                                    CL1 = -1;
                                    Ki1 = -1;
                                    RW2 = -1;
                                    CL2 = -1;
                                    Ki2 = -1;
                                    RW3 = -1;
                                    CL3 = -1;
                                    Ki3 = -1;
                                    RW5 = -1;
                                    CL5 = -1;
                                    Ki5 = -1;
                                    RW6 = -1;
                                    CL6 = -1;
                                    Ki6 = -1;
                                    MaxLess4 = (CastlesOnTable[RW4].CastleThinking[CL4].NumberOfPenalties);
                                    if (MaxLess4 > MaxLess1)
                                        MaxLess1 = -1;
                                    if (MaxLess4 > MaxLess2)
                                        MaxLess2 = -1;
                                    if (MaxLess4 > MaxLess3)
                                        MaxLess3 = -1;
                                    if (MaxLess4 > MaxLess5)
                                        MaxLess5 = -1;
                                    if (MaxLess4 > MaxLess6)
                                        MaxLess6 = -1;
                                    if (AStarGreedyi == 1)
                                    {
                                        Object OO = new Object();
                                        lock (OO)
                                        {
                                            if (Order == 1)
                                            {

                                            }
                                            else//If Order is Brown.
                                            {

                                            }
                                        }
                                        //Set Table and Heuristic Value and Syntax.
                                        Object On = new Object();
                                        lock (On)
                                        {
                                            AllDraw.LastRow = CastlesOnTable[i].CastleThinking[k].Row;
                                            AllDraw.LastColumn = CastlesOnTable[i].CastleThinking[k].Column;
                                            AllDraw.NextRow = CastlesOnTable[i].CastleThinking[k].RowColumnCastle[j][0];
                                            AllDraw.NextColumn = CastlesOnTable[i].CastleThinking[k].RowColumnCastle[j][1];
                                        }
                                        Act = true;
                                        Less = CastlesOnTable[i].CastleThinking[k].NumberOfPenalties;
                                        TableHeuristic = CastlesOnTable[i].CastleThinking[k].TableListCastle[j];
                                    }
                                }
                                else//Set Table and Heuristic Value and Syntax.
                                {
                                    if (AStarGreedyi == 1)
                                    {

                                        //Found of Max Non Probable Movments.
                                        Founded.Clear();
                                        int LessB = Int32.MinValue;
                                        BeginIndexFoundingMaxLessofMaxList(0, Founded, ref LessB);
                                        RW4 = (int)MaxHeuristicAStarGreedytBackWard[0][(int)Founded[0]];
                                        CL4 = (int)MaxHeuristicAStarGreedytBackWard[0][(int)Founded[0] + 1];
                                        Ki4 = (int)MaxHeuristicAStarGreedytBackWard[0][(int)Founded[0] + 2];
                                        if (Founded[0] != MaxCastlesFounded)
                                            continue;
                                        Object On = new Object();
                                        lock (On)
                                        {
                                            AllDraw.LastRow = CastlesOnTable[RW4].CastleThinking[CL4].Row;
                                            AllDraw.LastColumn = CastlesOnTable[RW4].CastleThinking[CL4].Column;
                                            AllDraw.NextRow = CastlesOnTable[i].CastleThinking[k].RowColumnCastle[j][0];
                                            AllDraw.NextColumn = CastlesOnTable[i].CastleThinking[k].RowColumnCastle[j][1];
                                        }
                                        Act = true;
                                        Less = CastlesOnTable[RW4].CastleThinking[CL4].ReturnHeuristic(RW4, Ki4, Order, false, ref HaveKilled);
                                        TableHeuristic = CastlesOnTable[RW4].CastleThinking[CL4].TableListCastle[Ki4];
                                        Object OO = new Object();
                                        lock (OO)
                                        {
                                            if (Order == 1)
                                            {

                                            }
                                            else//If Order is Brown.
                                            {

                                            }
                                        }
                                    }

                                }
                            }
                        }

                    Order = DummyOrder;
                    ChessRules.CurrentOrder = DummyCurrentOrder;
                    Order = DummyOrder;
                    ChessRules.CurrentOrder = DummyCurrentOrder;
                }

                for (i = MinisterMidle; i < MinisterHigh; i++)
                {
                    for (int k = 0; k < AllDraw.MinisterMovments; k++)
                        for (j = 0; MinisterOnTable != null && MinisterOnTable[i] != null && MinisterOnTable != null && MinisterOnTable[i] != null && MinisterOnTable[i].MinisterThinking[k] != null && MinisterOnTable[i].MinisterThinking[k] != null && j < MinisterOnTable[i].MinisterThinking[k].TableListMinister.Count; j++)
                        {
                            //For Penalty Reagrad Mechanisam of Current Check CheckMate Current Movments.
                            int CDummy = ChessRules.CurrentOrder;
                            int COrder = Order;
                            ChessRules.CurrentOrder *= -1;
                            Order *= -1;
                            Do = 0;
                            if (UsePenaltyRegardMechnisamT)
                            {
                                for (int ij = 0; ij < MinisterOnTable[i].MinisterThinking[k].AStarGreedy.Count - 1; ij++)
                                    MinisterOnTable[i].MinisterThinking[k].AStarGreedy[ij].IsPenaltyRegardCheckMateAtBranch(Order, ref Do, MinisterOnTable[i].MinisterThinking[k].AStarGreedy[ij]);
                                Order = COrder;
                                ChessRules.CurrentOrder = CDummy;
                                ToCheckMate = -1; ForCheckMate = -1; AA = IsToCheckMateHasLessDeeperThanForCheckMate(this, Order, ref ToCheckMate, ref ForCheckMate, 0); if (Do == -1)
                                    continue;
                            }

                            Order = COrder;
                            ChessRules.CurrentOrder = CDummy;
                            if ((MinisterOnTable[i].MinisterThinking[k].PenaltyRegardListMinister[j].IsPenaltyAction() != 0 && MinisterOnTable[i].MinisterThinking[k].PenaltyRegardListMinister[j].IsRewardAction() == 1 && AStarGreedyi == 1) || ((Do == 1 || AA) && UsePenaltyRegardMechnisamT))
                            {
                                Object On = new Object();
                                lock (On)
                                {
                                    AllDraw.LastRow = MinisterOnTable[i].MinisterThinking[k].Row;
                                    AllDraw.LastColumn = MinisterOnTable[i].MinisterThinking[k].Column;
                                    AllDraw.NextRow = MinisterOnTable[i].MinisterThinking[k].RowColumnMinister[j][0];
                                    AllDraw.NextColumn = MinisterOnTable[i].MinisterThinking[k].RowColumnMinister[j][1];

                                    Act = true;
                                    Less = MinisterOnTable[i].MinisterThinking[k].NumberOfPenalties;
                                }
                                TableHeuristic = MinisterOnTable[i].MinisterThinking[k].TableListMinister[j];
                                RegardOccurred = true;
                                continue;
                            }
                            Object ol = new Object();
                            lock (ol)
                            {
                                //When There is No Movments in Such Order Enemy continue.
                                if (Order != AllDraw.OrderPlateDraw)
                                    if (MinisterOnTable[i].MinisterThinking[0].NumberOfPenalties < Less)
                                        continue;

                                //When There is greater Heuristic Movments.
                                if (MinisterOnTable[i].MinisterThinking[0].NumberOfPenalties < Less)
                                //retrive table of current Heuristic.
                                {
                                    //retrive table of current Heuristic.
                                    int[,] TableS = MinisterOnTable[i].MinisterThinking[k].TableListMinister[j];
                                    //checked for Legal Movments ArgumentOutOfRangeException curnt game.
                                    if (DynamicAStarGreedytPrograming && !CurrentTableHeuristic && AStarGreedyi == 1)
                                    {
                                        if (!IsEnemyThingsinStable(CloneATable(TableS), AllDraw.TableListAction[AllDraw.TableListAction.Count - 1], AllDraw.OrderPlate))
                                            continue;
                                    }
                                    //When there is not Penalty regard mechanism.
                                    AB = new ChessRules(CurrentAStarGredyMax, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged, 5, CloneATable(TableS), Order, MinisterOnTable[i].MinisterThinking[k].Row, MinisterOnTable[i].MinisterThinking[k].Column);
                                    //If there is kish or kshachamaz Order.
                                    if (AB.Check(CloneATable(TableS), Order))
                                    {
                                        //When Order is Gray.
                                        if (Order == 1)
                                        {
                                            //Continue When is kish CheckObjectDangour and AStarGreadyFirstSearch .
                                            if (AB.CheckGray)
                                                continue;
                                        }
                                        else
                                        {
                                            //Continue when CheckBrown and AStarGreadyFirstSearch. 
                                            if (AB.CheckBrown)
                                                continue;
                                        }
                                    }
                                    RW5 = i;
                                    CL5 = k;
                                    Ki5 = j;
                                    RW1 = -1;
                                    CL1 = -1;
                                    Ki1 = -1;
                                    RW2 = -1;
                                    CL2 = -1;
                                    Ki2 = -1;
                                    RW3 = -1;
                                    CL3 = -1;
                                    Ki3 = -1;
                                    RW4 = -1;
                                    CL4 = -1;
                                    Ki4 = -1;
                                    RW6 = -1;
                                    CL6 = -1;
                                    Ki6 = -1;
                                    MaxLess5 = (MinisterOnTable[RW5].MinisterThinking[CL5].NumberOfPenalties);
                                    if (MaxLess5 > MaxLess1)
                                        MaxLess1 = -1;
                                    if (MaxLess5 > MaxLess2)
                                        MaxLess2 = -1;
                                    if (MaxLess5 > MaxLess3)
                                        MaxLess3 = -1;
                                    if (MaxLess5 > MaxLess4)
                                        MaxLess4 = -1;
                                    if (MaxLess5 > MaxLess6)
                                        MaxLess6 = -1;
                                    if (AStarGreedyi == 1)
                                    {
                                        Object OO = new Object();
                                        lock (OO)
                                        {
                                            if (Order == 1)
                                            {

                                            }
                                            else//If Order is Brown.
                                            {

                                            }
                                        }
                                        Object On = new Object();
                                        lock (On)
                                        {
                                            AllDraw.LastRow = MinisterOnTable[i].MinisterThinking[k].Row;
                                            AllDraw.LastColumn = MinisterOnTable[i].MinisterThinking[k].Column;
                                            AllDraw.NextRow = MinisterOnTable[i].MinisterThinking[k].RowColumnMinister[j][0];
                                            AllDraw.NextColumn = MinisterOnTable[i].MinisterThinking[k].RowColumnMinister[j][1];
                                        }
                                        Act = true;
                                        Less = MinisterOnTable[i].MinisterThinking[k].NumberOfPenalties;
                                        TableHeuristic = MinisterOnTable[i].MinisterThinking[k].TableListMinister[j];
                                    }
                                }
                                else//Set Table and Heuristic Value and Syntax.
                                {
                                    if (AStarGreedyi == 1)
                                    {
                                        //Found of Max Non Probable Movments.
                                        Founded.Clear();
                                        int LessB = Int32.MinValue;
                                        BeginIndexFoundingMaxLessofMaxList(0, Founded, ref LessB);
                                        RW5 = (int)MaxHeuristicAStarGreedytBackWard[0][(int)Founded[0]];
                                        CL5 = (int)MaxHeuristicAStarGreedytBackWard[0][(int)Founded[0] + 1];
                                        Ki5 = (int)MaxHeuristicAStarGreedytBackWard[0][(int)Founded[0] + 2];
                                        if (Founded[0] != MaxMinisterFounded)
                                            continue;
                                        Object On = new Object();
                                        lock (On)
                                        {
                                            AllDraw.LastRow = MinisterOnTable[RW5].MinisterThinking[CL5].Row;
                                            AllDraw.LastColumn = MinisterOnTable[RW5].MinisterThinking[CL5].Column;
                                            AllDraw.NextRow = MinisterOnTable[i].MinisterThinking[k].RowColumnMinister[j][0];
                                            AllDraw.NextColumn = MinisterOnTable[i].MinisterThinking[k].RowColumnMinister[j][1];
                                        }
                                        Act = true;
                                        Less = MinisterOnTable[RW5].MinisterThinking[CL5].ReturnHeuristic(RW5, Ki5, Order, false, ref HaveKilled);
                                        TableHeuristic = MinisterOnTable[RW5].MinisterThinking[CL5].TableListMinister[Ki5];
                                        Object OO = new Object();
                                        lock (OO)
                                        {
                                            if (Order == 1)
                                            {

                                            }
                                            else//If Order is Brown.
                                            {

                                            }
                                        }
                                    }
                                }
                            }
                        }

                    Order = DummyOrder;
                    ChessRules.CurrentOrder = DummyCurrentOrder;

                    Order = DummyOrder;
                    ChessRules.CurrentOrder = DummyCurrentOrder;
                }
                Order = DummyOrder;
                ChessRules.CurrentOrder = DummyCurrentOrder;
                for (i = KingMidle; i < KingHigh; i++)
                {
                    for (int k = 0; k < AllDraw.KingMovments; k++)
                        for (j = 0; KingOnTable != null && KingOnTable[i] != null && KingOnTable != null && KingOnTable[i] != null && KingOnTable[i].KingThinking[k] != null && KingOnTable[i].KingThinking[k] != null && j < KingOnTable[i].KingThinking[k].TableListKing.Count; j++)
                        {
                            int CDummy = ChessRules.CurrentOrder;
                            int COrder = Order;
                            ChessRules.CurrentOrder *= -1;
                            Order *= -1;
                            Do = 0;
                            if (UsePenaltyRegardMechnisamT)
                            {
                                for (int ij = 0; ij < KingOnTable[i].KingThinking[k].AStarGreedy.Count - 1; ij++)
                                    KingOnTable[i].KingThinking[k].AStarGreedy[ij].IsPenaltyRegardCheckMateAtBranch(Order, ref Do, KingOnTable[i].KingThinking[k].AStarGreedy[ij]);
                                Order = COrder;
                                ChessRules.CurrentOrder = CDummy;
                                ToCheckMate = -1; ForCheckMate = -1; AA = IsToCheckMateHasLessDeeperThanForCheckMate(this, Order, ref ToCheckMate, ref ForCheckMate, 0); if (Do == -1)
                                    continue;
                            }

                            Order = COrder;
                            ChessRules.CurrentOrder = CDummy;
                            if ((KingOnTable[i].KingThinking[k].PenaltyRegardListKing[j].IsPenaltyAction() != 0 && KingOnTable[i].KingThinking[k].PenaltyRegardListKing[j].IsRewardAction() == 1 && AStarGreedyi == 1) || ((Do == 1 || AA) && UsePenaltyRegardMechnisamT))
                            {
                                Object On = new Object();
                                lock (On)
                                {
                                    AllDraw.LastRow = KingOnTable[i].KingThinking[k].Row;
                                    AllDraw.LastColumn = KingOnTable[i].KingThinking[k].Column;
                                    AllDraw.NextRow = KingOnTable[i].KingThinking[k].RowColumnKing[j][0];
                                    AllDraw.NextColumn = KingOnTable[i].KingThinking[k].RowColumnKing[j][1];

                                    Act = true;
                                    Less = KingOnTable[i].KingThinking[k].NumberOfPenalties;
                                }
                                TableHeuristic = KingOnTable[i].KingThinking[k].TableListKing[j];
                                RegardOccurred = true;
                                continue;
                            }
                            Object ol = new Object();
                            lock (ol)
                            {
                                //When There is No Movments in Such Order Enemy continue.
                                if (Order != AllDraw.OrderPlateDraw)
                                    if (KingOnTable[i].KingThinking[0].NumberOfPenalties < Less)
                                        continue;

                                //When There is greater Heuristic Movments.
                                if (KingOnTable[i].KingThinking[0].NumberOfPenalties < Less)
                                //retrive table of current Heuristic.
                                {

                                    //retrive table of current Heuristic.
                                    int[,] TableS = KingOnTable[i].KingThinking[k].TableListKing[j];
                                    //checked for Legal Movments ArgumentOutOfRangeException curnt game.
                                    if (DynamicAStarGreedytPrograming && !CurrentTableHeuristic && AStarGreedyi == 1)
                                    {
                                        if (!IsEnemyThingsinStable(CloneATable(TableS), AllDraw.TableListAction[AllDraw.TableListAction.Count - 1], AllDraw.OrderPlate))
                                            continue;

                                    }
                                    //When there is not Penalty regard mechanism.
                                    AB = new ChessRules(CurrentAStarGredyMax, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged, 6, CloneATable(TableS), Order, KingOnTable[i].KingThinking[k].Row, KingOnTable[i].KingThinking[k].Column);
                                    //If there is kish or kshachamaz Order.
                                    if (AB.Check(CloneATable(TableS), Order))
                                    {
                                        //When Order is Gray.
                                        if (Order == 1)
                                        {
                                            //Continue When is kish CheckObjectDangour and AStarGreadyFirstSearch .
                                            if (AB.CheckGray)
                                                continue;
                                        }
                                        else
                                        {
                                            //Continue when CheckBrown and AStarGreadyFirstSearch. 
                                            if (AB.CheckBrown)
                                                continue;
                                        }
                                    }

                                    RW6 = i;
                                    CL6 = k;
                                    Ki6 = j;
                                    RW1 = -1;
                                    CL1 = -1;
                                    Ki1 = -1;
                                    RW2 = -1;
                                    CL2 = -1;
                                    Ki2 = -1;
                                    RW3 = -1;
                                    CL3 = -1;
                                    Ki3 = -1;
                                    RW4 = -1;
                                    CL4 = -1;
                                    Ki4 = -1;
                                    RW5 = -1;
                                    CL5 = -1;
                                    Ki5 = -1;
                                    MaxLess6 = (KingOnTable[RW6].KingThinking[CL6].NumberOfPenalties);
                                    if (MaxLess6 > MaxLess1)
                                        MaxLess1 = -1;
                                    if (MaxLess6 > MaxLess2)
                                        MaxLess2 = -1;
                                    if (MaxLess6 > MaxLess3)
                                        MaxLess3 = -1;
                                    if (MaxLess6 > MaxLess4)
                                        MaxLess4 = -1;
                                    if (MaxLess6 > MaxLess5)
                                        MaxLess5 = -1;
                                    if (AStarGreedyi == 1)
                                    {
                                        Object OO = new Object();
                                        lock (OO)
                                        {
                                            if (Order == 1)
                                            {

                                            }
                                            else//If Order is Brown.
                                            {

                                            }
                                        }
                                        Object On = new Object();
                                        lock (On)
                                        {
                                            AllDraw.LastRow = KingOnTable[i].KingThinking[k].Row;
                                            AllDraw.LastColumn = KingOnTable[i].KingThinking[k].Column;
                                            AllDraw.NextRow = KingOnTable[i].KingThinking[k].RowColumnKing[j][0];
                                            AllDraw.NextColumn = KingOnTable[i].KingThinking[k].RowColumnKing[j][1];
                                        }
                                        Act = true;
                                        Less = KingOnTable[i].KingThinking[k].NumberOfPenalties;
                                        TableHeuristic = KingOnTable[i].KingThinking[k].TableListKing[j];
                                    }
                                }
                                else//Set Table and Heuristic Value and Syntax.
                                {
                                    if (AStarGreedyi == 1)
                                    {

                                        //Found of Max Non Probable Movments.
                                        Founded.Clear();
                                        int LessB = Int32.MinValue;
                                        BeginIndexFoundingMaxLessofMaxList(0, Founded, ref LessB);
                                        if (Founded[0] != 1)
                                            continue;
                                        RW6 = (int)MaxHeuristicAStarGreedytBackWard[0][(int)Founded[0]];
                                        CL6 = (int)MaxHeuristicAStarGreedytBackWard[0][(int)Founded[0] + 1];
                                        Ki6 = (int)MaxHeuristicAStarGreedytBackWard[0][(int)Founded[0] + 2];
                                        if (Founded[0] != MaxKingFounded)
                                            continue;
                                        Object On = new Object();
                                        lock (On)
                                        {
                                            AllDraw.LastRow = KingOnTable[RW6].KingThinking[CL6].Row;
                                            AllDraw.LastColumn = KingOnTable[RW6].KingThinking[CL6].Column;
                                            AllDraw.NextRow = KingOnTable[i].KingThinking[k].RowColumnKing[j][0];
                                            AllDraw.NextColumn = KingOnTable[i].KingThinking[k].RowColumnKing[j][1];
                                        }
                                        Act = true;
                                        Less = KingOnTable[RW6].KingThinking[CL6].ReturnHeuristic(RW6, Ki6, Order, false, ref HaveKilled);
                                        TableHeuristic = KingOnTable[RW6].KingThinking[CL6].TableListKing[Ki6];
                                        Object OO = new Object();
                                        lock (OO)
                                        {
                                            if (Order == 1)
                                            {

                                            }
                                            else//If Order is Brown.
                                            {

                                            }
                                        }
                                    }
                                }
                            }
                        }

                    Order = DummyOrder;
                    ChessRules.CurrentOrder = DummyCurrentOrder;

                    Order = DummyOrder;
                    ChessRules.CurrentOrder = DummyCurrentOrder;
                }

                return TableHeuristic;
            }
        }
        //AStarGreedy First Heuristic Method.
      */
        public int[,] HeuristicAStarGreedySearch(int AStarGreedyi, Color a, int Order, bool CurrentTableHeuristic)
        {

            Object O = new Object();
            lock (O)
            {
                int[,] TableHeuristic = new int[8, 8];
                AStarGreedyi++;
                int DummyOrder = Order;
                int DummyCurrentOrder = ChessRules.CurrentOrder;
                //Initiate For Dynamic Backward Current AStarGreedyi Non Minus Founded Max Movments Detection Global Variables.
                List<int> Founded = new List<int>();
                //Initiateing Indicating Heuristic Multiple Same Value Best Found of Movments.
                MaxLess1 = -1;
                MaxLess2 = -1;
                MaxLess3 = -1;
                MaxLess4 = -1;
                MaxLess5 = -1;
                MaxLess6 = -1;
                RW1 = -1;
                CL1 = -1;
                Ki1 = -1;
                RW2 = -1;
                CL2 = -1;
                Ki2 = -1;
                RW3 = -1;
                CL3 = -1;
                Ki3 = -1;
                RW4 = -1;
                CL4 = -1;
                Ki4 = -1;
                RW5 = -1;
                CL5 = -1;
                Ki5 = -1;
                RW6 = -1;
                CL6 = -1;
                Ki6 = -1;
                int[] BacWard = new int[25];
                Object Omm = new Object();
                lock (Omm)
                {
                    //if (AStarGreedyi > MaxAStarGreedy)
                    //return TableHeuristic;
                }
                bool Act = false;
                if (Order == 1)
                {
                    bool Ac = Act;
                    int[,] Ta = TableHeuristic;
                    var ah = Task.Factory.StartNew(() => Ta = HeuristicAStarGreadySearchGray(AStarGreedyi, a, Order, CurrentTableHeuristic, ref Ac));
                    ah.Wait();
                    ah.Dispose();
                    Act = Ac;
                    TableHeuristic = Ta;
                }
                else
                {
                    bool Ac = Act;
                    int[,] Ta = TableHeuristic;
                    var ah = Task.Factory.StartNew(() => Ta = HeuristicAStarGreadySearchBrown(AStarGreedyi, a, Order, CurrentTableHeuristic, ref Ac));
                    ah.Wait();
                    ah.Dispose();
                    Act = Ac;
                    TableHeuristic = Ta;
                }
                Order = DummyOrder;
                ChessRules.CurrentOrder = DummyCurrentOrder;
                //Store In Local Variable and Dynamic Purpose Proccessing.
                //Every Non Minuse Non Idept in List Has Gretest Max Order.
                //Is Desired of Idept Oner Best Movments.
                BacWard[0] = AStarGreedyi;
                BacWard[1] = MaxLess1;
                BacWard[2] = RW1;
                BacWard[3] = RW1;
                BacWard[4] = Ki1;

                BacWard[5] = MaxLess2;
                BacWard[6] = RW2;
                BacWard[7] = RW2;
                BacWard[8] = Ki2;
                BacWard[9] = MaxLess3;
                BacWard[10] = RW3;
                BacWard[11] = RW3;
                BacWard[12] = Ki3;
                BacWard[13] = MaxLess4;
                BacWard[14] = RW4;
                BacWard[15] = RW4;
                BacWard[16] = Ki4;
                BacWard[17] = MaxLess5;
                BacWard[18] = RW5;
                BacWard[19] = RW5;
                BacWard[20] = Ki5;
                BacWard[21] = MaxLess6;
                BacWard[22] = RW6;
                BacWard[23] = RW6;
                BacWard[24] = Ki6;
                //We Have Information of Maximum of Heuristic in Each Level and Table.
                MaxHeuristicAStarGreedytBackWard.Add(BacWard);
                MaxHeuristicAStarGreedytBackWardTable.Add(TableHeuristic);
                Founded.Clear();
                //If Found retrun table.
                if (Act)
                    return TableHeuristic;
                //Return what found table.

                return TableHeuristic;
            }
        }
        /*    public int[,] HeuristicAStarGreedySearchPenalties(int AStarGreedyi, Color a, int Order, bool CurrentTableHeuristic)
            {

                Object O = new Object();
                lock (O)
                {
                    int[,] TableHeuristic = new int[8, 8];
                    AStarGreedyi++;
                    int DummyOrder = Order;
                    int DummyCurrentOrder = ChessRules.CurrentOrder;
                    //Initiate For Dynamic Backward Current AStarGreedyi Non Minus Founded Max Movments Detection Global Variables.
                    List<int> Founded = new List<int>();
                    //Initiateing Indicating Heuristic Multiple Same Value Best Found of Movments.
                    MaxLess1 = -1;
                    MaxLess2 = -1;
                    MaxLess3 = -1;
                    MaxLess4 = -1;
                    MaxLess5 = -1;
                    MaxLess6 = -1;
                    RW1 = -1;
                    CL1 = -1;
                    Ki1 = -1;
                    RW2 = -1;
                    CL2 = -1;
                    Ki2 = -1;
                    RW3 = -1;
                    CL3 = -1;
                    Ki3 = -1;
                    RW4 = -1;
                    CL4 = -1;
                    Ki4 = -1;
                    RW5 = -1;
                    CL5 = -1;
                    Ki5 = -1;
                    RW6 = -1;
                    CL6 = -1;
                    Ki6 = -1;
                    int[] BacWard = new int[25];
                    Object Omm = new Object();
                    lock (Omm)
                    {
                        if (AStarGreedyi > MaxAStarGreedy)
                            return TableHeuristic;
                    }
                    bool Act = false;
                    if (Order == 1)
                    {
                        TableHeuristic = HeuristicAStarGreadySearchPenalties(AStarGreedyi, a, Order, CurrentTableHeuristic, ref Act);
                    }
                    else
                    {
                        TableHeuristic = BrownHeuristicAStarGreaedySearchPenalites(AStarGreedyi, a, Order, CurrentTableHeuristic, ref Act);
                    }
                    Order = DummyOrder;
                    ChessRules.CurrentOrder = DummyCurrentOrder;
                    //Store In Local Variable and Dynamic Purpose Proccessing.
                    //Every Non Minuse Non Idept in List Has Gretest Max Order.
                    //Is Desired of Idept Oner Best Movments.
                    BacWard[0] = AStarGreedyi;
                    BacWard[1] = MaxLess1;
                    BacWard[2] = RW1;
                    BacWard[3] = RW1;
                    BacWard[4] = Ki1;

                    BacWard[5] = MaxLess2;
                    BacWard[6] = RW2;
                    BacWard[7] = RW2;
                    BacWard[8] = Ki2;
                    BacWard[9] = MaxLess3;
                    BacWard[10] = RW3;
                    BacWard[11] = RW3;
                    BacWard[12] = Ki3;
                    BacWard[13] = MaxLess4;
                    BacWard[14] = RW4;
                    BacWard[15] = RW4;
                    BacWard[16] = Ki4;
                    BacWard[17] = MaxLess5;
                    BacWard[18] = RW5;
                    BacWard[19] = RW5;
                    BacWard[20] = Ki5;
                    BacWard[21] = MaxLess6;
                    BacWard[22] = RW6;
                    BacWard[23] = RW6;
                    BacWard[24] = Ki6;
                    //We Have Information of Maximum of Heuristic in Each Level and Table.
                    MaxHeuristicAStarGreedytBackWard.Add(BacWard);
                    MaxHeuristicAStarGreedytBackWardTable.Add(TableHeuristic);
                    Founded.Clear();

                    //If Found retrun table.
                    if (Act)
                        return TableHeuristic;
                    //Return what found table.
                    return TableHeuristic;
                }
            }
            //Genethic Algorithm Game Method.
        */
        public void InitiateGenetic(int ii, int jj, Color a, int[,] Table, int Order, bool TB)
        {

            Object O = new Object();
            lock (O)
            {
                //Initiate Local and Global Variables.
                int Current = ChessRules.CurrentOrder;
                int DummyOrder = Order;
                TableList.Add(CloneATable(Table));

                Object OO = new Object();
                lock (OO)
                {
                    ThinkingRefrigtzChessPortable.NotSolvedKingDanger = false;
                }
                LoopHeuristicIndex = 0;
                //For One time.
                for (var i = 0; i < 1; i++)
                {
                    //If Order is Gray.
                    Object O2 = new Object();
                    lock (O2)
                    {
                        if (Order == 1)
                        {

                        }
                        else//If Order is Brown.
                        {


                        }
                    }
                    //Initiate Local Variables.
                    int[,] TablInit = new int[8, 8];
                    if (Order == 1)
                        a = Color.Gray;
                    else
                        a = Color.Brown;
                    int In = 0;
                    //Found Of Random Movments.
                    do
                    {
                        if (Order == 1)
                            In = (new System.Random()).Next(0, 8);
                        else
                            In = (new System.Random()).Next(8, 16);
                    } while (SolderesOnTable[In] == null);

                    //If Order is Gray.
                    Object OOO = new Object();
                    lock (OOO)
                    {
                        if (Order == 1)
                        {

                        }
                        else//If Order is Brown.
                        {


                        }
                    }
                    //Found Of Genetic Algorithm Movments By GeneticAlgorithm Call Objectsand Method.
                    RefrigtzChessPortableGeneticAlgorithm R = (new RefrigtzChessPortableGeneticAlgorithm(MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged));
                    //Found Table.
                    int[,] Tab = R.GenerateTable(TableListAction, 0, Order);
                    //If Order is Gray.
                    Object OOO1 = new Object();
                    lock (OOO1)
                    {
                        if (Order == 1)
                        {

                        }
                        else//If Order is Brown.
                        {


                        }
                    }
                    //If Table Found.
                    if (Tab != null)
                    {
                        //Construct a Clone Copy of Table.
                        for (var iii = 0; iii < 8; iii++)
                            for (var jjj = 0; jjj < 8; jjj++)
                            {
                                TablInit[iii, jjj] = Tab[iii, jjj];
                            }
                        //Initiate a Table.
                        Table = new int[8, 8];
                        //Construct a Clone Copy of Table.
                        for (var iii = 0; iii < 8; iii++)
                            for (var jjj = 0; jjj < 8; jjj++)
                            {
                                Table[iii, jjj] = TablInit[iii, jjj];
                            }
                        //Initiate Local and Global Varibales.
                        TableList.Add(CloneATable(TablInit));
                        ClList.Add(CL);
                        RWList.Add(RW);
                        KiList.Add(Ki);


                        AStarGreedy++;

                    }
                }
            //Determination of CheckMate Consideration.
            (new ChessRules(CurrentAStarGredyMax, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged, 1, CloneATable(Table), Order, -1, -1)).CheckMate(CloneATable(Table), Order);
                //Reconstruction of Order Global Varibales.
                Order = DummyOrder;
                ChessRules.CurrentOrder = Current;

            }
        }
        //AStarGreedy First Initiat Thinking Main Method.
        public AllDraw InitiateAStarGreedytOneNode(int iAStarGreedy, int ii, int jj, Color a, int[,] Tab, int Order, int iIndex, int KindIndex, int LeafAStarGreedy
            )
        {

            {
                var ah = Task.Factory.StartNew(() => SetObjectNumbers(Tab));
                ah.Wait();
                ah.Dispose();


                int[,] Table = new int[8, 8];
                for (var iii = 0; iii < 8; iii++)
                    for (var jjj = 0; jjj < 8; jjj++)
                        Table[iii, jjj] = Tab[iii, jjj];
                Object O = new Object();
                lock (O)
                {
                    ThinkingRefrigtzChessPortable.BeginThread = 0;
                    ThinkingRefrigtzChessPortable.EndThread = 0;
                }
                //Initiate of global Variables Byte Local Variables.
                int DummyOrder = new int();
                DummyOrder = Order;
                int DummyCurrentOrder = new int();
                DummyCurrentOrder = ChessRules.CurrentOrder;
                int[,] TablInit = new int[8, 8];
                if (Order == 1)
                    a = Color.Gray;
                else
                    a = Color.Brown;
                var j = 0;
                Object Omm = new Object();
                lock (Omm)
                {
                    if (iAStarGreedy >= MaxAStarGreedy)
                        return null;
                }



                //If Order is Gray.
                if (Order == 1)
                {
                    //For Gray Soldeirs Objects. 

                    if (KindIndex == 1)
                    {
                        Order = DummyOrder;
                        ChessRules.CurrentOrder = DummyCurrentOrder;
                        //If Solders Not Exist Continue and Traversal Back.
                        //If There is no Thinking Movments on Current Object  

                        bool ASS = false; Object OOOAAA = new Object(); lock (OOOAAA)
                        { ASS = AllDraw.Blitz; }
                        if (!ASS)
                        {
                            //Thinking of Gray Solder Operation.
                            SolderesOnTable[iIndex].SoldierThinking[0].ThinkingBegin = true;
                            SolderesOnTable[iIndex].SoldierThinking[0].ThinkingFinished = false;
                            int[] Lose = SolderesOnTable[iIndex].LoseOcuuredatChiled;
                            int Win = SolderesOnTable[iIndex].WinOcuuredatChiled;
                            var ah1 = Task.Factory.StartNew(() => SolderesOnTable[iIndex].SoldierThinking[0].Thinking(iAStarGreedy, this, ref Lose, ref Win));
                            ah1.Wait();
                            ah1.Dispose();
                            SolderesOnTable[iIndex].LoseOcuuredatChiled[0] = Lose[0];
                            SolderesOnTable[iIndex].LoseOcuuredatChiled[1] = Lose[1];
                            SolderesOnTable[iIndex].LoseOcuuredatChiled[2] = Lose[2];
                            SolderesOnTable[iIndex].WinOcuuredatChiled = Win;

                        }
                        else if (ASS)
                        //If There is A Soldeir Movments.                                   
                        {
                            //Thinking of Gray Soldeir Operations.
                            SolderesOnTable[iIndex].SoldierThinking[0].ThinkingBegin = true;
                            SolderesOnTable[iIndex].SoldierThinking[0].ThinkingFinished = false;
                            int[] Lose = SolderesOnTable[iIndex].LoseOcuuredatChiled;
                            int Win = SolderesOnTable[iIndex].WinOcuuredatChiled;
                            var ah1 = Task.Factory.StartNew(() => SolderesOnTable[iIndex].SoldierThinking[0].Thinking(iAStarGreedy, this, ref Lose, ref Win));
                            ah1.Wait();
                            ah1.Dispose();
                            SolderesOnTable[iIndex].LoseOcuuredatChiled[0] = Lose[0];
                            SolderesOnTable[iIndex].LoseOcuuredatChiled[1] = Lose[1];
                            SolderesOnTable[iIndex].LoseOcuuredatChiled[2] = Lose[2];
                            SolderesOnTable[iIndex].WinOcuuredatChiled = Win;
                        }
                    }
                    //Progressing.
                    //For All Gray Elephant Objects.
                    if (KindIndex == 2)
                    {
                        Order = DummyOrder;
                        ChessRules.CurrentOrder = DummyCurrentOrder;
                        //Ignore of Non Exist Current Elephant Gray Objects.
                        bool ASS = false; Object OOOAAA = new Object(); lock (OOOAAA)
                        { ASS = AllDraw.Blitz; }
                        if (!ASS)
                        {
                            //Operational Thinking Gray Elephant. 
                            ElephantOnTable[iIndex].ElefantThinking[0].ThinkingBegin = true;
                            ElephantOnTable[iIndex].ElefantThinking[0].ThinkingFinished = false;
                            int[] Lose = ElephantOnTable[iIndex].LoseOcuuredatChiled;
                            int Win = ElephantOnTable[iIndex].WinOcuuredatChiled;
                            var ah1 = Task.Factory.StartNew(() => ElephantOnTable[iIndex].ElefantThinking[0].Thinking(iAStarGreedy, this, ref Lose, ref Win));
                            ah1.Wait();
                            ah1.Dispose();
                            ElephantOnTable[iIndex].LoseOcuuredatChiled[0] = Lose[0];
                            ElephantOnTable[iIndex].LoseOcuuredatChiled[1] = Lose[1];
                            ElephantOnTable[iIndex].LoseOcuuredatChiled[2] = Lose[2];
                            ElephantOnTable[iIndex].WinOcuuredatChiled = Win;
                        }//If There is Movment Thinking Gary Elphant Object List.
                        else if (ASS)
                        {
                            //For Every Gray Elephant Thinking Movments.
                            //Gray Elephant Object Thinking Operations.
                            ElephantOnTable[iIndex].ElefantThinking[0].ThinkingBegin = true;
                            ElephantOnTable[iIndex].ElefantThinking[0].ThinkingFinished = false;
                            int[] Lose = ElephantOnTable[iIndex].LoseOcuuredatChiled;
                            int Win = ElephantOnTable[iIndex].WinOcuuredatChiled;
                            var ah1 = Task.Factory.StartNew(() => ElephantOnTable[iIndex].ElefantThinking[0].Thinking(iAStarGreedy, this, ref Lose, ref Win));
                            ah1.Wait();
                            ah1.Dispose();
                            ElephantOnTable[iIndex].LoseOcuuredatChiled[0] = Lose[0];
                            ElephantOnTable[iIndex].LoseOcuuredatChiled[1] = Lose[1];
                            ElephantOnTable[iIndex].LoseOcuuredatChiled[2] = Lose[2];
                            ElephantOnTable[iIndex].WinOcuuredatChiled = Win;
                        }
                    }
                    //Progressing.
                    //For All Gray Hourse Objects.
                    if (KindIndex == 3)
                    {
                        Order = DummyOrder;
                        ChessRules.CurrentOrder = DummyCurrentOrder;
                        bool ASS = false; Object OOOAAA = new Object(); lock (OOOAAA)
                        { ASS = AllDraw.Blitz; }
                        if (!ASS)
                        {
                            //Thinking of Gray Hourse Oprational.
                            HoursesOnTable[iIndex].HourseThinking[0].ThinkingBegin = true;
                            HoursesOnTable[iIndex].HourseThinking[0].ThinkingFinished = false;
                            int[] Lose = HoursesOnTable[iIndex].LoseOcuuredatChiled;
                            int Win = HoursesOnTable[iIndex].WinOcuuredatChiled;
                            var ah1 = Task.Factory.StartNew(() => HoursesOnTable[iIndex].HourseThinking[0].Thinking(iAStarGreedy, this, ref Lose, ref Win));
                            ah1.Wait();
                            ah1.Dispose();
                            HoursesOnTable[iIndex].LoseOcuuredatChiled[0] = Lose[0];
                            HoursesOnTable[iIndex].LoseOcuuredatChiled[1] = Lose[1];
                            HoursesOnTable[iIndex].LoseOcuuredatChiled[2] = Lose[2];
                            HoursesOnTable[iIndex].WinOcuuredatChiled = Win;
                        }
                        else if (ASS)//If Table List Exist int The Thinking.
                        {
                            //Thinking Operation of Gray Hourse.
                            HoursesOnTable[iIndex].HourseThinking[0].TableT = HoursesOnTable[iIndex].HourseThinking[0].TableListHourse[j];
                            HoursesOnTable[iIndex].HourseThinking[0].ThinkingBegin = true;
                            HoursesOnTable[iIndex].HourseThinking[0].ThinkingFinished = false;
                            int[] Lose = HoursesOnTable[iIndex].LoseOcuuredatChiled;
                            int Win = HoursesOnTable[iIndex].WinOcuuredatChiled;
                            var ah1 = Task.Factory.StartNew(() => HoursesOnTable[iIndex].HourseThinking[0].Thinking(iAStarGreedy, this, ref Lose, ref Win));
                            ah1.Wait();
                            ah1.Dispose();
                            HoursesOnTable[iIndex].LoseOcuuredatChiled[0] = Lose[0];
                            HoursesOnTable[iIndex].LoseOcuuredatChiled[1] = Lose[1];
                            HoursesOnTable[iIndex].LoseOcuuredatChiled[2] = Lose[2];
                            HoursesOnTable[iIndex].WinOcuuredatChiled = Win;
                        }
                    }
                    //Progressing.

                    if (KindIndex == 4)
                    {
                        Order = DummyOrder;
                        ChessRules.CurrentOrder = DummyCurrentOrder;
                        bool ASS = false; Object OOOAAA = new Object(); lock (OOOAAA)
                        { ASS = AllDraw.Blitz; }
                        if (!ASS)
                        {
                            //When There is Possible Thinking Castle of Gray Table
                            //Thinking of Gray Castles Operational.
                            CastlesOnTable[iIndex].CastleThinking[0].ThinkingBegin = true;
                            CastlesOnTable[iIndex].CastleThinking[0].ThinkingFinished = false;
                            int[] Lose = CastlesOnTable[iIndex].LoseOcuuredatChiled;
                            int Win = CastlesOnTable[iIndex].WinOcuuredatChiled;
                            var ah1 = Task.Factory.StartNew(() => CastlesOnTable[iIndex].CastleThinking[0].Thinking(iAStarGreedy, this, ref Lose, ref Win));
                            ah1.Wait();
                            ah1.Dispose();
                            CastlesOnTable[iIndex].LoseOcuuredatChiled[0] = Lose[0];
                            CastlesOnTable[iIndex].LoseOcuuredatChiled[1] = Lose[1];
                            CastlesOnTable[iIndex].LoseOcuuredatChiled[2] = Lose[2];
                            CastlesOnTable[iIndex].WinOcuuredatChiled = Win;
                        }
                        else if (ASS)
                        {
                            //When There is Possible Thinking Castle of Gray Table
                            //Thinking of Gray Castles  Objective Movments.
                            CastlesOnTable[iIndex].CastleThinking[0].TableT = CastlesOnTable[iIndex].CastleThinking[0].TableListCastle[j];
                            CastlesOnTable[iIndex].CastleThinking[0].ThinkingBegin = true;
                            CastlesOnTable[iIndex].CastleThinking[0].ThinkingFinished = false;
                            CastlesOnTable[iIndex].CastleThinking[0].Thinking(iAStarGreedy, this, ref CastlesOnTable[iIndex].LoseOcuuredatChiled, ref CastlesOnTable[iIndex].WinOcuuredatChiled);
                        }
                    }
                    if (KindIndex == 5)
                    {
                        Order = DummyOrder;
                        ChessRules.CurrentOrder = DummyCurrentOrder;
                        bool ASS = false; Object OOOAAA = new Object(); lock (OOOAAA)
                        { ASS = AllDraw.Blitz; }
                        if (!ASS)
                        {//When There is Table Gray Minister Count of Thinking.
                         //Thinking of Gray Minister Operational.
                            MinisterOnTable[iIndex].MinisterThinking[0].ThinkingBegin = true;
                            MinisterOnTable[iIndex].MinisterThinking[0].ThinkingFinished = false;
                            int[] Lose = MinisterOnTable[iIndex].LoseOcuuredatChiled;
                            int Win = MinisterOnTable[iIndex].WinOcuuredatChiled;
                            var ah1 = Task.Factory.StartNew(() => MinisterOnTable[iIndex].MinisterThinking[0].Thinking(iAStarGreedy, this, ref Lose, ref Win));
                            ah1.Wait();
                            ah1.Dispose();
                            MinisterOnTable[iIndex].LoseOcuuredatChiled[0] = Lose[0];
                            MinisterOnTable[iIndex].LoseOcuuredatChiled[1] = Lose[1];
                            MinisterOnTable[iIndex].LoseOcuuredatChiled[2] = Lose[2];
                            MinisterOnTable[iIndex].WinOcuuredatChiled = Win;
                        }
                        else if (ASS)//When There is Table Gray Minister Count of Thinking.
                        {
                            //Thinking.
                            MinisterOnTable[iIndex].Table = MinisterOnTable[iIndex].MinisterThinking[0].TableListMinister[j];
                            MinisterOnTable[iIndex].MinisterThinking[0].ThinkingBegin = true;
                            MinisterOnTable[iIndex].MinisterThinking[0].ThinkingFinished = false;
                            int[] Lose = MinisterOnTable[iIndex].LoseOcuuredatChiled;
                            int Win = MinisterOnTable[iIndex].WinOcuuredatChiled;
                            var ah1 = Task.Factory.StartNew(() => MinisterOnTable[iIndex].MinisterThinking[0].Thinking(iAStarGreedy, this, ref Lose, ref Win));
                            ah1.Wait();
                            ah1.Dispose();
                            MinisterOnTable[iIndex].LoseOcuuredatChiled[0] = Lose[0];
                            MinisterOnTable[iIndex].LoseOcuuredatChiled[1] = Lose[1];
                            MinisterOnTable[iIndex].LoseOcuuredatChiled[2] = Lose[2];
                            MinisterOnTable[iIndex].WinOcuuredatChiled = Win;
                        }
                    }
                    if (KindIndex == 6)
                    {

                        Order = DummyOrder;
                        ChessRules.CurrentOrder = DummyCurrentOrder;
                        bool ASS = false; Object OOOAAA = new Object(); lock (OOOAAA)
                        { ASS = AllDraw.Blitz; }
                        if (!ASS)
                        {//When Thinking Gray King Count of Existing Operations.
                         //Thinking Of Gray King Operatins.
                            KingOnTable[iIndex].KingThinking[0].ThinkingBegin = true;
                            KingOnTable[iIndex].KingThinking[0].ThinkingFinished = false;
                            int[] Lose = KingOnTable[iIndex].LoseOcuuredatChiled;
                            int Win = KingOnTable[iIndex].WinOcuuredatChiled;
                            var ah1 = Task.Factory.StartNew(() => KingOnTable[iIndex].KingThinking[0].Thinking(iAStarGreedy, this, ref Lose, ref Win));
                            ah1.Wait();
                            ah1.Dispose();
                            KingOnTable[iIndex].LoseOcuuredatChiled[0] = Lose[0];
                            KingOnTable[iIndex].LoseOcuuredatChiled[1] = Lose[1];
                            KingOnTable[iIndex].LoseOcuuredatChiled[2] = Lose[2];
                            KingOnTable[iIndex].WinOcuuredatChiled = Win;
                        }
                        else if (ASS)//When Thinking Gray King Count of Existing Operations.
                        {
                            //Gray King Thinking Operations.                                        
                            KingOnTable[iIndex].KingThinking[0].ThinkingBegin = true;
                            KingOnTable[iIndex].KingThinking[0].ThinkingFinished = false;
                            int[] Lose = KingOnTable[iIndex].LoseOcuuredatChiled;
                            int Win = KingOnTable[iIndex].WinOcuuredatChiled;
                            var ah1 = Task.Factory.StartNew(() => KingOnTable[iIndex].KingThinking[0].Thinking(iAStarGreedy, this, ref Lose, ref Win));
                            ah1.Wait();
                            ah1.Dispose();
                            KingOnTable[iIndex].LoseOcuuredatChiled[0] = Lose[0];
                            KingOnTable[iIndex].LoseOcuuredatChiled[1] = Lose[1];
                            KingOnTable[iIndex].LoseOcuuredatChiled[2] = Lose[2];
                            KingOnTable[iIndex].WinOcuuredatChiled = Win;
                        }
                    }
                    if (KindIndex == 7 || KindIndex == -7)
                    {

                        Order = DummyOrder;
                        ChessRules.CurrentOrder = DummyCurrentOrder;
                        bool ASS = false; Object OOOAAA = new Object(); lock (OOOAAA)
                        { ASS = AllDraw.Blitz; }
                        if (!ASS)
                        {//When Thinking Gray King Count of Existing Operations.
                         //Thinking Of Gray King Operatins.
                            CastlingOnTable[iIndex].CastlingThinking[0].ThinkingBegin = true;
                            CastlingOnTable[iIndex].CastlingThinking[0].ThinkingFinished = false;
                            int[] Lose = CastlingOnTable[iIndex].LoseOcuuredatChiled;
                            int Win = CastlingOnTable[iIndex].WinOcuuredatChiled;
                            var ah1 = Task.Factory.StartNew(() => CastlingOnTable[iIndex].CastlingThinking[0].Thinking(iAStarGreedy, this, ref Lose, ref Win));
                            ah1.Wait();
                            ah1.Dispose();
                            CastlingOnTable[iIndex].LoseOcuuredatChiled[0] = Lose[0];
                            CastlingOnTable[iIndex].LoseOcuuredatChiled[1] = Lose[1];
                            CastlingOnTable[iIndex].LoseOcuuredatChiled[2] = Lose[2];
                            CastlingOnTable[iIndex].WinOcuuredatChiled = Win;
                        }
                        else if (ASS)//When Thinking Gray Castling Count of Existing Operations.
                        {
                            //Gray Castling Thinking Operations.                                        
                            CastlingOnTable[iIndex].CastlingThinking[0].ThinkingBegin = true;
                            CastlingOnTable[iIndex].CastlingThinking[0].ThinkingFinished = false;
                            int[] Lose = CastlingOnTable[iIndex].LoseOcuuredatChiled;
                            int Win = CastlingOnTable[iIndex].WinOcuuredatChiled;
                            var ah1 = Task.Factory.StartNew(() => CastlingOnTable[iIndex].CastlingThinking[0].Thinking(iAStarGreedy, this, ref Lose, ref Win));
                            ah1.Wait();
                            ah1.Dispose();
                            CastlingOnTable[iIndex].LoseOcuuredatChiled[0] = Lose[0];
                            CastlingOnTable[iIndex].LoseOcuuredatChiled[1] = Lose[1];
                            CastlingOnTable[iIndex].LoseOcuuredatChiled[2] = Lose[2];
                            CastlingOnTable[iIndex].WinOcuuredatChiled = Win;
                        }
                    }
                }
                else//Brown Order Considarations.
                {
                    if (KindIndex == -1)
                    {
                        Order = DummyOrder;
                        ChessRules.CurrentOrder = DummyCurrentOrder;
                        bool ASS = false; Object OOOAAA = new Object(); lock (OOOAAA)
                        { ASS = AllDraw.Blitz; }
                        if (!ASS)//When There is Current Brown Existing Objective Thinking Movments.
                        {
                            //Wheen Brown King Object There is Not Continue Traversal Back.
                            //Thinking Operations of Brown Current Objects.
                            SolderesOnTable[iIndex].SoldierThinking[0].ThinkingBegin = true;
                            SolderesOnTable[iIndex].SoldierThinking[0].ThinkingFinished = false;
                            int[] Lose = SolderesOnTable[iIndex].LoseOcuuredatChiled;
                            int Win = SolderesOnTable[iIndex].WinOcuuredatChiled;
                            var ah1 = Task.Factory.StartNew(() => SolderesOnTable[iIndex].SoldierThinking[0].Thinking(iAStarGreedy, this, ref Lose, ref Win));
                            ah1.Wait();
                            ah1.Dispose();
                            SolderesOnTable[iIndex].LoseOcuuredatChiled[0] = Lose[0];
                            SolderesOnTable[iIndex].LoseOcuuredatChiled[1] = Lose[1];
                            SolderesOnTable[iIndex].LoseOcuuredatChiled[2] = Lose[2];
                            SolderesOnTable[iIndex].WinOcuuredatChiled = Win;
                        }
                        else if (ASS)//When There is Current Brown Existing Objective Thinking Movments.
                        {
                            //Thinking of Thinking Brown CurrentTable Objective Operations.
                            SolderesOnTable[iIndex].SoldierThinking[0].ThinkingBegin = true;
                            SolderesOnTable[iIndex].SoldierThinking[0].ThinkingFinished = false;
                            int[] Lose = SolderesOnTable[iIndex].LoseOcuuredatChiled;
                            int Win = SolderesOnTable[iIndex].WinOcuuredatChiled;
                            var ah1 = Task.Factory.StartNew(() => SolderesOnTable[iIndex].SoldierThinking[0].Thinking(iAStarGreedy, this, ref Lose, ref Win));
                            ah1.Wait();
                            ah1.Dispose();
                            SolderesOnTable[iIndex].LoseOcuuredatChiled[0] = Lose[0];
                            SolderesOnTable[iIndex].LoseOcuuredatChiled[1] = Lose[1];
                            SolderesOnTable[iIndex].LoseOcuuredatChiled[2] = Lose[2];
                            SolderesOnTable[iIndex].WinOcuuredatChiled = Win;
                        }
                    }
                    if (KindIndex == -2)
                    {
                        bool ASS = false; Object OOOAAA = new Object(); lock (OOOAAA)
                        { ASS = AllDraw.Blitz; }
                        if (!ASS)
                        {//When There is Current Brown Existing Objective Thinking Movments.
                            Order = DummyOrder;
                            ChessRules.CurrentOrder = DummyCurrentOrder;
                            //Thinking Operations of Brown Current Objects.
                            ElephantOnTable[iIndex].ElefantThinking[0].ThinkingBegin = true;
                            ElephantOnTable[iIndex].ElefantThinking[0].ThinkingFinished = false;
                            int[] Lose = ElephantOnTable[iIndex].LoseOcuuredatChiled;
                            int Win = ElephantOnTable[iIndex].WinOcuuredatChiled;
                            var ah1 = Task.Factory.StartNew(() => ElephantOnTable[iIndex].ElefantThinking[0].Thinking(iAStarGreedy, this, ref Lose, ref Win));
                            ah1.Wait();
                            ah1.Dispose();
                            ElephantOnTable[iIndex].LoseOcuuredatChiled[0] = Lose[0];
                            ElephantOnTable[iIndex].LoseOcuuredatChiled[1] = Lose[1];
                            ElephantOnTable[iIndex].LoseOcuuredatChiled[2] = Lose[2];
                            ElephantOnTable[iIndex].WinOcuuredatChiled = Win;
                        }
                        else if (ASS)//When There is Current Brown Existing Objective Thinking Movments.
                        {
                            //Inititae Local Varibale By Global Gray Elephant Objects Varibales.
                            //Thinking of Thinking Brown CurrentTable Objective Operations.                                                   
                            ElephantOnTable[iIndex].ElefantThinking[0].ThinkingBegin = true;
                            ElephantOnTable[iIndex].ElefantThinking[0].ThinkingFinished = false;
                            int[] Lose = ElephantOnTable[iIndex].LoseOcuuredatChiled;
                            int Win = ElephantOnTable[iIndex].WinOcuuredatChiled;
                            var ah1 = Task.Factory.StartNew(() => ElephantOnTable[iIndex].ElefantThinking[0].Thinking(iAStarGreedy, this, ref Lose, ref Win));
                            ah1.Wait();
                            ah1.Dispose();
                            ElephantOnTable[iIndex].LoseOcuuredatChiled[0] = Lose[0];
                            ElephantOnTable[iIndex].LoseOcuuredatChiled[1] = Lose[1];
                            ElephantOnTable[iIndex].LoseOcuuredatChiled[2] = Lose[2];
                            ElephantOnTable[iIndex].WinOcuuredatChiled = Win;
                        }
                    }

                    if (KindIndex == -3)
                    {
                        Order = DummyOrder;
                        ChessRules.CurrentOrder = DummyCurrentOrder;
                        bool ASS = false; Object OOOAAA = new Object(); lock (OOOAAA)
                        { ASS = AllDraw.Blitz; }
                        if (!ASS)
                        {//When There is Current Brown Existing Objective Thinking Movments.
                         //Thinking Operations of Brown Current Objects.

                            HoursesOnTable[iIndex].HourseThinking[0].ThinkingBegin = true;
                            HoursesOnTable[iIndex].HourseThinking[0].ThinkingFinished = false;
                            int[] Lose = HoursesOnTable[iIndex].LoseOcuuredatChiled;
                            int Win = HoursesOnTable[iIndex].WinOcuuredatChiled;
                            var ah1 = Task.Factory.StartNew(() => HoursesOnTable[iIndex].HourseThinking[0].Thinking(iAStarGreedy, this, ref Lose, ref Win));
                            ah1.Wait();
                            ah1.Dispose();
                            HoursesOnTable[iIndex].LoseOcuuredatChiled[0] = Lose[0];
                            HoursesOnTable[iIndex].LoseOcuuredatChiled[1] = Lose[1];
                            HoursesOnTable[iIndex].LoseOcuuredatChiled[2] = Lose[2];
                            HoursesOnTable[iIndex].WinOcuuredatChiled = Win;
                        }
                        else if (ASS)//When There is Current Brown Existing Objective Thinking Movments.
                        {

                            HoursesOnTable[iIndex].HourseThinking[0].ThinkingBegin = true;
                            HoursesOnTable[iIndex].HourseThinking[0].ThinkingFinished = false;
                            int[] Lose = HoursesOnTable[iIndex].LoseOcuuredatChiled;
                            int Win = HoursesOnTable[iIndex].WinOcuuredatChiled;
                            var ah1 = Task.Factory.StartNew(() => HoursesOnTable[iIndex].HourseThinking[0].Thinking(iAStarGreedy, this, ref Lose, ref Win));
                            ah1.Wait();
                            ah1.Dispose();
                            HoursesOnTable[iIndex].LoseOcuuredatChiled[0] = Lose[0];
                            HoursesOnTable[iIndex].LoseOcuuredatChiled[1] = Lose[1];
                            HoursesOnTable[iIndex].LoseOcuuredatChiled[2] = Lose[2];
                            HoursesOnTable[iIndex].WinOcuuredatChiled = Win;

                        }
                    }
                    //Progressing.


                    if (KindIndex == -4)
                    {
                        Order = DummyOrder;
                        ChessRules.CurrentOrder = DummyCurrentOrder;
                        bool ASS = false; Object OOOAAA = new Object(); lock (OOOAAA)
                        { ASS = AllDraw.Blitz; }
                        if (!ASS)
                        {//When There is Current Brown Existing Objective Thinking Movments.
                         //Thinking Operations of Brown Current Objects.
                            CastlesOnTable[iIndex].CastleThinking[0].ThinkingBegin = true;
                            CastlesOnTable[iIndex].CastleThinking[0].ThinkingFinished = false;
                            int[] Lose = CastlesOnTable[iIndex].LoseOcuuredatChiled;
                            int Win = CastlesOnTable[iIndex].WinOcuuredatChiled;
                            var ah1 = Task.Factory.StartNew(() => CastlesOnTable[iIndex].CastleThinking[0].Thinking(iAStarGreedy, this, ref Lose, ref Win));
                            ah1.Wait();
                            ah1.Dispose();
                            CastlesOnTable[iIndex].LoseOcuuredatChiled[0] = Lose[0];
                            CastlesOnTable[iIndex].LoseOcuuredatChiled[1] = Lose[1];
                            CastlesOnTable[iIndex].LoseOcuuredatChiled[2] = Lose[2];
                            CastlesOnTable[iIndex].WinOcuuredatChiled = Win;
                        }
                        else if (ASS)//When There is Current Brown Existing Objective Thinking Movments.
                        {
                            //Thinking of Thinking Brown CurrentTable Objective Operations.        
                            CastlesOnTable[iIndex].CastleThinking[0].ThinkingBegin = true;
                            CastlesOnTable[iIndex].CastleThinking[0].ThinkingFinished = false;
                            int[] Lose = CastlesOnTable[iIndex].LoseOcuuredatChiled;
                            int Win = CastlesOnTable[iIndex].WinOcuuredatChiled;
                            var ah1 = Task.Factory.StartNew(() => CastlesOnTable[iIndex].CastleThinking[0].Thinking(iAStarGreedy, this, ref Lose, ref Win));
                            ah1.Wait();
                            ah1.Dispose();
                            CastlesOnTable[iIndex].LoseOcuuredatChiled[0] = Lose[0];
                            CastlesOnTable[iIndex].LoseOcuuredatChiled[1] = Lose[1];
                            CastlesOnTable[iIndex].LoseOcuuredatChiled[2] = Lose[2];
                            CastlesOnTable[iIndex].WinOcuuredatChiled = Win;
                        }
                    }
                    if (KindIndex == -5)
                    {
                        Order = DummyOrder;
                        ChessRules.CurrentOrder = DummyCurrentOrder;
                        bool ASS = false; Object OOOAAA = new Object(); lock (OOOAAA)
                        { ASS = AllDraw.Blitz; }
                        if (!ASS)
                        {//When There is Current Brown Existing Objective Thinking Movments.
                         //Thinking Operations of Brown Current Objects.
                            MinisterOnTable[iIndex].MinisterThinking[0].ThinkingBegin = true;
                            MinisterOnTable[iIndex].MinisterThinking[0].ThinkingFinished = false;
                            int[] Lose = MinisterOnTable[iIndex].LoseOcuuredatChiled;
                            int Win = MinisterOnTable[iIndex].WinOcuuredatChiled;
                            var ah1 = Task.Factory.StartNew(() => MinisterOnTable[iIndex].MinisterThinking[0].Thinking(iAStarGreedy, this, ref Lose, ref Win));
                            ah1.Wait();
                            ah1.Dispose();
                            MinisterOnTable[iIndex].LoseOcuuredatChiled[0] = Lose[0];
                            MinisterOnTable[iIndex].LoseOcuuredatChiled[1] = Lose[1];
                            MinisterOnTable[iIndex].LoseOcuuredatChiled[2] = Lose[2];
                            MinisterOnTable[iIndex].WinOcuuredatChiled = Win;
                        }
                        else if (ASS)//When There is Current Brown Existing Objective Thinking Movments.
                        {

                            MinisterOnTable[iIndex].MinisterThinking[0].ThinkingBegin = true;
                            MinisterOnTable[iIndex].MinisterThinking[0].ThinkingFinished = false;
                            int[] Lose = MinisterOnTable[iIndex].LoseOcuuredatChiled;
                            int Win = MinisterOnTable[iIndex].WinOcuuredatChiled;
                            var ah1 = Task.Factory.StartNew(() => MinisterOnTable[iIndex].MinisterThinking[0].Thinking(iAStarGreedy, this, ref Lose, ref Win));
                            ah1.Wait();
                            ah1.Dispose();
                            MinisterOnTable[iIndex].LoseOcuuredatChiled[0] = Lose[0];
                            MinisterOnTable[iIndex].LoseOcuuredatChiled[1] = Lose[1];
                            MinisterOnTable[iIndex].LoseOcuuredatChiled[2] = Lose[2];
                            MinisterOnTable[iIndex].WinOcuuredatChiled = Win;
                        }
                    }
                    //Progressing.
                    if (KindIndex == -6)
                    {

                        Order = DummyOrder;
                        ChessRules.CurrentOrder = DummyCurrentOrder;
                        bool ASS = false; Object OOOAAA = new Object(); lock (OOOAAA)
                        { ASS = AllDraw.Blitz; }
                        if (!ASS)
                        {//When Thinking Gray King Count of Existing Operations.
                         //Thinking Of Gray King Operatins.
                            KingOnTable[iIndex].KingThinking[0].ThinkingBegin = true;
                            KingOnTable[iIndex].KingThinking[0].ThinkingFinished = false;
                            int[] Lose = KingOnTable[iIndex].LoseOcuuredatChiled;
                            int Win = KingOnTable[iIndex].WinOcuuredatChiled;
                            var ah1 = Task.Factory.StartNew(() => KingOnTable[iIndex].KingThinking[0].Thinking(iAStarGreedy, this, ref Lose, ref Win));
                            ah1.Wait();
                            ah1.Dispose();
                            KingOnTable[iIndex].LoseOcuuredatChiled[0] = Lose[0];
                            KingOnTable[iIndex].LoseOcuuredatChiled[1] = Lose[1];
                            KingOnTable[iIndex].LoseOcuuredatChiled[2] = Lose[2];
                            KingOnTable[iIndex].WinOcuuredatChiled = Win;
                        }
                        else if (ASS)//When Thinking Gray King Count of Existing Operations.
                        {
                            //Gray King Thinking Operations.                                        
                            KingOnTable[iIndex].KingThinking[0].ThinkingBegin = true;
                            KingOnTable[iIndex].KingThinking[0].ThinkingFinished = false;
                            int[] Lose = KingOnTable[iIndex].LoseOcuuredatChiled;
                            int Win = KingOnTable[iIndex].WinOcuuredatChiled;
                            var ah1 = Task.Factory.StartNew(() => KingOnTable[iIndex].KingThinking[0].Thinking(iAStarGreedy, this, ref Lose, ref Win));
                            ah1.Wait();
                            ah1.Dispose();
                            KingOnTable[iIndex].LoseOcuuredatChiled[0] = Lose[0];
                            KingOnTable[iIndex].LoseOcuuredatChiled[1] = Lose[1];
                            KingOnTable[iIndex].LoseOcuuredatChiled[2] = Lose[2];
                            KingOnTable[iIndex].WinOcuuredatChiled = Win;
                        }
                    }
                    if (KindIndex == 7 || KindIndex == -7)
                    {

                        Order = DummyOrder;
                        ChessRules.CurrentOrder = DummyCurrentOrder;
                        bool ASS = false; Object OOOAAA = new Object(); lock (OOOAAA)
                        { ASS = AllDraw.Blitz; }
                        if (!ASS)
                        {//When Thinking Gray King Count of Existing Operations.
                         //Thinking Of Gray King Operatins.
                            CastlingOnTable[iIndex].CastlingThinking[0].ThinkingBegin = true;
                            CastlingOnTable[iIndex].CastlingThinking[0].ThinkingFinished = false;
                            int[] Lose = CastlingOnTable[iIndex].LoseOcuuredatChiled;
                            int Win = CastlingOnTable[iIndex].WinOcuuredatChiled;
                            var ah1 = Task.Factory.StartNew(() => CastlingOnTable[iIndex].CastlingThinking[0].Thinking(iAStarGreedy, this, ref Lose, ref Win));
                            ah1.Wait();
                            ah1.Dispose();
                            CastlingOnTable[iIndex].LoseOcuuredatChiled[0] = Lose[0];
                            CastlingOnTable[iIndex].LoseOcuuredatChiled[1] = Lose[1];
                            CastlingOnTable[iIndex].LoseOcuuredatChiled[2] = Lose[2];
                            CastlingOnTable[iIndex].WinOcuuredatChiled = Win;
                        }
                        else if (ASS)//When Thinking Gray Castling Count of Existing Operations.
                        {
                            //Gray Castling Thinking Operations.                                        
                            CastlingOnTable[iIndex].CastlingThinking[0].ThinkingBegin = true;
                            CastlingOnTable[iIndex].CastlingThinking[0].ThinkingFinished = false;
                            int[] Lose = CastlingOnTable[iIndex].LoseOcuuredatChiled;
                            int Win = CastlingOnTable[iIndex].WinOcuuredatChiled;
                            var ah1 = Task.Factory.StartNew(() => CastlingOnTable[iIndex].CastlingThinking[0].Thinking(iAStarGreedy, this, ref Lose, ref Win));
                            ah1.Wait();
                            ah1.Dispose();
                            CastlingOnTable[iIndex].LoseOcuuredatChiled[0] = Lose[0];
                            CastlingOnTable[iIndex].LoseOcuuredatChiled[1] = Lose[1];
                            CastlingOnTable[iIndex].LoseOcuuredatChiled[2] = Lose[2];
                            CastlingOnTable[iIndex].WinOcuuredatChiled = Win;
                        }
                    }



                }



                bool FOUND = false;
                if (KindIndex == 1 || KindIndex == -1)
                {
                    SolderesOnTable[iIndex].SoldierThinking[0].AStarGreedy.Add(new AllDraw(Order * -1, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged));
                    SolderesOnTable[iIndex].SoldierThinking[0].AStarGreedy[SolderesOnTable[iIndex].SoldierThinking[0].AStarGreedy.Count - 1].TableList.Clear();
                    SolderesOnTable[iIndex].SoldierThinking[0].AStarGreedy[SolderesOnTable[iIndex].SoldierThinking[0].AStarGreedy.Count - 1].TableList.Add(CloneATable(Tab));
                    SolderesOnTable[iIndex].SoldierThinking[0].AStarGreedy[SolderesOnTable[iIndex].SoldierThinking[0].AStarGreedy.Count - 1].SetRowColumn(0);
                    var H = Task.Factory.StartNew(() => SolderesOnTable[iIndex].SoldierThinking[0].AStarGreedy[SolderesOnTable[iIndex].SoldierThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt(iAStarGreedy, ii, jj, a, CloneATable(Tab), Order * -1, false, FOUND, LeafAStarGreedy));
                    H.Wait();
                    H.Dispose();
                }
                else
                    if (KindIndex == 2 || KindIndex == -2)
                {
                    ElephantOnTable[iIndex].ElefantThinking[0].AStarGreedy.Add(new AllDraw(Order * -1, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged));
                    ElephantOnTable[iIndex].ElefantThinking[0].AStarGreedy[ElephantOnTable[iIndex].ElefantThinking[0].AStarGreedy.Count - 1].TableList.Clear();
                    ElephantOnTable[iIndex].ElefantThinking[0].AStarGreedy[ElephantOnTable[iIndex].ElefantThinking[0].AStarGreedy.Count - 1].TableList.Add(CloneATable(Tab));
                    ElephantOnTable[iIndex].ElefantThinking[0].AStarGreedy[ElephantOnTable[iIndex].ElefantThinking[0].AStarGreedy.Count - 1].SetRowColumn(0);
                    var H = Task.Factory.StartNew(() => ElephantOnTable[iIndex].ElefantThinking[0].AStarGreedy[ElephantOnTable[iIndex].ElefantThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt(iAStarGreedy, ii, jj, a, CloneATable(Tab), Order * -1, false, FOUND, LeafAStarGreedy));
                    H.Wait();
                    H.Dispose();
                }
                else
                        if (KindIndex == 3 || KindIndex == -3)
                {
                    HoursesOnTable[iIndex].HourseThinking[0].AStarGreedy.Add(new AllDraw(Order * -1, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged));
                    HoursesOnTable[iIndex].HourseThinking[0].AStarGreedy[HoursesOnTable[iIndex].HourseThinking[0].AStarGreedy.Count - 1].TableList.Clear();
                    HoursesOnTable[iIndex].HourseThinking[0].AStarGreedy[HoursesOnTable[iIndex].HourseThinking[0].AStarGreedy.Count - 1].TableList.Add(CloneATable(Tab));
                    HoursesOnTable[iIndex].HourseThinking[0].AStarGreedy[HoursesOnTable[iIndex].HourseThinking[0].AStarGreedy.Count - 1].SetRowColumn(0);
                    var H = Task.Factory.StartNew(() => HoursesOnTable[iIndex].HourseThinking[0].AStarGreedy[HoursesOnTable[iIndex].HourseThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt(iAStarGreedy, ii, jj, a, CloneATable(Tab), Order * -1, false, FOUND, LeafAStarGreedy));
                    H.Wait();
                    H.Dispose();
                }
                else
                            if (KindIndex == 4 || KindIndex == -4)
                {
                    CastlesOnTable[iIndex].CastleThinking[0].AStarGreedy.Add(new AllDraw(Order * -1, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged));
                    CastlesOnTable[iIndex].CastleThinking[0].AStarGreedy[CastlesOnTable[iIndex].CastleThinking[0].AStarGreedy.Count - 1].TableList.Clear();
                    CastlesOnTable[iIndex].CastleThinking[0].AStarGreedy[CastlesOnTable[iIndex].CastleThinking[0].AStarGreedy.Count - 1].TableList.Add(CloneATable(Tab));
                    CastlesOnTable[iIndex].CastleThinking[0].AStarGreedy[CastlesOnTable[iIndex].CastleThinking[0].AStarGreedy.Count - 1].SetRowColumn(0);
                    var H = Task.Factory.StartNew(() => CastlesOnTable[iIndex].CastleThinking[0].AStarGreedy[CastlesOnTable[iIndex].CastleThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt(iAStarGreedy, ii, jj, a, CloneATable(Tab), Order * -1, false, FOUND, LeafAStarGreedy));
                    H.Wait();
                    H.Dispose();
                }
                else
                                if (KindIndex == 5 || KindIndex == -5)
                {
                    MinisterOnTable[iIndex].MinisterThinking[0].AStarGreedy.Add(new AllDraw(Order * -1, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged));
                    MinisterOnTable[iIndex].MinisterThinking[0].AStarGreedy[MinisterOnTable[iIndex].MinisterThinking[0].AStarGreedy.Count - 1].TableList.Clear();
                    MinisterOnTable[iIndex].MinisterThinking[0].AStarGreedy[MinisterOnTable[iIndex].MinisterThinking[0].AStarGreedy.Count - 1].TableList.Add(CloneATable(Tab));
                    MinisterOnTable[iIndex].MinisterThinking[0].AStarGreedy[MinisterOnTable[iIndex].MinisterThinking[0].AStarGreedy.Count - 1].SetRowColumn(0);
                    var H = Task.Factory.StartNew(() => MinisterOnTable[iIndex].MinisterThinking[0].AStarGreedy[MinisterOnTable[iIndex].MinisterThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt(iAStarGreedy, ii, jj, a, CloneATable(Tab), Order * -1, false, FOUND, LeafAStarGreedy));
                    H.Wait();
                    H.Dispose();
                }
                else
                                    if (KindIndex == 6 || KindIndex == -6)
                {
                    KingOnTable[iIndex].KingThinking[0].AStarGreedy.Add(new AllDraw(Order * -1, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged));
                    KingOnTable[iIndex].KingThinking[0].AStarGreedy[MinisterOnTable[iIndex].MinisterThinking[0].AStarGreedy.Count - 1].TableList.Clear();
                    KingOnTable[iIndex].KingThinking[0].AStarGreedy[MinisterOnTable[iIndex].MinisterThinking[0].AStarGreedy.Count - 1].TableList.Add(CloneATable(Tab));
                    KingOnTable[iIndex].KingThinking[0].AStarGreedy[MinisterOnTable[iIndex].MinisterThinking[0].AStarGreedy.Count - 1].SetRowColumn(0);
                    var H = Task.Factory.StartNew(() => KingOnTable[iIndex].KingThinking[0].AStarGreedy[KingOnTable[iIndex].KingThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt(iAStarGreedy, ii, jj, a, CloneATable(Tab), Order * -1, false, FOUND, LeafAStarGreedy));
                    H.Wait();
                    H.Dispose();
                }
                else
                                    if (KindIndex == 7 || KindIndex == -6)
                {
                    CastlingOnTable[iIndex].CastlingThinking[0].AStarGreedy.Add(new AllDraw(Order * -1, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged));
                    CastlingOnTable[iIndex].CastlingThinking[0].AStarGreedy[MinisterOnTable[iIndex].MinisterThinking[0].AStarGreedy.Count - 1].TableList.Clear();
                    CastlingOnTable[iIndex].CastlingThinking[0].AStarGreedy[MinisterOnTable[iIndex].MinisterThinking[0].AStarGreedy.Count - 1].TableList.Add(CloneATable(Tab));
                    CastlingOnTable[iIndex].CastlingThinking[0].AStarGreedy[MinisterOnTable[iIndex].MinisterThinking[0].AStarGreedy.Count - 1].SetRowColumn(0);
                    var H = Task.Factory.StartNew(() => CastlingOnTable[iIndex].CastlingThinking[0].AStarGreedy[CastlingOnTable[iIndex].CastlingThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt(iAStarGreedy, ii, jj, a, CloneATable(Tab), Order * -1, false, FOUND, LeafAStarGreedy));
                    H.Wait();
                    H.Dispose();
                }
                //                } 
                Order = DummyOrder;
                ChessRules.CurrentOrder = DummyCurrentOrder;

                Order = DummyOrder;
                ChessRules.CurrentOrder = DummyCurrentOrder;
                return this;
            }
        }
        //Gray index objects max count
        int MaxGrayMidle()
        {

            Object O = new Object();
            lock (O)
            {
                int[] Tab = new int[6];
                Tab[0] = SodierMidle;
                Tab[1] = ElefantMidle;
                Tab[2] = HourseMidle;
                Tab[3] = CastleMidle;
                Tab[4] = MinisterMidle;
                Tab[5] = KingMidle;
                int Max = 0;
                for (var i = 0; i < 6; i++)
                {
                    if (Tab[i] > Max)
                        Max = Tab[i];
                }

                return Max;
            }
        }
        //Brown index objects max count
        int MaxBrownHigh()
        {

            Object O = new Object();
            lock (O)
            {
                int[] Tab = new int[6];
                Tab[0] = SodierHigh;
                Tab[1] = ElefantHigh;
                Tab[2] = HourseHight;
                Tab[3] = CastleHigh;
                Tab[4] = MinisterHigh;
                Tab[5] = KingHigh;
                int Max = 0;
                for (var i = 0; i < 6; i++)
                {
                    if (Tab[i] > Max)
                        Max = Tab[i];
                }

                return Max;
            }
        }
        //Gray index objects min count
        int MinBrownMidle()
        {

            Object O = new Object();
            lock (O)
            {
                int[] Tab = new int[6];
                Tab[0] = SodierHigh;
                Tab[1] = ElefantHigh;
                Tab[2] = HourseHight;
                Tab[3] = CastleHigh;
                Tab[4] = MinisterHigh;
                Tab[5] = KingHigh;
                int Min = MaxBrownHigh();
                for (var i = 0; i < 6; i++)
                {
                    if (Tab[i] < Min)
                        Min = Tab[i];
                }

                return Min;
            }
        }
        //Gray object initiation second method
        /*     AllDraw InitiateAStarGreedytObjectGray(int iii, int jjj, int[,] Table, int DummyOrder, int DummyCurrentOrder, int iAStarGreedy, int ii, int jj, Color a, int[,] Tab, int Order, bool TB, bool FOUND, int LeafAStarGreedy //, ref Refrigtz.Timer timer, ref Refrigtz.Timer Timerint, ref int Less
                 )
             {

                 Object oo = new Object();
                 lock (oo)
                 {
                     for (var i = 0; i < MaxGrayMidle(); i++)
                     {
                         //ParallelOptions po = new ParallelOptions();       po.MaxDegreeOfParallelism =PlatformHelper.ProcessorCount;                    Parallel.Invoke(() =>
                         {
                             Object ooo = new Object();
                             lock (ooo)
                             {
                                 if (SodierMidle > i)
                                 {
                                     Object O = new Object();
                                     lock (O)
                                     {
                                         Order = DummyOrder;
                                         ChessRules.CurrentOrder = DummyCurrentOrder;
                                         //If Solders Not Exist Continue and Traversal Back.
                                         if (SolderesOnTable != null && SolderesOnTable[i] != null)
                                         {
                                             //Initiate of Local Variables By Global Objective Gray Current Solder.
                                             int ik = (int)SolderesOnTable[i].Row;
                                             int jk = (int)SolderesOnTable[i].Column;
                                             //Construction of Thinking Gray Soldier By Local Variables.
                                             //If There is no Thinking Movments on Current Object  
                                             if (SolderesOnTable[i].SoldierThinking[0].TableListSolder.Count == 0)
                                             {
                                                 //For All Movable Gray Solders.
                                                 for (var j = 0; j < AllDraw.SodierMovments; j++)
                                                 ////ParallelOptions po = new ParallelOptions();       po.MaxDegreeOfParallelism =PlatformHelper.ProcessorCount;                    Parallel.For(0, AllDraw.SodierMovments, j =>
                                                 {
                                                     //Thinking of Gray Solder Operation.
                                                     Object OOO = new Object();
                                                     lock (OOO)
                                                     {
                                                         SolderesOnTable[i].SoldierThinking[0].ThinkingBegin = true;
                                                         SolderesOnTable[i].SoldierThinking[0].ThinkingFinished = false;
                                                         SolderesOnTable[i].SoldierThinking[0].Kind = 1;
                                                         SolderesOnTable[i].SoldierThinking[j].Thinking(iAStarGreedy, this, ref SolderesOnTable[i].LoseOcuuredatChiled, ref SolderesOnTable[i].WinOcuuredatChiled);

                                                     }
                                                 }
                                             }
                                         }
                                     }
                                 }
                             }
                         }//,
                         // () =>
                         {
                             Object ooo = new Object();
                             lock (ooo)
                             {
                                 if (MinisterMidle > i)
                                 {

                                     Object O = new Object();
                                     lock (O)
                                     {
                                         Order = DummyOrder;
                                         ChessRules.CurrentOrder = DummyCurrentOrder;
                                         //For Each Non Exist Gray Minister Objectives.
                                         if (MinisterOnTable != null && MinisterOnTable[i] != null)
                                         {
                                             //Inititate Local Variables By Global Varibales.
                                             int ik = (int)MinisterOnTable[i].Row;
                                             int jk = (int)MinisterOnTable[i].Column;
                                             //Construction of Thinking Objects Gray Minister.
                                             //If There is Not Minister Of Gray In The Thinking Table List.   
                                             if (MinisterOnTable[i].MinisterThinking[0].TableListMinister.Count == 0)
                                             {
                                                 //For All Possible Movments.
                                                 for (var j = 0; j < AllDraw.MinisterMovments; j++)
                                                 ////ParallelOptions po = new ParallelOptions();       po.MaxDegreeOfParallelism =PlatformHelper.ProcessorCount;                    Parallel.For(0, AllDraw.MinisterMovments, j =>
                                                 {
                                                     //Thinking of Gray Minister Operational.
                                                     Object OOO = new Object();
                                                     lock (OOO)
                                                     {
                                                         MinisterOnTable[i].MinisterThinking[0].ThinkingBegin = true;
                                                         MinisterOnTable[i].MinisterThinking[0].ThinkingFinished = false;
                                                         MinisterOnTable[i].MinisterThinking[0].Kind = 5;
                                                         MinisterOnTable[i].MinisterThinking[0].Thinking(iAStarGreedy, this, ref MinisterOnTable[i].LoseOcuuredatChiled, ref MinisterOnTable[i].WinOcuuredatChiled);
                                                     }
                                                 }
                                             }
                                         }
                                     }
                                 }
                             }
                         }//,
                          //() =>
                         {
                             Object ooo = new Object();
                             lock (ooo)
                             {
                                 if (KingMidle > i)
                                 {

                                     Object O = new Object();
                                     lock (O)
                                     {
                                         Order = DummyOrder;
                                         ChessRules.CurrentOrder = DummyCurrentOrder;
                                         //If There is Not Current Object Continue Traversal Back.
                                         if (KingOnTable != null && KingOnTable[i] != null)
                                         {
                                             //Initiate Local varibale By Global Objective Varibales.
                                             int ik = (int)(int)KingOnTable[i].Row;
                                             int jk = (int)KingOnTable[i].Column;
                                             //Construction of Gray King Thinking Objects.
                                             //When There is Not Thinking Table Gray King Movments.
                                             if (KingOnTable[i].KingThinking[0].TableListKing.Count == 0)
                                             {
                                                 //For All Possible Gray King Movments.
                                                 ////ParallelOptions po = new ParallelOptions();       po.MaxDegreeOfParallelism =PlatformHelper.ProcessorCount;                    Parallel.For(0, AllDraw.KingMovments, j =>
                                                 for (var j = 0; j < AllDraw.KingMovments; j++)
                                                 {
                                                     //Thinking Of Gray King Operatins.
                                                     Object OOO = new Object();
                                                     lock (OOO)
                                                     {
                                                         KingOnTable[i].KingThinking[0].ThinkingBegin = true;
                                                         KingOnTable[i].KingThinking[0].ThinkingFinished = false;
                                                         KingOnTable[i].KingThinking[0].Kind = 6;
                                                         KingOnTable[i].KingThinking[0].Thinking(iAStarGreedy, this, ref MinisterOnTable[i].LoseOcuuredatChiled, ref MinisterOnTable[i].WinOcuuredatChiled);
                                                     }
                                                 }
                                             }
                                         }
                                     }
                                 }
                             }
                         }
                     }
                 }

                 return this;
             }
             AllDraw InitiateAStarGreedytObjectBrown(int iii, int jjj, int[,] Table, int DummyOrder, int DummyCurrentOrder, int iAStarGreedy, int ii, int jj, Color a, int[,] Tab, int Order, bool TB, bool FOUND, int LeafAStarGreedy//, ref Refrigtz.Timer timer, ref Refrigtz.Timer Timerint, ref int Less
                 )
             {

                 Object oo = new Object();
                 lock (oo)
                 {
                     ////ParallelOptions po = new ParallelOptions();       po.MaxDegreeOfParallelism =PlatformHelper.ProcessorCount;                    Parallel.For(MinBrownMidle(), MaxBrownHigh(), i =>
                     for (var i = MinBrownMidle(); i < MaxBrownHigh(); i++)
                     {
                         //ParallelOptions po = new ParallelOptions();       po.MaxDegreeOfParallelism =PlatformHelper.ProcessorCount;                    Parallel.Invoke(() =>
                         {
                             Object ooo = new Object();
                             lock (ooo)
                             {
                                 if (SodierMidle <= i && SodierHigh > i)
                                 {
                                     Object O = new Object();
                                     lock (O)
                                     {
                                         Order = DummyOrder;
                                         ChessRules.CurrentOrder = DummyCurrentOrder;
                                         //If Solders Not Exist Continue and Traversal Back.
                                         if (SolderesOnTable != null && SolderesOnTable[i] != null)
                                         {
                                             //Initiate of Local Variables By Global Objective Gray Current Solder.
                                             int ik = (int)SolderesOnTable[i].Row;
                                             int jk = (int)SolderesOnTable[i].Column;
                                             //Construction of Thinking Gray Soldier By Local Variables.
                                             //If There is no Thinking Movments on Current Object  
                                             if (SolderesOnTable[i].SoldierThinking[0].TableListSolder.Count == 0)
                                             {
                                                 //For All Movable Gray Solders.
                                                 for (var j = 0; j < AllDraw.SodierMovments; j++)
                                                 ////ParallelOptions po = new ParallelOptions();       po.MaxDegreeOfParallelism =PlatformHelper.ProcessorCount;                    Parallel.For(0, AllDraw.SodierMovments, j =>
                                                 {
                                                     //Thinking of Gray Solder Operation.
                                                     Object OOO = new Object();
                                                     lock (OOO)
                                                     {
                                                         SolderesOnTable[i].SoldierThinking[0].ThinkingBegin = true;
                                                         SolderesOnTable[i].SoldierThinking[0].ThinkingFinished = false;
                                                         SolderesOnTable[i].SoldierThinking[0].Kind = 1;
                                                         SolderesOnTable[i].SoldierThinking[0].Thinking(iAStarGreedy, this, ref SolderesOnTable[i].LoseOcuuredatChiled, ref SolderesOnTable[i].WinOcuuredatChiled);
                                                     }
                                                 }
                                             }
                                         }
                                     }
                                 }
                             }
                         }//,() =>
                         {
                             Object oooo = new Object();
                             lock (oooo)
                             {
                                 if (ElefantMidle <= i && ElefantHigh > i)
                                 {
                                     Object O = new Object();
                                     lock (O)
                                     {
                                         Order = DummyOrder;
                                         ChessRules.CurrentOrder = DummyCurrentOrder;
                                         //Ignore of Non Exist Current Elephant Gray Objects.
                                         if (ElephantOnTable != null && ElephantOnTable[i] != null)
                                         {
                                             //Inititae Local Varibale By Global Gray Elephant Objects Varibales.
                                             int ik = (int)ElephantOnTable[i].Row;
                                             int jk = (int)ElephantOnTable[i].Column;
                                             //Construction of Thinking Objects By Local Varibales.
                                             //If There is Not Thinking Objetive List Elephant Gray. 
                                             if (ElephantOnTable[i].ElefantThinking[0].TableListElefant.Count == 0)
                                             {
                                                 //For All Possible Movments.
                                                 ////ParallelOptions po = new ParallelOptions();       po.MaxDegreeOfParallelism =PlatformHelper.ProcessorCount;                    Parallel.For(0, AllDraw.ElefantMovments, j =>
                                                 for (var j = 0; j < AllDraw.ElefantMovments; j++)
                                                 {
                                                     //Operational Thinking Gray Elephant. 
                                                     Object OOO = new Object();
                                                     lock (OOO)
                                                     {
                                                         ElephantOnTable[i].ElefantThinking[0].ThinkingBegin = true;
                                                         ElephantOnTable[i].ElefantThinking[0].ThinkingFinished = false;
                                                         ElephantOnTable[i].ElefantThinking[0].Kind = 2;
                                                         ElephantOnTable[i].ElefantThinking[0].Thinking(iAStarGreedy, this, ref ElephantOnTable[i].LoseOcuuredatChiled, ref ElephantOnTable[i].WinOcuuredatChiled);
                                                     }
                                                 }
                                             }
                                         }
                                     }
                                 }
                             }
                         }//,() =>
                         {
                             Object oooo = new Object();
                             lock (oooo)
                             {
                                 if (HourseMidle <= i && HourseHight > i)
                                 {
                                     Object O = new Object();
                                     lock (O)
                                     {
                                         Order = DummyOrder;
                                         ChessRules.CurrentOrder = DummyCurrentOrder;
                                         //Ignore of Non Exist Current Gray Hourse Objects.
                                         if (HoursesOnTable != null && HoursesOnTable[i] != null)
                                         {
                                             //Initiate of Local Variables By Global Gray Hourse Objectives.
                                             int ik = (int)HoursesOnTable[i].Row;
                                             int jk = (int)HoursesOnTable[i].Column;
                                             //Construction of Gray Hourse Thinking Objects..
                                             //When There is Not HourseList Count. 
                                             if (HoursesOnTable[i].HourseThinking[0].TableListHourse.Count == 0)
                                             {
                                                 //For All Possible Movments.
                                                 for (var j = 0; j < AllDraw.HourseMovments; j++)
                                                 ////ParallelOptions po = new ParallelOptions();       po.MaxDegreeOfParallelism =PlatformHelper.ProcessorCount;                    Parallel.For(0, AllDraw.HourseMovments, j =>
                                                 {
                                                     //Thinking of Gray Hourse Oprational.
                                                     Object OOO = new Object();
                                                     lock (OOO)
                                                     {
                                                         HoursesOnTable[i].HourseThinking[0].ThinkingBegin = true;
                                                         HoursesOnTable[i].HourseThinking[0].ThinkingFinished = false;
                                                         HoursesOnTable[i].HourseThinking[0].Kind = 3;
                                                         HoursesOnTable[i].HourseThinking[0].Thinking(iAStarGreedy, this, ref HoursesOnTable[i].LoseOcuuredatChiled, ref HoursesOnTable[i].WinOcuuredatChiled);
                                                     }
                                                 }
                                             }
                                         }
                                     }
                                 }
                             }
                         }//,() =>
                         {
                             Object oooo = new Object();
                             lock (oooo)
                             {
                                 if (CastleMidle <= i && CastleHigh < i)
                                 {
                                     Object O = new Object();
                                     lock (O)
                                     {
                                         Order = DummyOrder;
                                         ChessRules.CurrentOrder = DummyCurrentOrder;
                                         //When Current Castles Gray Not Exist Continue Traversal Back.
                                         if (CastlesOnTable != null && CastlesOnTable[i] != null)
                                         {
                                             //Initaiate of Local Varibales By Global Varoiables.
                                             int ik = (int)CastlesOnTable[i].Row;
                                             int jk = (int)CastlesOnTable[i].Column;
                                             //Construction of Thinking Variables By Local Variables.
                                             //When Count of Table Castles of Thinking Not Exist Do Operational.
                                             if (CastlesOnTable[i].CastleThinking[0].TableListCastle.Count == 0)
                                             {
                                                 //For All Possible Movments.
                                                 ////ParallelOptions po = new ParallelOptions();       po.MaxDegreeOfParallelism =PlatformHelper.ProcessorCount;                    Parallel.For(0, AllDraw.CastleMovments, j =>
                                                 for (var j = 0; j < AllDraw.CastleMovments; j++)
                                                 {
                                                     Object OOO = new Object();
                                                     lock (OOO)
                                                     {
                                                         //Thinking of Gray Castles Operational.
                                                         CastlesOnTable[i].CastleThinking[0].ThinkingBegin = true;
                                                         CastlesOnTable[i].CastleThinking[0].ThinkingFinished = false;
                                                         CastlesOnTable[i].CastleThinking[0].Kind = 4;
                                                         CastlesOnTable[i].CastleThinking[0].Thinking(iAStarGreedy, this, ref CastlesOnTable[i].LoseOcuuredatChiled, ref CastlesOnTable[i].WinOcuuredatChiled);
                                                     }
                                                 }
                                             }
                                         }
                                     }
                                 }
                             }
                         }//,() =>
                         {
                             Object oooo = new Object();
                             lock (oooo)
                             {

                                 if (MinisterMidle <= i && MinisterHigh > i)
                                 {
                                     Object O = new Object();
                                     lock (O)
                                     {
                                         Order = DummyOrder;
                                         ChessRules.CurrentOrder = DummyCurrentOrder;
                                         //For Each Non Exist Gray Minister Objectives.
                                         if (MinisterOnTable != null && MinisterOnTable[i] != null)
                                         {
                                             //Inititate Local Variables By Global Varibales.
                                             int ik = (int)MinisterOnTable[i].Row;
                                             int jk = (int)MinisterOnTable[i].Column;
                                             //Construction of Thinking Objects Gray Minister.
                                             //If There is Not Minister Of Gray In The Thinking Table List.   
                                             if (MinisterOnTable[i].MinisterThinking[0].TableListMinister.Count == 0)
                                             {
                                                 //For All Possible Movments.
                                                 ////ParallelOptions po = new ParallelOptions();       po.MaxDegreeOfParallelism =PlatformHelper.ProcessorCount;                    Parallel.For(0, AllDraw.MinisterMovments, j =>
                                                 for (var j = 0; j < AllDraw.MinisterMovments; j++)
                                                 {
                                                     //Thinking of Gray Minister Operational.
                                                     Object OOO = new Object();
                                                     lock (OOO)
                                                     {
                                                         MinisterOnTable[i].MinisterThinking[0].ThinkingBegin = true;
                                                         MinisterOnTable[i].MinisterThinking[0].ThinkingFinished = false;
                                                         MinisterOnTable[i].MinisterThinking[0].Kind = 5;
                                                         MinisterOnTable[i].MinisterThinking[0].Thinking(iAStarGreedy, this, ref CastlesOnTable[i].LoseOcuuredatChiled, ref CastlesOnTable[i].WinOcuuredatChiled);
                                                     }
                                                 }
                                             }
                                         }
                                     }
                                 }
                             }
                         }//,
                         // () =>
                         {
                             Object oooo = new Object();
                             lock (oooo)
                             {
                                 if (KingMidle <= i && KingHigh > i)
                                 {
                                     Object O = new Object();
                                     lock (O)
                                     {
                                         Order = DummyOrder;
                                         ChessRules.CurrentOrder = DummyCurrentOrder;
                                         //If There is Not Current Object Continue Traversal Back.
                                         if (KingOnTable != null && KingOnTable[i] != null)
                                         {
                                             //Initiate Local varibale By Global Objective Varibales.
                                             int ik = (int)(int)KingOnTable[i].Row;
                                             int jk = (int)KingOnTable[i].Column;
                                             //Construction of Gray King Thinking Objects.
                                             //When There is Not Thinking Table Gray King Movments.
                                             if (KingOnTable[i].KingThinking[0].TableListKing.Count == 0)
                                             {
                                                 //For All Possible Gray King Movments.
                                                 for (var j = 0; j < AllDraw.KingMovments; j++)
                                                 {
                                                     //Thinking Of Gray King Operatins.
                                                     Object OOO = new Object();
                                                     lock (OOO)
                                                     {
                                                         KingOnTable[i].KingThinking[0].ThinkingBegin = true;
                                                         KingOnTable[i].KingThinking[0].ThinkingFinished = false;
                                                         KingOnTable[i].KingThinking[0].Kind = 6;
                                                         KingOnTable[i].KingThinking[0].Thinking(iAStarGreedy, this, ref CastlesOnTable[i].LoseOcuuredatChiled, ref CastlesOnTable[i].WinOcuuredatChiled);
                                                     }
                                                 }
                                             }
                                         }
                                     }
                                 }
                             }
                         }
                     }
                 }

                 return this;
             }
           */  //return index of table state index at list
        int FoundTableIndex(List<int[,]> T, int[,] TAab)
        {

            int C = -1;
            for (var i = 0; i < T.Count; i++)
            {
                if (TableEqual(T[i], TAab))
                    C = i;
            }

            return C;
        }
        //when tatow table is not equal
        bool TableEqual(int[,] t1, int[,] t2)
        {

            bool Is = true;
            for (var i = 0; i < 8; i++)
                for (var j = 0; j < 8; j++)
                {
                    if (t1[i, j] != t2[i, j])
                        Is = false;
                }

            return Is;
        }
        bool ServeBoundryConditions(int i, int Kind, int Order)
        {
            bool Is = false;
            try
            {
                if (Kind == 1)
                {
                    Is = Is || ServeBoundryConditionsSoldier(i, Kind, Order);
                }
                else
                if (Kind == 2)
                {
                    Is = Is || ServeBoundryConditionsElephant(i, Kind, Order);
                }
                else
                if (Kind == 3)
                {
                    Is = Is || ServeBoundryConditionsHourse(i, Kind, Order);
                }
                else
                if (Kind == 4)
                {
                    Is = Is || ServeBoundryConditionsCastle(i, Kind, Order);
                }
                else
                if (Kind == 5)
                {
                    Is = Is || ServeBoundryConditionsMinister(i, Kind, Order);
                }
                else
                if (Kind == 6)
                {
                    Is = Is || ServeBoundryConditionsKing(i, Kind, Order);
                }
                else
                if (Kind == 7 || Kind == -7)
                {
                    Is = Is || ServeBoundryConditionsCasttling(i, Kind, Order);
                }
            }
            catch (Exception t)
            {
                Is = true;
            }
            return Is;

        }
        bool ServeBoundryConditionsSoldier(int i, int Kind, int Order)
        {
            if (Order == 1 && i >= SodierMidle)
                return true;
            if (Order == -1 && i >= SodierHigh)
                return true;
            if (SolderesOnTable == null)
                return true;
            if (SolderesOnTable[i] == null)
                return true;

            return false;

        }
        bool ServeBoundryConditionsElephant(int i, int Kind, int Order)
        {
            if (Order == 1 && i >= ElefantHigh)
                return true;
            if (Order == -1 && i >= ElefantHigh)
                return true;
            if (ElephantOnTable == null)
                return true;
            if (ElephantOnTable[i] == null)
                return true;
            return false;

        }
        bool ServeBoundryConditionsHourse(int i, int Kind, int Order)
        {
            if (Order == 1 && i >= HourseMidle)
                return true;
            if (Order == -1 && i >= HourseHight)
                return true;
            if (HoursesOnTable == null)
                return true;
            if (HoursesOnTable[i] == null)
                return true;
            return false;

        }
        bool ServeBoundryConditionsCastle(int i, int Kind, int Order)
        {
            if (Order == 1 && i >= CastleMidle)
                return true;
            if (Order == -1 && i >= CastleHigh)
                return true;
            if (CastlesOnTable == null)
                return true;
            if (CastlesOnTable[i] == null)
                return true;
            return false;

        }
        bool ServeBoundryConditionsMinister(int i, int Kind, int Order)
        {
            if (Order == 1 && i >= MinisterMidle)
                return true;
            if (Order == -1 && i >= MinisterHigh)
                return true;
            if (MinisterOnTable == null)
                return true;
            if (MinisterOnTable[i] == null)
                return true;
            return false;

        }
        bool ServeBoundryConditionsKing(int i, int Kind, int Order)
        {
            if (Order == 1 && i >= KingMidle)
                return true;
            if (Order == -1 && i >= KingHigh)
                return true;
            if (KingOnTable == null)
                return true;
            if (KingOnTable[i] == null)
                return true;
            return false;

        }
        bool ServeBoundryConditionsCasttling(int i, int Kind, int Order)
        {
            if (Order == 1 && i > 0)
                return true;
            if (Order == -1 && i > 0)
                return true;
            if (CastlingOnTable == null)
                return true;
            if (CastlingOnTable[i] == null)
                return true;
            return false;

        }
        //support of objects by self object regard by values named served
        void Serve(int Order)
        {
            //Gray
            if (Order == 1)
            {
                //sodier
                for (var i = 0; i < SodierMidle; i++)
                {
                    if (ServeBoundryConditions(i, 1, Order))
                        continue;
                    ServeISSup(Order, 1, i);
                }
                //elephant
                for (var i = 0; i < ElefantMidle; i++)
                {
                    if (ServeBoundryConditions(i, 2, Order))
                        continue;
                    ServeISSup(Order, 2, i);
                }
                //hourse
                for (var i = 0; i < HourseMidle; i++)
                {
                    if (ServeBoundryConditions(i, 3, Order))
                        continue;
                    ServeISSup(Order, 3, i);
                }
                //Castle
                for (var i = 0; i < CastleMidle; i++)
                {
                    if (ServeBoundryConditions(i, 4, Order))
                        continue;
                    ServeISSup(Order, 4, i);
                }
                //minister
                for (var i = 0; i < MinisterMidle; i++)
                {
                    if (ServeBoundryConditions(i, 5, Order))
                        continue;
                    ServeISSup(Order, 5, i);
                }
                //king
                for (var i = 0; i < KingMidle; i++)
                {
                    if (ServeBoundryConditions(i, 6, Order))
                        continue;
                    ServeISSup(Order, 6, i);
                }
                for (var i = 0; i < 1; i++)
                {
                    if (ServeBoundryConditions(i, 7, Order))
                        continue;
                    ServeISSup(Order, 7, i);
                }
            }//Brown
            else
            {   //soldier
                for (var i = SodierMidle; i < SodierHigh; i++)
                {
                    if (ServeBoundryConditions(i, 1, Order))
                        continue;
                    ServeISSup(Order, 1, i);
                }
                //elephant
                for (var i = ElefantMidle; i < ElefantHigh; i++)
                {
                    if (ServeBoundryConditions(i, 2, Order))
                        continue;
                    ServeISSup(Order, 2, i);
                }
                ///hourse
                for (var i = HourseMidle; i < HourseHight; i++)
                {
                    if (ServeBoundryConditions(i, 3, Order))
                        continue;
                    ServeISSup(Order, 3, i);
                }
                //Castle
                for (var i = CastleMidle; i < CastleHigh; i++)
                {
                    if (ServeBoundryConditions(i, 4, Order))
                        continue;
                    ServeISSup(Order, 4, i);
                }
                //minister
                for (var i = MinisterMidle; i < MinisterHigh; i++)
                {
                    if (ServeBoundryConditions(i, 5, Order))
                        continue;
                    ServeISSup(Order, 5, i);
                }
                //king
                for (var i = KingMidle; i < KingHigh; i++)
                {
                    if (ServeBoundryConditions(i, 6, Order))
                        continue;
                    ServeISSup(Order, 6, i);
                }
                for (var i = 0; i < 1; i++)
                {
                    if (ServeBoundryConditions(i, -7, Order))
                        continue;
                    ServeISSup(Order, -7, i);
                }
            }
        }
        //served mechaisam core
        void ServeISSup(int Order, int Kind,
                int ii
               )
        {

            //soldoer
            if (Kind == 1)
            {
                ServeISSupSoldier(Order, Kind, ii);
            }
            else if (Kind == 2)//elephant
            {
                ServeISSupElephant(Order, Kind, ii);
            }
            else if (Kind == 3)//hourse
            {
                ServeISSupHourse(Order, Kind, ii);
            }
            else if (Kind == 4)//Castle
            {
                ServeISSupCastle(Order, Kind, ii);
            }
            else//minister
            if (Kind == 5)
            {
                ServeISSupMinister(Order, Kind, ii);
            }
            else
            if (Kind == 6)//king
            {
                ServeISSupKing(Order, Kind, ii);
            }
            else
            if (Kind == 7 || Kind == -7)//king
            {
                ServeISSupCastling(Order, Kind, ii);
            }

        }
        void ServeISSupSoldier(int Order, int Kind,
               int ii
              )
        {

            //soldoer
            if (Kind == 1)
            {
                //Gray
                if (Order == 1)
                {
                    //soldier
                    ServeISSupSoldierGray(Order, Kind, ii);
                }
                else//Brown
                {
                    ServeISSupSoldierBrown(Order, Kind, ii);
                }
            }

        }
        void ServeISSupSoldierGray(int Order, int Kind,
              int ii
             )
        {

            //soldoer
            if (Kind == 1)
            {

                //soldier
                for (var i = 0; i < SodierMidle; i++)
                {
                    if (SolderesOnTable == null || SolderesOnTable[i] == null)
                        continue;
                    for (var j = 0; j < SolderesOnTable[i].SoldierThinking[0].HeuristicListSolder.Count; j++)
                    {
                        if (!(SolderesOnTable[i].SoldierThinking[0].IsSup[j]))
                            continue;

                        this.SolderesOnTable[i].SoldierThinking[0].HeuristicListSolder[j][0] += SolderesOnTable[ii].SoldierThinking[0].HeuristicAttackValueSup;
                        this.SolderesOnTable[i].SoldierThinking[0].HeuristicListSolder[j][1] += SolderesOnTable[ii].SoldierThinking[0].HeuristicReducedMovementValueSup;
                        this.SolderesOnTable[i].SoldierThinking[0].HeuristicListSolder[j][2] += SolderesOnTable[ii].SoldierThinking[0].HeuristicSelfSupportedValueSup;
                        this.SolderesOnTable[i].SoldierThinking[0].HeuristicListSolder[j][3] += SolderesOnTable[ii].SoldierThinking[0].HeuristicReducedMovementValueSup;
                        this.SolderesOnTable[i].SoldierThinking[0].HeuristicListSolder[j][4] += SolderesOnTable[ii].SoldierThinking[0].HeuristicReducedSupportSup;
                        this.SolderesOnTable[i].SoldierThinking[0].HeuristicListSolder[j][5] += SolderesOnTable[ii].SoldierThinking[0].HeuristicReducedAttackValueSup;
                        this.SolderesOnTable[i].SoldierThinking[0].HeuristicListSolder[j][6] += SolderesOnTable[ii].SoldierThinking[0].HeuristicDistributionValueSup;
                        this.SolderesOnTable[i].SoldierThinking[0].HeuristicListSolder[j][7] += SolderesOnTable[ii].SoldierThinking[0].HeuristicKingSafeSup;
                        this.SolderesOnTable[i].SoldierThinking[0].HeuristicListSolder[j][8] += SolderesOnTable[ii].SoldierThinking[0].HeuristicFromCenterSup;
                        this.SolderesOnTable[i].SoldierThinking[0].HeuristicListSolder[j][9] += SolderesOnTable[ii].SoldierThinking[0].HeuristicKingDangourSup;


                    }
                }
                SolderesOnTable[ii].SoldierThinking[0].HeuristicAttackValueSup = 0;
                SolderesOnTable[ii].SoldierThinking[0].HeuristicReducedMovementValueSup = 0;
                SolderesOnTable[ii].SoldierThinking[0].HeuristicSelfSupportedValueSup = 0;
                SolderesOnTable[ii].SoldierThinking[0].HeuristicReducedMovementValueSup = 0;
                SolderesOnTable[ii].SoldierThinking[0].HeuristicReducedSupportSup = 0;
                SolderesOnTable[ii].SoldierThinking[0].HeuristicReducedAttackValueSup = 0;
                SolderesOnTable[ii].SoldierThinking[0].HeuristicDistributionValueSup = 0;
                SolderesOnTable[ii].SoldierThinking[0].HeuristicKingSafeSup = 0;
                SolderesOnTable[ii].SoldierThinking[0].HeuristicFromCenterSup = 0;
                SolderesOnTable[ii].SoldierThinking[0].HeuristicKingDangourSup = 0;

            }

        }
        void ServeISSupSoldierBrown(int Order, int Kind,
             int ii
            )
        {

            //soldoer
            if (Kind == 1)
            {


                for (var i = SodierMidle; i < SodierHigh; i++)
                {
                    if (SolderesOnTable == null || SolderesOnTable[i] == null)
                        continue;
                    for (var j = 0; j < SolderesOnTable[i].SoldierThinking[0].HeuristicListSolder.Count; j++)
                    {
                        if (!(SolderesOnTable[i].SoldierThinking[0].IsSup[j]))
                            continue;

                        this.SolderesOnTable[i].SoldierThinking[0].HeuristicListSolder[j][0] += SolderesOnTable[ii].SoldierThinking[0].HeuristicAttackValueSup;
                        this.SolderesOnTable[i].SoldierThinking[0].HeuristicListSolder[j][1] += SolderesOnTable[ii].SoldierThinking[0].HeuristicReducedMovementValueSup;
                        this.SolderesOnTable[i].SoldierThinking[0].HeuristicListSolder[j][2] += SolderesOnTable[ii].SoldierThinking[0].HeuristicSelfSupportedValueSup;
                        this.SolderesOnTable[i].SoldierThinking[0].HeuristicListSolder[j][3] += SolderesOnTable[ii].SoldierThinking[0].HeuristicReducedMovementValueSup;
                        this.SolderesOnTable[i].SoldierThinking[0].HeuristicListSolder[j][4] += SolderesOnTable[ii].SoldierThinking[0].HeuristicReducedSupportSup;
                        this.SolderesOnTable[i].SoldierThinking[0].HeuristicListSolder[j][5] += SolderesOnTable[ii].SoldierThinking[0].HeuristicReducedAttackValueSup;
                        this.SolderesOnTable[i].SoldierThinking[0].HeuristicListSolder[j][6] += SolderesOnTable[ii].SoldierThinking[0].HeuristicDistributionValueSup;
                        this.SolderesOnTable[i].SoldierThinking[0].HeuristicListSolder[j][7] += SolderesOnTable[ii].SoldierThinking[0].HeuristicKingSafeSup;
                        this.SolderesOnTable[i].SoldierThinking[0].HeuristicListSolder[j][8] += SolderesOnTable[ii].SoldierThinking[0].HeuristicFromCenterSup;
                        this.SolderesOnTable[i].SoldierThinking[0].HeuristicListSolder[j][9] += SolderesOnTable[ii].SoldierThinking[0].HeuristicKingDangourSup;


                    }
                }
                SolderesOnTable[ii].SoldierThinking[0].HeuristicAttackValueSup = 0;
                SolderesOnTable[ii].SoldierThinking[0].HeuristicReducedMovementValueSup = 0;
                SolderesOnTable[ii].SoldierThinking[0].HeuristicSelfSupportedValueSup = 0;
                SolderesOnTable[ii].SoldierThinking[0].HeuristicReducedMovementValueSup = 0;
                SolderesOnTable[ii].SoldierThinking[0].HeuristicReducedSupportSup = 0;
                SolderesOnTable[ii].SoldierThinking[0].HeuristicReducedAttackValueSup = 0;
                SolderesOnTable[ii].SoldierThinking[0].HeuristicDistributionValueSup = 0;
                SolderesOnTable[ii].SoldierThinking[0].HeuristicKingSafeSup = 0;
                SolderesOnTable[ii].SoldierThinking[0].HeuristicFromCenterSup = 0;
                SolderesOnTable[ii].SoldierThinking[0].HeuristicKingDangourSup = 0;

            }

        }
        void ServeISSupElephant(int Order, int Kind,
              int ii
             )
        {

            //soldoer
            if (Kind == 2)//elephant
            {
                if (Order == 1)//Gray
                {
                    ServeISSupElephantGray(Order, Kind, ii);
                }
                else//Brown
                {
                    //elephant
                    ServeISSupElephantBrown(Order, Kind, ii);
                }
            }

        }
        void ServeISSupElephantGray(int Order, int Kind,
           int ii
          )
        {

            //soldoer
            if (Kind == 2)//elephant
            {

                for (var i = 0; i < ElefantMidle; i++)
                {
                    if (ElephantOnTable == null || ElephantOnTable[i] == null)
                        continue;

                    for (var j = 0; j < ElephantOnTable[i].ElefantThinking[0].HeuristicListElefant.Count; j++)
                    {
                        if (!(ElephantOnTable[i].ElefantThinking[0].IsSup[j]))
                            continue;
                        this.ElephantOnTable[i].ElefantThinking[0].HeuristicListElefant[j][0] += ElephantOnTable[ii].ElefantThinking[0].HeuristicAttackValueSup;
                        this.ElephantOnTable[i].ElefantThinking[0].HeuristicListElefant[j][1] += ElephantOnTable[ii].ElefantThinking[0].HeuristicReducedMovementValueSup;
                        this.ElephantOnTable[i].ElefantThinking[0].HeuristicListElefant[j][2] += ElephantOnTable[ii].ElefantThinking[0].HeuristicSelfSupportedValueSup;
                        this.ElephantOnTable[i].ElefantThinking[0].HeuristicListElefant[j][3] += ElephantOnTable[ii].ElefantThinking[0].HeuristicReducedMovementValueSup;
                        this.ElephantOnTable[i].ElefantThinking[0].HeuristicListElefant[j][4] += ElephantOnTable[ii].ElefantThinking[0].HeuristicReducedSupportSup;
                        this.ElephantOnTable[i].ElefantThinking[0].HeuristicListElefant[j][5] += ElephantOnTable[ii].ElefantThinking[0].HeuristicReducedAttackValueSup;
                        this.ElephantOnTable[i].ElefantThinking[0].HeuristicListElefant[j][6] += ElephantOnTable[ii].ElefantThinking[0].HeuristicDistributionValueSup;
                        this.ElephantOnTable[i].ElefantThinking[0].HeuristicListElefant[j][7] += ElephantOnTable[ii].ElefantThinking[0].HeuristicKingSafeSup;
                        this.ElephantOnTable[i].ElefantThinking[0].HeuristicListElefant[j][8] += ElephantOnTable[ii].ElefantThinking[0].HeuristicFromCenterSup;
                        this.ElephantOnTable[i].ElefantThinking[0].HeuristicListElefant[j][9] += ElephantOnTable[ii].ElefantThinking[0].HeuristicKingDangourSup;


                    }
                }
                ElephantOnTable[ii].ElefantThinking[0].HeuristicAttackValueSup = 0;
                ElephantOnTable[ii].ElefantThinking[0].HeuristicReducedMovementValueSup = 0;
                ElephantOnTable[ii].ElefantThinking[0].HeuristicSelfSupportedValueSup = 0;
                ElephantOnTable[ii].ElefantThinking[0].HeuristicReducedMovementValueSup = 0;
                ElephantOnTable[ii].ElefantThinking[0].HeuristicReducedSupportSup = 0;
                ElephantOnTable[ii].ElefantThinking[0].HeuristicReducedAttackValueSup = 0;
                ElephantOnTable[ii].ElefantThinking[0].HeuristicDistributionValueSup = 0;
                ElephantOnTable[ii].ElefantThinking[0].HeuristicKingSafeSup = 0;
                ElephantOnTable[ii].ElefantThinking[0].HeuristicFromCenterSup = 0;
                ElephantOnTable[ii].ElefantThinking[0].HeuristicKingDangourSup = 0;

            }

        }
        void ServeISSupElephantBrown(int Order, int Kind,
               int ii
              )
        {

            //soldoer
            if (Kind == 2)//elephant
            {

                for (var i = 0; i < ElefantMidle; i++)
                {
                    if (ElephantOnTable == null || ElephantOnTable[i] == null)
                        continue;

                    for (var j = 0; j < ElephantOnTable[i].ElefantThinking[0].HeuristicListElefant.Count; j++)
                    {
                        if (!(ElephantOnTable[i].ElefantThinking[0].IsSup[j]))
                            continue;
                        this.ElephantOnTable[i].ElefantThinking[0].HeuristicListElefant[j][0] += ElephantOnTable[ii].ElefantThinking[0].HeuristicAttackValueSup;
                        this.ElephantOnTable[i].ElefantThinking[0].HeuristicListElefant[j][1] += ElephantOnTable[ii].ElefantThinking[0].HeuristicReducedMovementValueSup;
                        this.ElephantOnTable[i].ElefantThinking[0].HeuristicListElefant[j][2] += ElephantOnTable[ii].ElefantThinking[0].HeuristicSelfSupportedValueSup;
                        this.ElephantOnTable[i].ElefantThinking[0].HeuristicListElefant[j][3] += ElephantOnTable[ii].ElefantThinking[0].HeuristicReducedMovementValueSup;
                        this.ElephantOnTable[i].ElefantThinking[0].HeuristicListElefant[j][4] += ElephantOnTable[ii].ElefantThinking[0].HeuristicReducedSupportSup;
                        this.ElephantOnTable[i].ElefantThinking[0].HeuristicListElefant[j][5] += ElephantOnTable[ii].ElefantThinking[0].HeuristicReducedAttackValueSup;
                        this.ElephantOnTable[i].ElefantThinking[0].HeuristicListElefant[j][6] += ElephantOnTable[ii].ElefantThinking[0].HeuristicDistributionValueSup;
                        this.ElephantOnTable[i].ElefantThinking[0].HeuristicListElefant[j][7] += ElephantOnTable[ii].ElefantThinking[0].HeuristicKingSafeSup;
                        this.ElephantOnTable[i].ElefantThinking[0].HeuristicListElefant[j][8] += ElephantOnTable[ii].ElefantThinking[0].HeuristicFromCenterSup;
                        this.ElephantOnTable[i].ElefantThinking[0].HeuristicListElefant[j][9] += ElephantOnTable[ii].ElefantThinking[0].HeuristicKingDangourSup;


                    }
                }
                ElephantOnTable[ii].ElefantThinking[0].HeuristicAttackValueSup = 0;
                ElephantOnTable[ii].ElefantThinking[0].HeuristicReducedMovementValueSup = 0;
                ElephantOnTable[ii].ElefantThinking[0].HeuristicSelfSupportedValueSup = 0;
                ElephantOnTable[ii].ElefantThinking[0].HeuristicReducedMovementValueSup = 0;
                ElephantOnTable[ii].ElefantThinking[0].HeuristicReducedSupportSup = 0;
                ElephantOnTable[ii].ElefantThinking[0].HeuristicReducedAttackValueSup = 0;
                ElephantOnTable[ii].ElefantThinking[0].HeuristicDistributionValueSup = 0;
                ElephantOnTable[ii].ElefantThinking[0].HeuristicKingSafeSup = 0;
                ElephantOnTable[ii].ElefantThinking[0].HeuristicFromCenterSup = 0;
                ElephantOnTable[ii].ElefantThinking[0].HeuristicKingDangourSup = 0;

            }

        }
        void ServeISSupHourse(int Order, int Kind,
             int ii
            )
        {

            if (Kind == 3)//hourse
            {
                if (Order == 1)//Gray
                {
                    ServeISSupHourseGray(Order, Kind, ii);

                }
                else//Brown
                {
                    ServeISSupHourseBrown(Order, Kind, ii);
                }
            }

        }
        void ServeISSupHourseGray(int Order, int Kind,
          int ii
         )
        {

            if (Kind == 3)//hourse
            {

                for (var i = 0; i < HourseMidle; i++)
                {
                    if (HoursesOnTable == null || HoursesOnTable[i] == null)
                        continue;

                    for (var j = 0; j < HoursesOnTable[i].HourseThinking[0].HeuristicListHourse.Count; j++)
                    {
                        if (!(HoursesOnTable[i].HourseThinking[0].IsSup[j]))
                            continue;
                        this.HoursesOnTable[i].HourseThinking[0].HeuristicListHourse[j][0] += HoursesOnTable[ii].HourseThinking[0].HeuristicAttackValueSup;
                        this.HoursesOnTable[i].HourseThinking[0].HeuristicListHourse[j][1] += HoursesOnTable[ii].HourseThinking[0].HeuristicReducedMovementValueSup;
                        this.HoursesOnTable[i].HourseThinking[0].HeuristicListHourse[j][2] += HoursesOnTable[ii].HourseThinking[0].HeuristicSelfSupportedValueSup;
                        this.HoursesOnTable[i].HourseThinking[0].HeuristicListHourse[j][3] += HoursesOnTable[ii].HourseThinking[0].HeuristicReducedMovementValueSup;
                        this.HoursesOnTable[i].HourseThinking[0].HeuristicListHourse[j][4] += HoursesOnTable[ii].HourseThinking[0].HeuristicReducedSupportSup;
                        this.HoursesOnTable[i].HourseThinking[0].HeuristicListHourse[j][5] += HoursesOnTable[ii].HourseThinking[0].HeuristicReducedAttackValueSup;
                        this.HoursesOnTable[i].HourseThinking[0].HeuristicListHourse[j][6] += HoursesOnTable[ii].HourseThinking[0].HeuristicDistributionValueSup;
                        this.HoursesOnTable[i].HourseThinking[0].HeuristicListHourse[j][7] += HoursesOnTable[ii].HourseThinking[0].HeuristicKingSafeSup;
                        this.HoursesOnTable[i].HourseThinking[0].HeuristicListHourse[j][8] += HoursesOnTable[ii].HourseThinking[0].HeuristicFromCenterSup;
                        this.HoursesOnTable[i].HourseThinking[0].HeuristicListHourse[j][9] += HoursesOnTable[ii].HourseThinking[0].HeuristicKingDangourSup;


                    }
                }
                HoursesOnTable[ii].HourseThinking[0].HeuristicAttackValueSup = 0;
                HoursesOnTable[ii].HourseThinking[0].HeuristicReducedMovementValueSup = 0;
                HoursesOnTable[ii].HourseThinking[0].HeuristicSelfSupportedValueSup = 0;
                HoursesOnTable[ii].HourseThinking[0].HeuristicReducedMovementValueSup = 0;
                HoursesOnTable[ii].HourseThinking[0].HeuristicReducedSupportSup = 0;
                HoursesOnTable[ii].HourseThinking[0].HeuristicReducedAttackValueSup = 0;
                HoursesOnTable[ii].HourseThinking[0].HeuristicDistributionValueSup = 0;
                HoursesOnTable[ii].HourseThinking[0].HeuristicKingSafeSup = 0;
                HoursesOnTable[ii].HourseThinking[0].HeuristicFromCenterSup = 0;
                HoursesOnTable[ii].HourseThinking[0].HeuristicKingDangourSup = 0;


            }

        }
        void ServeISSupHourseBrown(int Order, int Kind,
         int ii
        )
        {

            if (Kind == 3)//hourse
            {

                for (var i = HourseMidle; i < HourseHight; i++)
                {
                    if (HoursesOnTable == null || HoursesOnTable[i] == null)
                        continue;
                    for (var j = 0; j < HoursesOnTable[i].HourseThinking[0].HeuristicListHourse.Count; j++)
                    {
                        if (!(HoursesOnTable[i].HourseThinking[0].IsSup[j]))
                            continue;
                        this.HoursesOnTable[i].HourseThinking[0].HeuristicListHourse[j][0] += HoursesOnTable[ii].HourseThinking[0].HeuristicAttackValueSup;
                        this.HoursesOnTable[i].HourseThinking[0].HeuristicListHourse[j][1] += HoursesOnTable[ii].HourseThinking[0].HeuristicReducedMovementValueSup;
                        this.HoursesOnTable[i].HourseThinking[0].HeuristicListHourse[j][2] += HoursesOnTable[ii].HourseThinking[0].HeuristicSelfSupportedValueSup;
                        this.HoursesOnTable[i].HourseThinking[0].HeuristicListHourse[j][3] += HoursesOnTable[ii].HourseThinking[0].HeuristicReducedMovementValueSup;
                        this.HoursesOnTable[i].HourseThinking[0].HeuristicListHourse[j][4] += HoursesOnTable[ii].HourseThinking[0].HeuristicReducedSupportSup;
                        this.HoursesOnTable[i].HourseThinking[0].HeuristicListHourse[j][5] += HoursesOnTable[ii].HourseThinking[0].HeuristicReducedAttackValueSup;
                        this.HoursesOnTable[i].HourseThinking[0].HeuristicListHourse[j][6] += HoursesOnTable[ii].HourseThinking[0].HeuristicDistributionValueSup;
                        this.HoursesOnTable[i].HourseThinking[0].HeuristicListHourse[j][7] += HoursesOnTable[ii].HourseThinking[0].HeuristicKingSafeSup;
                        this.HoursesOnTable[i].HourseThinking[0].HeuristicListHourse[j][8] += HoursesOnTable[ii].HourseThinking[0].HeuristicFromCenterSup;
                        this.HoursesOnTable[i].HourseThinking[0].HeuristicListHourse[j][9] += HoursesOnTable[ii].HourseThinking[0].HeuristicKingDangourSup;


                    }
                }
                HoursesOnTable[ii].HourseThinking[0].HeuristicAttackValueSup = 0;
                HoursesOnTable[ii].HourseThinking[0].HeuristicReducedMovementValueSup = 0;
                HoursesOnTable[ii].HourseThinking[0].HeuristicSelfSupportedValueSup = 0;
                HoursesOnTable[ii].HourseThinking[0].HeuristicReducedMovementValueSup = 0;
                HoursesOnTable[ii].HourseThinking[0].HeuristicReducedSupportSup = 0;
                HoursesOnTable[ii].HourseThinking[0].HeuristicReducedAttackValueSup = 0;
                HoursesOnTable[ii].HourseThinking[0].HeuristicDistributionValueSup = 0;
                HoursesOnTable[ii].HourseThinking[0].HeuristicKingSafeSup = 0;
                HoursesOnTable[ii].HourseThinking[0].HeuristicFromCenterSup = 0;
                HoursesOnTable[ii].HourseThinking[0].HeuristicKingDangourSup = 0;

            }

        }
        void ServeISSupCastle(int Order, int Kind,
                int ii
               )
        {

            if (Kind == 4)//Castle
            {
                if (Order == 1)//Gray
                {
                    ServeISSupCastleGray(Order, Kind, ii);
                }
                else//Brown
                {
                    ServeISSupCastleBrown(Order, Kind, ii);
                }
            }

        }
        void ServeISSupCastleGray(int Order, int Kind,
            int ii
           )
        {

            if (Kind == 4)//Castle
            {

                for (var i = 0; i < CastleMidle; i++)
                {
                    if (CastlesOnTable == null || CastlesOnTable[i] == null)
                        continue;
                    for (var j = 0; j < CastlesOnTable[i].CastleThinking[0].HeuristicListCastle.Count; j++)
                    {
                        if (!(CastlesOnTable[i].CastleThinking[0].IsSup[j]))
                            continue;

                        this.CastlesOnTable[i].CastleThinking[0].HeuristicListCastle[j][0] += CastlesOnTable[ii].CastleThinking[0].HeuristicAttackValueSup;
                        this.CastlesOnTable[i].CastleThinking[0].HeuristicListCastle[j][1] += CastlesOnTable[ii].CastleThinking[0].HeuristicReducedMovementValueSup;
                        this.CastlesOnTable[i].CastleThinking[0].HeuristicListCastle[j][2] += CastlesOnTable[ii].CastleThinking[0].HeuristicSelfSupportedValueSup;
                        this.CastlesOnTable[i].CastleThinking[0].HeuristicListCastle[j][3] += CastlesOnTable[ii].CastleThinking[0].HeuristicReducedMovementValueSup;
                        this.CastlesOnTable[i].CastleThinking[0].HeuristicListCastle[j][4] += CastlesOnTable[ii].CastleThinking[0].HeuristicReducedSupportSup;
                        this.CastlesOnTable[i].CastleThinking[0].HeuristicListCastle[j][5] += CastlesOnTable[ii].CastleThinking[0].HeuristicReducedAttackValueSup;
                        this.CastlesOnTable[i].CastleThinking[0].HeuristicListCastle[j][6] += CastlesOnTable[ii].CastleThinking[0].HeuristicDistributionValueSup;
                        this.CastlesOnTable[i].CastleThinking[0].HeuristicListCastle[j][7] += CastlesOnTable[ii].CastleThinking[0].HeuristicKingSafeSup;
                        this.CastlesOnTable[i].CastleThinking[0].HeuristicListCastle[j][8] += CastlesOnTable[ii].CastleThinking[0].HeuristicFromCenterSup;
                        this.CastlesOnTable[i].CastleThinking[0].HeuristicListCastle[j][9] += CastlesOnTable[ii].CastleThinking[0].HeuristicKingDangourSup;


                    }
                }
                CastlesOnTable[ii].CastleThinking[0].HeuristicAttackValueSup = 0;
                CastlesOnTable[ii].CastleThinking[0].HeuristicReducedMovementValueSup = 0;
                CastlesOnTable[ii].CastleThinking[0].HeuristicSelfSupportedValueSup = 0;
                CastlesOnTable[ii].CastleThinking[0].HeuristicReducedMovementValueSup = 0;
                CastlesOnTable[ii].CastleThinking[0].HeuristicReducedSupportSup = 0;
                CastlesOnTable[ii].CastleThinking[0].HeuristicReducedAttackValueSup = 0;
                CastlesOnTable[ii].CastleThinking[0].HeuristicDistributionValueSup = 0;
                CastlesOnTable[ii].CastleThinking[0].HeuristicKingSafeSup = 0;
                CastlesOnTable[ii].CastleThinking[0].HeuristicFromCenterSup = 0;
                CastlesOnTable[ii].CastleThinking[0].HeuristicKingDangourSup = 0;

            }

        }
        void ServeISSupCastleBrown(int Order, int Kind,
               int ii
              )
        {

            if (Kind == 4)//Castle
            {

                for (var i = CastleMidle; i < CastleHigh; i++)
                {
                    if (CastlesOnTable == null || CastlesOnTable[i] == null)
                        continue;
                    for (var j = 0; j < CastlesOnTable[i].CastleThinking[0].HeuristicListCastle.Count; j++)
                    {
                        if (!(CastlesOnTable[i].CastleThinking[0].IsSup[j]))
                            continue;

                        this.CastlesOnTable[i].CastleThinking[0].HeuristicListCastle[j][0] += CastlesOnTable[ii].CastleThinking[0].HeuristicAttackValueSup;
                        this.CastlesOnTable[i].CastleThinking[0].HeuristicListCastle[j][1] += CastlesOnTable[ii].CastleThinking[0].HeuristicReducedMovementValueSup;
                        this.CastlesOnTable[i].CastleThinking[0].HeuristicListCastle[j][2] += CastlesOnTable[ii].CastleThinking[0].HeuristicSelfSupportedValueSup;
                        this.CastlesOnTable[i].CastleThinking[0].HeuristicListCastle[j][3] += CastlesOnTable[ii].CastleThinking[0].HeuristicReducedMovementValueSup;
                        this.CastlesOnTable[i].CastleThinking[0].HeuristicListCastle[j][4] += CastlesOnTable[ii].CastleThinking[0].HeuristicReducedSupportSup;
                        this.CastlesOnTable[i].CastleThinking[0].HeuristicListCastle[j][5] += CastlesOnTable[ii].CastleThinking[0].HeuristicReducedAttackValueSup;
                        this.CastlesOnTable[i].CastleThinking[0].HeuristicListCastle[j][6] += CastlesOnTable[ii].CastleThinking[0].HeuristicDistributionValueSup;
                        this.CastlesOnTable[i].CastleThinking[0].HeuristicListCastle[j][7] += CastlesOnTable[ii].CastleThinking[0].HeuristicKingSafeSup;
                        this.CastlesOnTable[i].CastleThinking[0].HeuristicListCastle[j][8] += CastlesOnTable[ii].CastleThinking[0].HeuristicFromCenterSup;
                        this.CastlesOnTable[i].CastleThinking[0].HeuristicListCastle[j][9] += CastlesOnTable[ii].CastleThinking[0].HeuristicKingDangourSup;


                    }
                }
                CastlesOnTable[ii].CastleThinking[0].HeuristicAttackValueSup = 0;
                CastlesOnTable[ii].CastleThinking[0].HeuristicReducedMovementValueSup = 0;
                CastlesOnTable[ii].CastleThinking[0].HeuristicSelfSupportedValueSup = 0;
                CastlesOnTable[ii].CastleThinking[0].HeuristicReducedMovementValueSup = 0;
                CastlesOnTable[ii].CastleThinking[0].HeuristicReducedSupportSup = 0;
                CastlesOnTable[ii].CastleThinking[0].HeuristicReducedAttackValueSup = 0;
                CastlesOnTable[ii].CastleThinking[0].HeuristicDistributionValueSup = 0;
                CastlesOnTable[ii].CastleThinking[0].HeuristicKingSafeSup = 0;
                CastlesOnTable[ii].CastleThinking[0].HeuristicFromCenterSup = 0;
                CastlesOnTable[ii].CastleThinking[0].HeuristicKingDangourSup = 0;

            }

        }
        void ServeISSupMinister(int Order, int Kind,
                int ii
               )
        {

            //minister
            if (Kind == 5)
            {
                if (Order == 1)//Gray
                {
                    ServeISSupMinisterGray(Order, Kind, ii);
                }
                else
                {
                    ServeISSupMinisterBrown(Order, Kind, ii);
                }
            }

        }
        void ServeISSupMinisterGray(int Order, int Kind,
              int ii
             )
        {

            //minister
            if (Kind == 5)
            {

                for (var i = 0; i < MinisterMidle; i++)
                {
                    if (MinisterOnTable == null || MinisterOnTable[i] == null)
                        continue;
                    for (var j = 0; j < MinisterOnTable[i].MinisterThinking[0].HeuristicListMinister.Count; j++)
                    {
                        if (!(MinisterOnTable[i].MinisterThinking[0].IsSup[j]))
                            continue;
                        this.MinisterOnTable[i].MinisterThinking[0].HeuristicListMinister[j][0] += MinisterOnTable[ii].MinisterThinking[0].HeuristicAttackValueSup;
                        this.MinisterOnTable[i].MinisterThinking[0].HeuristicListMinister[j][1] += MinisterOnTable[ii].MinisterThinking[0].HeuristicReducedMovementValueSup;
                        this.MinisterOnTable[i].MinisterThinking[0].HeuristicListMinister[j][2] += MinisterOnTable[ii].MinisterThinking[0].HeuristicSelfSupportedValueSup;
                        this.MinisterOnTable[i].MinisterThinking[0].HeuristicListMinister[j][3] += MinisterOnTable[ii].MinisterThinking[0].HeuristicReducedMovementValueSup;
                        this.MinisterOnTable[i].MinisterThinking[0].HeuristicListMinister[j][4] += MinisterOnTable[ii].MinisterThinking[0].HeuristicReducedSupportSup;
                        this.MinisterOnTable[i].MinisterThinking[0].HeuristicListMinister[j][5] += MinisterOnTable[ii].MinisterThinking[0].HeuristicReducedAttackValueSup;
                        this.MinisterOnTable[i].MinisterThinking[0].HeuristicListMinister[j][6] += MinisterOnTable[ii].MinisterThinking[0].HeuristicDistributionValueSup;
                        this.MinisterOnTable[i].MinisterThinking[0].HeuristicListMinister[j][7] += MinisterOnTable[ii].MinisterThinking[0].HeuristicKingSafeSup;
                        this.MinisterOnTable[i].MinisterThinking[0].HeuristicListMinister[j][8] += MinisterOnTable[ii].MinisterThinking[0].HeuristicFromCenterSup;
                        this.MinisterOnTable[i].MinisterThinking[0].HeuristicListMinister[j][9] += MinisterOnTable[ii].MinisterThinking[0].HeuristicKingDangourSup;



                    }
                }
                MinisterOnTable[ii].MinisterThinking[0].HeuristicAttackValueSup = 0;
                MinisterOnTable[ii].MinisterThinking[0].HeuristicReducedMovementValueSup = 0;
                MinisterOnTable[ii].MinisterThinking[0].HeuristicSelfSupportedValueSup = 0;
                MinisterOnTable[ii].MinisterThinking[0].HeuristicReducedMovementValueSup = 0;
                MinisterOnTable[ii].MinisterThinking[0].HeuristicReducedSupportSup = 0;
                MinisterOnTable[ii].MinisterThinking[0].HeuristicReducedAttackValueSup = 0;
                MinisterOnTable[ii].MinisterThinking[0].HeuristicDistributionValueSup = 0;
                MinisterOnTable[ii].MinisterThinking[0].HeuristicKingSafeSup = 0;
                MinisterOnTable[ii].MinisterThinking[0].HeuristicFromCenterSup = 0;
                MinisterOnTable[ii].MinisterThinking[0].HeuristicKingDangourSup = 0;
            }

        }
        void ServeISSupMinisterBrown(int Order, int Kind,
                int ii
               )
        {

            //minister
            if (Kind == 5)
            {

                for (var i = MinisterMidle; i < MinisterHigh; i++)
                {
                    if (MinisterOnTable == null || MinisterOnTable[i] == null)
                        continue;
                    for (var j = 0; j < MinisterOnTable[i].MinisterThinking[0].HeuristicListMinister.Count; j++)
                    {
                        if (!(MinisterOnTable[i].MinisterThinking[0].IsSup[j]))
                            continue;

                        this.MinisterOnTable[i].MinisterThinking[0].HeuristicListMinister[j][0] += MinisterOnTable[ii].MinisterThinking[0].HeuristicAttackValueSup;
                        this.MinisterOnTable[i].MinisterThinking[0].HeuristicListMinister[j][1] += MinisterOnTable[ii].MinisterThinking[0].HeuristicReducedMovementValueSup;
                        this.MinisterOnTable[i].MinisterThinking[0].HeuristicListMinister[j][2] += MinisterOnTable[ii].MinisterThinking[0].HeuristicSelfSupportedValueSup;
                        this.MinisterOnTable[i].MinisterThinking[0].HeuristicListMinister[j][3] += MinisterOnTable[ii].MinisterThinking[0].HeuristicReducedMovementValueSup;
                        this.MinisterOnTable[i].MinisterThinking[0].HeuristicListMinister[j][4] += MinisterOnTable[ii].MinisterThinking[0].HeuristicReducedSupportSup;
                        this.MinisterOnTable[i].MinisterThinking[0].HeuristicListMinister[j][5] += MinisterOnTable[ii].MinisterThinking[0].HeuristicReducedAttackValueSup;
                        this.MinisterOnTable[i].MinisterThinking[0].HeuristicListMinister[j][6] += MinisterOnTable[ii].MinisterThinking[0].HeuristicDistributionValueSup;
                        this.MinisterOnTable[i].MinisterThinking[0].HeuristicListMinister[j][7] += MinisterOnTable[ii].MinisterThinking[0].HeuristicKingSafeSup;
                        this.MinisterOnTable[i].MinisterThinking[0].HeuristicListMinister[j][8] += MinisterOnTable[ii].MinisterThinking[0].HeuristicFromCenterSup;
                        this.MinisterOnTable[i].MinisterThinking[0].HeuristicListMinister[j][9] += MinisterOnTable[ii].MinisterThinking[0].HeuristicKingDangourSup;


                    }
                }
                MinisterOnTable[ii].MinisterThinking[0].HeuristicAttackValueSup = 0;
                MinisterOnTable[ii].MinisterThinking[0].HeuristicReducedMovementValueSup = 0;
                MinisterOnTable[ii].MinisterThinking[0].HeuristicSelfSupportedValueSup = 0;
                MinisterOnTable[ii].MinisterThinking[0].HeuristicReducedMovementValueSup = 0;
                MinisterOnTable[ii].MinisterThinking[0].HeuristicReducedSupportSup = 0;
                MinisterOnTable[ii].MinisterThinking[0].HeuristicReducedAttackValueSup = 0;
                MinisterOnTable[ii].MinisterThinking[0].HeuristicDistributionValueSup = 0;
                MinisterOnTable[ii].MinisterThinking[0].HeuristicKingSafeSup = 0;
                MinisterOnTable[ii].MinisterThinking[0].HeuristicFromCenterSup = 0;
                MinisterOnTable[ii].MinisterThinking[0].HeuristicKingDangourSup = 0;

            }

        }
        void ServeISSupKing(int Order, int Kind,
               int ii
              )
        {


            if (Kind == 6)//king
            {
                if (Order == 1)//Gray
                {
                    ServeISSupKingGray(Order, Kind, ii);

                }
                else//Brown
                {
                    ServeISSupKingBrown(Order, Kind, ii);

                }
            }

        }
        void ServeISSupKingGray(int Order, int Kind,
             int ii
            )
        {


            if (Kind == 6)//king
            {

                for (var i = 0; i < KingMidle; i++)
                {
                    if (KingOnTable == null || KingOnTable[i] == null)
                        continue;
                    for (var j = 0; j < KingOnTable[i].KingThinking[0].HeuristicListKing.Count; j++)
                    {
                        if (!(KingOnTable[i].KingThinking[0].IsSup[j]))
                            continue;
                        this.KingOnTable[i].KingThinking[0].HeuristicListKing[j][0] += KingOnTable[ii].KingThinking[0].HeuristicAttackValueSup;
                        this.KingOnTable[i].KingThinking[0].HeuristicListKing[j][1] += KingOnTable[ii].KingThinking[0].HeuristicReducedMovementValueSup;
                        this.KingOnTable[i].KingThinking[0].HeuristicListKing[j][2] += KingOnTable[ii].KingThinking[0].HeuristicSelfSupportedValueSup;
                        this.KingOnTable[i].KingThinking[0].HeuristicListKing[j][3] += KingOnTable[ii].KingThinking[0].HeuristicReducedMovementValueSup;
                        this.KingOnTable[i].KingThinking[0].HeuristicListKing[j][4] += KingOnTable[ii].KingThinking[0].HeuristicReducedSupportSup;
                        this.KingOnTable[i].KingThinking[0].HeuristicListKing[j][5] += KingOnTable[ii].KingThinking[0].HeuristicReducedAttackValueSup;
                        this.KingOnTable[i].KingThinking[0].HeuristicListKing[j][6] += KingOnTable[ii].KingThinking[0].HeuristicDistributionValueSup;
                        this.KingOnTable[i].KingThinking[0].HeuristicListKing[j][7] += KingOnTable[ii].KingThinking[0].HeuristicKingSafeSup;
                        this.KingOnTable[i].KingThinking[0].HeuristicListKing[j][8] += KingOnTable[ii].KingThinking[0].HeuristicFromCenterSup;
                        this.KingOnTable[i].KingThinking[0].HeuristicListKing[j][9] += KingOnTable[ii].KingThinking[0].HeuristicKingDangourSup;



                    }
                }
                KingOnTable[ii].KingThinking[0].HeuristicAttackValueSup = 0;
                KingOnTable[ii].KingThinking[0].HeuristicReducedMovementValueSup = 0;
                KingOnTable[ii].KingThinking[0].HeuristicSelfSupportedValueSup = 0;
                KingOnTable[ii].KingThinking[0].HeuristicReducedMovementValueSup = 0;
                KingOnTable[ii].KingThinking[0].HeuristicReducedSupportSup = 0;
                KingOnTable[ii].KingThinking[0].HeuristicReducedAttackValueSup = 0;
                KingOnTable[ii].KingThinking[0].HeuristicDistributionValueSup = 0;
                KingOnTable[ii].KingThinking[0].HeuristicKingSafeSup = 0;
                KingOnTable[ii].KingThinking[0].HeuristicFromCenterSup = 0;
                KingOnTable[ii].KingThinking[0].HeuristicKingDangourSup = 0;


            }

        }
        void ServeISSupKingBrown(int Order, int Kind,
              int ii
             )
        {


            if (Kind == 6)//king
            {

                for (var i = KingMidle; i < KingHigh; i++)
                {
                    if (KingOnTable == null || KingOnTable[i] == null)
                        continue;
                    for (var j = 0; j < KingOnTable[i].KingThinking[0].HeuristicListKing.Count; j++)
                    {
                        if (!(KingOnTable[i].KingThinking[0].IsSup[j]))
                            continue;

                        this.KingOnTable[i].KingThinking[0].HeuristicListKing[j][0] += KingOnTable[ii].KingThinking[0].HeuristicAttackValueSup;
                        this.KingOnTable[i].KingThinking[0].HeuristicListKing[j][1] += KingOnTable[ii].KingThinking[0].HeuristicReducedMovementValueSup;
                        this.KingOnTable[i].KingThinking[0].HeuristicListKing[j][2] += KingOnTable[ii].KingThinking[0].HeuristicSelfSupportedValueSup;
                        this.KingOnTable[i].KingThinking[0].HeuristicListKing[j][3] += KingOnTable[ii].KingThinking[0].HeuristicReducedMovementValueSup;
                        this.KingOnTable[i].KingThinking[0].HeuristicListKing[j][4] += KingOnTable[ii].KingThinking[0].HeuristicReducedSupportSup;
                        this.KingOnTable[i].KingThinking[0].HeuristicListKing[j][5] += KingOnTable[ii].KingThinking[0].HeuristicReducedAttackValueSup;
                        this.KingOnTable[i].KingThinking[0].HeuristicListKing[j][6] += KingOnTable[ii].KingThinking[0].HeuristicDistributionValueSup;
                        this.KingOnTable[i].KingThinking[0].HeuristicListKing[j][7] += KingOnTable[ii].KingThinking[0].HeuristicKingSafeSup;
                        this.KingOnTable[i].KingThinking[0].HeuristicListKing[j][8] += KingOnTable[ii].KingThinking[0].HeuristicFromCenterSup;
                        this.KingOnTable[i].KingThinking[0].HeuristicListKing[j][9] += KingOnTable[ii].KingThinking[0].HeuristicKingDangourSup;



                    }
                }
                KingOnTable[ii].KingThinking[0].HeuristicAttackValueSup = 0;
                KingOnTable[ii].KingThinking[0].HeuristicReducedMovementValueSup = 0;
                KingOnTable[ii].KingThinking[0].HeuristicSelfSupportedValueSup = 0;
                KingOnTable[ii].KingThinking[0].HeuristicReducedMovementValueSup = 0;
                KingOnTable[ii].KingThinking[0].HeuristicReducedSupportSup = 0;
                KingOnTable[ii].KingThinking[0].HeuristicReducedAttackValueSup = 0;
                KingOnTable[ii].KingThinking[0].HeuristicDistributionValueSup = 0;
                KingOnTable[ii].KingThinking[0].HeuristicKingSafeSup = 0;
                KingOnTable[ii].KingThinking[0].HeuristicFromCenterSup = 0;
                KingOnTable[ii].KingThinking[0].HeuristicKingDangourSup = 0;


            }

        }
        void ServeISSupCastling(int Order, int Kind,
              int ii
             )
        {


            if (Kind == 7 || Kind == -7)//king
            {
                if (Order == 1)//Gray
                {
                    ServeISSupCastlingGray(Order, Kind, ii);
                }
                else//Brown
                {
                    ServeISSupCastlingBrown(Order, Kind, ii);

                }
            }

        }
        void ServeISSupCastlingGray(int Order, int Kind,
          int ii
         )
        {


            if (Kind == 7 || Kind == -7)//king
            {

                for (var i = 0; i < 1; i++)
                {
                    if (CastlingOnTable == null || CastlingOnTable[i] == null)
                        continue;
                    for (var j = 0; j < CastlingOnTable[i].CastlingThinking[0].HeuristicListCastling.Count; j++)
                    {
                        if (!(CastlingOnTable[i].CastlingThinking[0].IsSup[j]))
                            continue;
                        this.CastlingOnTable[i].CastlingThinking[0].HeuristicListCastling[j][0] += CastlingOnTable[ii].CastlingThinking[0].HeuristicAttackValueSup;
                        this.CastlingOnTable[i].CastlingThinking[0].HeuristicListCastling[j][1] += CastlingOnTable[ii].CastlingThinking[0].HeuristicReducedMovementValueSup;
                        this.CastlingOnTable[i].CastlingThinking[0].HeuristicListCastling[j][2] += CastlingOnTable[ii].CastlingThinking[0].HeuristicSelfSupportedValueSup;
                        this.CastlingOnTable[i].CastlingThinking[0].HeuristicListCastling[j][3] += CastlingOnTable[ii].CastlingThinking[0].HeuristicReducedMovementValueSup;
                        this.CastlingOnTable[i].CastlingThinking[0].HeuristicListCastling[j][4] += CastlingOnTable[ii].CastlingThinking[0].HeuristicReducedSupportSup;
                        this.CastlingOnTable[i].CastlingThinking[0].HeuristicListCastling[j][5] += CastlingOnTable[ii].CastlingThinking[0].HeuristicReducedAttackValueSup;
                        this.CastlingOnTable[i].CastlingThinking[0].HeuristicListCastling[j][6] += CastlingOnTable[ii].CastlingThinking[0].HeuristicDistributionValueSup;
                        this.CastlingOnTable[i].CastlingThinking[0].HeuristicListCastling[j][7] += CastlingOnTable[ii].CastlingThinking[0].HeuristicKingSafeSup;
                        this.CastlingOnTable[i].CastlingThinking[0].HeuristicListCastling[j][8] += CastlingOnTable[ii].CastlingThinking[0].HeuristicFromCenterSup;
                        this.CastlingOnTable[i].CastlingThinking[0].HeuristicListCastling[j][9] += CastlingOnTable[ii].CastlingThinking[0].HeuristicKingDangourSup;



                    }
                }
                CastlingOnTable[ii].CastlingThinking[0].HeuristicAttackValueSup = 0;
                CastlingOnTable[ii].CastlingThinking[0].HeuristicReducedMovementValueSup = 0;
                CastlingOnTable[ii].CastlingThinking[0].HeuristicSelfSupportedValueSup = 0;
                CastlingOnTable[ii].CastlingThinking[0].HeuristicReducedMovementValueSup = 0;
                CastlingOnTable[ii].CastlingThinking[0].HeuristicReducedSupportSup = 0;
                CastlingOnTable[ii].CastlingThinking[0].HeuristicReducedAttackValueSup = 0;
                CastlingOnTable[ii].CastlingThinking[0].HeuristicDistributionValueSup = 0;
                CastlingOnTable[ii].CastlingThinking[0].HeuristicKingSafeSup = 0;
                CastlingOnTable[ii].CastlingThinking[0].HeuristicFromCenterSup = 0;
                CastlingOnTable[ii].CastlingThinking[0].HeuristicKingDangourSup = 0;

            }


        }
        void ServeISSupCastlingBrown(int Order, int Kind,
              int ii
             )
        {


            if (Kind == 7 || Kind == -7)//king
            {

                for (var i = 0; i < 1; i++)
                {
                    if (CastlingOnTable == null || CastlingOnTable[i] == null)
                        continue;
                    for (var j = 0; j < CastlingOnTable[i].CastlingThinking[0].HeuristicListCastling.Count; j++)
                    {
                        if (!(CastlingOnTable[i].CastlingThinking[0].IsSup[j]))
                            continue;

                        this.CastlingOnTable[i].CastlingThinking[0].HeuristicListCastling[j][0] += CastlingOnTable[ii].CastlingThinking[0].HeuristicAttackValueSup;
                        this.CastlingOnTable[i].CastlingThinking[0].HeuristicListCastling[j][1] += CastlingOnTable[ii].CastlingThinking[0].HeuristicReducedMovementValueSup;
                        this.CastlingOnTable[i].CastlingThinking[0].HeuristicListCastling[j][2] += CastlingOnTable[ii].CastlingThinking[0].HeuristicSelfSupportedValueSup;
                        this.CastlingOnTable[i].CastlingThinking[0].HeuristicListCastling[j][3] += CastlingOnTable[ii].CastlingThinking[0].HeuristicReducedMovementValueSup;
                        this.CastlingOnTable[i].CastlingThinking[0].HeuristicListCastling[j][4] += CastlingOnTable[ii].CastlingThinking[0].HeuristicReducedSupportSup;
                        this.CastlingOnTable[i].CastlingThinking[0].HeuristicListCastling[j][5] += CastlingOnTable[ii].CastlingThinking[0].HeuristicReducedAttackValueSup;
                        this.CastlingOnTable[i].CastlingThinking[0].HeuristicListCastling[j][6] += CastlingOnTable[ii].CastlingThinking[0].HeuristicDistributionValueSup;
                        this.CastlingOnTable[i].CastlingThinking[0].HeuristicListCastling[j][7] += CastlingOnTable[ii].CastlingThinking[0].HeuristicKingSafeSup;
                        this.CastlingOnTable[i].CastlingThinking[0].HeuristicListCastling[j][8] += CastlingOnTable[ii].CastlingThinking[0].HeuristicFromCenterSup;
                        this.CastlingOnTable[i].CastlingThinking[0].HeuristicListCastling[j][9] += CastlingOnTable[ii].CastlingThinking[0].HeuristicKingDangourSup;



                    }
                }
                CastlingOnTable[ii].CastlingThinking[0].HeuristicAttackValueSup = 0;
                CastlingOnTable[ii].CastlingThinking[0].HeuristicReducedMovementValueSup = 0;
                CastlingOnTable[ii].CastlingThinking[0].HeuristicSelfSupportedValueSup = 0;
                CastlingOnTable[ii].CastlingThinking[0].HeuristicReducedMovementValueSup = 0;
                CastlingOnTable[ii].CastlingThinking[0].HeuristicReducedSupportSup = 0;
                CastlingOnTable[ii].CastlingThinking[0].HeuristicReducedAttackValueSup = 0;
                CastlingOnTable[ii].CastlingThinking[0].HeuristicDistributionValueSup = 0;
                CastlingOnTable[ii].CastlingThinking[0].HeuristicKingSafeSup = 0;
                CastlingOnTable[ii].CastlingThinking[0].HeuristicFromCenterSup = 0;
                CastlingOnTable[ii].CastlingThinking[0].HeuristicKingDangourSup = 0;

            }


        }
        void ThinkingAllowedSemaphore(int i)
        {
            if (ThinkingAllowed == null)
                ThinkingAllowed = new bool[14];
            do { } while (!ThinkingAllowed[i - 1]);

        }
        //main initiation of soldier Gray
        AllDraw InitiateAStarGreedytSodlerGray(int iii, int jjj, int[,] Table, int DummyOrder, int DummyCurrentOrder, int iAStarGreedy, int ii, int jj, Color a, int[,] Tab, int Order, bool TB, bool FOUND, int LeafAStarGreedy//, ref Refrigtz.Timer timer, ref Refrigtz.Timer Timerint, ref int Less
            )
        {
            Object oo = new Object();
            lock (oo)
            {

                //For Gray Soldeirs Objects. 
                ParallelOptions po = new ParallelOptions(); po.MaxDegreeOfParallelism = System.Threading.PlatformHelper.ProcessorCount; Parallel.For(0, SodierMidle, i =>
 {
     var H = Task.Factory.StartNew(() => InitiateAStarGreedytSodler(i, iii, jjj, CloneATable(Table), DummyOrder, DummyCurrentOrder, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ii, jj, a, CloneATable(Tab), Order, TB, FOUND, LeafAStarGreedy));
     H.Wait();
     H.Dispose();
 });

            }
            return this;
        }
        bool InitiateAStarGreedyt(int i, int Kind, int Order)
        {
            Object oo = new Object();
            lock (oo)
            {
                bool Is = false;
                try
                {
                    /* if (OrderPlateDraw == 1)
                     {
                         if (Wtime != null)
                         {
                             if (Wtime.EndTime)
                                 return true;
                         }
                     }
                     else {
                         if (Btime != null)
                         {
                             if (Btime.EndTime)
                                 return true;
                         }
                     }*/
                    if (
                        /*(MaxAStarGreedy <= CurrentMaxLevel + PlatformHelper.ProcessorCount) &&*/
                        ((MaxAStarGreedy < StoreInitMaxAStarGreedy + PlatformHelper.ProcessorCount) || SStopInitMaxAStarGreedy))// if (MaxAStarGreedy < indexStep * PlatformHelper.ProcessorCount)
                    {
                        MaxAStarGreedy = CurrentMaxLevel;
                    }
                    else
                        //if (CurrentMaxLevel >= MaxAStarGreedy)
                        return true;

                    if (CalIdle == 2)
                        return true;
                    if (Kind == 1)
                    {
                        Is = Is || InitiateAStarGreedytSoldier(i, Kind, Order);
                    }
                    else
     if (Kind == 2)
                    {
                        Is = Is || InitiateAStarGreedytElephant(i, Kind, Order);
                    }
                    else
     if (Kind == 3)
                    {
                        Is = Is || InitiateAStarGreedytHourse(i, Kind, Order);
                    }
                    else
     if (Kind == 4)
                    {
                        Is = Is || InitiateAStarGreedytCastle(i, Kind, Order);
                    }
                    else
     if (Kind == 5)
                    {
                        Is = Is || InitiateAStarGreedytMinidter(i, Kind, Order);
                    }
                    else
     if (Kind == 6)
                    {
                        Is = Is || InitiateAStarGreedytKing(i, Kind, Order);
                    }
                    else
     if (Kind == 7 || Kind == -7)
                    {
                        Is = Is || InitiateAStarGreedytCastling(i, Kind, Order);
                    }
                }
#pragma warning disable CS0168 // The variable 't' is declared but never used
                catch (Exception t)
#pragma warning restore CS0168 // The variable 't' is declared but never used
                {

                }
                return Is;
            }
        }
        bool InitiateAStarGreedytSoldier(int i, int Kind, int Order)
        {
            Object oo = new Object();
            lock (oo)
            {
                if (Order == 1 && i >= SodierMidle)
                    return false;
                if (Order == -1 && i >= SodierHigh)
                    return false;
                if (SolderesOnTable != null)
                    if (SolderesOnTable[i] != null)
                        return true;
                return false;
            }
        }
        bool InitiateAStarGreedytElephant(int i, int Kind, int Order)
        {
            Object oo = new Object();
            lock (oo)
            {
                if (Order == 1 && i >= ElefantMidle)
                    return false;
                if (Order == -1 && i >= ElefantHigh)
                    return false;
                if (ElephantOnTable != null)
                    if (ElephantOnTable[i] != null)
                        return true;
                return false;
            }
        }
        bool InitiateAStarGreedytHourse(int i, int Kind, int Order)
        {
            Object oo = new Object();
            lock (oo)
            {
                if (Order == 1 && i >= HourseMidle)
                    return false;
                if (Order == -1 && i >= HourseHight)
                    return false;

                if (HoursesOnTable != null)
                    if (HoursesOnTable[i] != null)
                        return true;
                return false;
            }

        }
        bool InitiateAStarGreedytCastle(int i, int Kind, int Order)
        {
            Object oo = new Object();
            lock (oo)
            {
                if (Order == 1 && i >= CastleMidle)
                    return false;
                if (Order == -1 && i >= CastleHigh)
                    return false;

                if (CastlesOnTable != null)
                    if (CastlesOnTable[i] != null)
                        return true;
                return false;
            }
        }
        bool InitiateAStarGreedytMinidter(int i, int Kind, int Order)
        {
            Object oo = new Object();
            lock (oo)
            {
                if (Order == 1 && i >= MinisterMidle)
                    return false;
                if (Order == -1 && i >= MinisterHigh)
                    return false;

                if (MinisterOnTable != null)
                    if (MinisterOnTable[i] != null)
                        return true;
                return false;
            }
        }
        bool InitiateAStarGreedytKing(int i, int Kind, int Order)
        {
            Object oo = new Object();
            lock (oo)
            {
                if (Order == 1 && i >= KingMidle)
                    return false;
                if (Order == -1 && i >= KingHigh)
                    return false;

                if (KingOnTable != null)
                    if (KingOnTable[i] != null)
                        return true;
                return false;

            }
        }
        bool InitiateAStarGreedytCastling(int i, int Kind, int Order)
        {
            Object oo = new Object();
            lock (oo)
            {
                if (Order == 1 && i > 0)
                    return false;
                if (Order == -1 && i > 0)
                    return false;

                if (CastlingOnTable != null)
                    if (CastlingOnTable[i] != null)
                        return true;
                return false;

            }
        }
        AllDraw InitiateAStarGreedytSodler(int i, int iii, int jjj, int[,] Table, int DummyOrder, int DummyCurrentOrder, int iAStarGreedy, int ii, int jj, Color a, int[,] Tab, int Order, bool TB, bool FOUND, int LeafAStarGreedy//, ref Refrigtz.Timer timer, ref Refrigtz.Timer Timerint, ref int Less
             )
        {
            Object oo = new Object();
            lock (oo)
            {
                //For Gray Soldeirs Objects. 
                Object O = new Object();
                lock (O)
                {
                    Order = DummyOrder;
                    ChessRules.CurrentOrder = DummyCurrentOrder;
                    //If Solders Not Exist Continue and Traversal Back.
                    if (InitiateAStarGreedyt(i, 1, Order))
                    {
                        AllDraw Th = AStarGreedyString;
                        if (IsAtLeastAllObjectIsNull())
                        {
                            TableList.Clear();
                            TableList.Add(CloneATable(Table));
                            SetRowColumn(0);
                            IsCurrentDraw = true;
                        }
                        AStarGreedyString = Th;

                        //Initiate of Local Variables By Global Objective Gray Current Solder.
                        //int ik = (int)SolderesOnTable[i].Row;
                        //int jk = (int)SolderesOnTable[i].Column;
                        //Construction of Thinking Gray Soldier By Local Variables.
                        //if (SolderesOnTable[i].SoldierThinking[0].TableListSolder.Count == 0)
                        //If There is no Thinking Movments on Current Object  
                        if (SolderesOnTable[i].SoldierThinking[0].TableListSolder.Count == 0)
                        {
                            InitiateAStarGreedytSodlerThinking(i, iii, jjj, Table, DummyOrder, DummyCurrentOrder, iAStarGreedy, ii, jj, a, Tab, Order, TB, FOUND, LeafAStarGreedy);
                        }
                        else
                        {
                            SolderesOnTable[i].SoldierThinking[0].ThinkingBegin = false;
                            SolderesOnTable[i].SoldierThinking[0].ThinkingFinished = true;
                        }
                    }
                }
            }
            return this;
        }
        AllDraw InitiateAStarGreedytSodlerThinking(int i, int iii, int jjj, int[,] Table, int DummyOrder, int DummyCurrentOrder, int iAStarGreedy, int ii, int jj, Color a, int[,] Tab, int Order, bool TB, bool FOUND, int LeafAStarGreedy//, ref Refrigtz.Timer timer, ref Refrigtz.Timer Timerint, ref int Less
         )
        {

            //For All Movable Gray Solders.
            //Thinking of Gray Solder Operation.
            Object OOO = new Object();
            lock (OOO)
            {
                SolderesOnTable[i].SoldierThinking[0].ThinkingBegin = true;
                SolderesOnTable[i].SoldierThinking[0].ThinkingFinished = false;
                var array = Task.Factory.StartNew(() => SolderesOnTable[i].SoldierThinking[0].Thinking(iAStarGreedy, this, ref SolderesOnTable[i].LoseOcuuredatChiled, ref SolderesOnTable[i].WinOcuuredatChiled));
                array.Wait(); array.Dispose();
                if (SolderesOnTable[i].SoldierThinking[0].TableListSolder.Count != 0)
                {
                    SolderesOnTableMove[i] = true;
                    AllDraw.ChangedInTreeOccured = true;

                }
            }

            return this;
        }
        //main initiation of elephant Gray
        AllDraw InitiateAStarGreedytElephantGray(int iii, int jjj, int[,] Table, int DummyOrder, int DummyCurrentOrder, int iAStarGreedy, int ii, int jj, Color a, int[,] Tab, int Order, bool TB, bool FOUND, int LeafAStarGreedy//, ref Refrigtz.Timer timer, ref Refrigtz.Timer Timerint, ref int Less
            )
        {
            Object oo = new Object();
            lock (oo)
            {
                ParallelOptions po = new ParallelOptions(); po.MaxDegreeOfParallelism = System.Threading.PlatformHelper.ProcessorCount; Parallel.For(0, ElefantMidle, i =>
 {
     var H = Task.Factory.StartNew(() => InitiateAStarGreedytElephant(i, iii, jjj, CloneATable(Table), DummyOrder, DummyCurrentOrder, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ii, jj, a, CloneATable(Tab), Order, TB, FOUND, LeafAStarGreedy));
     H.Wait();
     H.Dispose();
 });
            }
            return this;
        }
        AllDraw InitiateAStarGreedytElephant(int i, int iii, int jjj, int[,] Table, int DummyOrder, int DummyCurrentOrder, int iAStarGreedy, int ii, int jj, Color a, int[,] Tab, int Order, bool TB, bool FOUND, int LeafAStarGreedy//, ref Refrigtz.Timer timer, ref Refrigtz.Timer Timerint, ref int Less
             )
        {
            Object oo = new Object();
            lock (oo)
            {

                Object O = new Object();
                lock (O)
                {
                    Order = DummyOrder;
                    ChessRules.CurrentOrder = DummyCurrentOrder;
                    //Ignore of Non Exist Current Elephant Gray Objects.
                    if (InitiateAStarGreedyt(i, 2, Order))
                    {
                        AllDraw Th = AStarGreedyString;
                        if (IsAtLeastAllObjectIsNull())
                        {
                            TableList.Clear();
                            TableList.Add(CloneATable(Table));
                            SetRowColumn(0);
                            IsCurrentDraw = true;
                        }
                        AStarGreedyString = Th;

                        //Inititae Local Varibale By Global Gray Elephant Objects Varibales.
                        //int ik = (int)ElephantOnTable[i].Row;
                        //int jk = (int)ElephantOnTable[i].Column;
                        //Construction of Thinking Objects By Local Varibales.
                        //if (ElephantOnTable[i].ElefantThinking[0].TableListElefant.Count == 0)
                        //If There is Not Thinking Objetive List Elephant Gray. 
                        if (ElephantOnTable[i].ElefantThinking[0].TableListElefant.Count == 0)
                        {
                            InitiateAStarGreedytElephantThinking(i, iii, jjj, Table, DummyOrder, DummyCurrentOrder, iAStarGreedy, ii, jj, a, Tab, Order, TB, FOUND, LeafAStarGreedy);
                        }
                        else
                        {
                            ElephantOnTable[i].ElefantThinking[0].ThinkingBegin = false;
                            ElephantOnTable[i].ElefantThinking[0].ThinkingFinished = true;
                        }
                    }
                }
            }
            return this;
        }
        AllDraw InitiateAStarGreedytElephantThinking(int i, int iii, int jjj, int[,] Table, int DummyOrder, int DummyCurrentOrder, int iAStarGreedy, int ii, int jj, Color a, int[,] Tab, int Order, bool TB, bool FOUND, int LeafAStarGreedy//, ref Refrigtz.Timer timer, ref Refrigtz.Timer Timerint, ref int Less
         )
        {


            Object O = new Object();
            lock (O)
            {


                ElephantOnTable[i].ElefantThinking[0].ThinkingBegin = true;
                ElephantOnTable[i].ElefantThinking[0].ThinkingFinished = false;
                var array = Task.Factory.StartNew(() => ElephantOnTable[i].ElefantThinking[0].Thinking(iAStarGreedy, this, ref ElephantOnTable[i].LoseOcuuredatChiled, ref ElephantOnTable[i].WinOcuuredatChiled));
                array.Wait(); array.Dispose();
                if (ElephantOnTable[i].ElefantThinking[0].TableListElefant.Count != 0)
                {
                    ElephantOnTableMove[i] = true;
                    AllDraw.ChangedInTreeOccured = true;

                }

            }
            return this;
        }
        //main initiation of hourse Gray
        AllDraw InitiateAStarGreedythHourseGray(int iii, int jjj, int[,] Table, int DummyOrder, int DummyCurrentOrder, int iAStarGreedy, int ii, int jj, Color a, int[,] Tab, int Order, bool TB, bool FOUND, int LeafAStarGreedy//, ref Refrigtz.Timer timer, ref Refrigtz.Timer Timerint, ref int Less
            )
        {
            Object oo = new Object();
            lock (oo)
            {
                //For All Gray Hourse Objects.
                ParallelOptions po = new ParallelOptions(); po.MaxDegreeOfParallelism = System.Threading.PlatformHelper.ProcessorCount; Parallel.For(0, HourseMidle, i =>
 {
     var H = Task.Factory.StartNew(() => InitiateAStarGreedythHourse(i, iii, jjj, CloneATable(Table), DummyOrder, DummyCurrentOrder, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ii, jj, a, CloneATable(Tab), Order, TB, FOUND, LeafAStarGreedy));
     H.Wait();
     H.Dispose();
 });
            }
            return this;
        }
        AllDraw InitiateAStarGreedythHourse(int i, int iii, int jjj, int[,] Table, int DummyOrder, int DummyCurrentOrder, int iAStarGreedy, int ii, int jj, Color a, int[,] Tab, int Order, bool TB, bool FOUND, int LeafAStarGreedy//, ref Refrigtz.Timer timer, ref Refrigtz.Timer Timerint, ref int Less
            )
        {
            Object oo = new Object();
            lock (oo)
            {
                //For All Gray Hourse Objects.
                Object O = new Object();
                lock (O)
                {
                    Order = DummyOrder;
                    ChessRules.CurrentOrder = DummyCurrentOrder;
                    //Ignore of Non Exist Current Gray Hourse Objects.
                    if (InitiateAStarGreedyt(i, 3, Order))
                    {
                        AllDraw Th = AStarGreedyString;
                        if (IsAtLeastAllObjectIsNull())
                        {
                            TableList.Clear();
                            TableList.Add(CloneATable(Table));
                            SetRowColumn(0);
                            IsCurrentDraw = true;
                        }
                        AStarGreedyString = Th;

                        //Initiate of Local Variables By Global Gray Hourse Objectives.
                        //int ik = (int)HoursesOnTable[i].Row;
                        //int jk = (int)HoursesOnTable[i].Column;
                        //Construction of Gray Hourse Thinking Objects..
                        //if (HoursesOnTable[i].HourseThinking[0].TableListHourse.Count == 0)
                        //When There is Not HourseList Count. 
                        if (HoursesOnTable[i].HourseThinking[0].TableListHourse.Count == 0)
                        {
                            InitiateAStarGreedythHourseThinking(i, iii, jjj, Table, DummyOrder, DummyCurrentOrder, iAStarGreedy, ii, jj, a, Tab, Order, TB, FOUND, LeafAStarGreedy);
                        }
                        else
                        {
                            HoursesOnTable[i].HourseThinking[0].ThinkingBegin = false;
                            HoursesOnTable[i].HourseThinking[0].ThinkingFinished = true;
                        }
                    }
                }
            }
            return this;
        }
        AllDraw InitiateAStarGreedythHourseThinking(int i, int iii, int jjj, int[,] Table, int DummyOrder, int DummyCurrentOrder, int iAStarGreedy, int ii, int jj, Color a, int[,] Tab, int Order, bool TB, bool FOUND, int LeafAStarGreedy//, ref Refrigtz.Timer timer, ref Refrigtz.Timer Timerint, ref int Less
        )
        {

            //For All Gray Hourse Objects.
            Object O = new Object();
            lock (O)
            {

                //For All Possible Movments.

                //Thinking of Gray Hourse Oprational.

                HoursesOnTable[i].HourseThinking[0].ThinkingBegin = true;
                HoursesOnTable[i].HourseThinking[0].ThinkingFinished = false;
                var array = Task.Factory.StartNew(() => HoursesOnTable[i].HourseThinking[0].Thinking(iAStarGreedy, this, ref HoursesOnTable[i].LoseOcuuredatChiled, ref HoursesOnTable[i].WinOcuuredatChiled));
                array.Wait(); array.Dispose();
                if (HoursesOnTable[i].HourseThinking[0].TableListHourse.Count != 0)
                {
                    HoursesOnTableMove[i] = true;
                    AllDraw.ChangedInTreeOccured = true;

                }



                return this;
            }
        }
        //main initiation of Castle Gray
        AllDraw InitiateAStarGreedythCastleGray(int iii, int jjj, int[,] Table, int DummyOrder, int DummyCurrentOrder, int iAStarGreedy, int ii, int jj, Color a, int[,] Tab, int Order, bool TB, bool FOUND, int LeafAStarGreedy//, ref Refrigtz.Timer timer, ref Refrigtz.Timer Timerint, ref int Less
       )
        {
            Object oo = new Object();
            lock (oo)
            {
                //For All Possible Gray Castles Objects.
                ParallelOptions po = new ParallelOptions(); po.MaxDegreeOfParallelism = System.Threading.PlatformHelper.ProcessorCount; Parallel.For(0, CastleMidle, i =>
 {
     var H = Task.Factory.StartNew(() => InitiateAStarGreedythCastle(i, iii, jjj, CloneATable(Table), DummyOrder, DummyCurrentOrder, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ii, jj, a, CloneATable(Tab), Order, TB, FOUND, LeafAStarGreedy));
     H.Wait();
     H.Dispose();
 });
            }
            return this;
        }
        AllDraw InitiateAStarGreedythCastle(int i, int iii, int jjj, int[,] Table, int DummyOrder, int DummyCurrentOrder, int iAStarGreedy, int ii, int jj, Color a, int[,] Tab, int Order, bool TB, bool FOUND, int LeafAStarGreedy//, ref Refrigtz.Timer timer, ref Refrigtz.Timer Timerint, ref int Less
       )
        {
            Object oo = new Object();
            lock (oo)
            {
                //For All Possible Gray Castles Objects.
                Object O = new Object();
                lock (O)
                {
                    Order = DummyOrder;
                    ChessRules.CurrentOrder = DummyCurrentOrder;
                    //When Current Castles Gray Not Exist Continue Traversal Back.
                    if (InitiateAStarGreedyt(i, 4, Order))
                    {
                        AllDraw Th = AStarGreedyString;
                        if (IsAtLeastAllObjectIsNull())
                        {
                            TableList.Clear();
                            TableList.Add(CloneATable(Table));
                            SetRowColumn(0);
                            IsCurrentDraw = true;
                        }
                        AStarGreedyString = Th;

                        //Initaiate of Local Varibales By Global Varoiables.
                        //int ik = (int)CastlesOnTable[i].Row;
                        //int jk = (int)CastlesOnTable[i].Column;
                        //Construction of Thinking Variables By Local Variables.
                        //if (CastlesOnTable[i].CastleThinking[0].TableListCastle.Count == 0)
                        //When Count of Table Castles of Thinking Not Exist Do Operational.
                        if (CastlesOnTable[i].CastleThinking[0].TableListCastle.Count == 0)
                        {
                            InitiateAStarGreedythCastleThinking(i, iii, jjj, Table, DummyOrder, DummyCurrentOrder, iAStarGreedy, ii, jj, a, Tab, Order, TB, FOUND, LeafAStarGreedy);
                        }
                        else
                        {
                            CastlesOnTable[i].CastleThinking[0].ThinkingBegin = false;
                            CastlesOnTable[i].CastleThinking[0].ThinkingFinished = true;
                        }
                    }
                }
            }
            return this;
        }
        AllDraw InitiateAStarGreedythCastleThinking(int i, int iii, int jjj, int[,] Table, int DummyOrder, int DummyCurrentOrder, int iAStarGreedy, int ii, int jj, Color a, int[,] Tab, int Order, bool TB, bool FOUND, int LeafAStarGreedy//, ref Refrigtz.Timer timer, ref Refrigtz.Timer Timerint, ref int Less
   )
        {

            //For All Possible Movments.

            Object OOO = new Object();
            lock (OOO)
            {
                //Thinking of Gray Castles Operational.
                CastlesOnTable[i].CastleThinking[0].ThinkingBegin = true;
                CastlesOnTable[i].CastleThinking[0].ThinkingFinished = false;
                var array = Task.Factory.StartNew(() => CastlesOnTable[i].CastleThinking[0].Thinking(iAStarGreedy, this, ref CastlesOnTable[i].LoseOcuuredatChiled, ref CastlesOnTable[i].WinOcuuredatChiled));
                array.Wait(); array.Dispose();

                if (CastlesOnTable[i].CastleThinking[0].TableListCastle.Count != 0)
                {
                    CastlesOnTableMove[i] = true;
                    AllDraw.ChangedInTreeOccured = true;

                }
            }


            return this;
        }
        //main initiation of minister Gray
        AllDraw InitiateAStarGreedythMinisterGray(int iii, int jjj, int[,] Table, int DummyOrder, int DummyCurrentOrder, int iAStarGreedy, int ii, int jj, Color a, int[,] Tab, int Order, bool TB, bool FOUND, int LeafAStarGreedy//, ref Refrigtz.Timer timer, ref Refrigtz.Timer Timerint, ref int Less
            )
        {
            Object oo = new Object();
            lock (oo)
            {
                //For All Possible Gray Minister Movments.
                ParallelOptions po = new ParallelOptions(); po.MaxDegreeOfParallelism = System.Threading.PlatformHelper.ProcessorCount; Parallel.For(0, MinisterMidle, i =>
 {
     var H = Task.Factory.StartNew(() => InitiateAStarGreedythMinister(i, iii, jjj, CloneATable(Table), DummyOrder, DummyCurrentOrder, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ii, jj, a, CloneATable(Tab), Order, TB, FOUND, LeafAStarGreedy));
     H.Wait();
     H.Dispose();
 });
            }
            return this;
        }
        AllDraw InitiateAStarGreedythMinister(int i, int iii, int jjj, int[,] Table, int DummyOrder, int DummyCurrentOrder, int iAStarGreedy, int ii, int jj, Color a, int[,] Tab, int Order, bool TB, bool FOUND, int LeafAStarGreedy//, ref Refrigtz.Timer timer, ref Refrigtz.Timer Timerint, ref int Less
            )
        {
            Object oo = new Object();
            lock (oo)
            {
                //For All Possible Gray Minister Movments.
                Object O = new Object();
                lock (O)
                {
                    Order = DummyOrder;
                    ChessRules.CurrentOrder = DummyCurrentOrder;
                    //For Each Non Exist Gray Minister Objectives.
                    if (InitiateAStarGreedyt(i, 5, Order))
                    {
                        AllDraw Th = AStarGreedyString;
                        if (IsAtLeastAllObjectIsNull())
                        {
                            TableList.Clear();
                            TableList.Add(CloneATable(Table));
                            SetRowColumn(0);
                            IsCurrentDraw = true;
                        }
                        AStarGreedyString = Th;

                        //Inititate Local Variables By Global Varibales.
                        //int ik = (int)MinisterOnTable[i].Row;
                        //int jk = (int)MinisterOnTable[i].Column;
                        //Construction of Thinking Objects Gray Minister.
                        //if (MinisterOnTable[i].MinisterThinking[0].TableListMinister.Count == 0)
                        //If There is Not Minister Of Gray In The Thinking Table List.   
                        if (MinisterOnTable[i].MinisterThinking[0].TableListMinister.Count == 0)
                        {
                            InitiateAStarGreedythMinisterThinking(i, iii, jjj, Table, DummyOrder, DummyCurrentOrder, iAStarGreedy, ii, jj, a, Tab, Order, TB, FOUND, LeafAStarGreedy);
                        }
                        else
                        {
                            MinisterOnTable[i].MinisterThinking[0].ThinkingBegin = false;
                            MinisterOnTable[i].MinisterThinking[0].ThinkingFinished = true;
                        }
                    }
                }
            }
            return this;
        }
        AllDraw InitiateAStarGreedythMinisterThinking(int i, int iii, int jjj, int[,] Table, int DummyOrder, int DummyCurrentOrder, int iAStarGreedy, int ii, int jj, Color a, int[,] Tab, int Order, bool TB, bool FOUND, int LeafAStarGreedy//, ref Refrigtz.Timer timer, ref Refrigtz.Timer Timerint, ref int Less
      )
        {
            Object oo = new Object();
            lock (oo)
            {
                //For All Possible Gray Minister Movments.
                Object O = new Object();
                lock (O)
                {

                    //For All Possible Movments.

                    //Thinking of Gray Minister Operational.
                    Object OOO = new Object();
                    lock (OOO)
                    {
                        MinisterOnTable[i].MinisterThinking[0].ThinkingBegin = true;
                        MinisterOnTable[i].MinisterThinking[0].ThinkingFinished = false;
                        var array = Task.Factory.StartNew(() => MinisterOnTable[i].MinisterThinking[0].Thinking(iAStarGreedy, this, ref MinisterOnTable[i].LoseOcuuredatChiled, ref MinisterOnTable[i].WinOcuuredatChiled));
                        array.Wait(); array.Dispose();
                        if (MinisterOnTable[i].MinisterThinking[0].TableListMinister.Count != 0)
                        {
                            MinisterOnTableMove[i] = true;
                            AllDraw.ChangedInTreeOccured = true;

                        }
                    }
                }

            }
            return this;
        }
        //main initiation of king Gray
        AllDraw InitiateAStarGreedythKingGray(int iii, int jjj, int[,] Table, int DummyOrder, int DummyCurrentOrder, int iAStarGreedy, int ii, int jj, Color a, int[,] Tab, int Order, bool TB, bool FOUND, int LeafAStarGreedy//, ref Refrigtz.Timer timer, ref Refrigtz.Timer Timerint, ref int Less
            )
        {
            Object oo = new Object();
            lock (oo)
            {
                //For All Possible Gray King Objects.
                ParallelOptions po = new ParallelOptions(); po.MaxDegreeOfParallelism = System.Threading.PlatformHelper.ProcessorCount; Parallel.For(0, KingMidle, i =>
 {
     var H = Task.Factory.StartNew(() => InitiateAStarGreedythKing(i, iii, jjj, CloneATable(Table), DummyOrder, DummyCurrentOrder, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ii, jj, a, CloneATable(Tab), Order, TB, FOUND, LeafAStarGreedy));
     H.Wait();
     H.Dispose();
 });
            }
            return this;
        }
        AllDraw InitiateAStarGreedythCastlingGray(int iii, int jjj, int[,] Table, int DummyOrder, int DummyCurrentOrder, int iAStarGreedy, int ii, int jj, Color a, int[,] Tab, int Order, bool TB, bool FOUND, int LeafAStarGreedy//, ref Refrigtz.Timer timer, ref Refrigtz.Timer Timerint, ref int Less
             )
        {
            Object oo = new Object();
            lock (oo)
            {
                //For All Possible Gray Castling Objects.
                ParallelOptions po = new ParallelOptions(); po.MaxDegreeOfParallelism = System.Threading.PlatformHelper.ProcessorCount; Parallel.For(0, 1, i =>
                 {
                     var H = Task.Factory.StartNew(() => InitiateAStarGreedythCastling(7, i, iii, jjj, CloneATable(Table), DummyOrder, DummyCurrentOrder, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ii, jj, a, CloneATable(Tab), Order, TB, FOUND, LeafAStarGreedy));
                     H.Wait();
                     H.Dispose();
                 });
            }
            return this;
        }
        AllDraw InitiateAStarGreedythKing(int i, int iii, int jjj, int[,] Table, int DummyOrder, int DummyCurrentOrder, int iAStarGreedy, int ii, int jj, Color a, int[,] Tab, int Order, bool TB, bool FOUND, int LeafAStarGreedy//, ref Refrigtz.Timer timer, ref Refrigtz.Timer Timerint, ref int Less
             )
        {
            Object oo = new Object();
            lock (oo)
            {
                //For All Possible Gray King Objects.
                Object O = new Object();
                lock (O)
                {
                    Order = DummyOrder;
                    ChessRules.CurrentOrder = DummyCurrentOrder;
                    //If There is Not Current Object Continue Traversal Back.
                    if (InitiateAStarGreedyt(i, 6, Order))
                    {
                        AllDraw Th = AStarGreedyString;
                        if (IsAtLeastAllObjectIsNull())
                        {
                            TableList.Clear();
                            TableList.Add(CloneATable(Table));
                            SetRowColumn(0);
                            IsCurrentDraw = true;
                        }
                        AStarGreedyString = Th;

                        //Initiate Local varibale By Global Objective Varibales.
                        //int ik = (int)(int)KingOnTable[i].Row;
                        //int jk = (int)KingOnTable[i].Column;
                        //Construction of Gray King Thinking Objects.
                        //if (KingOnTable[i].KingThinking[0].TableListKing.Count == 0)
                        //When There is Not Thinking Table Gray King Movments.
                        if (KingOnTable[i].KingThinking[0].TableListKing.Count == 0)
                        {
                            InitiateAStarGreedythKingThinking(i, iii, jjj, Table, DummyOrder, DummyCurrentOrder, iAStarGreedy, ii, jj, a, Tab, Order, TB, FOUND, LeafAStarGreedy);
                        }
                        else
                        {
                            KingOnTable[i].KingThinking[0].ThinkingBegin = false;
                            KingOnTable[i].KingThinking[0].ThinkingFinished = true;
                        }
                    }
                }
            }
            return this;
        }
        AllDraw InitiateAStarGreedythKingThinking(int i, int iii, int jjj, int[,] Table, int DummyOrder, int DummyCurrentOrder, int iAStarGreedy, int ii, int jj, Color a, int[,] Tab, int Order, bool TB, bool FOUND, int LeafAStarGreedy//, ref Refrigtz.Timer timer, ref Refrigtz.Timer Timerint, ref int Less
       )
        {
            Object oo = new Object();
            lock (oo)
            {

                //For All Possible Gray King Movments.

                //Thinking Of Gray King Operatins.
                Object OOO = new Object();
                lock (OOO)
                {
                    KingOnTable[i].KingThinking[0].ThinkingBegin = true;
                    KingOnTable[i].KingThinking[0].ThinkingFinished = false;
                    ; var array = Task.Factory.StartNew(() => KingOnTable[i].KingThinking[0].Thinking(iAStarGreedy, this, ref KingOnTable[i].LoseOcuuredatChiled, ref KingOnTable[i].WinOcuuredatChiled));
                    array.Wait(); array.Dispose();
                    if (KingOnTable[i].KingThinking[0].TableListKing.Count != 0)
                    {
                        KingOnTableMove[i] = true;
                        AllDraw.ChangedInTreeOccured = true;

                    }
                }

            }
            return this;
        }
        AllDraw InitiateAStarGreedythCastling(int kin, int i, int iii, int jjj, int[,] Table, int DummyOrder, int DummyCurrentOrder, int iAStarGreedy, int ii, int jj, Color a, int[,] Tab, int Order, bool TB, bool FOUND, int LeafAStarGreedy//, ref Refrigtz.Timer timer, ref Refrigtz.Timer Timerint, ref int Less
             )
        {
            Object oo = new Object();
            lock (oo)
            {
                //For All Possible Gray Castling Objects.
                Object O = new Object();
                lock (O)
                {
                    Order = DummyOrder;
                    ChessRules.CurrentOrder = DummyCurrentOrder;
                    //If There is Not Current Object Continue Traversal Back.
                    if (InitiateAStarGreedyt(i, kin, Order))
                    {
                        AllDraw Th = AStarGreedyString;
                        if (IsAtLeastAllObjectIsNull())
                        {
                            TableList.Clear();
                            TableList.Add(CloneATable(Table));
                            SetRowColumn(0);
                            IsCurrentDraw = true;
                        }
                        AStarGreedyString = Th;

                        //Initiate Local varibale By Global Objective Varibales.
                        //int ik = (int)(int)CastlingOnTable[i].Row;
                        //int jk = (int)CastlingOnTable[i].Column;
                        //Construction of Gray Castling Thinking Objects.
                        //if (CastlingOnTable[i].CastlingThinking[0].TableListCastling.Count == 0)
                        //When There is Not Thinking Table Gray Castling Movments.
                        if (CastlingOnTable[i].CastlingThinking[0].TableListCastling.Count == 0)
                        {
                            InitiateAStarGreedythCastlingThinking(kin, i, iii, jjj, Table, DummyOrder, DummyCurrentOrder, iAStarGreedy, ii, jj, a, Tab, Order, TB, FOUND, LeafAStarGreedy);
                        }
                        else
                        {
                            CastlingOnTable[i].CastlingThinking[0].ThinkingBegin = false;
                            CastlingOnTable[i].CastlingThinking[0].ThinkingFinished = true;
                        }
                    }
                }
            }
            return this;
        }
        AllDraw InitiateAStarGreedythCastlingThinking(int kin, int i, int iii, int jjj, int[,] Table, int DummyOrder, int DummyCurrentOrder, int iAStarGreedy, int ii, int jj, Color a, int[,] Tab, int Order, bool TB, bool FOUND, int LeafAStarGreedy//, ref Refrigtz.Timer timer, ref Refrigtz.Timer Timerint, ref int Less
           )
        {
            Object oo = new Object();
            lock (oo)
            {
                //For All Possible Gray Castling Movments.
                //Thinking Of Gray Castling Operatins.
                CastlingOnTable[i].CastlingThinking[0].ThinkingBegin = true;
                CastlingOnTable[i].CastlingThinking[0].ThinkingFinished = false;
                var array = Task.Factory.StartNew(() => CastlingOnTable[i].CastlingThinking[0].Thinking(iAStarGreedy, this, ref CastlingOnTable[i].LoseOcuuredatChiled, ref CastlingOnTable[i].WinOcuuredatChiled));
                array.Wait(); array.Dispose();
                if (CastlingOnTable[i].CastlingThinking[0].TableListCastling.Count != 0)
                {
                    CastlingOnTableMove[i] = true;
                    AllDraw.ChangedInTreeOccured = true;

                }



            }
            return this;
        }
        //main initiation of soldier Brown 
        AllDraw InitiateAStarGreedythSoldierBrown(int iii, int jjj, int[,] Table, int DummyOrder, int DummyCurrentOrder, int iAStarGreedy, int ii, int jj, Color a, int[,] Tab, int Order, bool TB, bool FOUND, int LeafAStarGreedy//, ref Refrigtz.Timer timer, ref Refrigtz.Timer Timerint, ref int Less
            )
        {

            Object oo = new Object();
            lock (oo)
            {


                //For Each Objects of Brown Sodiers.
                ParallelOptions po = new ParallelOptions(); po.MaxDegreeOfParallelism = System.Threading.PlatformHelper.ProcessorCount; Parallel.For(SodierMidle, SodierHigh, i =>

 {
     var H = Task.Factory.StartNew(() => InitiateAStarGreedytSodler(i, iii, jjj, CloneATable(Table), DummyOrder, DummyCurrentOrder, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ii, jj, a, CloneATable(Tab), Order, TB, FOUND, LeafAStarGreedy));
     H.Wait();
     H.Dispose();
 });

            }

            return this;
        }
        //main initiation of elephant Brown
        AllDraw InitiateAStarGreedythElephantBrown(int iii, int jjj, int[,] Table, int DummyOrder, int DummyCurrentOrder, int iAStarGreedy, int ii, int jj, Color a, int[,] Tab, int Order, bool TB, bool FOUND, int LeafAStarGreedy//, ref Refrigtz.Timer timer, ref Refrigtz.Timer Timerint, ref int Less
            )
        {

            Object oo = new Object();
            lock (oo)
            {



                ParallelOptions po = new ParallelOptions(); po.MaxDegreeOfParallelism = System.Threading.PlatformHelper.ProcessorCount; Parallel.For(ElefantMidle, ElefantHigh, i =>

 {
     var H = Task.Factory.StartNew(() => InitiateAStarGreedytElephant(i, iii, jjj, CloneATable(Table), DummyOrder, DummyCurrentOrder, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ii, jj, a, CloneATable(Tab), Order, TB, FOUND, LeafAStarGreedy));
     H.Wait();
     H.Dispose();
 });

            }

            return this;
        }
        //main initiation of hourse Brown
        AllDraw InitiateAStarGreedythHourseBrown(int iii, int jjj, int[,] Table, int DummyOrder, int DummyCurrentOrder, int iAStarGreedy, int ii, int jj, Color a, int[,] Tab, int Order, bool TB, bool FOUND, int LeafAStarGreedy//, ref Refrigtz.Timer timer, ref Refrigtz.Timer Timerint, ref int Less
            )
        {

            Object oo = new Object();
            lock (oo)
            {


                ParallelOptions po = new ParallelOptions(); po.MaxDegreeOfParallelism = System.Threading.PlatformHelper.ProcessorCount; Parallel.For(HourseMidle, HourseHight, i =>

 {
     var H = Task.Factory.StartNew(() => InitiateAStarGreedythHourse(i, iii, jjj, CloneATable(Table), DummyOrder, DummyCurrentOrder, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ii, jj, a, CloneATable(Tab), Order, TB, FOUND, LeafAStarGreedy));
     H.Wait();
     H.Dispose();
 });

            }

            return this;
        }
        //main initiation of Castle Brown
        AllDraw InitiateAStarGreedythCastleBrown(int iii, int jjj, int[,] Table, int DummyOrder, int DummyCurrentOrder, int iAStarGreedy, int ii, int jj, Color a, int[,] Tab, int Order, bool TB, bool FOUND, int LeafAStarGreedy//, ref Refrigtz.Timer timer, ref Refrigtz.Timer Timerint, ref int Less
            )
        {

            Object oo = new Object();
            lock (oo)
            {


                ParallelOptions po = new ParallelOptions(); po.MaxDegreeOfParallelism = System.Threading.PlatformHelper.ProcessorCount; Parallel.For(CastleMidle, CastleHigh, i =>

 {
     var H = Task.Factory.StartNew(() => InitiateAStarGreedythCastle(i, iii, jjj, CloneATable(Table), DummyOrder, DummyCurrentOrder, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ii, jj, a, CloneATable(Tab), Order, TB, FOUND, LeafAStarGreedy));
     H.Wait();
     H.Dispose();
 });

            }

            return this;
        }
        //main initiatiob of minister Brown
        AllDraw InitiateAStarGreedythMinisterBrown(int iii, int jjj, int[,] Table, int DummyOrder, int DummyCurrentOrder, int iAStarGreedy, int ii, int jj, Color a, int[,] Tab, int Order, bool TB, bool FOUND, int LeafAStarGreedy//, ref Refrigtz.Timer timer, ref Refrigtz.Timer Timerint, ref int Less
            )
        {

            Object oo = new Object();
            lock (oo)
            {



                ParallelOptions po = new ParallelOptions(); po.MaxDegreeOfParallelism = System.Threading.PlatformHelper.ProcessorCount; Parallel.For(MinisterMidle, MinisterHigh, i =>

 {
     var H = Task.Factory.StartNew(() => InitiateAStarGreedythMinister(i, iii, jjj, CloneATable(Table), DummyOrder, DummyCurrentOrder, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ii, jj, a, CloneATable(Tab), Order, TB, FOUND, LeafAStarGreedy));
     H.Wait();
     H.Dispose();
 });
            }

            return this;
        }
        //main initiation of king Brown
        AllDraw InitiateAStarGreedythKingBrown(int iii, int jjj, int[,] Table, int DummyOrder, int DummyCurrentOrder, int iAStarGreedy, int ii, int jj, Color a, int[,] Tab, int Order, bool TB, bool FOUND, int LeafAStarGreedy//, ref Refrigtz.Timer timer, ref Refrigtz.Timer Timerint, ref int Less
            )
        {

            Object oo = new Object();
            lock (oo)
            {



                ParallelOptions po = new ParallelOptions(); po.MaxDegreeOfParallelism = System.Threading.PlatformHelper.ProcessorCount; Parallel.For(KingMidle, KingHigh, i =>

                 {
                     var H = Task.Factory.StartNew(() => InitiateAStarGreedythKing(i, iii, jjj, CloneATable(Table), DummyOrder, DummyCurrentOrder, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ii, jj, a, CloneATable(Tab), Order, TB, FOUND, LeafAStarGreedy));
                     H.Wait();
                     H.Dispose();
                 });
            }

            return this;
        }
        AllDraw InitiateAStarGreedythCastlingBrown(int iii, int jjj, int[,] Table, int DummyOrder, int DummyCurrentOrder, int iAStarGreedy, int ii, int jj, Color a, int[,] Tab, int Order, bool TB, bool FOUND, int LeafAStarGreedy//, ref Refrigtz.Timer timer, ref Refrigtz.Timer Timerint, ref int Less
             )
        {

            Object oo = new Object();
            lock (oo)
            {



                ParallelOptions po = new ParallelOptions(); po.MaxDegreeOfParallelism = System.Threading.PlatformHelper.ProcessorCount; Parallel.For(0, 1, i =>

                 {
                     var H = Task.Factory.StartNew(() => InitiateAStarGreedythCastling(-7, i, iii, jjj, CloneATable(Table), DummyOrder, DummyCurrentOrder, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ii, jj, a, CloneATable(Tab), Order, TB, FOUND, LeafAStarGreedy));
                     H.Wait();
                     H.Dispose();
                 });
            }

            return this;
        }
        //boundry condition determistic method for break
        bool FullBoundryConditionsSoldierIgnore(int ikk, int Current, int Order, int iAStarGreedy)
        {
            Object O = new Object();
            lock (O)
            {
                bool IS = false;
                try
                {
                    if (SolderesOnTable == null)
                        return true;
                    if (SolderesOnTable[ikk] == null)
                        return true;
                    if (SolderesOnTable[ikk].LoseOcuuredatChiled == null)
                        return true;
                    if (SolderesOnTable[ikk].SoldierThinking == null)
                        return true;
                    if (SolderesOnTable[ikk].SoldierThinking[0] == null)
                        return true;
                    if (SolderesOnTable[ikk].SoldierThinking[0].TableListSolder == null)
                    {
                        SolderesOnTable[ikk].SoldierThinking[0].TableListSolder = new List<int[,]>();
                        SolderesOnTable[ikk].SoldierThinking[0].RowColumnSoldier = new List<int[]>();
                        SolderesOnTable[ikk].SoldierThinking[0].HitNumberSoldier = new List<int>();
                        SolderesOnTable[ikk].SoldierThinking[0].HeuristicListSolder = new List<int[]>();
                        SolderesOnTable[ikk].SoldierThinking[0].PenaltyRegardListSolder = new List<QuantumAtamata>();
                    }
                }
                catch (Exception t) { Log(t); }
                return IS;
            }
        }
        //boundry condition determistic method for break
        bool FullBoundryConditionsElephantIgnore(int ikk, int Current, int Order, int iAStarGreedy)
        {
            Object O = new Object();
            lock (O)
            {
                bool IS = false;
                try
                {
                    if (ElephantOnTable == null)
                        return true;
                    if (ElephantOnTable[ikk] == null)
                        return true;
                    if (ElephantOnTable[ikk].LoseOcuuredatChiled == null)
                        return true;
                    if (ElephantOnTable[ikk].ElefantThinking == null)
                        return true;
                    if (ElephantOnTable[ikk].ElefantThinking[0] == null)
                        return true;
                    if (ElephantOnTable[ikk].ElefantThinking[0].TableListElefant == null)

                    {
                        ElephantOnTable[ikk].ElefantThinking[0].TableListElefant = new List<int[,]>();
                        ElephantOnTable[ikk].ElefantThinking[0].RowColumnElefant = new List<int[]>();
                        ElephantOnTable[ikk].ElefantThinking[0].HitNumberElefant = new List<int>();
                        ElephantOnTable[ikk].ElefantThinking[0].HeuristicListElefant = new List<int[]>();
                        ElephantOnTable[ikk].ElefantThinking[0].PenaltyRegardListElefant = new List<QuantumAtamata>();
                    }

                }
                catch (Exception t) { Log(t); }
                return IS;
            }
        }
        //boundry condition determistic method for break
        bool FullBoundryConditionsHourseIgnore(int ikk, int Current, int Order, int iAStarGreedy)
        {

            Object O = new Object();
            lock (O)
            {
                bool IS = false;
                try
                {
                    if (HoursesOnTable == null)
                        return true;

                    if (HoursesOnTable[ikk] == null)
                        return true;
                    if (HoursesOnTable[ikk].LoseOcuuredatChiled == null)
                        return true;
                    if (HoursesOnTable[ikk].HourseThinking == null)
                        return true;
                    if (HoursesOnTable[ikk].HourseThinking[0] == null)
                        return true;
                    if (HoursesOnTable[ikk].HourseThinking[0].TableListHourse == null)

                    {
                        HoursesOnTable[ikk].HourseThinking[0].TableListHourse = new List<int[,]>();
                        HoursesOnTable[ikk].HourseThinking[0].RowColumnHourse = new List<int[]>();
                        HoursesOnTable[ikk].HourseThinking[0].HitNumberHourse = new List<int>();
                        HoursesOnTable[ikk].HourseThinking[0].HeuristicListHourse = new List<int[]>();
                        HoursesOnTable[ikk].HourseThinking[0].PenaltyRegardListHourse = new List<QuantumAtamata>();
                    }

                }
                catch (Exception t) { Log(t); }
                return IS;
            }
        }
        //boundry condition determistic method for break
        bool FullBoundryConditionsCastleIgnore(int ikk, int Current, int Order, int iAStarGreedy)
        {
            Object O = new Object();
            lock (O)
            {
                bool IS = false;
                try
                {
                    if (CastlesOnTable == null)
                        return true;
                    if (CastlesOnTable[ikk] == null)
                        return true;
                    if (CastlesOnTable[ikk].LoseOcuuredatChiled == null)
                        return true;
                    if (CastlesOnTable[ikk].CastleThinking == null)
                        return true;
                    if (CastlesOnTable[ikk].CastleThinking[0] == null)
                        return true;
                    if (CastlesOnTable[ikk].CastleThinking[0].TableListCastle == null)
                    {
                        CastlesOnTable[ikk].CastleThinking[0].TableListCastle = new List<int[,]>();
                        CastlesOnTable[ikk].CastleThinking[0].RowColumnCastle = new List<int[]>();
                        CastlesOnTable[ikk].CastleThinking[0].HitNumberCastle = new List<int>();
                        CastlesOnTable[ikk].CastleThinking[0].HeuristicListCastle = new List<int[]>();
                        CastlesOnTable[ikk].CastleThinking[0].PenaltyRegardListCastle = new List<QuantumAtamata>();
                    }
                }
                catch (Exception t) { Log(t); }
                return IS;
            }
        }
        //boundry condition determistic method for break
        bool FullBoundryConditionsMinisterIgnore(int ikk, int Current, int Order, int iAStarGreedy)
        {
            Object O = new Object();
            lock (O)
            {
                bool IS = false;
                try
                {
                    if (MinisterOnTable == null)
                        return true;
                    if (MinisterOnTable[ikk] == null)
                        return true;
                    if (MinisterOnTable[ikk].LoseOcuuredatChiled == null)
                        return true;
                    if (MinisterOnTable[ikk].MinisterThinking == null)
                        return true;
                    if (MinisterOnTable[ikk].MinisterThinking[0] == null)
                        return true;
                    if (MinisterOnTable[ikk].MinisterThinking[0].TableListMinister == null)
                    {
                        MinisterOnTable[ikk].MinisterThinking[0].TableListMinister = new List<int[,]>();
                        MinisterOnTable[ikk].MinisterThinking[0].RowColumnMinister = new List<int[]>();
                        MinisterOnTable[ikk].MinisterThinking[0].HitNumberMinister = new List<int>();
                        MinisterOnTable[ikk].MinisterThinking[0].HeuristicListMinister = new List<int[]>();
                        MinisterOnTable[ikk].MinisterThinking[0].PenaltyRegardListMinister = new List<QuantumAtamata>();
                    }
                }
                catch (Exception t) { Log(t); }
                return IS;
            }
        }
        //boundry condition determistic method for break
        bool FullBoundryConditionsKingIgnore(int ikk, int Current, int Order, int iAStarGreedy)
        {
            Object O = new Object();
            lock (O)
            {
                bool IS = false;
                try
                {
                    if (KingOnTable == null)
                        return true;
                    if (KingOnTable[ikk] == null)
                        return true;
                    if (KingOnTable[ikk].LoseOcuuredatChiled == null)
                        return true;
                    if (KingOnTable[ikk].KingThinking == null)
                        return true;
                    if (KingOnTable[ikk].KingThinking[0] == null)
                        return true;
                    if (KingOnTable[ikk].KingThinking[0].TableListKing == null)
                    {
                        KingOnTable[ikk].KingThinking[0].TableListKing = new List<int[,]>();
                        KingOnTable[ikk].KingThinking[0].RowColumnKing = new List<int[]>();
                        KingOnTable[ikk].KingThinking[0].HitNumberKing = new List<int>();
                        KingOnTable[ikk].KingThinking[0].HeuristicListKing = new List<int[]>();
                        KingOnTable[ikk].KingThinking[0].PenaltyRegardListKing = new List<QuantumAtamata>();
                    }

                }
                catch (Exception t) { Log(t); }
                return IS;
            }
        }
        bool FullBoundryConditionsCastlingIgnore(int ikk, int Current, int Order, int iAStarGreedy)
        {
            Object O = new Object();
            lock (O)
            {
                bool IS = false;
                try
                {
                    if (CastlingOnTable == null)
                        return true;
                    if (CastlingOnTable[ikk] == null)
                        return true;
                    if (CastlingOnTable[ikk].LoseOcuuredatChiled == null)
                        return true;
                    if (CastlingOnTable[ikk].CastlingThinking == null)
                        return true;
                    if (CastlingOnTable[ikk].CastlingThinking[0] == null)
                        return true;
                    if (CastlingOnTable[ikk].CastlingThinking[0].TableListCastling == null)
                    {
                        CastlingOnTable[ikk].CastlingThinking[0].TableListCastling = new List<int[,]>();
                        CastlingOnTable[ikk].CastlingThinking[0].RowColumnCastling = new List<int[]>();
                        CastlingOnTable[ikk].CastlingThinking[0].HitNumberCastling = new List<int>();
                        CastlingOnTable[ikk].CastlingThinking[0].HeuristicListCastling = new List<int[]>();
                        CastlingOnTable[ikk].CastlingThinking[0].PenaltyRegardListCastling = new List<QuantumAtamata>();
                    }
                }
                catch (Exception t) { Log(t); }
                return IS;
            }
        }
        //boundry condition determistic method for break
        bool FullBoundryConditionsSoldier(int ikk, int Current, int Order, int iAStarGreedy)
        {
            Object O = new Object();
            lock (O)
            {
                bool IS = false;
                try
                {

                    if (FullBoundryConditionsSoldierIgnore(ikk, Current, Order, iAStarGreedy))
                        return false;
                    if (SolderesOnTable[ikk].LoseOcuuredatChiled[0] < 0 && (!AllowedSupTrue))
                    {
                        IS = true;
                    }
                }
                catch (Exception t) { Log(t); }
                return IS;
            }
        }
        //boundry condition determistic method for break
        bool FullBoundryConditionsElephant(int ikk, int Current, int Order, int iAStarGreedy)
        {

            Object O = new Object();
            lock (O)
            {
                bool IS = false;
                try
                {
                    if (FullBoundryConditionsElephantIgnore(ikk, Current, Order, iAStarGreedy))
                        return false;
                    if (ElephantOnTable[ikk].LoseOcuuredatChiled[0] < 0 && (!AllowedSupTrue))
                    {
                        IS = true;
                    }
                }
                catch (Exception t) { Log(t); }
                return IS;
            }
        }
        //boundry condition determistic method for break
        bool FullBoundryConditionsHourse(int ikk, int Current, int Order, int iAStarGreedy)
        {

            Object O = new Object();
            lock (O)
            {
                bool IS = false;
                try
                {
                    if (FullBoundryConditionsHourseIgnore(ikk, Current, Order, iAStarGreedy))
                        return false;
                    if (HoursesOnTable[ikk].LoseOcuuredatChiled[0] < 0 && (!AllowedSupTrue))
                    {
                        IS = true;
                    }
                }
                catch (Exception t) { Log(t); }
                return IS;
            }
        }
        //boundry condition determistic method for break
        bool FullBoundryConditionsCastle(int ikk, int Current, int Order, int iAStarGreedy)
        {
            Object O = new Object();
            lock (O)
            {
                bool IS = false;
                try
                {
                    if (FullBoundryConditionsCastleIgnore(ikk, Current, Order, iAStarGreedy))
                        return false;
                    if (CastlesOnTable[ikk].LoseOcuuredatChiled[0] < 0 && (!AllowedSupTrue))
                    {
                        IS = true;
                    }

                }
                catch (Exception t) { Log(t); }
                return IS;
            }
        }
        //boundry condition determistic method for break
        bool FullBoundryConditionsMinister(int ikk, int Current, int Order, int iAStarGreedy)
        {
            Object O = new Object();
            lock (O)
            {
                bool IS = false;
                try
                {
                    if (FullBoundryConditionsMinisterIgnore(ikk, Current, Order, iAStarGreedy))
                        return false;
                    if (MinisterOnTable[ikk].LoseOcuuredatChiled[0] < 0 && (!AllowedSupTrue))
                    {
                        IS = true;
                    }
                }
                catch (Exception t) { Log(t); }
                return IS;
            }
        }
        //boundry condition determistic method for break
        bool FullBoundryConditionsKing(int ikk, int Current, int Order, int iAStarGreedy)
        {
            Object O = new Object();
            lock (O)
            {
                bool IS = false;
                try
                {
                    if (FullBoundryConditionsKingIgnore(ikk, Current, Order, iAStarGreedy))
                        return false;
                    if (KingOnTable[ikk].LoseOcuuredatChiled[0] < 0 && (!AllowedSupTrue))
                    {
                        IS = true;
                    }
                }
                catch (Exception t) { Log(t); }
                return IS;
            }
        }
        bool FullBoundryConditionsCastling(int ikk, int Current, int Order, int iAStarGreedy)
        {
            Object O = new Object();
            lock (O)
            {
                bool IS = false;
                try
                {
                    if (FullBoundryConditionsCastlingIgnore(ikk, Current, Order, iAStarGreedy))
                        return false;
                    if (CastlingOnTable[ikk].LoseOcuuredatChiled[0] < 0 && (!AllowedSupTrue))
                    {
                        IS = true;
                    }
                }
                catch (Exception t) { Log(t); }
                return IS;
            }
        }
        //boundry condition determistic method for break
        //boundry condition determistic method for break
        bool FullBoundryConditions(int Current, int Order, int iAStarGreedy)
        {
            Object O = new Object();
            lock (O)
            {
                if (CalIdle == 2)
                    return true;
                bool IS = false;
                if (!CompleteTreeDo)
                {
                    try
                    {
                        //heigth justice math and logic
                        /*   if (MaxAStarGreedy < MaxAStarGreedy + CurrentMaxLevel + (PlatformHelper.ProcessorCount - iAStarGreedy))
                           {
                               MaxAStarGreedy = MaxAStarGreedy + CurrentMaxLevel + (PlatformHelper.ProcessorCount - iAStarGreedy);
                           }
                           */
                        if (
                             /*(MaxAStarGreedy <= CurrentMaxLevel + PlatformHelper.ProcessorCount) &&*/
                             ((MaxAStarGreedy < StoreInitMaxAStarGreedy + PlatformHelper.ProcessorCount) || SStopInitMaxAStarGreedy))// if (MaxAStarGreedy < indexStep * PlatformHelper.ProcessorCount)
                        {
                            MaxAStarGreedy = CurrentMaxLevel;
                        }
                        else
                            //if (CurrentMaxLevel >= MaxAStarGreedy)
                            return true;
                        Object Omm1 = new Object();
                        lock (Omm1)
                        {
                            /*//if (CurrentMaxLevel >= MaxAStarGreedy)
                                return;
                            else
                            {
                                //if (CurrentMaxLevel < CurrentMaxLevel + (PlatformHelper.ProcessorCount - iAStarGreedy))
                                //CurrentMaxLevel = CurrentMaxLevel + 1;
                                if (CurrentMaxLevel < CurrentMaxLevel + (PlatformHelper.ProcessorCount - iAStarGreedy))
                                     CurrentMaxLevel = CurrentMaxLevel + (PlatformHelper.ProcessorCount - iAStarGreedy);

                            }*/
                            /* if (iAStarGreedy < 0 //&& iAStarGreedy < MaxDuringLevelThinkingCreation
                        )
                             {
                                 IS = true;
                             }*/
                        }
                        //gray
                        if (Order == 1)
                        {
                            IS = IS || FullBoundryConditionsGray(Current, Order, iAStarGreedy);
                            //when vicrory count satisfied
                            if ((ThinkingRefrigtzChessPortable.FoundFirstMating > (MaxAStarGreedy)) && (!AllowedSupTrue)) //|| (SetDeptIgnore))
                            {
                                IS = true;
                            }
                        }
                        else
                        {
                            IS = IS || FullBoundryConditionsBrown(Current, Order, iAStarGreedy);
                            //when victory count satisfied
                            if ((ThinkingRefrigtzChessPortable.FoundFirstMating > (MaxAStarGreedy)) && (!AllowedSupTrue)) //|| (SetDeptIgnore))
                            {
                                IS = true;
                            }
                        }
                        //when nu,bers of computational leafs satisfied 
                        if (((ThinkingRefrigtzChessPortable.NumbersOfAllNode - AllDraw.NumberOfLeafComputation) > 100) && AllDraw.NumberOfLeafComputation != -1 && (!AllowedSupTrue))
                            IS = true;


                    }
                    catch (Exception t) { Log(t); }
                }
                else
                {
                    if (ThinkingRefrigtzChessPortable.NumbersOfAllNode > CompleteNumber)
                        return true;
                    if (CompleteTreeCancel)
                        return true;

                }
                return IS;
            }
        }
        //boundry condition determistic method for break
        bool FullBoundryConditionsBrown(int Current, int Order, int iAStarGreedy)
        {
            Object O = new Object();
            lock (O)
            {
                bool IS = false;
                try
                {
                    //soldier
                    for (int ikk = SodierMidle; ikk < SodierHigh; ikk++)
                    {
                        IS = IS || FullBoundryConditionsSoldier(ikk, Current, Order, iAStarGreedy);
                    }
                    //elephant
                    for (int ikk = ElefantMidle; ikk < ElefantHigh; ikk++)
                    {
                        IS = IS || FullBoundryConditionsElephant(ikk, Current, Order, iAStarGreedy);
                    }
                    //hourse
                    for (int ikk = HourseMidle; ikk < HourseHight; ikk++)
                    {
                        IS = IS || FullBoundryConditionsHourse(ikk, Current, Order, iAStarGreedy);
                    }
                    //Castle
                    for (int ikk = CastleMidle; ikk < CastleHigh; ikk++)
                    {
                        IS = IS || FullBoundryConditionsCastle(ikk, Current, Order, iAStarGreedy);
                    }
                    //minister
                    for (int ikk = MinisterMidle; ikk < MinisterHigh; ikk++)
                    {
                        IS = IS || FullBoundryConditionsMinister(ikk, Current, Order, iAStarGreedy);
                    }
                    //king
                    for (int ikk = KingMidle; ikk < KingHigh; ikk++)
                    {
                        IS = IS || FullBoundryConditionsKing(ikk, Current, Order, iAStarGreedy);
                    }
                    for (int ikk = 0; ikk < 1; ikk++)
                    {
                        IS = IS || FullBoundryConditionsCastling(ikk, Current, Order, iAStarGreedy);
                    }
                    //when victory count satisfied
                    if ((ThinkingRefrigtzChessPortable.FoundFirstMating > (MaxAStarGreedy)) && (!AllowedSupTrue)) //|| (SetDeptIgnore))
                    {
                        IS = true;
                    }

                }
                catch (Exception t) { Log(t); }
                return IS;
            }
        }
        //boundry condition determistic method for break
        bool FullBoundryConditionsGray(int Current, int Order, int iAStarGreedy)
        {
            Object O = new Object();
            lock (O)
            {
                bool IS = false;
                try
                {
                    //soldier
                    for (int ikk = 0; ikk < SodierMidle; ikk++)
                    {
                        IS = IS || FullBoundryConditionsSoldier(ikk, Current, Order, iAStarGreedy);
                    }
                    //elephant
                    for (int ikk = 0; ikk < ElefantMidle; ikk++)
                    {
                        IS = IS || FullBoundryConditionsElephant(ikk, Current, Order, iAStarGreedy);
                    }
                    //hourse
                    for (int ikk = 0; ikk < HourseMidle; ikk++)
                    {
                        IS = IS || FullBoundryConditionsHourse(ikk, Current, Order, iAStarGreedy);
                    }
                    //Castle
                    for (int ikk = 0; ikk < CastleMidle; ikk++)
                    {
                        IS = IS || FullBoundryConditionsCastle(ikk, Current, Order, iAStarGreedy);
                    }
                    //minister
                    for (int ikk = 0; ikk < MinisterMidle; ikk++)
                    {
                        IS = IS || FullBoundryConditionsMinister(ikk, Current, Order, iAStarGreedy);
                    }
                    //king
                    for (int ikk = 0; ikk < KingMidle; ikk++)
                    {
                        IS = IS || FullBoundryConditionsKing(ikk, Current, Order, iAStarGreedy);
                    }
                    for (int ikk = 0; ikk < 1; ikk++)
                    {
                        IS = IS || FullBoundryConditionsCastling(ikk, Current, Order, iAStarGreedy);
                    }
                    //when vicrory count satisfied
                    if ((ThinkingRefrigtzChessPortable.FoundFirstMating > (MaxAStarGreedy)) && (!AllowedSupTrue)) //|| (SetDeptIgnore))
                    {
                        IS = true;
                    }

                }
                catch (Exception t) { Log(t); }
                return IS;
            }
        }
        //AStarGreedy First Initiat Thinking Main Method.
        void AstarGreedyThinking(int Order, int DummyOrder, int DummyCurrentOrder, int iAStarGreedy, int i, int j, int ii, int jj, int[,] Table, Color a, bool TB, bool FOUND, int LeafAStarGreedy)
        {

            Object o = new Object();
            lock (o)
            {
                //If Order is Gray.
                if (Order == 1)
                {
                    int i1 = i, j1 = j;
                    int[,] Tab = CloneATable(Table);
                    int DummyOrder1 = DummyOrder, DummyCurrentOrder1 = DummyCurrentOrder, iAStarGreedy1 = iAStarGreedy, ii1 = ii, jj1 = jj, Ord1 = OrderP;
                    bool TB1 = TB;
                    Color aa = a;
                    var output = Task.Factory.StartNew(() =>
                    {
                        //if (!feedCancellationTokenSource.IsCancellationRequested)
                        {
                            ParallelOptions po = new ParallelOptions(); po.MaxDegreeOfParallelism = System.Threading.PlatformHelper.ProcessorCount; Parallel.Invoke(() =>
     {
        //For All Gray Soldier Objects.
        Object O = new Object();
         lock (O)
         {
             var H = Task.Factory.StartNew(() => this.InitiateAStarGreedytSodlerGray(i1, j1, CloneATable(Tabl), DummyOrder1, DummyCurrentOrder1, iAStarGreedy1, ii1, jj1, aa, CloneATable(Tab), Ord1, TB1, FOUND, LeafAStarGreedy));
             H.Wait();
             H.Dispose();
         }
     }, () =>
     {
        //For All Gray Elephant Objects.
        Object O = new Object();
         lock (O)
         {
             var H = Task.Factory.StartNew(() => this.InitiateAStarGreedytElephantGray(i1, j1, CloneATable(Tabl), DummyOrder1, DummyCurrentOrder1, iAStarGreedy1, ii1, jj1, aa, CloneATable(Tab), Ord1, TB1, FOUND, LeafAStarGreedy));
             H.Wait();
             H.Dispose();
         }
     }, () =>
     {
        //For All Gray Hourse Objects.
        Object O = new Object();
         lock (O)
         {
             var H = Task.Factory.StartNew(() => this.InitiateAStarGreedythHourseGray(i1, j1, CloneATable(Tabl), DummyOrder1, DummyCurrentOrder1, iAStarGreedy1, ii1, jj1, aa, CloneATable(Tab), Ord1, TB1, FOUND, LeafAStarGreedy));
             H.Wait();
             H.Dispose();
         }
     }, () =>
     {
         Object O = new Object();
         lock (O)
         {

             var H = Task.Factory.StartNew(() => this.InitiateAStarGreedythCastleGray(i1, j1, CloneATable(Tabl), DummyOrder1, DummyCurrentOrder1, iAStarGreedy1, ii1, jj1, aa, CloneATable(Tab), Ord1, TB1, FOUND, LeafAStarGreedy));
             H.Wait();
             H.Dispose();
         }
     }, () =>
     {
         Object O = new Object();
         lock (O)
         {
             var H = Task.Factory.StartNew(() => this.InitiateAStarGreedythMinisterGray(i1, j1, CloneATable(Tabl), DummyOrder1, DummyCurrentOrder1, iAStarGreedy1, ii1, jj1, aa, CloneATable(Tab), Ord1, TB1, FOUND, LeafAStarGreedy));
             H.Wait();
             H.Dispose();
         }
     }, () =>
     {
         Object O = new Object();
         lock (O)
         {
             var H = Task.Factory.StartNew(() => this.InitiateAStarGreedythKingGray(i1, j1, CloneATable(Tabl), DummyOrder1, DummyCurrentOrder1, iAStarGreedy1, ii1, jj1, aa, CloneATable(Tab), Ord1, TB1, FOUND, LeafAStarGreedy));
             H.Wait();
             H.Dispose();
         }
     });
                        }
                    });
                }
                else//Brown Order Considarations.
                {
                    int i1 = i, j1 = j;
                    int[,] Tab = CloneATable(Table);
                    int DummyOrder1 = DummyOrder, DummyCurrentOrder1 = DummyCurrentOrder, iAStarGreedy1 = iAStarGreedy, ii1 = ii, jj1 = jj, Ord1 = OrderP;
                    bool TB1 = TB;
                    Color aa = a;
                    //If Order is Gray.
                    var output = Task.Factory.StartNew(() =>
                    {
                        //if (!feedCancellationTokenSource.IsCancellationRequested)
                        {
                            ParallelOptions po = new ParallelOptions(); po.MaxDegreeOfParallelism = System.Threading.PlatformHelper.ProcessorCount; Parallel.Invoke(() =>
     {
        //For All Gray Soldier Objects.
        Object O = new Object();
         lock (O)
         {
             var H = Task.Factory.StartNew(() => this.InitiateAStarGreedythSoldierBrown(i1, j1, CloneATable(Tabl), DummyOrder1, DummyCurrentOrder1, iAStarGreedy1, ii1, jj1, aa, CloneATable(Tab), Ord1, TB1, FOUND, LeafAStarGreedy));
             H.Wait();
             H.Dispose();
         }
     }, () =>
     {
        //For All Gray Elephant Objects.
        Object O = new Object();
         lock (O)
         {
             var H = Task.Factory.StartNew(() => this.InitiateAStarGreedythElephantBrown(i1, j1, CloneATable(Tabl), DummyOrder1, DummyCurrentOrder1, iAStarGreedy1, ii1, jj1, aa, CloneATable(Tab), Ord1, TB1, FOUND, LeafAStarGreedy));
             H.Wait();
             H.Dispose();
         }
     }, () =>
     {
        //For All Gray Hourse Objects.
        Object O = new Object();
         lock (O)
         {
             var H = Task.Factory.StartNew(() => this.InitiateAStarGreedythHourseBrown(i1, j1, CloneATable(Tabl), DummyOrder1, DummyCurrentOrder1, iAStarGreedy1, ii1, jj1, aa, CloneATable(Tab), Ord1, TB1, FOUND, LeafAStarGreedy));
             H.Wait();
             H.Dispose();
         }
     }, () =>
     {
         Object O = new Object();
         lock (O)
         {
             var H = Task.Factory.StartNew(() => this.InitiateAStarGreedythCastleBrown(i1, j1, CloneATable(Tabl), DummyOrder1, DummyCurrentOrder1, iAStarGreedy1, ii1, jj1, aa, CloneATable(Tab), Ord1, TB1, FOUND, LeafAStarGreedy));
             H.Wait();
             H.Dispose();
         }
     }, () =>
     {
         Object O = new Object();
         lock (O)
         {
             var H = Task.Factory.StartNew(() => this.InitiateAStarGreedythMinisterBrown(i1, j1, CloneATable(Tabl), DummyOrder1, DummyCurrentOrder1, iAStarGreedy1, ii1, jj1, aa, CloneATable(Tab), Ord1, TB1, FOUND, LeafAStarGreedy));
             H.Wait();
             H.Dispose();
         }
     }, () =>
     {
         Object O = new Object();
         lock (O)
         {
             var H = Task.Factory.StartNew(() => this.InitiateAStarGreedythKingBrown(i1, j1, CloneATable(Tabl), DummyOrder1, DummyCurrentOrder1, iAStarGreedy1, ii1, jj1, aa, CloneATable(Tab), Ord1, TB1, FOUND, LeafAStarGreedy));
             H.Wait();
             H.Dispose();
         }
     });
                        }
                    });
                    output.Wait(); output.Dispose();
                }
            }

        }
        //initiation setdrawfounding tow stage computational method 
        public bool InitiateAStarGreedytCreationThinking(int iAStarGreedy, int ii, int jj, Color a, int[,] Tab, int Order, bool TB, bool FOUND, int LeafAStarGreedy//, ref Refrigtz.Timer timer, ref Refrigtz.Timer Timerint, ref int Less
     )
        {

            Object o = new Object();
            lock (o)
            {
                if (ThinkingAllowed == null)
                    ThinkingAllowed = new bool[4];
                for (int iii = 0; iii < 14; iii++)
                    ThinkingAllowed[iii] = true;
                int DummyOrder = new int();
                DummyOrder = Order;
                int DummyCurrentOrder = new int();
                DummyCurrentOrder = ChessRules.CurrentOrder;
                //#pragma warning disable CS0219 // The variable 'ik' is assigned but its value is never used
#pragma warning disable CS0219 // The variable 'ik' is assigned but its value is never used
                int i = 0, ik = 0;
#pragma warning restore CS0219 // The variable 'ik' is assigned but its value is never used
                //#pragma warning restore CS0219 // The variable 'ik' is assigned but its value is never used
                var j = 0;
                int[,] Table = new int[8, 8];
                for (var iii = 0; iii < 8; iii++)
                    for (var jjj = 0; jjj < 8; jjj++)
                        Table[iii, jjj] = Tab[iii, jjj];
                AllDraw thiB = AStarGreedyString;
                if (IsAtLeastAllObjectIsNull())
                {
                    TableList.Clear();
                    TableList.Add(CloneATable(Table));
                    SetRowColumn(0);
                    IsCurrentDraw = true;
                }
                AStarGreedyString = thiB;
                //If Order is Gray.
                if (Order == 1)
                {
                    var array1 = Task.Factory.StartNew(() => InitiateAStarGreedytCreationThinkingGray(DummyOrder, DummyCurrentOrder, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ii, jj, i, j, a, CloneATable(Tab), Order, TB, FOUND, LeafAStarGreedy));

                    array1.Wait();
                    array1.Dispose();
                }
                else//Brown Order Considarations.
                {
                    var array1 = Task.Factory.StartNew(() => InitiateAStarGreedytCreationThinkingBrown(DummyOrder, DummyCurrentOrder, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ii, jj, i, j, a, CloneATable(Tab), Order, TB, FOUND, LeafAStarGreedy));

                    array1.Wait();
                    array1.Dispose();
                }
            }

            return true;
        }
        public bool InitiateAStarGreedytCreationThinkingGray(int DummyOrder, int DummyCurrentOrder, int iAStarGreedy, int ii, int jj, int i, int j, Color a, int[,] Table, int Order, bool TB, bool FOUND, int LeafAStarGreedy//, ref Refrigtz.Timer timer, ref Refrigtz.Timer Timerint, ref int Less
)
        {
            Object o = new Object();
            lock (o)
            {
                int i1 = i, j1 = j;
                int[,] Tabl = CloneATable(Table);
                int DummyOrder1 = DummyOrder, DummyCurrentOrder1 = DummyCurrentOrder, iAStarGreedy1 = iAStarGreedy, ii1 = ii, jj1 = jj, Ord1 = OrderP;
                bool TB1 = TB;
                Color aa = a;
                var output = Task.Factory.StartNew(() =>
                {
                    //if (!feedCancellationTokenSource.IsCancellationRequested)
                    {
                        ParallelOptions po = new ParallelOptions(); po.MaxDegreeOfParallelism = System.Threading.PlatformHelper.ProcessorCount; Parallel.Invoke(() =>
 {
    //For All Gray Soldier Objects.
    Object O = new Object();
     lock (O)
     {
         var H = Task.Factory.StartNew(() => this.InitiateAStarGreedytSodlerGray(i1, j1, CloneATable(Tabl), DummyOrder1, DummyCurrentOrder1, iAStarGreedy1, ii1, jj1, aa, CloneATable(Tabl), Ord1, TB1, FOUND, LeafAStarGreedy));
         H.Wait();
         H.Dispose();
     }
 }, () =>
 {
    //For All Gray Elephant Objects.
    Object O = new Object();
     lock (O)
     {
         var H = Task.Factory.StartNew(() => this.InitiateAStarGreedytElephantGray(i1, j1, CloneATable(Tabl), DummyOrder1, DummyCurrentOrder1, iAStarGreedy1, ii1, jj1, aa, CloneATable(Tabl), Ord1, TB1, FOUND, LeafAStarGreedy));
         H.Wait();
         H.Dispose();
     }
 }, () =>
 {
    //For All Gray Hourse Objects.
    Object O = new Object();
     lock (O)
     {
         var H = Task.Factory.StartNew(() => this.InitiateAStarGreedythHourseGray(i1, j1, CloneATable(Tabl), DummyOrder1, DummyCurrentOrder1, iAStarGreedy1, ii1, jj1, aa, CloneATable(Tabl), Ord1, TB1, FOUND, LeafAStarGreedy));
         H.Wait();
         H.Dispose();
     }
 }, () =>
 {
     Object O = new Object();
     lock (O)
     {
         var H = Task.Factory.StartNew(() => this.InitiateAStarGreedythCastleGray(i1, j1, CloneATable(Tabl), DummyOrder1, DummyCurrentOrder1, iAStarGreedy1, ii1, jj1, aa, CloneATable(Tabl), Ord1, TB1, FOUND, LeafAStarGreedy));
         H.Wait();
         H.Dispose();
     }
 }, () =>
 {
     Object O = new Object();
     lock (O)
     {
         var H = Task.Factory.StartNew(() => this.InitiateAStarGreedythMinisterGray(i1, j1, CloneATable(Tabl), DummyOrder1, DummyCurrentOrder1, iAStarGreedy1, ii1, jj1, aa, CloneATable(Tabl), Ord1, TB1, FOUND, LeafAStarGreedy));
         H.Wait();
         H.Dispose();
     }
 }
 , () =>
 {
     Object O = new Object();
     lock (O)
     {
         var H = Task.Factory.StartNew(() => this.InitiateAStarGreedythKingGray(i1, j1, CloneATable(Tabl), DummyOrder1, DummyCurrentOrder1, iAStarGreedy1, ii1, jj1, aa, CloneATable(Tabl), Ord1, TB1, FOUND, LeafAStarGreedy));
         H.Wait();
         H.Dispose();
     }
 }, () =>
 {
     Object O = new Object();
     lock (O)
     {
         var H = Task.Factory.StartNew(() => this.InitiateAStarGreedythCastlingGray(i1, j1, CloneATable(Tabl), DummyOrder1, DummyCurrentOrder1, iAStarGreedy1, ii1, jj1, aa, CloneATable(Tabl), Ord1, TB1, FOUND, LeafAStarGreedy));
         H.Wait();
         H.Dispose();
     }
 });
                    }
                });
                output.Wait(); output.Dispose();
            }
            return true;
        }
        public bool InitiateAStarGreedytCreationThinkingBrown(int DummyOrder, int DummyCurrentOrder, int iAStarGreedy, int ii, int jj, int i, int j, Color a, int[,] Table, int Order, bool TB, bool FOUND, int LeafAStarGreedy//, ref Refrigtz.Timer timer, ref Refrigtz.Timer Timerint, ref int Less
)
        {
            Object o = new Object();
            lock (o)
            {
                int i1 = i, j1 = j;
                int[,] Tabl = CloneATable(Table);
                int DummyOrder1 = DummyOrder, DummyCurrentOrder1 = DummyCurrentOrder, iAStarGreedy1 = iAStarGreedy, ii1 = ii, jj1 = jj, Ord1 = OrderP;
                bool TB1 = TB;
                Color aa = a;
                //If Order is Gray.
                var output = Task.Factory.StartNew(() =>
                {
                    //if (!feedCancellationTokenSource.IsCancellationRequested)
                    {
                        ParallelOptions po = new ParallelOptions(); po.MaxDegreeOfParallelism = System.Threading.PlatformHelper.ProcessorCount; Parallel.Invoke(() =>
 {
    //For All Gray Soldier Objects.
    Object O = new Object();
     lock (O)
     {
         var H = Task.Factory.StartNew(() => this.InitiateAStarGreedythSoldierBrown(i1, j1, CloneATable(Tabl), DummyOrder1, DummyCurrentOrder1, iAStarGreedy1, ii1, jj1, aa, CloneATable(Tabl), Ord1, TB1, FOUND, LeafAStarGreedy));
         H.Wait();
         H.Dispose();
     }
 }, () =>
 {
    //For All Gray Elephant Objects.
    Object O = new Object();
     lock (O)
     {
         var H = Task.Factory.StartNew(() => this.InitiateAStarGreedythElephantBrown(i1, j1, CloneATable(Tabl), DummyOrder1, DummyCurrentOrder1, iAStarGreedy1, ii1, jj1, aa, CloneATable(Tabl), Ord1, TB1, FOUND, LeafAStarGreedy));
         H.Wait();
         H.Dispose();
     }
 }, () =>
 {
    //For All Gray Hourse Objects.
    Object O = new Object();
     lock (O)
     {
         var H = Task.Factory.StartNew(() => this.InitiateAStarGreedythHourseBrown(i1, j1, CloneATable(Tabl), DummyOrder1, DummyCurrentOrder1, iAStarGreedy1, ii1, jj1, aa, CloneATable(Tabl), Ord1, TB1, FOUND, LeafAStarGreedy));
         H.Wait();
         H.Dispose();
     }
 }, () =>
 {
     Object O = new Object();
     lock (O)
     {
         var H = Task.Factory.StartNew(() => this.InitiateAStarGreedythCastleBrown(i1, j1, CloneATable(Tabl), DummyOrder1, DummyCurrentOrder1, iAStarGreedy1, ii1, jj1, aa, CloneATable(Tabl), Ord1, TB1, FOUND, LeafAStarGreedy));
         H.Wait();
         H.Dispose();
     }
 }, () =>
 {
     Object O = new Object();
     lock (O)
     {
         var H = Task.Factory.StartNew(() => this.InitiateAStarGreedythMinisterBrown(i1, j1, CloneATable(Tabl), DummyOrder1, DummyCurrentOrder1, iAStarGreedy1, ii1, jj1, aa, CloneATable(Tabl), Ord1, TB1, FOUND, LeafAStarGreedy));
         H.Wait();
         H.Dispose();
     }
 }, () =>
 {
     Object O = new Object();
     lock (O)
     {
         var H = Task.Factory.StartNew(() => this.InitiateAStarGreedythKingBrown(i1, j1, CloneATable(Tabl), DummyOrder1, DummyCurrentOrder1, iAStarGreedy1, ii1, jj1, aa, CloneATable(Tabl), Ord1, TB1, FOUND, LeafAStarGreedy));
         H.Wait();
         H.Dispose();
     }
 }, () =>
 {
     Object O = new Object();
     lock (O)
     {
         var H = Task.Factory.StartNew(() => this.InitiateAStarGreedythCastlingBrown(i1, j1, CloneATable(Tabl), DummyOrder1, DummyCurrentOrder1, iAStarGreedy1, ii1, jj1, aa, CloneATable(Tabl), Ord1, TB1, FOUND, LeafAStarGreedy));
         H.Wait();
         H.Dispose();
     }
 });
                    }
                });
                output.Wait(); output.Dispose();
            }
            return true;
        }
        bool ExistChild(int i, int j, int kindA, AllDraw jungle)
        {
            bool Act = false;
            Object oo = new Object();
            lock (oo)
            {
                if (jungle == null)
                    return false;

                if (kindA == 1)
                {

                    if (jungle.SolderesOnTable != null)
                    {
                        if (jungle.SolderesOnTable[i] != null)
                        {
                            if (jungle.SolderesOnTable[i].SoldierThinking != null)
                            {
                                if (jungle.SolderesOnTable[i].SoldierThinking[0] != null)
                                {
                                    if (jungle.SolderesOnTable[i].SoldierThinking[0].AStarGreedy != null)
                                    {

                                        Object ooo = new Object();
                                        lock (ooo)
                                        {
                                            Act = true;

                                        }

                                    }
                                }

                            }

                        }
                    }
                }
                else
                if (kindA == 2)
                {
                    if (jungle.ElephantOnTable != null)
                    {
                        if (jungle.ElephantOnTable[i] != null)
                        {
                            if (jungle.ElephantOnTable[i].ElefantThinking != null)
                            {
                                if (jungle.ElephantOnTable[i].ElefantThinking[0] != null)
                                {
                                    if (jungle.ElephantOnTable[i].ElefantThinking[0].AStarGreedy != null)
                                    {

                                        Object ooo = new Object();
                                        lock (ooo)
                                        {
                                            Act = true;

                                        }

                                    }
                                }

                            }

                        }
                    }

                }
                else
                if (kindA == 3)
                {
                    if (jungle.HoursesOnTable != null)
                    {
                        if (jungle.HoursesOnTable[i] != null)
                        {
                            if (jungle.HoursesOnTable[i].HourseThinking != null)
                            {
                                if (jungle.HoursesOnTable[i].HourseThinking[0] != null)
                                {
                                    if (jungle.HoursesOnTable[i].HourseThinking[0].AStarGreedy != null)
                                    {

                                        Object ooo = new Object();
                                        lock (ooo)
                                        {
                                            Act = true;

                                        }
                                    }
                                }
                            }
                        }
                    }


                }
                else
                     if (kindA == 4)
                {

                    if (jungle.CastlesOnTable != null)
                    {
                        if (jungle.CastlesOnTable[i] != null)
                        {
                            if (jungle.CastlesOnTable[i].CastleThinking != null)
                            {
                                if (jungle.CastlesOnTable[i].CastleThinking[0] != null)
                                {
                                    if (jungle.CastlesOnTable[i].CastleThinking[0].AStarGreedy != null)
                                    {
                                        Object ooo = new Object();
                                        lock (ooo)
                                        {
                                            Act = true;

                                        }

                                    }
                                }

                            }
                        }
                    }
                }
                else
                if (kindA == 5)
                {

                    if (jungle.MinisterOnTable != null)
                    {
                        if (jungle.MinisterOnTable[i] != null)
                        {
                            if (jungle.MinisterOnTable[i].MinisterThinking != null)
                            {
                                if (jungle.MinisterOnTable[i].MinisterThinking[0] != null)
                                {
                                    if (jungle.MinisterOnTable[i].MinisterThinking[0].AStarGreedy != null)
                                    {

                                        Object ooo = new Object();
                                        lock (ooo)
                                        {
                                            Act = true;

                                        }

                                    }
                                }
                            }

                        }
                    }

                }
                else
                if (kindA == 6)
                {

                    if (jungle.KingOnTable != null)
                    {
                        if (jungle.KingOnTable[i] != null)
                        {
                            if (jungle.KingOnTable[i].KingThinking != null)
                            {
                                if (jungle.KingOnTable[i].KingThinking[0] != null)
                                {
                                    if (jungle.KingOnTable[i].KingThinking[0].AStarGreedy != null)
                                    {

                                        Object ooo = new Object();
                                        lock (ooo)
                                        {
                                            Act = true;

                                        }

                                    }
                                }

                            }

                        }
                    }

                }
                else
                if (kindA == 7 || kindA == -7)
                {

                    if (jungle.CastlingOnTable != null)
                    {
                        if (jungle.CastlingOnTable[i] != null)
                        {
                            if (jungle.CastlingOnTable[i].CastlingThinking != null)
                            {
                                if (jungle.CastlingOnTable[i].CastlingThinking[0] != null)
                                {
                                    if (jungle.CastlingOnTable[i].CastlingThinking[0].AStarGreedy != null)
                                    {

                                        Object ooo = new Object();
                                        lock (ooo)
                                        {
                                            Act = true;

                                        }

                                    }

                                }

                            }

                        }
                    }

                }

            }
            return Act;
        }
        bool BlitzNotValidFullGameThinkingTreePartFour(int ik, int Order, int kind, ThinkingRefrigtzChessPortable obj, int j)
        {

            Object oo = new Object();
            lock (oo)
            {
                bool Act = false;
                //soldier
                if (kind == 1)
                {
                    //when valid 
                    Act = BlitzNotValidFullGameThinkingTreePartFourSoldier(ik, Order, obj, j);
                }
                else if (kind == 2)//elephant
                {
                    //when valid 

                    Act = BlitzNotValidFullGameThinkingTreePartFourElephant(ik, Order, obj, j);
                }
                else if (kind == 3)//hourse
                {
                    //when valid 

                    Act = BlitzNotValidFullGameThinkingTreePartFourHourse(ik, Order, obj, j);
                }
                else if (kind == 4)//Castle
                {
                    //when valid 

                    Act = BlitzNotValidFullGameThinkingTreePartFourCastle(ik, Order, obj, j);
                }
                else if (kind == 5)//minister
                {
                    //when valid ThinkingChess

                    Act = BlitzNotValidFullGameThinkingTreePartFourMinister(ik, Order, obj, j);
                }
                else if (kind == 6)//king
                {
                    //when valid 

                    Act = BlitzNotValidFullGameThinkingTreePartFourKing(ik, Order, obj, j);
                }
                else if (kind == 7 || kind == -7)//king
                {
                    //when valid 
                    Act = BlitzNotValidFullGameThinkingTreePartFourCastling(ik, Order, obj, j);
                }
                return Act;
            }
        }
        bool BlitzNotValidFullGameThinkingTreePartFourSoldier(int ik, int Order, ThinkingRefrigtzChessPortable obj, int j)
        {

            Object oo = new Object();
            lock (oo)
            {
                bool Act = false;
                if (obj.HeuristicListSolder[j].Length != 10)
                    return Act;
                //when valid 
                SolderesOnTable[ik].SoldierThinking[0].TableListSolder.Add(obj.TableListSolder[j]);
                SolderesOnTable[ik].SoldierThinking[0].HeuristicListSolder.Add(obj.HeuristicListSolder[j]);
                SolderesOnTable[ik].SoldierThinking[0].RowColumnSoldier.Add(obj.RowColumnSoldier[j]);
                SolderesOnTable[ik].SoldierThinking[0].HitNumberSoldier.Add(obj.HitNumberSoldier[j]);
                SolderesOnTable[ik].SoldierThinking[0].PenaltyRegardListSolder.Add(obj.PenaltyRegardListSolder[j]);
                SolderesOnTable[ik].SoldierThinking[0].KishSelf.Add(obj.KishSelf[j]);
                SolderesOnTable[ik].SoldierThinking[0].KishEnemy.Add(obj.KishEnemy[j]);
                SolderesOnTable[ik].SoldierThinking[0].LoseChiled.Add(obj.LoseChiled[j]);
                SolderesOnTable[ik].SoldierThinking[0].WinChiled.Add(obj.WinChiled[j]);
                SolderesOnTable[ik].SoldierThinking[0].IsSup.Add(obj.IsSup[j]);
                SolderesOnTable[ik].SoldierThinking[0].IsSupHu.Add(obj.IsSupHu[j]);
                SolderesOnTable[ik].SoldierThinking[0].IsThereCheckOfEnemy.Add(obj.IsThereCheckOfEnemy[j]);
                SolderesOnTable[ik].SoldierThinking[0].IsThereCheckOfSelf.Add(obj.IsThereCheckOfSelf[j]);
                SolderesOnTable[ik].SoldierThinking[0].IsThereMateOfEnemy.Add(obj.IsThereMateOfEnemy[j]);
                SolderesOnTable[ik].SoldierThinking[0].IsThereMateOfSelf.Add(obj.IsThereMateOfSelf[j]);
                Act = true;

                return Act;
            }
        }
        bool BlitzNotValidFullGameThinkingTreePartFourElephant(int ik, int Order, ThinkingRefrigtzChessPortable obj, int j)
        {

            Object oo = new Object();
            lock (oo)
            {
                bool Act = false;

                if (obj.HeuristicListElefant[j].Length != 10)
                    return Act;
                //when valid 

                ElephantOnTable[ik].ElefantThinking[0].TableListElefant.Add(obj.TableListElefant[j]);
                ElephantOnTable[ik].ElefantThinking[0].HeuristicListElefant.Add(obj.HeuristicListElefant[j]);
                ElephantOnTable[ik].ElefantThinking[0].RowColumnElefant.Add(obj.RowColumnElefant[j]);
                ElephantOnTable[ik].ElefantThinking[0].HitNumberElefant.Add(obj.HitNumberElefant[j]);
                ElephantOnTable[ik].ElefantThinking[0].PenaltyRegardListElefant.Add(obj.PenaltyRegardListElefant[j]);
                ElephantOnTable[ik].ElefantThinking[0].KishSelf.Add(obj.KishSelf[j]);
                ElephantOnTable[ik].ElefantThinking[0].KishEnemy.Add(obj.KishEnemy[j]);
                ElephantOnTable[ik].ElefantThinking[0].LoseChiled.Add(obj.LoseChiled[j]);
                ElephantOnTable[ik].ElefantThinking[0].WinChiled.Add(obj.WinChiled[j]);
                ElephantOnTable[ik].ElefantThinking[0].IsSup.Add(obj.IsSup[j]);
                ElephantOnTable[ik].ElefantThinking[0].IsSupHu.Add(obj.IsSupHu[j]);
                ElephantOnTable[ik].ElefantThinking[0].IsThereCheckOfEnemy.Add(obj.IsThereCheckOfEnemy[j]);
                ElephantOnTable[ik].ElefantThinking[0].IsThereCheckOfSelf.Add(obj.IsThereCheckOfSelf[j]);
                ElephantOnTable[ik].ElefantThinking[0].IsThereMateOfEnemy.Add(obj.IsThereMateOfEnemy[j]);
                ElephantOnTable[ik].ElefantThinking[0].IsThereMateOfSelf.Add(obj.IsThereMateOfSelf[j]);

                Act = true;

                return Act;
            }
        }
        bool BlitzNotValidFullGameThinkingTreePartFourHourse(int ik, int Order, ThinkingRefrigtzChessPortable obj, int j)
        {

            Object oo = new Object();
            lock (oo)
            {
                bool Act = false;

                if (obj.HeuristicListHourse[j].Length != 10)
                    return Act;
                //when valid 

                HoursesOnTable[ik].HourseThinking[0].TableListHourse.Add(obj.TableListHourse[j]);
                HoursesOnTable[ik].HourseThinking[0].HeuristicListHourse.Add(obj.HeuristicListHourse[j]);
                HoursesOnTable[ik].HourseThinking[0].RowColumnHourse.Add(obj.RowColumnHourse[j]);
                HoursesOnTable[ik].HourseThinking[0].HitNumberHourse.Add(obj.HitNumberHourse[j]);
                HoursesOnTable[ik].HourseThinking[0].PenaltyRegardListHourse.Add(obj.PenaltyRegardListHourse[j]);
                HoursesOnTable[ik].HourseThinking[0].KishSelf.Add(obj.KishSelf[j]);
                HoursesOnTable[ik].HourseThinking[0].KishEnemy.Add(obj.KishEnemy[j]);
                HoursesOnTable[ik].HourseThinking[0].LoseChiled.Add(obj.LoseChiled[j]);
                HoursesOnTable[ik].HourseThinking[0].WinChiled.Add(obj.WinChiled[j]);
                HoursesOnTable[ik].HourseThinking[0].IsSup.Add(obj.IsSup[j]);
                HoursesOnTable[ik].HourseThinking[0].IsSupHu.Add(obj.IsSupHu[j]);
                HoursesOnTable[ik].HourseThinking[0].IsThereCheckOfEnemy.Add(obj.IsThereCheckOfEnemy[j]);
                HoursesOnTable[ik].HourseThinking[0].IsThereCheckOfSelf.Add(obj.IsThereCheckOfSelf[j]);
                HoursesOnTable[ik].HourseThinking[0].IsThereMateOfEnemy.Add(obj.IsThereMateOfEnemy[j]);
                HoursesOnTable[ik].HourseThinking[0].IsThereMateOfSelf.Add(obj.IsThereMateOfSelf[j]);
                Act = true;
                return Act;
            }
        }
        bool BlitzNotValidFullGameThinkingTreePartFourCastle(int ik, int Order, ThinkingRefrigtzChessPortable obj, int j)
        {

            Object oo = new Object();
            lock (oo)
            {
                bool Act = false;

                if (obj.HeuristicListCastle[j].Length != 10)
                    return Act;
                //when valid 

                CastlesOnTable[ik].CastleThinking[0].TableListCastle.Add(obj.TableListCastle[j]);
                CastlesOnTable[ik].CastleThinking[0].HeuristicListCastle.Add(obj.HeuristicListCastle[j]);
                CastlesOnTable[ik].CastleThinking[0].RowColumnCastle.Add(obj.RowColumnCastle[j]);
                CastlesOnTable[ik].CastleThinking[0].HitNumberCastle.Add(obj.HitNumberMinister[j]);
                CastlesOnTable[ik].CastleThinking[0].PenaltyRegardListCastle.Add(obj.PenaltyRegardListCastle[j]);
                CastlesOnTable[ik].CastleThinking[0].KishSelf.Add(obj.KishSelf[j]);
                CastlesOnTable[ik].CastleThinking[0].KishEnemy.Add(obj.KishEnemy[j]);
                CastlesOnTable[ik].CastleThinking[0].LoseChiled.Add(obj.LoseChiled[j]);
                CastlesOnTable[ik].CastleThinking[0].WinChiled.Add(obj.WinChiled[j]);
                CastlesOnTable[ik].CastleThinking[0].IsSup.Add(obj.IsSup[j]);
                CastlesOnTable[ik].CastleThinking[0].IsSupHu.Add(obj.IsSupHu[j]);
                CastlesOnTable[ik].CastleThinking[0].IsThereCheckOfEnemy.Add(obj.IsThereCheckOfEnemy[j]);
                CastlesOnTable[ik].CastleThinking[0].IsThereCheckOfSelf.Add(obj.IsThereCheckOfSelf[j]);
                CastlesOnTable[ik].CastleThinking[0].IsThereMateOfEnemy.Add(obj.IsThereMateOfEnemy[j]);
                CastlesOnTable[ik].CastleThinking[0].IsThereMateOfSelf.Add(obj.IsThereMateOfSelf[j]);
                Act = true;

                return Act;
            }
        }
        bool BlitzNotValidFullGameThinkingTreePartFourMinister(int ik, int Order, ThinkingRefrigtzChessPortable obj, int j)
        {
            Object oo = new Object();
            lock (oo)
            {
                bool Act = false;

                if (obj.HeuristicListMinister[j].Length != 10)
                    return Act;
                //when valid 

                MinisterOnTable[ik].MinisterThinking[0].TableListMinister.Add(obj.TableListCastling[j]);
                MinisterOnTable[ik].MinisterThinking[0].HeuristicListMinister.Add(obj.HeuristicListMinister[j]);
                MinisterOnTable[ik].MinisterThinking[0].RowColumnMinister.Add(obj.RowColumnMinister[j]);
                MinisterOnTable[ik].MinisterThinking[0].HitNumberMinister.Add(obj.HitNumberMinister[j]);
                MinisterOnTable[ik].MinisterThinking[0].PenaltyRegardListMinister.Add(obj.PenaltyRegardListMinister[j]);
                MinisterOnTable[ik].MinisterThinking[0].KishSelf.Add(obj.KishSelf[j]);
                MinisterOnTable[ik].MinisterThinking[0].KishEnemy.Add(obj.KishEnemy[j]);
                MinisterOnTable[ik].MinisterThinking[0].LoseChiled.Add(obj.LoseChiled[j]);
                MinisterOnTable[ik].MinisterThinking[0].WinChiled.Add(obj.WinChiled[j]);
                MinisterOnTable[ik].MinisterThinking[0].IsSup.Add(obj.IsSup[j]);
                MinisterOnTable[ik].MinisterThinking[0].IsSupHu.Add(obj.IsSupHu[j]);
                MinisterOnTable[ik].MinisterThinking[0].IsThereCheckOfEnemy.Add(obj.IsThereCheckOfEnemy[j]);
                MinisterOnTable[ik].MinisterThinking[0].IsThereCheckOfSelf.Add(obj.IsThereCheckOfSelf[j]);
                MinisterOnTable[ik].MinisterThinking[0].IsThereMateOfEnemy.Add(obj.IsThereMateOfEnemy[j]);
                MinisterOnTable[ik].MinisterThinking[0].IsThereMateOfSelf.Add(obj.IsThereMateOfSelf[j]);
                Act = true;

                return Act;
            }
        }
        bool BlitzNotValidFullGameThinkingTreePartFourKing(int ik, int Order, ThinkingRefrigtzChessPortable obj, int j)
        {
            Object oo = new Object();
            lock (oo)
            {
                bool Act = false;

                if (obj.HeuristicListKing[j].Length != 10)
                    return Act;
                //when valid 

                KingOnTable[ik].KingThinking[0].TableListKing.Add(obj.TableListKing[j]);
                KingOnTable[ik].KingThinking[0].HeuristicListKing.Add(obj.HeuristicListKing[j]);
                KingOnTable[ik].KingThinking[0].RowColumnKing.Add(obj.RowColumnKing[j]);
                KingOnTable[ik].KingThinking[0].HitNumberKing.Add(obj.HitNumberKing[j]);
                KingOnTable[ik].KingThinking[0].PenaltyRegardListKing.Add(obj.PenaltyRegardListKing[j]);
                KingOnTable[ik].KingThinking[0].KishSelf.Add(obj.KishSelf[j]);
                KingOnTable[ik].KingThinking[0].KishEnemy.Add(obj.KishEnemy[j]);
                KingOnTable[ik].KingThinking[0].LoseChiled.Add(obj.LoseChiled[j]);
                KingOnTable[ik].KingThinking[0].WinChiled.Add(obj.WinChiled[j]);
                KingOnTable[ik].KingThinking[0].IsSup.Add(obj.IsSup[j]);
                KingOnTable[ik].KingThinking[0].IsSupHu.Add(obj.IsSupHu[j]);
                KingOnTable[ik].KingThinking[0].IsThereCheckOfEnemy.Add(obj.IsThereCheckOfEnemy[j]);
                KingOnTable[ik].KingThinking[0].IsThereCheckOfSelf.Add(obj.IsThereCheckOfSelf[j]);
                KingOnTable[ik].KingThinking[0].IsThereMateOfEnemy.Add(obj.IsThereMateOfEnemy[j]);
                KingOnTable[ik].KingThinking[0].IsThereMateOfSelf.Add(obj.IsThereMateOfSelf[j]);
                Act = true;

                return Act;
            }
        }
        bool BlitzNotValidFullGameThinkingTreePartFourCastling(int ik, int Order, ThinkingRefrigtzChessPortable obj, int j)
        {

            Object oo = new Object();
            lock (oo)
            {
                bool Act = false;

                if (obj.HeuristicListCastling[j].Length != 10)
                    return Act;
                //when valid 


                CastlingOnTable[ik].CastlingThinking[0].TableListCastling.Add(obj.TableListCastling[j]);
                CastlingOnTable[ik].CastlingThinking[0].HeuristicListCastling.Add(obj.HeuristicListCastling[j]);
                CastlingOnTable[ik].CastlingThinking[0].RowColumnCastling.Add(obj.RowColumnCastling[j]);
                CastlingOnTable[ik].CastlingThinking[0].HitNumberCastling.Add(obj.HitNumberCastling[j]);
                CastlingOnTable[ik].CastlingThinking[0].PenaltyRegardListCastling.Add(obj.PenaltyRegardListCastling[j]);
                CastlingOnTable[ik].CastlingThinking[0].KishSelf.Add(obj.KishSelf[j]);
                CastlingOnTable[ik].CastlingThinking[0].KishEnemy.Add(obj.KishEnemy[j]);
                CastlingOnTable[ik].CastlingThinking[0].LoseChiled.Add(obj.LoseChiled[j]);
                CastlingOnTable[ik].CastlingThinking[0].WinChiled.Add(obj.WinChiled[j]);
                CastlingOnTable[ik].CastlingThinking[0].IsSup.Add(obj.IsSup[j]);
                CastlingOnTable[ik].CastlingThinking[0].IsSupHu.Add(obj.IsSupHu[j]);
                CastlingOnTable[ik].CastlingThinking[0].IsThereCheckOfEnemy.Add(obj.IsThereCheckOfEnemy[j]);
                CastlingOnTable[ik].CastlingThinking[0].IsThereCheckOfSelf.Add(obj.IsThereCheckOfSelf[j]);
                CastlingOnTable[ik].CastlingThinking[0].IsThereMateOfEnemy.Add(obj.IsThereMateOfEnemy[j]);
                CastlingOnTable[ik].CastlingThinking[0].IsThereMateOfSelf.Add(obj.IsThereMateOfSelf[j]);
                Act = true;
                return Act;
            }
        }
        public bool MergeJungleTree(AllDraw jungle)
        {
            bool Act = false;
            Object oo = new Object();
            lock (oo)
            {
                var output = Task.Factory.StartNew(() =>
                {
                    ParallelOptions po = new ParallelOptions(); po.MaxDegreeOfParallelism = System.Threading.PlatformHelper.ProcessorCount; Parallel.Invoke(() =>
                     {
                         Object o = new Object();
                         lock (o)
                         {

                             ParallelOptions poo = new ParallelOptions(); poo.MaxDegreeOfParallelism = System.Threading.PlatformHelper.ProcessorCount; Parallel.For(0, jungle.SodierHigh, p =>
                             {
                                 Act = Act || MergeJungleTreeSoldier(jungle, p);
                             });
                         }
                     },
                     () =>
                     {

                         Object o = new Object();
                         lock (o)
                         {
                             ParallelOptions poo = new ParallelOptions(); poo.MaxDegreeOfParallelism = System.Threading.PlatformHelper.ProcessorCount; Parallel.For(0, jungle.ElefantHigh, p =>
                             {
                                 Act = Act || MergeJungleTreeElephant(jungle, p);



                             });
                         }
                     },
                     () =>
                     {
                         Object o = new Object();
                         lock (o)
                         {
                             ParallelOptions poo = new ParallelOptions(); poo.MaxDegreeOfParallelism = System.Threading.PlatformHelper.ProcessorCount; Parallel.For(0, jungle.HourseHight, p =>
                             {

                                 Act = Act || MergeJungleTreeHhourse(jungle, p);


                             });
                         }
                     }, () =>
                     {
                         Object o = new Object();
                         lock (o)
                         {
                             ParallelOptions poo = new ParallelOptions(); poo.MaxDegreeOfParallelism = System.Threading.PlatformHelper.ProcessorCount; Parallel.For(0, jungle.CastleHigh, p =>
                             {

                                 Act = Act || MergeJungleTreeCastle(jungle, p);



                             });
                         }
                     },
                     () =>
                     {
                         Object o = new Object();
                         lock (o)
                         {
                             ParallelOptions poo = new ParallelOptions(); poo.MaxDegreeOfParallelism = System.Threading.PlatformHelper.ProcessorCount; Parallel.For(0, jungle.MinisterHigh, p =>
                             {
                                 Act = Act || MergeJungleTreeMinister(jungle, p);



                             });
                         }
                     }, () =>
                     {
                         Object o = new Object();
                         lock (o)
                         {
                             ParallelOptions poo = new ParallelOptions(); poo.MaxDegreeOfParallelism = System.Threading.PlatformHelper.ProcessorCount; Parallel.For(0, jungle.KingHigh, p =>
                             {
                                 Act = Act || MergeJungleTreeKing(jungle, p);
                             });
                         }
                     },
                     () =>
                     {
                         Object o = new Object();
                         lock (o)
                         {
                             ParallelOptions poo = new ParallelOptions(); poo.MaxDegreeOfParallelism = System.Threading.PlatformHelper.ProcessorCount; Parallel.For(0, 1, p =>
                             {
                                 Act = Act || MergeJungleTreeCastling(jungle, p);
                             });
                         }
                     });
                });
                output.Wait();
                output.Dispose();
            }
            return Act;
        }
        public bool MergeJungleTreeSoldier(AllDraw jungle, int p)
        {
            bool Act = false;
            Object oo = new Object();
            lock (oo)
            {

                if (jungle.SolderesOnTable != null)
                {
                    if (jungle.SolderesOnTable[p] != null)
                    {

                        if (jungle.SolderesOnTable[p].SoldierThinking != null)
                        {
                            if (jungle.SolderesOnTable[p].SoldierThinking[0] != null)
                            {

                                if (jungle.SolderesOnTable[p].SoldierThinking[0].AStarGreedy != null)
                                {
                                    for (int k = 0; k < jungle.SolderesOnTable[p].SoldierThinking[0].AStarGreedy.Count; k++)
                                    {
                                        var outputH = Task.Factory.StartNew(() => Act = Act || MergeJungleTree(jungle, p, k, 1));
                                        outputH.Wait();
                                        outputH.Dispose();
                                    }


                                }
                                else
                                    return Act;
                            }
                            else
                                return Act;

                        }
                        else
                            return Act;

                    }
                    else
                        return Act;

                }
                else
                    return Act;


            }
            return Act;
        }
        public bool MergeJungleTreeElephant(AllDraw jungle, int p)
        {
            bool Act = false;
            Object oo = new Object();
            lock (oo)
            {

                if (jungle.ElephantOnTable != null)
                {
                    if (jungle.ElephantOnTable[p] != null)
                    {

                        if (jungle.ElephantOnTable[p].ElefantThinking != null)
                        {
                            if (jungle.ElephantOnTable[p].ElefantThinking[0] != null)
                            {

                                if (jungle.ElephantOnTable[p].ElefantThinking[0].AStarGreedy != null)
                                {
                                    for (int k = 0; k < jungle.ElephantOnTable[p].ElefantThinking[0].AStarGreedy.Count; k++)
                                    {
                                        var outputH = Task.Factory.StartNew(() => Act = Act || MergeJungleTree(jungle, p, k, 2));
                                        outputH.Wait();
                                        outputH.Dispose();

                                    }


                                }
                                else
                                    return Act;

                            }
                            else
                                return Act;

                        }
                        else
                            return Act;

                    }
                    else
                        return Act;

                }
                else
                    return Act;


            }
            return Act;
        }
        public bool MergeJungleTreeHhourse(AllDraw jungle, int p)
        {
            bool Act = false;
            Object oo = new Object();
            lock (oo)
            {

                if (jungle.HoursesOnTable != null)
                {
                    if (jungle.HoursesOnTable[p] != null)
                    {

                        if (jungle.HoursesOnTable[p].HourseThinking != null)
                        {
                            if (jungle.HoursesOnTable[p].HourseThinking[0] != null)
                            {

                                if (jungle.HoursesOnTable[p].HourseThinking[0].AStarGreedy != null)
                                {
                                    for (int k = 0; k < jungle.HoursesOnTable[p].HourseThinking[0].AStarGreedy.Count; k++)
                                    {
                                        var outputH = Task.Factory.StartNew(() => Act = Act || MergeJungleTree(jungle, p, k, 3));
                                        outputH.Wait();
                                        outputH.Dispose();

                                    }


                                }
                                else
                                    return Act;

                            }
                            else
                                return Act;

                        }
                        else
                            return Act;
                    }
                    else
                        return Act;

                }
                else
                    return Act;

            }
            return Act;
        }
        public bool MergeJungleTreeCastle(AllDraw jungle, int p)
        {
            bool Act = false;
            Object oo = new Object();
            lock (oo)
            {

                if (jungle.CastlesOnTable != null)
                {
                    if (jungle.CastlesOnTable[p] != null)
                    {

                        if (jungle.CastlesOnTable[p].CastleThinking != null)
                        {
                            if (jungle.CastlesOnTable[p].CastleThinking[0] != null)
                            {

                                if (jungle.CastlesOnTable[p].CastleThinking[0].AStarGreedy != null)
                                {
                                    for (int k = 0; k < jungle.CastlesOnTable[p].CastleThinking[0].AStarGreedy.Count; k++)
                                    {
                                        var outputH = Task.Factory.StartNew(() => Act = Act || MergeJungleTree(jungle, p, k, 4));
                                        outputH.Wait();
                                        outputH.Dispose();

                                    }


                                }
                                else
                                    return Act;
                            }
                            else
                                return Act;

                        }
                        else
                            return Act;

                    }
                    else
                        return Act;

                }
                else
                    return Act;




            }
            return Act;
        }
        public bool MergeJungleTreeMinister(AllDraw jungle, int p)
        {
            bool Act = false;
            Object oo = new Object();
            lock (oo)
            {
                if (jungle.MinisterOnTable != null)
                {
                    if (jungle.MinisterOnTable[p] != null)
                    {

                        if (jungle.MinisterOnTable[p].MinisterThinking != null)
                        {
                            if (jungle.MinisterOnTable[p].MinisterThinking[0] != null)
                            {

                                if (jungle.MinisterOnTable[p].MinisterThinking[0].AStarGreedy != null)
                                {
                                    for (int k = 0; k < jungle.MinisterOnTable[p].MinisterThinking[0].AStarGreedy.Count; k++)
                                    {
                                        var outputH = Task.Factory.StartNew(() => Act = Act || MergeJungleTree(jungle, p, k, 5));
                                        outputH.Wait();
                                        outputH.Dispose();

                                    }


                                }
                                else
                                    return Act;

                            }
                            else
                                return Act;

                        }
                        else
                            return Act;
                    }
                    else
                        return Act;

                }
                else
                    return Act;




            }
            return Act;
        }
        public bool MergeJungleTreeKing(AllDraw jungle, int p)
        {
            bool Act = false;
            Object oo = new Object();
            lock (oo)
            {



                if (jungle.KingOnTable != null)
                {
                    if (jungle.KingOnTable[p] != null)
                    {

                        if (jungle.KingOnTable[p].KingThinking != null)
                        {
                            if (jungle.KingOnTable[p].KingThinking[0] != null)
                            {

                                if (jungle.KingOnTable[p].KingThinking[0].AStarGreedy != null)
                                {
                                    for (int k = 0; k < jungle.KingOnTable[p].KingThinking[0].AStarGreedy.Count; k++)
                                    {
                                        var outputH = Task.Factory.StartNew(() => Act = Act || MergeJungleTree(jungle, p, k, 6));
                                        outputH.Wait();
                                        outputH.Dispose();

                                    }


                                }
                                else
                                    return Act;

                            }
                            else
                                return Act;

                        }
                        else
                            return Act;

                    }
                    else
                        return Act;

                }
                else
                    return Act;




            }
            return Act;
        }
        public bool MergeJungleTreeCastling(AllDraw jungle, int p)
        {
            bool Act = false;
            Object oo = new Object();
            lock (oo)
            {
                if (jungle.CastlingOnTable != null)
                {
                    if (jungle.CastlingOnTable[p] != null)
                    {

                        if (jungle.CastlingOnTable[p].CastlingThinking != null)
                        {
                            if (jungle.CastlingOnTable[p].CastlingThinking[0] != null)
                            {

                                if (jungle.CastlingOnTable[p].CastlingThinking[0].AStarGreedy != null)
                                {
                                    for (int k = 0; k < jungle.CastlingOnTable[p].CastlingThinking[0].AStarGreedy.Count; k++)
                                    {
                                        var outputH = Task.Factory.StartNew(() => Act = Act || MergeJungleTree(jungle, p, k, 7));
                                        outputH.Wait();
                                        outputH.Dispose();

                                    }


                                }
                                else
                                    return Act;

                            }
                            else
                                return Act;

                        }
                        else
                            return Act;

                    }
                    else
                        return Act;

                }
                else
                    return Act;



            }
            return Act;

        }
        bool MergeJungleTree(AllDraw jungle, int i, int j, int kindA)
        {
            bool Act = false;
            Object oo = new Object();
            lock (oo)
            {


                if (kindA == 1)
                {
                    Act = Act || MergeJungleTreeSoldier(jungle, i, j);
                }
                else
              if (kindA == 2)
                {
                    Act = Act || MergeJungleTreeElephant(jungle, i, j);

                }
                else
                if (kindA == 3)
                {
                    Act = Act || MergeJungleTreeHourse(jungle, i, j);


                }
                else
                     if (kindA == 4)
                {

                    Act = Act || MergeJungleTreeCastle(jungle, i, j);

                }
                else
                if (kindA == 5)
                {

                    Act = Act || MergeJungleTreeMinister(jungle, i, j);

                }
                else
                if (kindA == 6)
                {

                    Act = Act || MergeJungleTreeKing(jungle, i, j);

                }
                else
                if (kindA == 7 || kindA == -7)
                {

                    Act = Act || MergeJungleTreeCastling(jungle, i, j);

                }
            }




            var output = Task.Factory.StartNew(() =>
            {
                ParallelOptions po = new ParallelOptions(); po.MaxDegreeOfParallelism = System.Threading.PlatformHelper.ProcessorCount; Parallel.Invoke(() =>
                 {
                     Object o = new Object();
                     lock (o)
                     {

                         ParallelOptions poo = new ParallelOptions(); poo.MaxDegreeOfParallelism = System.Threading.PlatformHelper.ProcessorCount; Parallel.For(0, SodierHigh, p =>
                         {
                             if (SolderesOnTable != null)
                             {
                                 if (SolderesOnTable[p] != null)
                                 {

                                     if (SolderesOnTable[p].SoldierThinking != null)
                                     {
                                         if (SolderesOnTable[p].SoldierThinking[0] != null)
                                         {

                                             if (SolderesOnTable[p].SoldierThinking[0].AStarGreedy != null)
                                             {
                                                 for (int k = 0; k < SolderesOnTable[p].SoldierThinking[0].AStarGreedy.Count; k++)
                                                 {
                                                     var outputH = Task.Factory.StartNew(() => Act = Act || SolderesOnTable[p].SoldierThinking[0].AStarGreedy[k].MergeJungleTree(jungle.SolderesOnTable[p].SoldierThinking[0].AStarGreedy[k], p, k, 1));
                                                     outputH.Wait();
                                                     outputH.Dispose();
                                                 }


                                             }
                                             else
                                                 return;
                                         }
                                         else
                                             return;

                                     }
                                     else
                                         return;

                                 }
                                 else
                                     return;

                             }
                             else
                                 return;



                         });
                     }
                 },
                 () =>
                 {

                     Object o = new Object();
                     lock (o)
                     {
                         ParallelOptions poo = new ParallelOptions(); poo.MaxDegreeOfParallelism = System.Threading.PlatformHelper.ProcessorCount; Parallel.For(0, ElefantHigh, p =>
                         {
                             if (ElephantOnTable != null)
                             {
                                 if (ElephantOnTable[p] != null)
                                 {

                                     if (ElephantOnTable[p].ElefantThinking != null)
                                     {
                                         if (ElephantOnTable[p].ElefantThinking[0] != null)
                                         {

                                             if (ElephantOnTable[p].ElefantThinking[0].AStarGreedy != null)
                                             {
                                                 for (int k = 0; k < ElephantOnTable[p].ElefantThinking[0].AStarGreedy.Count; k++)
                                                 {
                                                     var outputH = Task.Factory.StartNew(() => Act = Act || ElephantOnTable[p].ElefantThinking[0].AStarGreedy[k].MergeJungleTree(jungle.ElephantOnTable[p].ElefantThinking[0].AStarGreedy[k], p, k, 2));
                                                     outputH.Wait();
                                                     outputH.Dispose();

                                                 }


                                             }
                                             else
                                                 return;

                                         }
                                         else
                                             return;

                                     }
                                     else
                                         return;

                                 }
                                 else
                                     return;

                             }
                             else
                                 return;



                         });
                     }
                 },
                 () =>
                 {
                     Object o = new Object();
                     lock (o)
                     {
                         ParallelOptions poo = new ParallelOptions(); poo.MaxDegreeOfParallelism = System.Threading.PlatformHelper.ProcessorCount; Parallel.For(0, HourseHight, p =>
                         {

                             if (HoursesOnTable != null)
                             {
                                 if (HoursesOnTable[p] != null)
                                 {

                                     if (HoursesOnTable[p].HourseThinking != null)
                                     {
                                         if (HoursesOnTable[p].HourseThinking[0] != null)
                                         {

                                             if (HoursesOnTable[p].HourseThinking[0].AStarGreedy != null)
                                             {
                                                 for (int k = 0; k < HoursesOnTable[p].HourseThinking[0].AStarGreedy.Count; k++)
                                                 {
                                                     var outputH = Task.Factory.StartNew(() => Act = Act || HoursesOnTable[p].HourseThinking[0].AStarGreedy[k].MergeJungleTree(jungle.HoursesOnTable[p].HourseThinking[0].AStarGreedy[k], p, k, 3));
                                                     outputH.Wait();
                                                     outputH.Dispose();

                                                 }


                                             }
                                             else
                                                 return;

                                         }
                                         else
                                             return;

                                     }
                                     else
                                         return;

                                 }
                                 else
                                     return;

                             }
                             else
                                 return;


                         });
                     }
                 }, () =>
                 {
                     Object o = new Object();
                     lock (o)
                     {
                         ParallelOptions poo = new ParallelOptions(); poo.MaxDegreeOfParallelism = System.Threading.PlatformHelper.ProcessorCount; Parallel.For(0, CastleHigh, p =>
                         {

                             if (CastlesOnTable != null)
                             {
                                 if (CastlesOnTable[p] != null)
                                 {

                                     if (CastlesOnTable[p].CastleThinking != null)
                                     {
                                         if (CastlesOnTable[p].CastleThinking[0] != null)
                                         {

                                             if (CastlesOnTable[p].CastleThinking[0].AStarGreedy != null)
                                             {
                                                 for (int k = 0; k < CastlesOnTable[p].CastleThinking[0].AStarGreedy.Count; k++)
                                                 {
                                                     var outputH = Task.Factory.StartNew(() => Act = Act || CastlesOnTable[p].CastleThinking[0].AStarGreedy[k].MergeJungleTree(jungle.CastlesOnTable[p].CastleThinking[0].AStarGreedy[k], p, k, 4));
                                                     outputH.Wait();
                                                     outputH.Dispose();

                                                 }


                                             }
                                             else
                                                 return;

                                         }
                                         else
                                             return;

                                     }
                                     else
                                         return;

                                 }
                                 else
                                     return;

                             }
                             else
                                 return;



                         });
                     }
                 },
                 () =>
                 {
                     Object o = new Object();
                     lock (o)
                     {
                         ParallelOptions poo = new ParallelOptions(); poo.MaxDegreeOfParallelism = System.Threading.PlatformHelper.ProcessorCount; Parallel.For(0, MinisterHigh, p =>
                         {

                             if (MinisterOnTable != null)
                             {
                                 if (MinisterOnTable[p] != null)
                                 {

                                     if (MinisterOnTable[p].MinisterThinking != null)
                                     {
                                         if (MinisterOnTable[p].MinisterThinking[0] != null)
                                         {

                                             if (MinisterOnTable[p].MinisterThinking[0].AStarGreedy != null)
                                             {
                                                 for (int k = 0; k < MinisterOnTable[p].MinisterThinking[0].AStarGreedy.Count; k++)
                                                 {
                                                     var outputH = Task.Factory.StartNew(() => Act = Act || MinisterOnTable[p].MinisterThinking[0].AStarGreedy[k].MergeJungleTree(jungle.MinisterOnTable[p].MinisterThinking[0].AStarGreedy[k], p, k, 5));
                                                     outputH.Wait();
                                                     outputH.Dispose();

                                                 }


                                             }
                                             else
                                                 return;

                                         }
                                         else
                                             return;

                                     }
                                     else
                                         return;

                                 }
                                 else
                                     return;

                             }
                             else
                                 return;



                         });
                     }
                 }, () =>
                 {
                     Object o = new Object();
                     lock (o)
                     {
                         ParallelOptions poo = new ParallelOptions(); poo.MaxDegreeOfParallelism = System.Threading.PlatformHelper.ProcessorCount; Parallel.For(0, KingHigh, p =>
                         {
                             if (KingOnTable != null)
                             {
                                 if (KingOnTable[p] != null)
                                 {

                                     if (KingOnTable[p].KingThinking != null)
                                     {
                                         if (KingOnTable[p].KingThinking[0] != null)
                                         {

                                             if (KingOnTable[p].KingThinking[0].AStarGreedy != null)
                                             {
                                                 for (int k = 0; k < KingOnTable[p].KingThinking[0].AStarGreedy.Count; k++)
                                                 {
                                                     var outputH = Task.Factory.StartNew(() => Act = Act || KingOnTable[p].KingThinking[0].AStarGreedy[k].MergeJungleTree(jungle.KingOnTable[p].KingThinking[0].AStarGreedy[k], p, k, 6));
                                                     outputH.Wait();
                                                     outputH.Dispose();

                                                 }


                                             }
                                             else
                                                 return;

                                         }
                                         else
                                             return;

                                     }
                                     else
                                         return;

                                 }
                                 else
                                     return;

                             }
                             else
                                 return;



                         });
                     }
                 },
                 () =>
                 {
                     Object o = new Object();
                     lock (o)
                     {
                         ParallelOptions poo = new ParallelOptions(); poo.MaxDegreeOfParallelism = System.Threading.PlatformHelper.ProcessorCount; Parallel.For(0, 1, p =>
                         {
                             if (CastlingOnTable != null)
                             {
                                 if (CastlingOnTable[p] != null)
                                 {

                                     if (CastlingOnTable[p].CastlingThinking != null)
                                     {
                                         if (CastlingOnTable[p].CastlingThinking[0] != null)
                                         {

                                             if (CastlingOnTable[p].CastlingThinking[0].AStarGreedy != null)
                                             {
                                                 for (int k = 0; k < CastlingOnTable[p].CastlingThinking[0].AStarGreedy.Count; k++)
                                                 {
                                                     var outputH = Task.Factory.StartNew(() => Act = Act || CastlingOnTable[p].CastlingThinking[0].AStarGreedy[k].MergeJungleTree(jungle.CastlingOnTable[p].CastlingThinking[0].AStarGreedy[k], p, k, 7));
                                                     outputH.Wait();
                                                     outputH.Dispose();

                                                 }


                                             }
                                             else
                                                 return;

                                         }
                                         else
                                             return;

                                     }
                                     else
                                         return;

                                 }
                                 else
                                     return;

                             }
                             else
                                 return;


                         });
                     }
                 });
            });
            output.Wait();
            output.Dispose();
            return Act;
        }
        bool MergeJungleTreeSoldier(AllDraw jungle, int i, int j)
        {
            bool Act = false;
            Object oo = new Object();
            lock (oo)
            {



                if (SolderesOnTable != null)
                {
                    if (SolderesOnTable[i] != null)
                    {
                        if (SolderesOnTable[i].SoldierThinking != null)
                        {
                            if (SolderesOnTable[i].SoldierThinking[0] != null)
                            {
                                if (SolderesOnTable[i].SoldierThinking[0].AStarGreedy == null)
                                {

                                    if (SolderesOnTable[i].SoldierThinking[0].AStarGreedy == null)
                                        SolderesOnTable[i].SoldierThinking[0].AStarGreedy = new List<AllDraw>();
                                    SolderesOnTable[i].SoldierThinking[0].TableListSolder.Clear();
                                    SolderesOnTable[i].SoldierThinking[0].HeuristicListSolder.Clear();
                                    SolderesOnTable[i].SoldierThinking[0].RowColumnSoldier.Clear();
                                    SolderesOnTable[i].SoldierThinking[0].HitNumberSoldier.Clear();
                                    SolderesOnTable[i].SoldierThinking[0].PenaltyRegardListSolder.Clear();
                                    SolderesOnTable[i].SoldierThinking[0].KishSelf.Clear();
                                    SolderesOnTable[i].SoldierThinking[0].KishEnemy.Clear();
                                    SolderesOnTable[i].SoldierThinking[0].LoseChiled.Clear();
                                    SolderesOnTable[i].SoldierThinking[0].WinChiled.Clear();
                                    SolderesOnTable[i].SoldierThinking[0].IsSup.Clear();
                                    SolderesOnTable[i].SoldierThinking[0].IsSupHu.Clear();
                                    SolderesOnTable[i].SoldierThinking[0].IsThereCheckOfEnemy.Clear();
                                    SolderesOnTable[i].SoldierThinking[0].IsThereCheckOfSelf.Clear();
                                    SolderesOnTable[i].SoldierThinking[0].IsThereMateOfEnemy.Clear();
                                    SolderesOnTable[i].SoldierThinking[0].IsThereMateOfSelf.Clear();
                                    Object ooo = new Object();
                                    lock (ooo)
                                    {
                                        ////HarasAct = true; Act = true;
                                        for (int h = 0; h < jungle.SolderesOnTable[i].SoldierThinking[0].TableListSolder.Count; h++)
                                            Act = Act || BlitzNotValidFullGameThinkingTreePartFour(i, OrderP, 1, jungle.SolderesOnTable[i].SoldierThinking[0], h);

                                        for (int h = 0; h < jungle.SolderesOnTable[i].SoldierThinking[0].AStarGreedy.Count; h++)
                                        {
                                            SolderesOnTable[i].SoldierThinking[0].AStarGreedy.Add(jungle.SolderesOnTable[i].SoldierThinking[0].AStarGreedy[h]);
                                            SolderesOnTable[i].SoldierThinking[0].AStarGreedy[SolderesOnTable[i].SoldierThinking[0].AStarGreedy.Count - 1].AStarGreedyString = this;
                                        }
                                    }
                                    return Act;
                                }
                                else
                                if (SolderesOnTable[i].SoldierThinking[0].AStarGreedy.Count < jungle.SolderesOnTable[i].SoldierThinking[0].AStarGreedy.Count)
                                {
                                    SolderesOnTable[i].SoldierThinking[0].AStarGreedy.Clear();
                                    SolderesOnTable[i].SoldierThinking[0].TableListSolder.Clear();
                                    SolderesOnTable[i].SoldierThinking[0].HeuristicListSolder.Clear();
                                    SolderesOnTable[i].SoldierThinking[0].RowColumnSoldier.Clear();
                                    SolderesOnTable[i].SoldierThinking[0].HitNumberSoldier.Clear();
                                    SolderesOnTable[i].SoldierThinking[0].PenaltyRegardListSolder.Clear();
                                    SolderesOnTable[i].SoldierThinking[0].KishSelf.Clear();
                                    SolderesOnTable[i].SoldierThinking[0].KishEnemy.Clear();
                                    SolderesOnTable[i].SoldierThinking[0].LoseChiled.Clear();
                                    SolderesOnTable[i].SoldierThinking[0].WinChiled.Clear();
                                    SolderesOnTable[i].SoldierThinking[0].IsSup.Clear();
                                    SolderesOnTable[i].SoldierThinking[0].IsSupHu.Clear();
                                    SolderesOnTable[i].SoldierThinking[0].IsThereCheckOfEnemy.Clear();
                                    SolderesOnTable[i].SoldierThinking[0].IsThereCheckOfSelf.Clear();
                                    SolderesOnTable[i].SoldierThinking[0].IsThereMateOfEnemy.Clear();
                                    SolderesOnTable[i].SoldierThinking[0].IsThereMateOfSelf.Clear();
                                    Object ooo = new Object();
                                    lock (ooo)
                                    {
                                        ////HarasAct = true; Act = true;
                                        for (int h = 0; h < jungle.SolderesOnTable[i].SoldierThinking[0].TableListSolder.Count; h++)
                                            Act = Act || BlitzNotValidFullGameThinkingTreePartFour(i, OrderP, 1, jungle.SolderesOnTable[i].SoldierThinking[0], h);

                                        for (int h = 0; h < jungle.SolderesOnTable[i].SoldierThinking[0].AStarGreedy.Count; h++)
                                        {
                                            SolderesOnTable[i].SoldierThinking[0].AStarGreedy.Add(jungle.SolderesOnTable[i].SoldierThinking[0].AStarGreedy[h]);
                                            SolderesOnTable[i].SoldierThinking[0].AStarGreedy[SolderesOnTable[i].SoldierThinking[0].AStarGreedy.Count - 1].AStarGreedyString = this;
                                        }
                                    }
                                    return Act;
                                }
                                else
                                    return Act;
                            }
                            else
                                return Act;

                        }
                        else
                            return Act;

                    }
                    else
                        return Act;
                }
                else
                    return Act;
            }
            return Act;
        }
        bool MergeJungleTreeElephant(AllDraw jungle, int i, int j)
        {
            bool Act = false;
            Object oo = new Object();
            lock (oo)
            {



                if (ElephantOnTable != null)
                {
                    if (ElephantOnTable[i] != null)
                    {
                        if (ElephantOnTable[i].ElefantThinking != null)
                        {
                            if (ElephantOnTable[i].ElefantThinking[0] != null)
                            {
                                if (ElephantOnTable[i].ElefantThinking[0].AStarGreedy == null)
                                {
                                    if (ElephantOnTable[i].ElefantThinking[0].AStarGreedy == null)
                                        ElephantOnTable[i].ElefantThinking[0].AStarGreedy = new List<AllDraw>();
                                    ElephantOnTable[i].ElefantThinking[0].TableListElefant.Clear();
                                    ElephantOnTable[i].ElefantThinking[0].HeuristicListElefant.Clear();
                                    ElephantOnTable[i].ElefantThinking[0].RowColumnElefant.Clear();
                                    ElephantOnTable[i].ElefantThinking[0].HitNumberElefant.Clear();
                                    ElephantOnTable[i].ElefantThinking[0].PenaltyRegardListElefant.Clear();
                                    ElephantOnTable[i].ElefantThinking[0].KishSelf.Clear();
                                    ElephantOnTable[i].ElefantThinking[0].KishEnemy.Clear();
                                    ElephantOnTable[i].ElefantThinking[0].LoseChiled.Clear();
                                    ElephantOnTable[i].ElefantThinking[0].WinChiled.Clear();
                                    ElephantOnTable[i].ElefantThinking[0].IsSup.Clear();
                                    ElephantOnTable[i].ElefantThinking[0].IsSupHu.Clear();
                                    ElephantOnTable[i].ElefantThinking[0].IsThereCheckOfEnemy.Clear();
                                    ElephantOnTable[i].ElefantThinking[0].IsThereCheckOfSelf.Clear();
                                    ElephantOnTable[i].ElefantThinking[0].IsThereMateOfEnemy.Clear();
                                    ElephantOnTable[i].ElefantThinking[0].IsThereMateOfSelf.Clear();
                                    Object ooo = new Object();
                                    lock (ooo)
                                    {
                                        ////HarasAct = true; Act = true;
                                        for (int h = 0; h < jungle.ElephantOnTable[i].ElefantThinking[0].TableListElefant.Count; h++)
                                            Act = Act || BlitzNotValidFullGameThinkingTreePartFour(i, OrderP, 2, jungle.ElephantOnTable[i].ElefantThinking[0], h);

                                        for (int h = 0; h < jungle.ElephantOnTable[i].ElefantThinking[0].AStarGreedy.Count; h++)
                                        {
                                            ElephantOnTable[i].ElefantThinking[0].AStarGreedy.Add(jungle.ElephantOnTable[i].ElefantThinking[0].AStarGreedy[h]);
                                            ElephantOnTable[i].ElefantThinking[0].AStarGreedy[ElephantOnTable[i].ElefantThinking[0].AStarGreedy.Count - 1].AStarGreedyString = this;
                                        }
                                    }
                                    return Act;
                                }
                                else
                                if (ElephantOnTable[i].ElefantThinking[0].AStarGreedy.Count < jungle.ElephantOnTable[i].ElefantThinking[0].AStarGreedy.Count)
                                {
                                    ElephantOnTable[i].ElefantThinking[0].AStarGreedy.Clear();
                                    ElephantOnTable[i].ElefantThinking[0].TableListElefant.Clear();
                                    ElephantOnTable[i].ElefantThinking[0].HeuristicListElefant.Clear();
                                    ElephantOnTable[i].ElefantThinking[0].RowColumnElefant.Clear();
                                    ElephantOnTable[i].ElefantThinking[0].HitNumberElefant.Clear();
                                    ElephantOnTable[i].ElefantThinking[0].PenaltyRegardListElefant.Clear();
                                    ElephantOnTable[i].ElefantThinking[0].KishSelf.Clear();
                                    ElephantOnTable[i].ElefantThinking[0].KishEnemy.Clear();
                                    ElephantOnTable[i].ElefantThinking[0].LoseChiled.Clear();
                                    ElephantOnTable[i].ElefantThinking[0].WinChiled.Clear();
                                    ElephantOnTable[i].ElefantThinking[0].IsSup.Clear();
                                    ElephantOnTable[i].ElefantThinking[0].IsSupHu.Clear();
                                    ElephantOnTable[i].ElefantThinking[0].IsThereCheckOfEnemy.Clear();
                                    ElephantOnTable[i].ElefantThinking[0].IsThereCheckOfSelf.Clear();
                                    ElephantOnTable[i].ElefantThinking[0].IsThereMateOfEnemy.Clear();
                                    ElephantOnTable[i].ElefantThinking[0].IsThereMateOfSelf.Clear();
                                    Object ooo = new Object();
                                    lock (ooo)
                                    {
                                        ////HarasAct = true; Act = true;
                                        for (int h = 0; h < jungle.ElephantOnTable[i].ElefantThinking[0].TableListElefant.Count; h++)
                                            Act = Act || BlitzNotValidFullGameThinkingTreePartFour(i, OrderP, 2, jungle.ElephantOnTable[i].ElefantThinking[0], h);

                                        for (int h = 0; h < jungle.ElephantOnTable[i].ElefantThinking[0].AStarGreedy.Count; h++)
                                        {
                                            ElephantOnTable[i].ElefantThinking[0].AStarGreedy.Add(jungle.ElephantOnTable[i].ElefantThinking[0].AStarGreedy[h]);
                                            ElephantOnTable[i].ElefantThinking[0].AStarGreedy[ElephantOnTable[i].ElefantThinking[0].AStarGreedy.Count - 1].AStarGreedyString = this;
                                        }
                                    }
                                    return Act;
                                }
                                else
                                    return Act;
                            }
                            else
                                return Act;

                        }
                        else
                            return Act;

                    }
                    else
                        return Act;
                }
                else
                    return Act;

            }




            return Act;
        }
        bool MergeJungleTreeHourse(AllDraw jungle, int i, int j)
        {
            bool Act = false;
            Object oo = new Object();
            lock (oo)
            {

                if (HoursesOnTable != null)
                {
                    if (HoursesOnTable[i] != null)
                    {
                        if (HoursesOnTable[i].HourseThinking != null)
                        {
                            if (HoursesOnTable[i].HourseThinking[0] != null)
                            {
                                if (HoursesOnTable[i].HourseThinking[0].AStarGreedy == null)
                                {
                                    if (HoursesOnTable[i].HourseThinking[0].AStarGreedy == null)
                                        HoursesOnTable[i].HourseThinking[0].AStarGreedy = new List<AllDraw>();
                                    HoursesOnTable[i].HourseThinking[0].TableListHourse.Clear();
                                    HoursesOnTable[i].HourseThinking[0].HeuristicListHourse.Clear();
                                    HoursesOnTable[i].HourseThinking[0].RowColumnHourse.Clear();
                                    HoursesOnTable[i].HourseThinking[0].HitNumberHourse.Clear();
                                    HoursesOnTable[i].HourseThinking[0].PenaltyRegardListHourse.Clear();
                                    HoursesOnTable[i].HourseThinking[0].KishSelf.Clear();
                                    HoursesOnTable[i].HourseThinking[0].KishEnemy.Clear();
                                    HoursesOnTable[i].HourseThinking[0].LoseChiled.Clear();
                                    HoursesOnTable[i].HourseThinking[0].WinChiled.Clear();
                                    HoursesOnTable[i].HourseThinking[0].IsSup.Clear();
                                    HoursesOnTable[i].HourseThinking[0].IsSupHu.Clear();
                                    HoursesOnTable[i].HourseThinking[0].IsThereCheckOfEnemy.Clear();
                                    HoursesOnTable[i].HourseThinking[0].IsThereCheckOfSelf.Clear();
                                    HoursesOnTable[i].HourseThinking[0].IsThereMateOfEnemy.Clear();
                                    HoursesOnTable[i].HourseThinking[0].IsThereMateOfSelf.Clear();
                                    Object ooo = new Object();
                                    lock (ooo)
                                    {
                                        ////HarasAct = true; Act = true;
                                        for (int h = 0; h < jungle.HoursesOnTable[i].HourseThinking[0].TableListHourse.Count; h++)
                                            Act = Act || BlitzNotValidFullGameThinkingTreePartFour(i, OrderP, 3, jungle.HoursesOnTable[i].HourseThinking[0], h);
                                        for (int h = 0; h < jungle.HoursesOnTable[i].HourseThinking[0].AStarGreedy.Count; h++)
                                        {
                                            HoursesOnTable[i].HourseThinking[0].AStarGreedy.Add(jungle.HoursesOnTable[i].HourseThinking[0].AStarGreedy[h]);
                                            HoursesOnTable[i].HourseThinking[0].AStarGreedy[HoursesOnTable[i].HourseThinking[0].AStarGreedy.Count - 1].AStarGreedyString = this;
                                        }
                                    }
                                    return Act;
                                }
                                else
                                if (HoursesOnTable[i].HourseThinking[0].AStarGreedy.Count < jungle.HoursesOnTable[i].HourseThinking[0].AStarGreedy.Count)
                                {
                                    HoursesOnTable[i].HourseThinking[0].AStarGreedy.Clear();
                                    HoursesOnTable[i].HourseThinking[0].TableListHourse.Clear();
                                    HoursesOnTable[i].HourseThinking[0].HeuristicListHourse.Clear();
                                    HoursesOnTable[i].HourseThinking[0].RowColumnHourse.Clear();
                                    HoursesOnTable[i].HourseThinking[0].HitNumberHourse.Clear();
                                    HoursesOnTable[i].HourseThinking[0].PenaltyRegardListHourse.Clear();
                                    HoursesOnTable[i].HourseThinking[0].KishSelf.Clear();
                                    HoursesOnTable[i].HourseThinking[0].KishEnemy.Clear();
                                    HoursesOnTable[i].HourseThinking[0].LoseChiled.Clear();
                                    HoursesOnTable[i].HourseThinking[0].WinChiled.Clear();
                                    HoursesOnTable[i].HourseThinking[0].IsSup.Clear();
                                    HoursesOnTable[i].HourseThinking[0].IsSupHu.Clear();
                                    HoursesOnTable[i].HourseThinking[0].IsThereCheckOfEnemy.Clear();
                                    HoursesOnTable[i].HourseThinking[0].IsThereCheckOfSelf.Clear();
                                    HoursesOnTable[i].HourseThinking[0].IsThereMateOfEnemy.Clear();
                                    HoursesOnTable[i].HourseThinking[0].IsThereMateOfSelf.Clear();
                                    Object ooo = new Object();
                                    lock (ooo)
                                    {
                                        ////HarasAct = true; Act = true;
                                        for (int h = 0; h < jungle.HoursesOnTable[i].HourseThinking[0].TableListHourse.Count; h++)
                                            Act = Act || BlitzNotValidFullGameThinkingTreePartFour(i, OrderP, 3, jungle.HoursesOnTable[i].HourseThinking[0], h);

                                        for (int h = 0; h < jungle.HoursesOnTable[i].HourseThinking[0].AStarGreedy.Count; h++)
                                        {
                                            HoursesOnTable[i].HourseThinking[0].AStarGreedy.Add(jungle.HoursesOnTable[i].HourseThinking[0].AStarGreedy[h]);
                                            HoursesOnTable[i].HourseThinking[0].AStarGreedy[HoursesOnTable[i].HourseThinking[0].AStarGreedy.Count - 1].AStarGreedyString = this;
                                        }
                                    }
                                    return Act;
                                }
                                else
                                    return Act;
                            }
                            else
                                return Act;

                        }
                        else
                            return Act;

                    }
                    else
                        return Act;
                }
                else
                    return Act;

            }




            return Act;
        }
        bool MergeJungleTreeCastle(AllDraw jungle, int i, int j)
        {
            bool Act = false;
            Object oo = new Object();
            lock (oo)
            {




                if (CastlesOnTable != null)
                {
                    if (CastlesOnTable[i] != null)
                    {
                        if (CastlesOnTable[i].CastleThinking != null)
                        {
                            if (CastlesOnTable[i].CastleThinking[0] != null)
                            {
                                if (CastlesOnTable[i].CastleThinking[0].AStarGreedy == null)
                                {
                                    if (CastlesOnTable[i].CastleThinking[0].AStarGreedy == null)
                                        CastlesOnTable[i].CastleThinking[0].AStarGreedy = new List<AllDraw>();
                                    CastlesOnTable[i].CastleThinking[0].TableListCastle.Clear();
                                    CastlesOnTable[i].CastleThinking[0].HeuristicListCastle.Clear();
                                    CastlesOnTable[i].CastleThinking[0].RowColumnCastle.Clear();
                                    CastlesOnTable[i].CastleThinking[0].HitNumberCastle.Clear();
                                    CastlesOnTable[i].CastleThinking[0].PenaltyRegardListCastle.Clear();
                                    CastlesOnTable[i].CastleThinking[0].KishSelf.Clear();
                                    CastlesOnTable[i].CastleThinking[0].KishEnemy.Clear();
                                    CastlesOnTable[i].CastleThinking[0].LoseChiled.Clear();
                                    CastlesOnTable[i].CastleThinking[0].IsSup.Clear();
                                    CastlesOnTable[i].CastleThinking[0].IsSupHu.Clear();
                                    CastlesOnTable[i].CastleThinking[0].IsThereCheckOfEnemy.Clear();
                                    CastlesOnTable[i].CastleThinking[0].IsThereCheckOfSelf.Clear();
                                    CastlesOnTable[i].CastleThinking[0].IsThereMateOfEnemy.Clear();
                                    CastlesOnTable[i].CastleThinking[0].IsThereMateOfSelf.Clear();
                                    Object ooo = new Object();
                                    lock (ooo)
                                    {
                                        ////HarasAct = true; Act = true;
                                        for (int h = 0; h < jungle.CastlesOnTable[i].CastleThinking[0].TableListCastle.Count; h++)
                                            Act = Act || BlitzNotValidFullGameThinkingTreePartFour(i, OrderP, 4, jungle.CastlesOnTable[i].CastleThinking[0], h);

                                        for (int h = 0; h < jungle.CastlesOnTable[i].CastleThinking[0].AStarGreedy.Count; h++)
                                        {
                                            CastlesOnTable[i].CastleThinking[0].AStarGreedy.Add(jungle.CastlesOnTable[i].CastleThinking[0].AStarGreedy[h]);
                                            CastlesOnTable[i].CastleThinking[0].AStarGreedy[CastlesOnTable[i].CastleThinking[0].AStarGreedy.Count - 1].AStarGreedyString = this;
                                        }
                                    }
                                    return Act;
                                }
                                else
                                if (CastlesOnTable[i].CastleThinking[0].AStarGreedy.Count < jungle.CastlesOnTable[i].CastleThinking[0].AStarGreedy.Count)
                                {
                                    CastlesOnTable[i].CastleThinking[0].AStarGreedy.Clear();
                                    CastlesOnTable[i].CastleThinking[0].TableListCastle.Clear();
                                    CastlesOnTable[i].CastleThinking[0].HeuristicListCastle.Clear();
                                    CastlesOnTable[i].CastleThinking[0].RowColumnCastle.Clear();
                                    CastlesOnTable[i].CastleThinking[0].HitNumberCastle.Clear();
                                    CastlesOnTable[i].CastleThinking[0].PenaltyRegardListCastle.Clear();
                                    CastlesOnTable[i].CastleThinking[0].KishSelf.Clear();
                                    CastlesOnTable[i].CastleThinking[0].KishEnemy.Clear();
                                    CastlesOnTable[i].CastleThinking[0].LoseChiled.Clear();
                                    CastlesOnTable[i].CastleThinking[0].IsSup.Clear();
                                    CastlesOnTable[i].CastleThinking[0].IsSupHu.Clear();
                                    CastlesOnTable[i].CastleThinking[0].IsThereCheckOfEnemy.Clear();
                                    CastlesOnTable[i].CastleThinking[0].IsThereCheckOfSelf.Clear();
                                    CastlesOnTable[i].CastleThinking[0].IsThereMateOfEnemy.Clear();
                                    CastlesOnTable[i].CastleThinking[0].IsThereMateOfSelf.Clear();
                                    Object ooo = new Object();
                                    lock (ooo)
                                    {
                                        ////HarasAct = true; Act = true;
                                        for (int h = 0; h < jungle.CastlesOnTable[i].CastleThinking[0].TableListCastle.Count; h++)
                                            Act = Act || BlitzNotValidFullGameThinkingTreePartFour(i, OrderP, 4, jungle.CastlesOnTable[i].CastleThinking[0], h);

                                        for (int h = 0; h < jungle.CastlesOnTable[i].CastleThinking[0].AStarGreedy.Count; h++)
                                        {
                                            CastlesOnTable[i].CastleThinking[0].AStarGreedy.Add(jungle.CastlesOnTable[i].CastleThinking[0].AStarGreedy[h]);
                                            CastlesOnTable[i].CastleThinking[0].AStarGreedy[CastlesOnTable[i].CastleThinking[0].AStarGreedy.Count - 1].AStarGreedyString = this;
                                        }
                                    }
                                    return Act;

                                }
                                else
                                    return Act;
                            }
                            else
                                return Act;

                        }
                        else
                            return Act;

                    }
                    else
                        return Act;
                }
                else
                    return Act;

            }




            return Act;
        }
        bool MergeJungleTreeMinister(AllDraw jungle, int i, int j)
        {
            bool Act = false;
            Object oo = new Object();
            lock (oo)
            {




                if (MinisterOnTable != null)
                {
                    if (MinisterOnTable[i] != null)
                    {
                        if (MinisterOnTable[i].MinisterThinking != null)
                        {
                            if (MinisterOnTable[i].MinisterThinking[0] != null)
                            {
                                if (MinisterOnTable[i].MinisterThinking[0].AStarGreedy == null)
                                {
                                    if (MinisterOnTable[i].MinisterThinking[0].AStarGreedy == null)
                                        MinisterOnTable[i].MinisterThinking[0].AStarGreedy = new List<AllDraw>();
                                    MinisterOnTable[i].MinisterThinking[0].TableListMinister.Clear();
                                    MinisterOnTable[i].MinisterThinking[0].HeuristicListMinister.Clear();
                                    MinisterOnTable[i].MinisterThinking[0].RowColumnMinister.Clear();
                                    MinisterOnTable[i].MinisterThinking[0].HitNumberMinister.Clear();
                                    MinisterOnTable[i].MinisterThinking[0].PenaltyRegardListMinister.Clear();
                                    MinisterOnTable[i].MinisterThinking[0].KishSelf.Clear();
                                    MinisterOnTable[i].MinisterThinking[0].KishEnemy.Clear();
                                    MinisterOnTable[i].MinisterThinking[0].WinChiled.Clear();
                                    MinisterOnTable[i].MinisterThinking[0].IsSup.Clear();
                                    MinisterOnTable[i].MinisterThinking[0].IsSupHu.Clear();
                                    MinisterOnTable[i].MinisterThinking[0].IsThereCheckOfEnemy.Clear();
                                    MinisterOnTable[i].MinisterThinking[0].IsThereCheckOfSelf.Clear();
                                    MinisterOnTable[i].MinisterThinking[0].IsThereMateOfEnemy.Clear();
                                    MinisterOnTable[i].MinisterThinking[0].IsThereMateOfSelf.Clear();
                                    Object ooo = new Object();
                                    lock (ooo)
                                    {
                                        ////HarasAct = true; Act = true;
                                        for (int h = 0; h < jungle.MinisterOnTable[i].MinisterThinking[0].TableListMinister.Count; h++)
                                            Act = Act || BlitzNotValidFullGameThinkingTreePartFour(i, OrderP, 5, jungle.MinisterOnTable[i].MinisterThinking[0], h);

                                        for (int h = 0; h < jungle.MinisterOnTable[i].MinisterThinking[0].AStarGreedy.Count; h++)
                                        {
                                            MinisterOnTable[i].MinisterThinking[0].AStarGreedy.Add(jungle.MinisterOnTable[i].MinisterThinking[0].AStarGreedy[h]);
                                            MinisterOnTable[i].MinisterThinking[0].AStarGreedy[MinisterOnTable[i].MinisterThinking[0].AStarGreedy.Count - 1].AStarGreedyString = this;
                                        }
                                    }
                                    return Act;
                                }
                                else
                                 if (MinisterOnTable[i].MinisterThinking[0].AStarGreedy.Count < jungle.MinisterOnTable[i].MinisterThinking[0].AStarGreedy.Count)
                                {
                                    MinisterOnTable[i].MinisterThinking[0].AStarGreedy.Clear();
                                    MinisterOnTable[i].MinisterThinking[0].TableListMinister.Clear();
                                    MinisterOnTable[i].MinisterThinking[0].HeuristicListMinister.Clear();
                                    MinisterOnTable[i].MinisterThinking[0].RowColumnMinister.Clear();
                                    MinisterOnTable[i].MinisterThinking[0].HitNumberMinister.Clear();
                                    MinisterOnTable[i].MinisterThinking[0].PenaltyRegardListMinister.Clear();
                                    MinisterOnTable[i].MinisterThinking[0].KishSelf.Clear();
                                    MinisterOnTable[i].MinisterThinking[0].KishEnemy.Clear();
                                    MinisterOnTable[i].MinisterThinking[0].WinChiled.Clear();
                                    MinisterOnTable[i].MinisterThinking[0].IsSup.Clear();
                                    MinisterOnTable[i].MinisterThinking[0].IsSupHu.Clear();
                                    MinisterOnTable[i].MinisterThinking[0].IsThereCheckOfEnemy.Clear();
                                    MinisterOnTable[i].MinisterThinking[0].IsThereCheckOfSelf.Clear();
                                    MinisterOnTable[i].MinisterThinking[0].IsThereMateOfEnemy.Clear();
                                    MinisterOnTable[i].MinisterThinking[0].IsThereMateOfSelf.Clear();
                                    Object ooo = new Object();
                                    lock (ooo)
                                    {
                                        ////HarasAct = true; Act = true;
                                        for (int h = 0; h < jungle.MinisterOnTable[i].MinisterThinking[0].TableListMinister.Count; h++)
                                            Act = Act || BlitzNotValidFullGameThinkingTreePartFour(i, OrderP, 5, jungle.MinisterOnTable[i].MinisterThinking[0], h);

                                        for (int h = 0; h < jungle.MinisterOnTable[i].MinisterThinking[0].AStarGreedy.Count; h++)
                                        {
                                            MinisterOnTable[i].MinisterThinking[0].AStarGreedy.Add(jungle.MinisterOnTable[i].MinisterThinking[0].AStarGreedy[h]);
                                            MinisterOnTable[i].MinisterThinking[0].AStarGreedy[MinisterOnTable[i].MinisterThinking[0].AStarGreedy.Count - 1].AStarGreedyString = this;
                                        }
                                    }
                                    return Act;
                                }
                                else
                                    return Act;
                            }
                            else
                                return Act;

                        }
                        else
                            return Act;

                    }
                    else
                        return Act;
                }
                else
                    return Act;

            }




            return Act;
        }
        bool MergeJungleTreeKing(AllDraw jungle, int i, int j)
        {
            bool Act = false;
            Object oo = new Object();
            lock (oo)
            {



                if (KingOnTable != null)
                {
                    if (KingOnTable[i] != null)
                    {
                        if (KingOnTable[i].KingThinking != null)
                        {
                            if (KingOnTable[i].KingThinking[0] != null)
                            {
                                if (KingOnTable[i].KingThinking[0].AStarGreedy == null)
                                {
                                    if (KingOnTable[i].KingThinking[0].AStarGreedy == null)
                                        KingOnTable[i].KingThinking[0].AStarGreedy = new List<AllDraw>();
                                    KingOnTable[i].KingThinking[0].TableListKing.Clear();
                                    KingOnTable[i].KingThinking[0].HeuristicListKing.Clear();
                                    KingOnTable[i].KingThinking[0].RowColumnKing.Clear();
                                    KingOnTable[i].KingThinking[0].HitNumberKing.Clear();
                                    KingOnTable[i].KingThinking[0].PenaltyRegardListKing.Clear();
                                    KingOnTable[i].KingThinking[0].KishSelf.Clear();
                                    KingOnTable[i].KingThinking[0].KishEnemy.Clear();
                                    KingOnTable[i].KingThinking[0].LoseChiled.Clear();
                                    KingOnTable[i].KingThinking[0].WinChiled.Clear();
                                    KingOnTable[i].KingThinking[0].IsSup.Clear();
                                    KingOnTable[i].KingThinking[0].IsSupHu.Clear();
                                    KingOnTable[i].KingThinking[0].IsThereCheckOfEnemy.Clear();
                                    KingOnTable[i].KingThinking[0].IsThereCheckOfSelf.Clear();
                                    KingOnTable[i].KingThinking[0].IsThereMateOfEnemy.Clear();
                                    KingOnTable[i].KingThinking[0].IsThereMateOfSelf.Clear();
                                    Object ooo = new Object();
                                    lock (ooo)
                                    {
                                        ////HarasAct = true; Act = true;
                                        for (int h = 0; h < jungle.KingOnTable[i].KingThinking[0].TableListKing.Count; h++)
                                            Act = Act || BlitzNotValidFullGameThinkingTreePartFour(i, OrderP, 6, jungle.KingOnTable[i].KingThinking[0], h);

                                        for (int h = 0; h < jungle.KingOnTable[i].KingThinking[0].AStarGreedy.Count; h++)
                                        {
                                            KingOnTable[i].KingThinking[0].AStarGreedy.Add(jungle.KingOnTable[i].KingThinking[0].AStarGreedy[h]);
                                            KingOnTable[i].KingThinking[0].AStarGreedy[KingOnTable[i].KingThinking[0].AStarGreedy.Count - 1].AStarGreedyString = this;
                                        }
                                    }
                                    return Act;
                                }
                                else
                                    if (KingOnTable[i].KingThinking[0].AStarGreedy.Count < KingOnTable[i].KingThinking[0].AStarGreedy.Count)
                                {
                                    KingOnTable[i].KingThinking[0].AStarGreedy.Clear();
                                    KingOnTable[i].KingThinking[0].TableListKing.Clear();
                                    KingOnTable[i].KingThinking[0].HeuristicListKing.Clear();
                                    KingOnTable[i].KingThinking[0].RowColumnKing.Clear();
                                    KingOnTable[i].KingThinking[0].HitNumberKing.Clear();
                                    KingOnTable[i].KingThinking[0].PenaltyRegardListKing.Clear();
                                    KingOnTable[i].KingThinking[0].KishSelf.Clear();
                                    KingOnTable[i].KingThinking[0].KishEnemy.Clear();
                                    KingOnTable[i].KingThinking[0].LoseChiled.Clear();
                                    KingOnTable[i].KingThinking[0].WinChiled.Clear();
                                    KingOnTable[i].KingThinking[0].IsSup.Clear();
                                    KingOnTable[i].KingThinking[0].IsSupHu.Clear();
                                    KingOnTable[i].KingThinking[0].IsThereCheckOfEnemy.Clear();
                                    KingOnTable[i].KingThinking[0].IsThereCheckOfSelf.Clear();
                                    KingOnTable[i].KingThinking[0].IsThereMateOfEnemy.Clear();
                                    KingOnTable[i].KingThinking[0].IsThereMateOfSelf.Clear();
                                    Object ooo = new Object();
                                    lock (ooo)
                                    {
                                        ////HarasAct = true; Act = true;
                                        for (int h = 0; h < jungle.KingOnTable[i].KingThinking[0].TableListKing.Count; h++)
                                            Act = Act || BlitzNotValidFullGameThinkingTreePartFour(i, OrderP, 6, jungle.KingOnTable[i].KingThinking[0], h);


                                        for (int h = 0; h < jungle.KingOnTable[i].KingThinking[0].AStarGreedy.Count; h++)
                                        {
                                            KingOnTable[i].KingThinking[0].AStarGreedy.Add(jungle.KingOnTable[i].KingThinking[0].AStarGreedy[h]);
                                            KingOnTable[i].KingThinking[0].AStarGreedy[KingOnTable[i].KingThinking[0].AStarGreedy.Count - 1].AStarGreedyString = this;
                                        }
                                    }
                                    return Act;
                                }
                                else
                                    return Act;
                            }
                            else
                                return Act;

                        }
                        else
                            return Act;

                    }
                    else
                        return Act;
                }
                else
                    return Act;

            }




            return Act;
        }
        bool MergeJungleTreeCastling(AllDraw jungle, int i, int j)
        {
            bool Act = false;
            Object oo = new Object();
            lock (oo)
            {

                if (CastlingOnTable != null)
                {
                    if (CastlingOnTable[i] != null)
                    {
                        if (CastlingOnTable[i].CastlingThinking != null)
                        {
                            if (CastlingOnTable[i].CastlingThinking[0].AStarGreedy == null)
                            {
                                if (CastlingOnTable[i].CastlingThinking[0].AStarGreedy == null)
                                    CastlingOnTable[i].CastlingThinking[0].AStarGreedy = new List<AllDraw>();
                                CastlingOnTable[i].CastlingThinking[0].TableListCastling.Clear();
                                CastlingOnTable[i].CastlingThinking[0].HeuristicListCastling.Clear();
                                CastlingOnTable[i].CastlingThinking[0].RowColumnCastling.Clear();
                                CastlingOnTable[i].CastlingThinking[0].HitNumberCastling.Clear();
                                CastlingOnTable[i].CastlingThinking[0].PenaltyRegardListCastling.Clear();
                                CastlingOnTable[i].CastlingThinking[0].KishSelf.Clear();
                                CastlingOnTable[i].CastlingThinking[0].KishEnemy.Clear();
                                CastlingOnTable[i].CastlingThinking[0].LoseChiled.Clear();
                                CastlingOnTable[i].CastlingThinking[0].WinChiled.Clear();
                                CastlingOnTable[i].CastlingThinking[0].IsSup.Clear();
                                CastlingOnTable[i].CastlingThinking[0].IsSupHu.Clear();
                                CastlingOnTable[i].CastlingThinking[0].IsThereCheckOfEnemy.Clear();
                                CastlingOnTable[i].CastlingThinking[0].IsThereCheckOfSelf.Clear();
                                CastlingOnTable[i].CastlingThinking[0].IsThereMateOfEnemy.Clear();
                                CastlingOnTable[i].CastlingThinking[0].IsThereMateOfSelf.Clear();
                                Object ooo = new Object();
                                lock (ooo)
                                {
                                    ////HarasAct = true; Act = true;
                                    for (int h = 0; h < jungle.CastlingOnTable[i].CastlingThinking[0].TableListCastling.Count; h++)
                                        Act = Act || BlitzNotValidFullGameThinkingTreePartFour(i, OrderP, 7, jungle.CastlingOnTable[i].CastlingThinking[0], h);

                                    for (int h = 0; h < jungle.CastlingOnTable[i].CastlingThinking[0].AStarGreedy.Count; h++)
                                    {
                                        CastlingOnTable[i].CastlingThinking[0].AStarGreedy.Add(jungle.CastlingOnTable[i].CastlingThinking[0].AStarGreedy[h]);
                                        CastlingOnTable[i].CastlingThinking[0].AStarGreedy[CastlingOnTable[i].CastlingThinking[0].AStarGreedy.Count - 1].AStarGreedyString = this;
                                    }
                                }
                                return Act;
                            }
                            else
                                if (CastlingOnTable[i].CastlingThinking[0].AStarGreedy.Count < jungle.CastlingOnTable[i].CastlingThinking[0].AStarGreedy.Count)
                            {
                                CastlingOnTable[i].CastlingThinking[0].AStarGreedy.Clear();
                                CastlingOnTable[i].CastlingThinking[0].TableListCastling.Clear();
                                CastlingOnTable[i].CastlingThinking[0].HeuristicListCastling.Clear();
                                CastlingOnTable[i].CastlingThinking[0].RowColumnCastling.Clear();
                                CastlingOnTable[i].CastlingThinking[0].HitNumberCastling.Clear();
                                CastlingOnTable[i].CastlingThinking[0].PenaltyRegardListCastling.Clear();
                                CastlingOnTable[i].CastlingThinking[0].KishSelf.Clear();
                                CastlingOnTable[i].CastlingThinking[0].KishEnemy.Clear();
                                CastlingOnTable[i].CastlingThinking[0].LoseChiled.Clear();
                                CastlingOnTable[i].CastlingThinking[0].WinChiled.Clear();
                                CastlingOnTable[i].CastlingThinking[0].IsSup.Clear();
                                CastlingOnTable[i].CastlingThinking[0].IsSupHu.Clear();
                                CastlingOnTable[i].CastlingThinking[0].IsThereCheckOfEnemy.Clear();
                                CastlingOnTable[i].CastlingThinking[0].IsThereCheckOfSelf.Clear();
                                CastlingOnTable[i].CastlingThinking[0].IsThereMateOfEnemy.Clear();

                                Object ooo = new Object();
                                lock (ooo)
                                {
                                    ////HarasAct = true; Act = true;
                                    for (int h = 0; h < jungle.CastlingOnTable[i].CastlingThinking[0].TableListCastling.Count; h++)
                                        Act = Act || BlitzNotValidFullGameThinkingTreePartFour(i, OrderP, 7, jungle.CastlingOnTable[i].CastlingThinking[0], h);

                                    for (int h = 0; h < jungle.CastlingOnTable[i].CastlingThinking[0].AStarGreedy.Count; h++)
                                    {
                                        CastlingOnTable[i].CastlingThinking[0].AStarGreedy.Add(jungle.CastlingOnTable[i].CastlingThinking[0].AStarGreedy[h]);
                                        CastlingOnTable[i].CastlingThinking[0].AStarGreedy[CastlingOnTable[i].CastlingThinking[0].AStarGreedy.Count - 1].AStarGreedyString = this;
                                    }
                                }
                                return Act;
                            }
                            else
                                return Act;
                        }
                        else
                            return Act;
                    }
                    else
                        return Act;

                }
                else
                    return Act;
            }




            return Act;
        }
        public bool HarasAlphaBeta(int i, int j, int kindA)
        {
            bool Act = false;
            Object oo = new Object();
            lock (oo)
            {
                if (CurrentMaxLevel >= 2)
                {

                    if (kindA == 1)
                    {
                        if (SolderesOnTable != null)
                        {
                            if (SolderesOnTable[i] != null)
                            {
                                if (SolderesOnTable[i].SoldierThinking != null)
                                {
                                    if (SolderesOnTable[i].SoldierThinking[0] != null)
                                    {
                                        if (SolderesOnTable[i].SoldierThinking[0].AStarGreedy != null)
                                        {
                                            if (SolderesOnTable[i].SoldierThinking[0].AStarGreedy.Count > j)
                                            {
                                                if (SolderesOnTable[i].LoseOcuuredatChiled[0] < 0 || SolderesOnTable[i].SoldierThinking[0].LoseChiled[j] < 0)
                                                {
                                                    Object ooo = new Object();
                                                    lock (ooo)
                                                    {
                                                        HarasAct = true; Act = true;
                                                        SolderesOnTable[i].SoldierThinking[0].AStarGreedy[j].Dispose();
                                                    }
                                                }
                                            }
                                        }
                                        else
                                            return Act;
                                    }
                                    else
                                        return Act;

                                }
                                else
                                    return Act;

                            }
                            else
                                return Act;
                        }
                        else
                            return Act;

                    }
                    else
                    if (kindA == 2)
                    {
                        if (ElephantOnTable != null)
                        {
                            if (ElephantOnTable[i] != null)
                            {
                                if (ElephantOnTable[i].ElefantThinking != null)
                                {
                                    if (ElephantOnTable[i].ElefantThinking[0] != null)
                                    {
                                        if (ElephantOnTable[i].ElefantThinking[0].AStarGreedy != null)
                                        {
                                            if (ElephantOnTable[i].ElefantThinking[0].AStarGreedy.Count > j)
                                            {
                                                if (ElephantOnTable[i].LoseOcuuredatChiled[0] < 0 || ElephantOnTable[i].ElefantThinking[0].LoseChiled[j] < 0)
                                                {
                                                    Object ooo = new Object();
                                                    lock (ooo)
                                                    {
                                                        HarasAct = true; Act = true;
                                                        ElephantOnTable[i].ElefantThinking[0].AStarGreedy[j].Dispose();
                                                    }
                                                }
                                            }
                                        }
                                        else
                                            return Act;
                                    }
                                    else
                                        return Act;

                                }
                                else
                                    return Act;

                            }
                            else
                                return Act;
                        }
                        else
                            return Act;

                    }
                    else
                    if (kindA == 3)
                    {
                        if (HoursesOnTable != null)
                        {
                            if (HoursesOnTable[i] != null)
                            {
                                if (HoursesOnTable[i].HourseThinking != null)
                                {
                                    if (HoursesOnTable[i].HourseThinking[0] != null)
                                    {
                                        if (HoursesOnTable[i].HourseThinking[0].AStarGreedy != null)
                                        {
                                            if (HoursesOnTable[i].HourseThinking[0].AStarGreedy.Count > j)
                                            {
                                                if (HoursesOnTable[i].LoseOcuuredatChiled[0] < 0 || HoursesOnTable[i].HourseThinking[0].LoseChiled[j] < 0)
                                                {
                                                    Object ooo = new Object();
                                                    lock (ooo)
                                                    {
                                                        HarasAct = true; Act = true;
                                                        HoursesOnTable[i].HourseThinking[0].AStarGreedy[j].Dispose();
                                                    }
                                                }
                                            }
                                        }
                                        else
                                            return Act;
                                    }
                                    else
                                        return Act;

                                }
                                else
                                    return Act;

                            }
                            else
                                return Act;
                        }
                        else
                            return Act;


                    }
                    else
                         if (kindA == 4)
                    {

                        if (CastlesOnTable != null)
                        {
                            if (CastlesOnTable[i] != null)
                            {
                                if (CastlesOnTable[i].CastleThinking != null)
                                {
                                    if (CastlesOnTable[i].CastleThinking[0] != null)
                                    {
                                        if (CastlesOnTable[i].CastleThinking[0].AStarGreedy != null)
                                        {
                                            if (CastlesOnTable[i].CastleThinking[0].AStarGreedy.Count > j)
                                            {
                                                if (CastlesOnTable[i].LoseOcuuredatChiled[0] < 0 || CastlesOnTable[i].CastleThinking[0].LoseChiled[j] < 0)
                                                {
                                                    Object ooo = new Object();
                                                    lock (ooo)
                                                    {
                                                        HarasAct = true; Act = true;
                                                        CastlesOnTable[i].CastleThinking[0].AStarGreedy[j].Dispose();
                                                    }
                                                }
                                            }
                                        }
                                        else
                                            return Act;
                                    }
                                    else
                                        return Act;

                                }
                                else
                                    return Act;

                            }
                            else
                                return Act;
                        }
                        else
                            return Act;

                    }
                    else
                    if (kindA == 5)
                    {

                        if (MinisterOnTable != null)
                        {
                            if (MinisterOnTable[i] != null)
                            {
                                if (MinisterOnTable[i].MinisterThinking != null)
                                {
                                    if (MinisterOnTable[i].MinisterThinking[0] != null)
                                    {
                                        if (MinisterOnTable[i].MinisterThinking[0].AStarGreedy != null)
                                        {
                                            if (MinisterOnTable[i].MinisterThinking[0].AStarGreedy.Count > j)
                                            {
                                                if (MinisterOnTable[i].LoseOcuuredatChiled[0] < 0 || MinisterOnTable[i].MinisterThinking[0].LoseChiled[j] < 0)
                                                {
                                                    Object ooo = new Object();
                                                    lock (ooo)
                                                    {
                                                        HarasAct = true; Act = true;
                                                        MinisterOnTable[i].MinisterThinking[0].AStarGreedy[j].Dispose();
                                                    }
                                                }
                                            }
                                        }
                                        else
                                            return Act;
                                    }
                                    else
                                        return Act;

                                }
                                else
                                    return Act;

                            }
                            else
                                return Act;
                        }
                        else
                            return Act;

                    }
                    else
                    if (kindA == 6)
                    {

                        if (KingOnTable != null)
                        {
                            if (KingOnTable[i] != null)
                            {
                                if (KingOnTable[i].KingThinking != null)
                                {
                                    if (KingOnTable[i].KingThinking[0] != null)
                                    {
                                        if (KingOnTable[i].KingThinking[0].AStarGreedy != null)
                                        {
                                            if (KingOnTable[i].KingThinking[0].AStarGreedy.Count > j)
                                            {
                                                if (KingOnTable[i].LoseOcuuredatChiled[0] < 0 || KingOnTable[i].KingThinking[0].LoseChiled[j] < 0)
                                                {
                                                    Object ooo = new Object();
                                                    lock (ooo)
                                                    {
                                                        HarasAct = true; Act = true;
                                                        KingOnTable[i].KingThinking[0].AStarGreedy[j].Dispose();
                                                    }
                                                }
                                            }
                                        }
                                        else
                                            return Act;
                                    }
                                    else
                                        return Act;

                                }
                                else
                                    return Act;

                            }
                            else
                                return Act;
                        }
                        else
                            return Act;

                    }
                    else
                    if (kindA == 7 || kindA == -7)
                    {

                        if (CastlingOnTable != null)
                        {
                            if (CastlingOnTable[i] != null)
                            {
                                if (CastlingOnTable[i].CastlingThinking != null)
                                {
                                    if (CastlingOnTable[i].CastlingThinking[0] != null)
                                    {
                                        if (CastlingOnTable[i].CastlingThinking[0].AStarGreedy != null)
                                        {
                                            if (CastlingOnTable[i].CastlingThinking[0].AStarGreedy.Count > j)
                                            {
                                                if (CastlingOnTable[i].LoseOcuuredatChiled[0] < 0 || CastlingOnTable[i].CastlingThinking[0].LoseChiled[j] < 0)
                                                {
                                                    Object ooo = new Object();
                                                    lock (ooo)
                                                    {
                                                        HarasAct = true; Act = true;
                                                        CastlingOnTable[i].CastlingThinking[0].AStarGreedy[j].Dispose();
                                                    }
                                                }
                                            }
                                        }
                                        else
                                            return Act;
                                    }
                                    else
                                        return Act;

                                }
                                else
                                    return Act;

                            }
                            else
                                return Act;
                        }
                        else
                            return Act;

                    }

                }
            }
            var output = Task.Factory.StartNew(() =>
            {
                ParallelOptions po = new ParallelOptions(); po.MaxDegreeOfParallelism = System.Threading.PlatformHelper.ProcessorCount; Parallel.Invoke(() =>
                 {
                     Object o = new Object();
                     lock (o)
                     {

                         ParallelOptions poo = new ParallelOptions(); poo.MaxDegreeOfParallelism = System.Threading.PlatformHelper.ProcessorCount; Parallel.For(0, SodierHigh, p =>
                         {
                             if (SolderesOnTable != null)
                             {
                                 if (SolderesOnTable[p] != null)
                                 {

                                     if (SolderesOnTable[p].SoldierThinking != null)
                                     {
                                         if (SolderesOnTable[p].SoldierThinking[0] != null)
                                         {

                                             if (SolderesOnTable[p].SoldierThinking[0].AStarGreedy != null)
                                             {
                                                 for (int k = 0; k < SolderesOnTable[p].SoldierThinking[0].AStarGreedy.Count; k++)
                                                 {
                                                     var outputH = Task.Factory.StartNew(() => Act = Act || SolderesOnTable[p].SoldierThinking[0].AStarGreedy[k].HarasAlphaBeta(p, k, 1));
                                                     outputH.Wait();
                                                     outputH.Dispose();
                                                 }


                                             }
                                             else
                                                 return;
                                         }
                                         else
                                             return;

                                     }
                                     else
                                         return;

                                 }
                                 else
                                     return;

                             }
                             else
                                 return;



                         });
                     }
                 },
                 () =>
                 {

                     Object o = new Object();
                     lock (o)
                     {
                         ParallelOptions poo = new ParallelOptions(); poo.MaxDegreeOfParallelism = System.Threading.PlatformHelper.ProcessorCount; Parallel.For(0, ElefantHigh, p =>
                         {
                             if (ElephantOnTable != null)
                             {
                                 if (ElephantOnTable[p] != null)
                                 {

                                     if (ElephantOnTable[p].ElefantThinking != null)
                                     {
                                         if (ElephantOnTable[p].ElefantThinking[0] != null)
                                         {

                                             if (ElephantOnTable[p].ElefantThinking[0].AStarGreedy != null)
                                             {
                                                 for (int k = 0; k < ElephantOnTable[p].ElefantThinking[0].AStarGreedy.Count; k++)
                                                 {
                                                     var outputH = Task.Factory.StartNew(() => Act = Act || ElephantOnTable[p].ElefantThinking[0].AStarGreedy[k].HarasAlphaBeta(p, k, 2));
                                                     outputH.Wait();
                                                     outputH.Dispose();

                                                 }


                                             }
                                             else
                                                 return;

                                         }
                                         else
                                             return;

                                     }
                                     else
                                         return;

                                 }
                                 else
                                     return;

                             }
                             else
                                 return;



                         });
                     }
                 },
                 () =>
                 {
                     Object o = new Object();
                     lock (o)
                     {
                         ParallelOptions poo = new ParallelOptions(); poo.MaxDegreeOfParallelism = System.Threading.PlatformHelper.ProcessorCount; Parallel.For(0, HourseHight, p =>
                         {

                             if (HoursesOnTable != null)
                             {
                                 if (HoursesOnTable[p] != null)
                                 {

                                     if (HoursesOnTable[p].HourseThinking != null)
                                     {
                                         if (HoursesOnTable[p].HourseThinking[0] != null)
                                         {

                                             if (HoursesOnTable[p].HourseThinking[0].AStarGreedy != null)
                                             {
                                                 for (int k = 0; k < HoursesOnTable[p].HourseThinking[0].AStarGreedy.Count; k++)
                                                 {
                                                     var outputH = Task.Factory.StartNew(() => Act = Act || HoursesOnTable[p].HourseThinking[0].AStarGreedy[k].HarasAlphaBeta(p, k, 3));
                                                     outputH.Wait();
                                                     outputH.Dispose();

                                                 }


                                             }
                                             else
                                                 return;

                                         }
                                         else
                                             return;

                                     }
                                     else
                                         return;

                                 }
                                 else
                                     return;

                             }
                             else
                                 return;


                         });
                     }
                 }, () =>
                 {
                     Object o = new Object();
                     lock (o)
                     {
                         ParallelOptions poo = new ParallelOptions(); poo.MaxDegreeOfParallelism = System.Threading.PlatformHelper.ProcessorCount; Parallel.For(0, CastleHigh, p =>
                         {

                             if (CastlesOnTable != null)
                             {
                                 if (CastlesOnTable[p] != null)
                                 {

                                     if (CastlesOnTable[p].CastleThinking != null)
                                     {
                                         if (CastlesOnTable[p].CastleThinking[0] != null)
                                         {

                                             if (CastlesOnTable[p].CastleThinking[0].AStarGreedy != null)
                                             {
                                                 for (int k = 0; k < CastlesOnTable[p].CastleThinking[0].AStarGreedy.Count; k++)
                                                 {
                                                     var outputH = Task.Factory.StartNew(() => Act = Act || CastlesOnTable[p].CastleThinking[0].AStarGreedy[k].HarasAlphaBeta(p, k, 4));
                                                     outputH.Wait();
                                                     outputH.Dispose();

                                                 }


                                             }
                                             else
                                                 return;

                                         }
                                         else
                                             return;

                                     }
                                     else
                                         return;

                                 }
                                 else
                                     return;

                             }
                             else
                                 return;



                         });
                     }
                 },
                 () =>
                 {
                     Object o = new Object();
                     lock (o)
                     {
                         ParallelOptions poo = new ParallelOptions(); poo.MaxDegreeOfParallelism = System.Threading.PlatformHelper.ProcessorCount; Parallel.For(0, MinisterHigh, p =>
                         {

                             if (MinisterOnTable != null)
                             {
                                 if (MinisterOnTable[p] != null)
                                 {

                                     if (MinisterOnTable[p].MinisterThinking != null)
                                     {
                                         if (MinisterOnTable[p].MinisterThinking[0] != null)
                                         {

                                             if (MinisterOnTable[p].MinisterThinking[0].AStarGreedy != null)
                                             {
                                                 for (int k = 0; k < MinisterOnTable[p].MinisterThinking[0].AStarGreedy.Count; k++)
                                                 {
                                                     var outputH = Task.Factory.StartNew(() => Act = Act || MinisterOnTable[p].MinisterThinking[0].AStarGreedy[k].HarasAlphaBeta(p, k, 5));
                                                     outputH.Wait();
                                                     outputH.Dispose();

                                                 }


                                             }
                                             else
                                                 return;

                                         }
                                         else
                                             return;

                                     }
                                     else
                                         return;

                                 }
                                 else
                                     return;

                             }
                             else
                                 return;



                         });
                     }
                 }, () =>
                 {
                     Object o = new Object();
                     lock (o)
                     {
                         ParallelOptions poo = new ParallelOptions(); poo.MaxDegreeOfParallelism = System.Threading.PlatformHelper.ProcessorCount; Parallel.For(0, KingHigh, p =>
                         {
                             if (KingOnTable != null)
                             {
                                 if (KingOnTable[p] != null)
                                 {

                                     if (KingOnTable[p].KingThinking != null)
                                     {
                                         if (KingOnTable[p].KingThinking[0] != null)
                                         {

                                             if (KingOnTable[p].KingThinking[0].AStarGreedy != null)
                                             {
                                                 for (int k = 0; k < KingOnTable[p].KingThinking[0].AStarGreedy.Count; k++)
                                                 {
                                                     var outputH = Task.Factory.StartNew(() => Act = Act || KingOnTable[p].KingThinking[0].AStarGreedy[k].HarasAlphaBeta(p, k, 6));
                                                     outputH.Wait();
                                                     outputH.Dispose();

                                                 }


                                             }
                                             else
                                                 return;

                                         }
                                         else
                                             return;

                                     }
                                     else
                                         return;

                                 }
                                 else
                                     return;

                             }
                             else
                                 return;



                         });
                     }
                 },
                 () =>
                 {
                     Object o = new Object();
                     lock (o)
                     {
                         ParallelOptions poo = new ParallelOptions(); poo.MaxDegreeOfParallelism = System.Threading.PlatformHelper.ProcessorCount; Parallel.For(0, 1, p =>
                         {
                             if (CastlingOnTable != null)
                             {
                                 if (CastlingOnTable[p] != null)
                                 {

                                     if (CastlingOnTable[p].CastlingThinking != null)
                                     {
                                         if (CastlingOnTable[p].CastlingThinking[0] != null)
                                         {

                                             if (CastlingOnTable[p].CastlingThinking[0].AStarGreedy != null)
                                             {
                                                 for (int k = 0; k < CastlingOnTable[p].CastlingThinking[0].AStarGreedy.Count; k++)
                                                 {
                                                     var outputH = Task.Factory.StartNew(() => Act = Act || CastlingOnTable[p].CastlingThinking[0].AStarGreedy[k].HarasAlphaBeta(p, k, 7));
                                                     outputH.Wait();
                                                     outputH.Dispose();

                                                 }


                                             }
                                             else
                                                 return;

                                         }
                                         else
                                             return;

                                     }
                                     else
                                         return;

                                 }
                                 else
                                     return;

                             }
                             else
                                 return;


                         });
                     }
                 });
            });
            output.Wait();
            output.Dispose();
            return Act;
        }
        //computational initiation
        public AllDraw InitiateAStarGreedyt(int iAStarGreedy, int ii, int jj, Color a, int[,] Tab, int Order, bool TB, bool FOUND, int LeafAStarGreedy//, ref Refrigtz.Timer timer, ref Refrigtz.Timer Timerint, ref int Less
            )
        {
            if (iAStarGreedy <= 0)
                return this;
            ThinkingRunInBothSide = true;
            OrderP = Order;
            SetObjectNumbers(Tab);
            int[,] Table = new int[8, 8];
            for (var iii = 0; iii < 8; iii++)
                for (var jjj = 0; jjj < 8; jjj++)
                    Table[iii, jjj] = Tab[iii, jjj];
            Object oo = new Object();
            lock (oo)
            {
                ThinkingRefrigtzChessPortable.BeginThread = 0;
                ThinkingRefrigtzChessPortable.EndThread = 0;
            }
            //Initiate of global Variables Byte Local Variables.
            int DummyOrder = new int();
            DummyOrder = Order;
            int DummyCurrentOrder = new int();
            DummyCurrentOrder = ChessRules.CurrentOrder;
            //#pragma warning disable CS0219 // The variable 'i' is assigned but its value is never used
#pragma warning disable CS0219 // The variable 'i' is assigned but its value is never used
            int i = 0, ik = 0;
#pragma warning restore CS0219 // The variable 'i' is assigned but its value is never used
            //#pragma warning restore CS0219 // The variable 'i' is assigned but its value is never used
            int[,] TablInit = new int[8, 8];
            if (Order == 1)
                a = Color.Gray;
            else
                a = Color.Brown;
            var j = 0;
            //Fairness conditions for perposive astar greedy search.
            Object Omm = new Object();
            lock (Omm)
            {
                Object OOOO = new Object();
                lock (OOOO)
                {

                    //when search finished stop and return
                    if (FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy))
                        return null;
                    if (LeafSemaphoreIndex)
                        LeafAStarGreedy++;

                }
                CurrentAStarGredyMax = AStarGreedyiLevelMax - iAStarGreedy;
            }
            bool Do = false;
            if (iAStarGreedy >= 0 && iAStarGreedy < MaxDuringLevelThinkingCreation)
            {
                MaxDuringLevelThinkingCreation = iAStarGreedy;
                Object O = new Object();
                DepthIterative++;
                lock (O)
                {
                }
            }

            if (tH == null)
                tH = new List<Task>();

            if (!FOUND)
            {
                //Initiate Of Local Variables.
                Object o = new Object();
                lock (o)
                {

                    var array1 = Task.Factory.StartNew(() => InitiateAStarGreedytCreationThinking(PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ii, jj, a, CloneATable(Tab), Order, TB, FOUND, LeafAStarGreedy));

                    array1.Wait();
                    array1.Dispose();

                }

            }
            Order = DummyOrder;
            ChessRules.CurrentOrder = DummyCurrentOrder;
            var array = Task.Factory.StartNew(() => Serve(Order));
            array.Wait();
            array.Dispose();


            if (FOUND)
            {
                Object O = new Object();
                lock (O)
                {
                    FOUND = false;
                    RefrigtzChessPortable.AllDraw Leaf = null;
                    Tabl = CloneATable(Table);
                    int LeafDeep = 0;// MaxAStarGreedy;
                    var array1 = Task.Factory.StartNew(() => FoundOfLeafDepenOfKind(ref Leaf, ref FOUND, Order, LeafDeep, 0, 0, 0, 0));

                    array1.Wait();
                    array1.Dispose();
                    var array11 = Task.Factory.StartNew(() => FullGameThinkingTreeWin(Order));
                    array11.Wait();
                    array11.Dispose();
                    array11 = Task.Factory.StartNew(() => FullGameThinkingTreeLose(Order));
                    array11.Wait();
                    array11.Dispose();
                }
            }
            else
            {
                if (!Deeperthandeeper || ThinkingRefrigtzChessPortable.FullGameAllow)
                {
                    Object O = new Object();
                    lock (O)
                    {
                        NumberOfnewMove = 0;
                        Order = DummyOrder;
                        ChessRules.CurrentOrder = DummyCurrentOrder;
                        int Ord = Order, iAStarGreedy1 = iAStarGreedy, ii1 = ii, jj1 = jj, ik1 = ik, j1 = j;

                        var array1 = Task.Factory.StartNew(() => Do = this.FullGameThinkingTree(Ord, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ii1, jj1, ik1, j1, false, LeafAStarGreedy));


                        array1.Wait();
                        array1.Dispose();
                        if (NumberOfnewMove == 0)
                        {
                            UsedRestrictedMoveBlitzAndFull = false;
                            array1 = Task.Factory.StartNew(() => Do = this.FullGameThinkingTree(Ord, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ii1, jj1, ik1, j1, false, LeafAStarGreedy));
                            array1.Wait();
                            array1.Dispose();
                        }
                        var array11 = Task.Factory.StartNew(() => FullGameThinkingTreeWin(Order));
                        array11.Wait();
                        array11.Dispose();
                        array11 = Task.Factory.StartNew(() => FullGameThinkingTreeLose(Order));
                        array11.Wait();
                        array11.Dispose();

                    }
                }
            }
            Object Om = new Object();
            lock (Om)
            {
                if (!Do)
                    if (iAStarGreedy < MinThinkingTreeDepth)
                        MinThinkingTreeDepth = iAStarGreedy;
            }
            tH.Clear();


            return this;
        }
        //computational second object
        /*     public AllDraw InitiateAStarGreedytObject(int iAStarGreedy, int ii, int jj, Color a, int[,] Tab, int Order, bool TB, bool FOUND, int LeafAStarGreedy//, ref Refrigtz.Timer timer, ref Refrigtz.Timer Timerint, ref int Less
                 )
             {

                 bool Do = false;
                 {
                     OrderP = Order;
                     SetObjectNumbers(Tab);
                     int[,] Table = new int[8, 8];
                     for (var iii = 0; iii < 8; iii++)
                         for (var jjj = 0; jjj < 8; jjj++)
                             Table[iii, jjj] = Tab[iii, jjj];
                     Object oo = new Object();
                     lock (oo)
                     {
                         ThinkingRefrigtzChessPortable.BeginThread = 0;
                         ThinkingRefrigtzChessPortable.EndThread = 0;
                     }
                     //Initiate of global Variables Byte Local Variables.
                     int DummyOrder = new int();
                     DummyOrder = Order;
                     int DummyCurrentOrder = new int();
                     DummyCurrentOrder = ChessRules.CurrentOrder;
                     List<Task> ThB = new List<Task>();
                     int i = 0, ik = 0;
                     int[,] TablInit = new int[8, 8];
                     if (Order == 1)
                         a = Color.Gray;
                     else
                         a = Color.Brown;
                     var j = 0;
                     //if (iAStarGreedy>=0)

                     Object OOOO = new Object();
                     lock (OOOO)
                     {
                         //if (iAStarGreedy <= 0)
                         {
                             //when search finished stop and return
                             if (FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy))
                                 return null;

                         }
                     }
                     CurrentAStarGredyMax = AStarGreedyiLevelMax - iAStarGreedy;

                     if (iAStarGreedy >= 0 && iAStarGreedy < MaxDuringLevelThinkingCreation)
                     {
                         MaxDuringLevelThinkingCreation = iAStarGreedy;
                         Object O = new Object();
                         DepthIterative++;
                         lock (O)
                         {

                         }

                     }


                     if (!FOUND)
                     {
                         Object o = new Object();
                         lock (o)
                         {
                             if (Order == 1)
                                 this.InitiateAStarGreedytObjectGray(i, j, CloneATable(Table), DummyOrder, DummyCurrentOrder, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ii, jj, a, CloneATable(Tab), Order, TB, FOUND, LeafAStarGreedy);
                             else
                                 this.InitiateAStarGreedytObjectBrown(i, j, CloneATable(Table), DummyOrder, DummyCurrentOrder, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ii, jj, a, CloneATable(Tab), Order, TB, FOUND, LeafAStarGreedy);
                         }
                     }
                     if (FOUND)
                     {
                         Object O = new Object();
                         lock (O)
                         {
                             Tabl = CloneATable(Table);
                             FoundOfLeafDepenOfKindFullGame(Tabl, Order, iAStarGreedy - 1, ii, jj, ik, j, FOUND, LeafAStarGreedy);
                         }
                     }
                     else
                     {
                         Object O = new Object();
                         lock (O)
                         {
                             Order = DummyOrder;
                             ChessRules.CurrentOrder = DummyCurrentOrder;
                             int Ord = Order, iAStarGreedy1 = iAStarGreedy - 1, ii1 = ii, jj1 = jj, ik1 = ik, j1 = j;

                             //ParallelOptions po = new ParallelOptions();       po.MaxDegreeOfParallelism =PlatformHelper.ProcessorCount;                    Parallel.Invoke(() =>
                             {
                                 Do |= this.FullGameThinkingTree((Ord, , PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ii1, jj1, ik1, j1, false, LeafAStarGreedy);
                             }
                         }
                     }
                     Object Om = new Object();
                     lock (Om)
                     {
                         if (!Do)
                             if (iAStarGreedy < MinThinkingTreeDepth)
                                 MinThinkingTreeDepth = iAStarGreedy;
                     }

                     return this;
                 }
             }
       */      //determistic of checked blitz game
        bool KingDan(int[,] Tab, int Order)
        {

            bool IsDang = false;
            RefrigtzChessPortable.ChessRules A = new RefrigtzChessPortable.ChessRules(0, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged, Order);
            IsDang = A.ObjectDangourKingMove(Order, Tab);
            if (Order == 1 && (IsDang))
            {
                if (A.CheckBrownObjectDangour && ((!A.CheckGrayObjectDangour)))
                    IsDang = false;
            }
            if (Order == -1 && (IsDang))
            {
                if (A.CheckGrayObjectDangour && ((!A.CheckBrownObjectDangour)))
                    IsDang = false;
            }

            return IsDang;
        }
        //always by calling empty deeper
        void ClearAStarGreadyWhenListsAreEmpy(int Kind, int i)
        {
            //soldier
            if (Kind == 1 && SolderesOnTable[i].SoldierThinking[0].AStarGreedy != null && SolderesOnTable[i].SoldierThinking[0].AStarGreedy.Count > 0)
                SolderesOnTable[i].SoldierThinking[0].AStarGreedy.Clear();
            else//elephant
if (Kind == 2 && ElephantOnTable[i].ElefantThinking[0].AStarGreedy != null && ElephantOnTable[i].ElefantThinking[0].AStarGreedy.Count > 0)
                ElephantOnTable[i].ElefantThinking[0].AStarGreedy.Clear();
            else//hourse
                if (Kind == 3 && HoursesOnTable[i].HourseThinking[0].AStarGreedy != null && HoursesOnTable[i].HourseThinking[0].AStarGreedy.Count > 0)
                HoursesOnTable[i].HourseThinking[0].AStarGreedy.Clear();
            else//Castle
                if (Kind == 4 && CastlesOnTable[i].CastleThinking[0].AStarGreedy != null && CastlesOnTable[i].CastleThinking[0].AStarGreedy.Count > 0)
                CastlesOnTable[i].CastleThinking[0].AStarGreedy.Clear();
            else//minister
                if (Kind == 5 && MinisterOnTable[i].MinisterThinking[0].AStarGreedy != null && MinisterOnTable[i].MinisterThinking[0].AStarGreedy.Count > 0)
                MinisterOnTable[i].MinisterThinking[0].AStarGreedy.Clear();
            else//king
                if (Kind == 6 && KingOnTable[i].KingThinking[0].AStarGreedy != null && KingOnTable[i].KingThinking[0].AStarGreedy.Count > 0)
                KingOnTable[i].KingThinking[0].AStarGreedy.Clear();
            else//king
                if ((Kind == 7 || Kind == -7) && CastlingOnTable[i].CastlingThinking[0].AStarGreedy != null && CastlingOnTable[i].CastlingThinking[0].AStarGreedy.Count > 0)
                CastlingOnTable[i].CastlingThinking[0].AStarGreedy.Clear();
        }
        //deterministic of calculated computational deeper
        bool IsThereCalculatedAStarGreedyNode()
        {
            bool Is = false;
            //soldier
            for (int i = 0; i < SodierHigh; i++)
            {
                if (SolderesOnTable != null && SolderesOnTable[i] != null && SolderesOnTable[i].SoldierThinking != null && SolderesOnTable[i].SoldierThinking[0] != null && SolderesOnTable[i].SoldierThinking[0].TableListSolder != null)
                {
                    if (SolderesOnTable[i].SoldierThinking[0].TableListSolder.Count > 0)
                    {
                        Is = true;
                        break;
                    }
                    else
                        ClearAStarGreadyWhenListsAreEmpy(1, i);
                }
            }
            if (!Is)
            {
                //elephant
                for (int i = 0; i < ElefantHigh; i++)
                {
                    if (ElephantOnTable != null && ElephantOnTable[i] != null && ElephantOnTable[i].ElefantThinking != null && ElephantOnTable[i].ElefantThinking[0] != null && ElephantOnTable[i].ElefantThinking[0].TableListElefant != null)
                    {
                        if (ElephantOnTable[i].ElefantThinking[0].TableListElefant.Count > 0)
                        {
                            Is = true;
                            break;
                        }
                        else
                            ClearAStarGreadyWhenListsAreEmpy(2, i);
                    }
                }
            }
            if (!Is)
            {
                //hourse
                for (int i = 0; i < HourseHight; i++)
                {
                    if (HoursesOnTable != null && HoursesOnTable[i] != null && HoursesOnTable[i].HourseThinking != null && HoursesOnTable[i].HourseThinking[0] != null && HoursesOnTable[i].HourseThinking[0].TableListHourse != null)
                    {
                        if (HoursesOnTable[i].HourseThinking[0].TableListHourse.Count > 0)
                        {
                            Is = true;
                            break;
                        }
                        else
                            ClearAStarGreadyWhenListsAreEmpy(3, i);
                    }
                }
            }
            if (!Is)
            {
                //Castle
                for (int i = 0; i < CastleHigh; i++)
                {
                    if (CastlesOnTable != null && CastlesOnTable[i] != null && CastlesOnTable[i].CastleThinking != null && CastlesOnTable[i].CastleThinking[0] != null && CastlesOnTable[i].CastleThinking[0].TableListCastle != null)
                    {
                        if (CastlesOnTable[i].CastleThinking[0].TableListCastle.Count > 0)
                        {
                            Is = true;
                            break;
                        }
                        else
                            ClearAStarGreadyWhenListsAreEmpy(4, i);
                    }
                }
            }
            if (!Is)
            {
                //minister
                for (int i = 0; i < MinisterHigh; i++)
                {
                    if (MinisterOnTable != null && MinisterOnTable[i] != null && MinisterOnTable[i].MinisterThinking != null && MinisterOnTable[i].MinisterThinking[0] != null && MinisterOnTable[i].MinisterThinking[0].TableListMinister != null)
                    {
                        if (MinisterOnTable[i].MinisterThinking[0].TableListMinister.Count > 0)
                        {
                            Is = true;
                            break;
                        }
                        else
                            ClearAStarGreadyWhenListsAreEmpy(5, i);

                    }
                }
            }
            if (!Is)
            {
                //king
                for (int i = 0; i < KingHigh; i++)
                {
                    if (KingOnTable != null && KingOnTable[i] != null && KingOnTable[i].KingThinking != null && KingOnTable[i].KingThinking[0] != null && KingOnTable[i].KingThinking[0].TableListKing != null)
                    {
                        if (KingOnTable[i].KingThinking[0].TableListKing.Count > 0)
                        {
                            Is = true;
                            break;
                        }
                        else
                            ClearAStarGreadyWhenListsAreEmpy(6, i);

                    }
                }
            }
            if (!Is)
            {
                //king
                for (int i = 0; i < 1; i++)
                {
                    if (CastlingOnTable != null && CastlingOnTable[i] != null && CastlingOnTable[i].CastlingThinking != null && CastlingOnTable[i].CastlingThinking[0] != null && CastlingOnTable[i].CastlingThinking[0].TableListCastling != null)
                    {
                        if (CastlingOnTable[i].CastlingThinking[0].TableListCastling.Count > 0)
                        {
                            Is = true;
                            break;
                        }
                        else
                            ClearAStarGreadyWhenListsAreEmpy(7, i);

                    }
                }
            }
            return Is;
        }
        //when there is index notified deeper computational node
        bool IsThereCalculatedAStarGreedyNode(int i, int Kind)
        {
            bool Is = false;
            //soldier
            if (Kind == 1)
            {
                if (SolderesOnTable != null && SolderesOnTable[i] != null && SolderesOnTable[i].SoldierThinking != null && SolderesOnTable[i].SoldierThinking[0] != null && SolderesOnTable[i].SoldierThinking[0].TableListSolder != null)
                {
                    if (SolderesOnTable[i].SoldierThinking[0].TableListSolder.Count > 0)
                    {
                        Is = true;
                    }
                    else
                        ClearAStarGreadyWhenListsAreEmpy(1, i);

                }
            }
            else
            if (Kind == 2)
            {
                //elephant
                if (ElephantOnTable != null && ElephantOnTable[i] != null && ElephantOnTable[i].ElefantThinking != null && ElephantOnTable[i].ElefantThinking[0] != null && ElephantOnTable[i].ElefantThinking[0].TableListElefant != null)
                {
                    if (ElephantOnTable[i].ElefantThinking[0].TableListElefant.Count > 0)
                    {
                        Is = true;
                    }
                    else
                        ClearAStarGreadyWhenListsAreEmpy(2, i);
                }
            }
            else
            if (Kind == 3)
            {
                //hourse
                if (HoursesOnTable != null && HoursesOnTable[i] != null && HoursesOnTable[i].HourseThinking != null && HoursesOnTable[i].HourseThinking[0] != null && HoursesOnTable[i].HourseThinking[0].TableListHourse != null)
                {
                    if (HoursesOnTable[i].HourseThinking[0].TableListHourse.Count > 0)
                    {
                        Is = true;
                    }
                    else
                        ClearAStarGreadyWhenListsAreEmpy(3, i);

                }
            }
            else
            if (Kind == 4)
            {
                //Castle
                if (CastlesOnTable != null && CastlesOnTable[i] != null && CastlesOnTable[i].CastleThinking != null && CastlesOnTable[i].CastleThinking[0] != null && CastlesOnTable[i].CastleThinking[0].TableListCastle != null)
                {
                    if (CastlesOnTable[i].CastleThinking[0].TableListCastle.Count > 0)
                    {
                        Is = true;
                    }
                    else
                        ClearAStarGreadyWhenListsAreEmpy(4, i);

                }
            }
            else
            if (Kind == 5)
            {
                //minister
                if (MinisterOnTable != null && MinisterOnTable[i] != null && MinisterOnTable[i].MinisterThinking != null && MinisterOnTable[i].MinisterThinking[0] != null && MinisterOnTable[i].MinisterThinking[0].TableListMinister != null)
                {
                    if (MinisterOnTable[i].MinisterThinking[0].TableListMinister.Count > 0)
                    {
                        Is = true;
                    }
                    else
                        ClearAStarGreadyWhenListsAreEmpy(5, i);

                }
            }
            else
            if (Kind == 6)
            {
                //king
                if (KingOnTable != null && KingOnTable[i] != null && KingOnTable[i].KingThinking != null && KingOnTable[i].KingThinking[0] != null && KingOnTable[i].KingThinking[0].TableListKing != null)
                {
                    if (KingOnTable[i].KingThinking[0].TableListKing.Count > 0)
                    {
                        Is = true;
                    }
                    else
                        ClearAStarGreadyWhenListsAreEmpy(6, i);

                }
            }
            else
            if (Kind == 7 || Kind == -7)
                if (CastlingOnTable != null && CastlingOnTable[i] != null && CastlingOnTable[i].CastlingThinking != null && CastlingOnTable[i].CastlingThinking[0] != null && CastlingOnTable[i].CastlingThinking[0].TableListCastling != null)
                {
                    if (CastlingOnTable[i].CastlingThinking[0].TableListCastling.Count > 0)
                    {
                        Is = true;
                    }
                    else
                        ClearAStarGreadyWhenListsAreEmpy(7, i);

                }
            return Is;
        }
        //when there is all deeper computational nodes return true else return false
        bool IsThereNotAllOfEmptyOrNonCalculatedAStarGreedyNode(int Order, int Kind, int i)
        {
            bool Is = true;
            //soldier
            if (Kind == 1)
            {
                if (SolderesOnTable != null && SolderesOnTable[i] != null && SolderesOnTable[i].SoldierThinking != null && SolderesOnTable[i].SoldierThinking[0] != null && SolderesOnTable[i].SoldierThinking[0].AStarGreedy != null)
                {
                    for (int j = 0; j < SolderesOnTable[i].SoldierThinking[0].AStarGreedy.Count; j++)
                        Is = Is && SolderesOnTable[i].SoldierThinking[0].AStarGreedy[j].IsThereCalculatedAStarGreedyNode();
                }
            }
            else//elephant
                if (Kind == 2)
            {
                if (ElephantOnTable != null && ElephantOnTable[i] != null && ElephantOnTable[i].ElefantThinking != null && ElephantOnTable[i].ElefantThinking[0] != null && ElephantOnTable[i].ElefantThinking[0].AStarGreedy != null)
                {
                    for (int j = 0; j < ElephantOnTable[i].ElefantThinking[0].AStarGreedy.Count; j++)
                        Is = Is && ElephantOnTable[i].ElefantThinking[0].AStarGreedy[j].IsThereCalculatedAStarGreedyNode();
                }
            }
            else//hourse
                if (Kind == 3)
            {
                if (HoursesOnTable != null && HoursesOnTable[i] != null && HoursesOnTable[i].HourseThinking != null && HoursesOnTable[i].HourseThinking[0] != null && HoursesOnTable[i].HourseThinking[0].AStarGreedy != null)
                {
                    for (int j = 0; j < HoursesOnTable[i].HourseThinking[0].AStarGreedy.Count; j++)
                        Is = Is && HoursesOnTable[i].HourseThinking[0].AStarGreedy[j].IsThereCalculatedAStarGreedyNode();
                }
            }
            else//Castle
                if (Kind == 4)
            {
                if (CastlesOnTable != null && CastlesOnTable[i] != null && CastlesOnTable[i].CastleThinking != null && CastlesOnTable[i].CastleThinking[0] != null && CastlesOnTable[i].CastleThinking[0].AStarGreedy != null)
                {
                    for (int j = 0; j < CastlesOnTable[i].CastleThinking[0].AStarGreedy.Count; j++)
                        Is = Is && CastlesOnTable[i].CastleThinking[0].AStarGreedy[j].IsThereCalculatedAStarGreedyNode();
                }
            }
            else//minister
                if (Kind == 5)
            {
                if (MinisterOnTable != null && MinisterOnTable[i] != null && MinisterOnTable[i].MinisterThinking != null && MinisterOnTable[i].MinisterThinking[0] != null && MinisterOnTable[i].MinisterThinking[0].AStarGreedy != null)
                {
                    for (int j = 0; j < MinisterOnTable[i].MinisterThinking[0].AStarGreedy.Count; j++)
                        Is = Is && MinisterOnTable[i].MinisterThinking[0].AStarGreedy[j].IsThereCalculatedAStarGreedyNode();
                }
            }
            else//king
            if (Kind == 6)
            {
                if (KingOnTable != null && KingOnTable[i] != null && KingOnTable[i].KingThinking != null && KingOnTable[i].KingThinking[0] != null && KingOnTable[i].KingThinking[0].AStarGreedy != null)
                {
                    for (int j = 0; j < KingOnTable[i].KingThinking[0].AStarGreedy.Count; j++)
                        Is = Is && KingOnTable[i].KingThinking[0].AStarGreedy[j].IsThereCalculatedAStarGreedyNode();
                }
            }
            else//king
            if (Kind == 7 || Kind == -7)
            {
                if (CastlingOnTable != null && CastlingOnTable[i] != null && CastlingOnTable[i].CastlingThinking != null && CastlingOnTable[i].CastlingThinking[0] != null && CastlingOnTable[i].CastlingThinking[0].AStarGreedy != null)
                {
                    for (int j = 0; j < CastlingOnTable[i].CastlingThinking[0].AStarGreedy.Count; j++)
                        Is = Is && CastlingOnTable[i].CastlingThinking[0].AStarGreedy[j].IsThereCalculatedAStarGreedyNode();
                }
            }
            return Is;
        }
        //when there is at least one non compuational deeper determined NON existence of deeper computational indexed deeper node 
        bool IsThereEmptyOrNonCalculatedAStarGreedyNode(int Order, int Kind, int i, int j)
        {
            bool Is = false;
            if (!IsThereNotAllOfEmptyOrNonCalculatedAStarGreedyNode(Order, Kind, i))
            {
                //soldier
                if (Kind == 1)
                {
                    if (SolderesOnTable != null && SolderesOnTable[i] != null && SolderesOnTable[i].SoldierThinking != null && SolderesOnTable[i].SoldierThinking[0] != null && SolderesOnTable[i].SoldierThinking[0].AStarGreedy != null && SolderesOnTable[i].SoldierThinking[0].AStarGreedy.Count > j)
                        Is = SolderesOnTable[i].SoldierThinking[0].AStarGreedy[j].IsThereCalculatedAStarGreedyNode();
                }
                else//elephant
                    if (Kind == 2)
                {
                    if (ElephantOnTable != null && ElephantOnTable[i] != null && ElephantOnTable[i].ElefantThinking != null && ElephantOnTable[i].ElefantThinking[0] != null && ElephantOnTable[i].ElefantThinking[0].AStarGreedy != null && ElephantOnTable[i].ElefantThinking[0].AStarGreedy.Count > j)
                        Is = ElephantOnTable[i].ElefantThinking[0].AStarGreedy[j].IsThereCalculatedAStarGreedyNode();
                }
                else//hourse
                    if (Kind == 3)
                {
                    if (HoursesOnTable != null && HoursesOnTable[i] != null && HoursesOnTable[i].HourseThinking != null && HoursesOnTable[i].HourseThinking[0] != null && HoursesOnTable[i].HourseThinking[0].AStarGreedy != null && HoursesOnTable[i].HourseThinking[0].AStarGreedy.Count > j)
                        Is = HoursesOnTable[i].HourseThinking[0].AStarGreedy[j].IsThereCalculatedAStarGreedyNode();
                }
                else//Castle
                    if (Kind == 4)
                {
                    if (CastlesOnTable != null && CastlesOnTable[i] != null && CastlesOnTable[i].CastleThinking != null && CastlesOnTable[i].CastleThinking[0] != null && CastlesOnTable[i].CastleThinking[0].AStarGreedy != null && CastlesOnTable[i].CastleThinking[0].AStarGreedy.Count > j)
                        Is = CastlesOnTable[i].CastleThinking[0].AStarGreedy[j].IsThereCalculatedAStarGreedyNode();
                }
                else//minister
                    if (Kind == 5)
                {
                    if (MinisterOnTable != null && MinisterOnTable[i] != null && MinisterOnTable[i].MinisterThinking != null && MinisterOnTable[i].MinisterThinking[0] != null && MinisterOnTable[i].MinisterThinking[0].AStarGreedy != null && MinisterOnTable[i].MinisterThinking[0].AStarGreedy.Count > j)
                        Is = MinisterOnTable[i].MinisterThinking[0].AStarGreedy[j].IsThereCalculatedAStarGreedyNode();
                }
                else//king
                if (Kind == 6)
                {
                    if (KingOnTable != null && KingOnTable[i] != null && KingOnTable[i].KingThinking != null && KingOnTable[i].KingThinking[0] != null && KingOnTable[i].KingThinking[0].AStarGreedy != null && KingOnTable[i].KingThinking[0].AStarGreedy.Count > j)
                        Is = KingOnTable[i].KingThinking[0].AStarGreedy[j].IsThereCalculatedAStarGreedyNode();
                }
                else//king
                if (Kind == 7 || Kind == -7)
                {
                    if (CastlingOnTable != null && CastlingOnTable[i] != null && CastlingOnTable[i].CastlingThinking != null && CastlingOnTable[i].CastlingThinking[0] != null && CastlingOnTable[i].CastlingThinking[0].AStarGreedy != null && CastlingOnTable[i].CastlingThinking[0].AStarGreedy.Count > j)
                        Is = CastlingOnTable[i].CastlingThinking[0].AStarGreedy[j].IsThereCalculatedAStarGreedyNode();
                }
            }
            return (!Is);
        }
        bool BlitzGameThinkingTreeBoundryConditions(int ik, int Kind)
        {
            if (Kind == 1)
            {
                if (SolderesOnTable == null)
                    return true;
                if (SolderesOnTable[ik] == null)
                    return true;
                if (SolderesOnTable[ik].SoldierThinking == null)
                    return true;
                if (SolderesOnTable[ik].SoldierThinking[0] == null)
                    return true;
                if (SolderesOnTable[ik].SoldierThinking[0].HeuristicListSolder == null)
                    return true;
            }
            else
            if (Kind == 2)
            {
                if (ElephantOnTable == null)
                    return true;
                if (ElephantOnTable[ik] == null)
                    return true;
                if (ElephantOnTable[ik].ElefantThinking == null)
                    return true;
                if (ElephantOnTable[ik].ElefantThinking[0] == null)
                    return true;
                if (ElephantOnTable[ik].ElefantThinking[0].HeuristicListElefant == null)
                    return true;
            }
            else
            if (Kind == 3)
            {
                if (HoursesOnTable == null)
                    return true;
                if (HoursesOnTable[ik] == null)
                    return true;
                if (HoursesOnTable[ik].HourseThinking == null)
                    return true;
                if (HoursesOnTable[ik].HourseThinking[0] == null)
                    return true;
                if (HoursesOnTable[ik].HourseThinking[0].HeuristicListHourse == null)
                    return true;
            }
            else
            if (Kind == 4)
            {
                if (CastlesOnTable == null)
                    return true;
                if (CastlesOnTable[ik] == null)
                    return true;
                if (CastlesOnTable[ik].CastleThinking == null)
                    return true;
                if (CastlesOnTable[ik].CastleThinking[0] == null)
                    return true;
                if (CastlesOnTable[ik].CastleThinking[0].HeuristicListCastle == null)
                    return true;
            }
            else
            if (Kind == 5)
            {
                if (MinisterOnTable == null)
                    return true;
                if (MinisterOnTable[ik] == null)
                    return true;
                if (MinisterOnTable[ik].MinisterThinking == null)
                    return true;
                if (MinisterOnTable[ik].MinisterThinking[0] == null)
                    return true;
                if (MinisterOnTable[ik].MinisterThinking[0].HeuristicListMinister == null)
                    return true;
            }
            else
            if (Kind == 6)
            {
                if (KingOnTable == null)
                    return true;
                if (KingOnTable[ik] == null)
                    return true;
                if (KingOnTable[ik].KingThinking == null)
                    return true;
                if (KingOnTable[ik].KingThinking[0] == null)
                    return true;
                if (KingOnTable[ik].KingThinking[0].HeuristicListKing == null)
                    return true;
            }
            else
            if (Kind == 7 || Kind == -7)
            {
                if (CastlingOnTable == null)
                    return true;
                if (CastlingOnTable[ik] == null)
                    return true;
                if (CastlingOnTable[ik].CastlingThinking == null)
                    return true;
                if (CastlingOnTable[ik].CastlingThinking[0] == null)
                    return true;
                if (CastlingOnTable[ik].CastlingThinking[0].HeuristicListCastling == null)
                    return true;
            }
            return false;
        }

        bool UsedRestrictedBlitzMoveAstarGreedy(int Kind, int ik, int j)
        {
            if (Kind == 1)
            {
                if (SolderesOnTable[ik].SoldierThinking[0].AStarGreedyMove.Count > j)
                {
                    if ((SolderesOnTable[ik].SoldierThinking[0].AStarGreedyMove[j] && UsedRestrictedMoveBlitzAndFull))
                        return true;
                }
            }
            else
            if (Kind == 2)
            {
                if (ElephantOnTable[ik].ElefantThinking[0].AStarGreedyMove.Count > j)
                {
                    if ((ElephantOnTable[ik].ElefantThinking[0].AStarGreedyMove[j] && UsedRestrictedMoveBlitzAndFull))
                        return true;
                }
            }
            else
            if (Kind == 3)
            {
                if (HoursesOnTable[ik].HourseThinking[0].AStarGreedyMove.Count > j)
                {
                    if ((HoursesOnTable[ik].HourseThinking[0].AStarGreedyMove[j] && UsedRestrictedMoveBlitzAndFull))
                        return true;
                }
            }
            else
            if (Kind == 4)
            {
                if (CastlesOnTable[ik].CastleThinking[0].AStarGreedyMove.Count > j)
                {
                    if ((CastlesOnTable[ik].CastleThinking[0].AStarGreedyMove[j] && UsedRestrictedMoveBlitzAndFull))
                        return true;
                }
            }
            else
            if (Kind == 5)
            {
                if (MinisterOnTable[ik].MinisterThinking[0].AStarGreedyMove.Count > j)
                {
                    if ((MinisterOnTable[ik].MinisterThinking[0].AStarGreedyMove[j] && UsedRestrictedMoveBlitzAndFull))
                        return true;
                }
            }
            else
            if (Kind == 6)
            {
                if (KingOnTable[ik].KingThinking[0].AStarGreedyMove.Count > j)
                {
                    if ((KingOnTable[ik].KingThinking[0].AStarGreedyMove[j] && UsedRestrictedMoveBlitzAndFull))
                        return true;
                }
            }
            else
            if (Kind == 7 || Kind == -7)
            {
                if (CastlingOnTable[ik].CastlingThinking[0].AStarGreedyMove.Count > j)
                {
                    if ((CastlingOnTable[ik].CastlingThinking[0].AStarGreedyMove[j] && UsedRestrictedMoveBlitzAndFull))
                        return true;
                }
            }
            return false;
        }
        //blitz for determination about best movment of every objects
        void BlitzGameThinkingTreeSolderGray(ref int PreviousLessS, ref int[] Index, ref int[] jIndex, int Order, int iAStarGreedy, int ik, int j, bool FOUND, int LeafAStarGreedy)
        {
            //Soldeir
            for (ik = 0; ik < SodierMidle; ik++)
            {
                bool ac = false;
                var ah = Task.Factory.StartNew(() => ac = BlitzGameThinkingTreeBoundryConditions(ik, 1));
                ah.Wait();
                ah.Dispose();
                if (ac)
                    continue;
                //when there is computational lists
                for (j = 0; j < SolderesOnTable[ik].SoldierThinking[0].HeuristicListSolder.Count; j++)
                {
                    //when node is serving node continue
                    if (IsSupHuTrue(ik, j, 0, 1)
                      )
                        continue;
                    Object O = new Object();
                    lock (O)
                    {
                        //when node is empty deeper and there is not computatiional node continue
                        var ah1 = Task.Factory.StartNew(() => ac = IsThereEmptyOrNonCalculatedAStarGreedyNode(Order, 1, ik, j));
                        ah1.Wait();
                        ah1.Dispose();
                        if (!ac)
                            continue;
                        //when node have kings dangoures ignore and continue.
                        var ah2 = Task.Factory.StartNew(() => ac = CheckeHuristci(CloneATable(SolderesOnTable[ik].SoldierThinking[0].TableListSolder[j]), Order, ik, j, 0));
                        ah2.Wait();
                        ah2.Dispose();
                        if (!ac)
                            continue;
                        //when is self
                        if (Order != AllDraw.OrderPlateDraw)
                        {
                            //when in learning autamata is penalty or Heuristic specified is less than specific dynamic programming var
                            if (UsedRestrictedBlitzMoveAstarGreedy(1, ik, j) || SolderesOnTable[ik].SoldierThinking[0].ReturnHeuristic(ik, j, Order, false, ref HaveKilled) < PreviousLessS || (SolderesOnTable[ik].SoldierThinking[0].PenaltyRegardListSolder[j].IsPenaltyAction() == 0 && UsePenaltyRegardMechnisamT))
                            {
                            }
                            else
                            {
                                Index[0] = ik;
                                jIndex[0] = j;
                                int Hav = HaveKilled;
                                int pre = PreviousLessS;
                                var ah3 = Task.Factory.StartNew(() => pre = SolderesOnTable[ik].SoldierThinking[0].ReturnHeuristic(ik, j, Order, false, ref Hav));
                                ah3.Wait();
                                ah3.Dispose();
                                HaveKilled = Hav;
                                PreviousLessS = pre;
                            }
                        }
                        else
                        {
                            //when in learning autamata is penalty or Heuristic specified is greater than specific dynamic programming var
                            if (UsedRestrictedBlitzMoveAstarGreedy(1, ik, j) || SolderesOnTable[ik].SoldierThinking[0].ReturnHeuristic(ik, j, Order, false, ref HaveKilled) > PreviousLessS || (SolderesOnTable[ik].SoldierThinking[0].PenaltyRegardListSolder[j].IsPenaltyAction() == 0 && UsePenaltyRegardMechnisamT))
                            {
                            }
                            else
                            {
                                Index[0] = ik;
                                jIndex[0] = j;
                                int Hav = HaveKilled;
                                int pre = PreviousLessS;
                                var ah3 = Task.Factory.StartNew(() => pre = SolderesOnTable[ik].SoldierThinking[0].ReturnHeuristic(ik, j, Order, false, ref Hav));
                                ah3.Wait();
                                ah3.Dispose();
                                HaveKilled = Hav;
                                PreviousLessS = pre;
                            }
                        }
                    }
                }
                //Elephant
            }
        }
        //blitz for determination about best movment of every objects
        void BlitzGameThinkingTreeElephantGray(ref int PreviousLessE, ref int[] Index, ref int[] jIndex, int Order, int iAStarGreedy, int ik, int j, bool FOUND, int LeafAStarGreedy)
        {
            //Elephant
            for (ik = 0; ik < ElefantMidle; ik++)
            {
                bool ac = false;
                var ah = Task.Factory.StartNew(() => ac = BlitzGameThinkingTreeBoundryConditions(ik, 2));
                ah.Wait();
                ah.Dispose();
                if (ac) continue;
                //when there is computational lists
                for (j = 0; j < ElephantOnTable[ik].ElefantThinking[0].HeuristicListElefant.Count; j++)
                {
                    //when node is serving node continue
                    if (IsSupHuTrue(ik, j, 0, 2)
               )
                        continue;
                    Object O = new Object();
                    lock (O)
                    {
                        //when node is empty deeper and there is not computatiional node continue
                        var ah1 = Task.Factory.StartNew(() => ac = IsThereEmptyOrNonCalculatedAStarGreedyNode(Order, 2, ik, j));
                        ah1.Wait();
                        ah1.Dispose();
                        if (!ac)
                            continue;
                        //when node have kings dangoures ignore and continue.
                        var ah2 = Task.Factory.StartNew(() => ac = CheckeHuristci(CloneATable(ElephantOnTable[ik].ElefantThinking[0].TableListElefant[j]), Order, ik, j, 0));
                        ah2.Wait();
                        ah2.Dispose();
                        if (!ac)
                            continue;
                        //when is self
                        if (Order != AllDraw.OrderPlateDraw)
                        {
                            //when in learning autamata is penalty or Heuristic specified is less than specific dynamic programming var
                            if (UsedRestrictedBlitzMoveAstarGreedy(2, ik, j) || ElephantOnTable[ik].ElefantThinking[0].ReturnHeuristic(ik, j, Order, false, ref HaveKilled) < PreviousLessE || (ElephantOnTable[ik].ElefantThinking[0].PenaltyRegardListElefant[j].IsPenaltyAction() == 0 && UsePenaltyRegardMechnisamT))
                            {
                            }
                            else
                            {
                                Index[1] = ik;
                                jIndex[1] = j;
                                int Hav = HaveKilled;
                                int pre = PreviousLessE;
                                var ah3 = Task.Factory.StartNew(() => pre = ElephantOnTable[ik].ElefantThinking[0].ReturnHeuristic(ik, j, Order, false, ref Hav));
                                ah3.Wait();
                                ah3.Dispose();
                                HaveKilled = Hav;
                                PreviousLessE = pre;
                            }
                        }
                        else
                        {
                            //when in learning autamata is penalty or Heuristic specified is greater than specific dynamic programming var
                            if (UsedRestrictedBlitzMoveAstarGreedy(2, ik, j) || ElephantOnTable[ik].ElefantThinking[0].ReturnHeuristic(ik, j, Order, false, ref HaveKilled) > PreviousLessE || (ElephantOnTable[ik].ElefantThinking[0].PenaltyRegardListElefant[j].IsPenaltyAction() == 0 && UsePenaltyRegardMechnisamT))
                            {
                            }
                            else
                            {
                                Index[1] = ik;
                                jIndex[1] = j;
                                int Hav = HaveKilled;
                                int pre = PreviousLessE;
                                var ah3 = Task.Factory.StartNew(() => pre = ElephantOnTable[ik].ElefantThinking[0].ReturnHeuristic(ik, j, Order, false, ref Hav));
                                ah3.Wait();
                                ah3.Dispose();
                                HaveKilled = Hav;
                                PreviousLessE = pre;
                            }
                        }
                    }
                }
            }
        }
        //blitz for determination about best movment of every objects
        void BlitzGameThinkingTreeHourseGray(ref int PreviousLessH, ref int[] Index, ref int[] jIndex, int Order, int iAStarGreedy, int ik, int j, bool FOUND, int LeafAStarGreedy)
        {
            //Hourse.
            for (ik = 0; ik < HourseMidle; ik++)
            {
                bool ac = false;
                var ah = Task.Factory.StartNew(() => ac = BlitzGameThinkingTreeBoundryConditions(ik, 3));
                ah.Wait();
                ah.Dispose();
                if (ac) continue;
                //when there is computational lists
                for (j = 0; j < HoursesOnTable[ik].HourseThinking[0].HeuristicListHourse.Count; j++)
                {
                    //when node is serving node continue
                    if (HoursesOnTable[ik].HourseThinking[0].IsSupHu[j]
                  )
                        continue;
                    Object O = new Object();
                    lock (O)
                    {
                        //when node is empty deeper and there is not computatiional node continue
                        var ah1 = Task.Factory.StartNew(() => ac = IsThereEmptyOrNonCalculatedAStarGreedyNode(Order, 3, ik, j));
                        ah1.Wait();
                        ah1.Dispose();
                        if (!ac)
                            continue;
                        //when node have kings dangoures ignore and continue.
                        var ah2 = Task.Factory.StartNew(() => ac = CheckeHuristci(CloneATable(HoursesOnTable[ik].HourseThinking[0].TableListHourse[j]), Order, ik, j, 0));
                        ah2.Wait();
                        ah2.Dispose();
                        if (!ac)
                            continue;
                        //when is self
                        if (Order != AllDraw.OrderPlateDraw)
                        {
                            //when in learning autamata is penalty or Heuristic specified is less than specific dynamic programming var
                            if (UsedRestrictedBlitzMoveAstarGreedy(3, ik, j) || HoursesOnTable[ik].HourseThinking[0].ReturnHeuristic(ik, j, Order, false, ref HaveKilled) < PreviousLessH || (HoursesOnTable[ik].HourseThinking[0].PenaltyRegardListHourse[j].IsPenaltyAction() == 0 && UsePenaltyRegardMechnisamT))
                            {
                            }
                            else
                            {
                                Index[2] = ik;
                                jIndex[2] = j;
                                int Hav = HaveKilled;
                                int pre = PreviousLessH;
                                var ah3 = Task.Factory.StartNew(() => pre = HoursesOnTable[ik].HourseThinking[0].ReturnHeuristic(ik, j, Order, false, ref Hav));
                                ah3.Wait();
                                ah3.Dispose();
                                HaveKilled = Hav;
                                PreviousLessH = pre;
                            }
                        }
                        else
                        {
                            //when in learning autamata is penalty or Heuristic specified is greater than specific dynamic programming var
                            if (UsedRestrictedBlitzMoveAstarGreedy(3, ik, j) || HoursesOnTable[ik].HourseThinking[0].ReturnHeuristic(ik, j, Order, false, ref HaveKilled) > PreviousLessH || (HoursesOnTable[ik].HourseThinking[0].PenaltyRegardListHourse[j].IsPenaltyAction() == 0 && UsePenaltyRegardMechnisamT))
                            {
                            }
                            else
                            {
                                Index[2] = ik;
                                jIndex[2] = j;
                                int Hav = HaveKilled;
                                int pre = PreviousLessH;
                                var ah3 = Task.Factory.StartNew(() => pre = HoursesOnTable[ik].HourseThinking[0].ReturnHeuristic(ik, j, Order, false, ref Hav));
                                ah3.Wait();
                                ah3.Dispose();
                                HaveKilled = Hav;
                                PreviousLessH = pre;
                            }
                        }
                    }
                }
            }
        }
        //blitz for determination about best movment of every objects
        void BlitzGameThinkingTreeCastleGray(ref int PreviousLessB, ref int[] Index, ref int[] jIndex, int Order, int iAStarGreedy, int ik, int j, bool FOUND, int LeafAStarGreedy)
        {
            //Castle.
            for (ik = 0; ik < CastleMidle; ik++)
            {
                bool ac = false;
                var ah = Task.Factory.StartNew(() => ac = BlitzGameThinkingTreeBoundryConditions(ik, 4));
                ah.Wait();
                ah.Dispose();
                if (ac) continue;
                //when there is computational lists
                for (j = 0; j < CastlesOnTable[ik].CastleThinking[0].HeuristicListCastle.Count; j++)
                {
                    //when node is serving node continue
                    if (IsSupHuTrue(ik, j, 0, 4)
                 )
                        continue;
                    Object O = new Object();
                    lock (O)
                    {
                        //when node is empty deeper and there is not computatiional node continue
                        var ah1 = Task.Factory.StartNew(() => ac = IsThereEmptyOrNonCalculatedAStarGreedyNode(Order, 4, ik, j));
                        ah1.Wait();
                        ah1.Dispose();
                        if (!ac)
                            continue;
                        //when node have kings dangoures ignore and continue.
                        var ah2 = Task.Factory.StartNew(() => ac = CheckeHuristci(CloneATable(CastlesOnTable[ik].CastleThinking[0].TableListCastle[j]), Order, ik, j, 0));
                        ah2.Wait();
                        ah2.Dispose();
                        if (!ac)
                            continue;
                        //when is self
                        if (Order != AllDraw.OrderPlateDraw)
                        {
                            //when in learning autamata is penalty or Heuristic specified is less than specific dynamic programming var
                            if (UsedRestrictedBlitzMoveAstarGreedy(4, ik, j) || CastlesOnTable[ik].CastleThinking[0].ReturnHeuristic(ik, j, Order, false, ref HaveKilled) < PreviousLessB || (CastlesOnTable[ik].CastleThinking[0].PenaltyRegardListCastle[j].IsPenaltyAction() == 0 && UsePenaltyRegardMechnisamT))
                            {
                            }
                            else
                            {
                                Index[3] = ik;
                                jIndex[3] = j;
                                int Hav = HaveKilled;
                                int pre = PreviousLessB;
                                var ah3 = Task.Factory.StartNew(() => pre = CastlesOnTable[ik].CastleThinking[0].ReturnHeuristic(ik, j, Order, false, ref Hav));
                                ah3.Wait();
                                ah3.Dispose();
                                HaveKilled = Hav;
                                PreviousLessB = pre;
                            }
                        }
                        else
                        {
                            //when in learning autamata is penalty or Heuristic specified is greater than specific dynamic programming var
                            if (UsedRestrictedBlitzMoveAstarGreedy(4, ik, j) || CastlesOnTable[ik].CastleThinking[0].ReturnHeuristic(ik, j, Order, false, ref HaveKilled) > PreviousLessB || (CastlesOnTable[ik].CastleThinking[0].PenaltyRegardListCastle[j].IsPenaltyAction() == 0 && UsePenaltyRegardMechnisamT))
                            {
                            }
                            else
                            {
                                Index[3] = ik;
                                jIndex[3] = j;
                                int Hav = HaveKilled;
                                int pre = PreviousLessB;
                                var ah3 = Task.Factory.StartNew(() => pre = CastlesOnTable[ik].CastleThinking[0].ReturnHeuristic(ik, j, Order, false, ref Hav));
                                ah3.Wait();
                                ah3.Dispose();
                                HaveKilled = Hav;
                                PreviousLessB = pre;
                            }

                        }
                    }
                }
            }
        }
        //blitz for determination about best movment of every objects
        void BlitzGameThinkingTreeMinisterGray(ref int PreviousLessM, ref int[] Index, ref int[] jIndex, int Order, int iAStarGreedy, int ik, int j, bool FOUND, int LeafAStarGreedy)
        {
            //Minister.
            for (ik = 0; ik < MinisterMidle; ik++)
            {
                bool ac = false;
                var ah = Task.Factory.StartNew(() => ac = BlitzGameThinkingTreeBoundryConditions(ik, 5));
                ah.Wait();
                ah.Dispose();
                if (ac)
                    continue;
                //when there is computational lists
                for (j = 0; j < MinisterOnTable[ik].MinisterThinking[0].HeuristicListMinister.Count; j++)
                {
                    //when node is serving node continue
                    if (IsSupHuTrue(ik, j, 0, 5)
                      )
                        continue;
                    //when node is empty deeper and there is not computatiional node continue
                    var ah1 = Task.Factory.StartNew(() => ac = IsThereEmptyOrNonCalculatedAStarGreedyNode(Order, 5, ik, j));
                    ah1.Wait();
                    ah1.Dispose();
                    if (!ac)
                        continue;
                    //when node have kings dangoures ignore and continue.
                    var ah2 = Task.Factory.StartNew(() => ac = CheckeHuristci(CloneATable(MinisterOnTable[ik].MinisterThinking[0].TableListMinister[j]), Order, ik, j, 0));
                    ah2.Wait();
                    ah2.Dispose();
                    if (!ac)
                        continue;
                    Object O = new Object();
                    lock (O)
                    {
                        //when is self
                        if (Order != AllDraw.OrderPlateDraw)
                        {
                            //when in learning autamata is penalty or Heuristic specified is less than specific dynamic programming var
                            if (UsedRestrictedBlitzMoveAstarGreedy(5, ik, j) || MinisterOnTable[ik].MinisterThinking[0].ReturnHeuristic(ik, j, Order, false, ref HaveKilled) < PreviousLessM || (MinisterOnTable[ik].MinisterThinking[0].PenaltyRegardListMinister[j].IsPenaltyAction() == 0 && UsePenaltyRegardMechnisamT))
                            {
                            }
                            else
                            {
                                Index[4] = ik;
                                jIndex[4] = j;
                                int Hav = HaveKilled;
                                int pre = PreviousLessM;
                                var ah3 = Task.Factory.StartNew(() => pre = MinisterOnTable[ik].MinisterThinking[0].ReturnHeuristic(ik, j, Order, false, ref Hav));
                                ah3.Wait();
                                ah3.Dispose();
                                HaveKilled = Hav;
                                PreviousLessM = pre;
                            }
                        }
                        else
                        {
                            //when in learning autamata is penalty or Heuristic specified is greater than specific dynamic programming var
                            if (UsedRestrictedBlitzMoveAstarGreedy(5, ik, j) || MinisterOnTable[ik].MinisterThinking[0].ReturnHeuristic(ik, j, Order, false, ref HaveKilled) > PreviousLessM || (MinisterOnTable[ik].MinisterThinking[0].PenaltyRegardListMinister[j].IsPenaltyAction() == 0 && UsePenaltyRegardMechnisamT))
                            {
                            }
                            else
                            {
                                Index[4] = ik;
                                jIndex[4] = j;
                                int Hav = HaveKilled;
                                int pre = PreviousLessM;
                                var ah3 = Task.Factory.StartNew(() => pre = MinisterOnTable[ik].MinisterThinking[0].ReturnHeuristic(ik, j, Order, false, ref Hav));
                                ah3.Wait();
                                ah3.Dispose();
                                HaveKilled = Hav;
                                PreviousLessM = pre;
                            }
                        }
                    }
                }
            }
        }
        //blitz for determination about best movment of every objects
        void BlitzGameThinkingTreeKingGray(ref int PreviousLessK, ref int[] Index, ref int[] jIndex, int Order, int iAStarGreedy, int ik, int j, bool FOUND, int LeafAStarGreedy)
        {
            //King.
            for (ik = 0; ik < KingMidle; ik++)
            {
                bool ac = false;
                var ah = Task.Factory.StartNew(() => ac = BlitzGameThinkingTreeBoundryConditions(ik, 6));
                ah.Wait();
                ah.Dispose();
                if (ac)
                    continue;
                //when there is computational lists
                for (j = 0; j < KingOnTable[ik].KingThinking[0].HeuristicListKing.Count; j++)
                {
                    //when node is serving node continue
                    if (IsSupHuTrue(ik, j, 0, 6)
                      )
                        continue;
                    Object O = new Object();
                    lock (O)
                    {
                        //when node is empty deeper and there is not computatiional node continue
                        var ah1 = Task.Factory.StartNew(() => ac = IsThereEmptyOrNonCalculatedAStarGreedyNode(Order, 6, ik, j));
                        ah1.Wait();
                        ah1.Dispose();
                        if (!ac)
                            continue;
                        //when node have kings dangoures ignore and continue.
                        var ah2 = Task.Factory.StartNew(() => ac = CheckeHuristci(CloneATable(KingOnTable[ik].KingThinking[0].TableListKing[j]), Order, ik, j, 0));
                        ah2.Wait();
                        ah2.Dispose();
                        if (!ac)
                            continue;
                        //when is self
                        if (Order != AllDraw.OrderPlateDraw)
                        {
                            //when in learning autamata is penalty or Heuristic specified is less than specific dynamic programming var
                            if (UsedRestrictedBlitzMoveAstarGreedy(6, ik, j) || KingOnTable[ik].KingThinking[0].ReturnHeuristic(ik, j, Order, false, ref HaveKilled) < PreviousLessK || (KingOnTable[ik].KingThinking[0].PenaltyRegardListKing[j].IsPenaltyAction() == 0 && UsePenaltyRegardMechnisamT))
                            {
                            }
                            else
                            {
                                Index[5] = ik;
                                jIndex[5] = j;
                                int Hav = HaveKilled;
                                int pre = PreviousLessK;
                                var ah3 = Task.Factory.StartNew(() => pre = KingOnTable[ik].KingThinking[0].ReturnHeuristic(ik, j, Order, false, ref Hav));
                                ah3.Wait();
                                ah3.Dispose();
                                HaveKilled = Hav;
                                PreviousLessK = pre;
                            }
                        }
                        else
                        {
                            //when in learning autamata is penalty or Heuristic specified is less than specific dynamic programming var
                            if (UsedRestrictedBlitzMoveAstarGreedy(6, ik, j) || KingOnTable[ik].KingThinking[0].ReturnHeuristic(ik, j, Order, false, ref HaveKilled) > PreviousLessK || (KingOnTable[ik].KingThinking[0].PenaltyRegardListKing[j].IsPenaltyAction() == 0 && UsePenaltyRegardMechnisamT))
                            {
                            }
                            else
                            {
                                Index[5] = ik;
                                jIndex[5] = j;
                                int Hav = HaveKilled;
                                int pre = PreviousLessK;
                                var ah3 = Task.Factory.StartNew(() => pre = KingOnTable[ik].KingThinking[0].ReturnHeuristic(ik, j, Order, false, ref Hav));
                                ah3.Wait();
                                ah3.Dispose();
                                HaveKilled = Hav;
                                PreviousLessK = pre;
                            }
                        }
                    }
                }
            }
        }
        //blitz for determination about best movment of every objects
        void BlitzGameThinkingTreeCastlingGray(ref int PreviousLessK, ref int[] Index, ref int[] jIndex, int Order, int iAStarGreedy, int ik, int j, bool FOUND, int LeafAStarGreedy)
        {
            //Castling.
            for (ik = 0; ik < 1; ik++)
            {
                bool ac = false;
                var ah = Task.Factory.StartNew(() => ac = BlitzGameThinkingTreeBoundryConditions(ik, 7));
                ah.Wait();
                ah.Dispose();
                if (ac)
                    continue;
                //when there is computational lists
                for (j = 0; j < CastlingOnTable[ik].CastlingThinking[0].HeuristicListCastling.Count; j++)
                {
                    //when node is serving node continue
                    if (IsSupHuTrue(ik, j, 0, 7)
                      )
                        continue;
                    Object O = new Object();
                    lock (O)
                    {
                        //when node is empty deeper and there is not computatiional node continue
                        var ah1 = Task.Factory.StartNew(() => ac = IsThereEmptyOrNonCalculatedAStarGreedyNode(Order, 7, ik, j));
                        ah1.Wait();
                        ah1.Dispose();
                        if (!ac)
                            continue;
                        //when node have Castlings dangoures ignore and continue.
                        var ah2 = Task.Factory.StartNew(() => ac = CheckeHuristci(CloneATable(CastlingOnTable[ik].CastlingThinking[0].TableListCastling[j]), Order, ik, j, 0));
                        ah2.Wait();
                        ah2.Dispose();
                        if (!ac)
                            continue;
                        //when is self
                        if (Order != AllDraw.OrderPlateDraw)
                        {
                            //when in learning autamata is penalty or Heuristic specified is less than specific dynamic programming var
                            if (UsedRestrictedBlitzMoveAstarGreedy(7, ik, j) || CastlingOnTable[ik].CastlingThinking[0].ReturnHeuristic(ik, j, Order, false, ref HaveKilled) < PreviousLessK || (CastlingOnTable[ik].CastlingThinking[0].PenaltyRegardListCastling[j].IsPenaltyAction() == 0 && UsePenaltyRegardMechnisamT))
                            {
                            }
                            else
                            {
                                Index[6] = ik;
                                jIndex[6] = j;
                                int Hav = HaveKilled;
                                int pre = PreviousLessK;
                                var ah3 = Task.Factory.StartNew(() => pre = CastlingOnTable[ik].CastlingThinking[0].ReturnHeuristic(ik, j, Order, false, ref Hav));
                                ah3.Wait();
                                ah3.Dispose();
                                HaveKilled = Hav;
                                PreviousLessK = pre;
                            }
                        }
                        else
                        {
                            //when in learning autamata is penalty or Heuristic specified is less than specific dynamic programming var
                            if (UsedRestrictedBlitzMoveAstarGreedy(6, ik, j) || CastlingOnTable[ik].CastlingThinking[0].ReturnHeuristic(ik, j, Order, false, ref HaveKilled) > PreviousLessK || (CastlingOnTable[ik].CastlingThinking[0].PenaltyRegardListCastling[j].IsPenaltyAction() == 0 && UsePenaltyRegardMechnisamT))
                            {
                            }
                            else
                            {
                                Index[6] = ik;
                                jIndex[6] = j;
                                int Hav = HaveKilled;
                                int pre = PreviousLessK;
                                var ah3 = Task.Factory.StartNew(() => pre = CastlingOnTable[ik].CastlingThinking[0].ReturnHeuristic(ik, j, Order, false, ref Hav));
                                ah3.Wait();
                                ah3.Dispose();
                                HaveKilled = Hav;
                                PreviousLessK = pre;
                            }
                        }
                    }
                }
            }
        }
        //blitz for determination about best movment of every objects
        void BlitzGameTreeCreationThinkingTreeSolder(Color a, int[] Index, int[] jIndex, int Order, int iAStarGreedy, int ik, int j, bool FOUND, int LeafAStarGreedy)
        {
            List<Task> tHA = new List<Task>();
            Object O1 = new Object();
            lock (O1)
            {
                //when do permite
                if (Index[0] != -1)
                {
                    if (SolderesOnTable[Index[0]].SoldierThinking[0].AStarGreedy.Count == 0)
                        SolderesOnTable[Index[0]].SoldierThinking[0].AStarGreedy.Add(new AllDraw(Order * -1, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged));
                    SolderesOnTable[Index[0]].SoldierThinking[0].AStarGreedy[SolderesOnTable[Index[0]].SoldierThinking[0].AStarGreedy.Count - 1].TableList.Clear();
                    SolderesOnTable[Index[0]].SoldierThinking[0].AStarGreedy[SolderesOnTable[Index[0]].SoldierThinking[0].AStarGreedy.Count - 1].TableList.Add(CloneATable(SolderesOnTable[Index[0]].SoldierThinking[0].TableListSolder[jIndex[0]]));
                    SolderesOnTable[Index[0]].SoldierThinking[0].AStarGreedy[SolderesOnTable[Index[0]].SoldierThinking[0].AStarGreedy.Count - 1].SetRowColumn(0);
                    SolderesOnTable[Index[0]].SoldierThinking[0].AStarGreedy[SolderesOnTable[Index[0]].SoldierThinking[0].AStarGreedy.Count - 1].AStarGreedyString = this;
                    var H = Task.Factory.StartNew(() => SolderesOnTable[Index[0]].SoldierThinking[0].AStarGreedy[SolderesOnTable[Index[0]].SoldierThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt(iAStarGreedy, SolderesOnTable[Index[0]].SoldierThinking[0].RowColumnSoldier[jIndex[0]][0], SolderesOnTable[Index[0]].SoldierThinking[0].RowColumnSoldier[jIndex[0]][1], a, SolderesOnTable[Index[0]].SoldierThinking[0].TableListSolder[jIndex[0]], Order, false, FOUND, LeafAStarGreedy));
                    H.Wait();
                    H.Dispose();
                }
            }
        }
        //blitz for determination about best movment of every objects
        void BlitzGameTreeCreationThinkingTreeElephant(Color a, int[] Index, int[] jIndex, int Order, int iAStarGreedy, int ik, int j, bool FOUND, int LeafAStarGreedy)
        {
            List<Task> tHA = new List<Task>();
            Object O1 = new Object();
            lock (O1)
            {
                //when do permite
                if (Index[1] != -1)
                {
                    if (ElephantOnTable[Index[1]].ElefantThinking[0].AStarGreedy.Count == 0)
                        ElephantOnTable[Index[1]].ElefantThinking[0].AStarGreedy.Add(new AllDraw(Order * -1, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged));
                    ElephantOnTable[Index[1]].ElefantThinking[0].AStarGreedy[ElephantOnTable[Index[1]].ElefantThinking[0].AStarGreedy.Count - 1].TableList.Clear();
                    ElephantOnTable[Index[1]].ElefantThinking[0].AStarGreedy[ElephantOnTable[Index[1]].ElefantThinking[0].AStarGreedy.Count - 1].TableList.Add(CloneATable(ElephantOnTable[Index[1]].ElefantThinking[0].TableListElefant[jIndex[1]]));
                    ElephantOnTable[Index[1]].ElefantThinking[0].AStarGreedy[ElephantOnTable[Index[1]].ElefantThinking[0].AStarGreedy.Count - 1].SetRowColumn(0);
                    ElephantOnTable[Index[1]].ElefantThinking[0].AStarGreedy[ElephantOnTable[Index[1]].ElefantThinking[0].AStarGreedy.Count - 1].AStarGreedyString = this;
                    var H = Task.Factory.StartNew(() => ElephantOnTable[Index[1]].ElefantThinking[0].AStarGreedy[ElephantOnTable[Index[1]].ElefantThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt(iAStarGreedy, ElephantOnTable[Index[1]].ElefantThinking[0].RowColumnElefant[jIndex[1]][0], ElephantOnTable[Index[1]].ElefantThinking[0].RowColumnElefant[jIndex[1]][1], a, ElephantOnTable[Index[1]].ElefantThinking[0].TableListElefant[jIndex[1]], Order, false, FOUND, LeafAStarGreedy));
                    H.Wait();
                    H.Dispose();
                }
            }
        }
        //blitz for determination about best movment of every objects
        void BlitzGameTreeCreationThinkingTreeHourse(Color a, int[] Index, int[] jIndex, int Order, int iAStarGreedy, int ik, int j, bool FOUND, int LeafAStarGreedy)
        {
            List<Task> tHA = new List<Task>();
            Object O1 = new Object();
            lock (O1)
            {
                //when do permite
                if (Index[2] != -1)
                {
                    if (HoursesOnTable[Index[2]].HourseThinking[0].AStarGreedy.Count == 0)
                        HoursesOnTable[Index[2]].HourseThinking[0].AStarGreedy.Add(new AllDraw(Order * -1, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged));
                    HoursesOnTable[Index[2]].HourseThinking[0].AStarGreedy[HoursesOnTable[Index[2]].HourseThinking[0].AStarGreedy.Count - 1].TableList.Clear();
                    HoursesOnTable[Index[2]].HourseThinking[0].AStarGreedy[HoursesOnTable[Index[2]].HourseThinking[0].AStarGreedy.Count - 1].TableList.Add(CloneATable(HoursesOnTable[Index[2]].HourseThinking[0].TableListHourse[jIndex[2]]));
                    HoursesOnTable[Index[2]].HourseThinking[0].AStarGreedy[HoursesOnTable[Index[2]].HourseThinking[0].AStarGreedy.Count - 1].SetRowColumn(0);
                    HoursesOnTable[Index[2]].HourseThinking[0].AStarGreedy[HoursesOnTable[Index[2]].HourseThinking[0].AStarGreedy.Count - 1].AStarGreedyString = this;
                    var H = Task.Factory.StartNew(() => HoursesOnTable[Index[2]].HourseThinking[0].AStarGreedy[HoursesOnTable[Index[2]].HourseThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt(iAStarGreedy, HoursesOnTable[Index[2]].HourseThinking[0].RowColumnHourse[jIndex[2]][0], HoursesOnTable[Index[2]].HourseThinking[0].RowColumnHourse[jIndex[2]][1], a, HoursesOnTable[Index[2]].HourseThinking[0].TableListHourse[jIndex[2]], Order, false, FOUND, LeafAStarGreedy));
                    H.Wait();
                    H.Dispose();
                }
            }
        }
        //blitz for determination about best movment of every objects
        void BlitzGameTreeCreationThinkingTreeCastle(Color a, int[] Index, int[] jIndex, int Order, int iAStarGreedy, int ik, int j, bool FOUND, int LeafAStarGreedy)
        {
            List<Task> tHA = new List<Task>();
            Object O1 = new Object();
            lock (O1)
            {
                //when do permite
                if (Index[3] != -1)
                {
                    if (CastlesOnTable[Index[3]].CastleThinking[0].AStarGreedy.Count == 0)
                        CastlesOnTable[Index[3]].CastleThinking[0].AStarGreedy.Add(new AllDraw(Order * -1, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged));
                    CastlesOnTable[Index[3]].CastleThinking[0].AStarGreedy[CastlesOnTable[Index[3]].CastleThinking[0].AStarGreedy.Count - 1].TableList.Clear();
                    CastlesOnTable[Index[3]].CastleThinking[0].AStarGreedy[CastlesOnTable[Index[3]].CastleThinking[0].AStarGreedy.Count - 1].TableList.Add(CloneATable(CastlesOnTable[Index[3]].CastleThinking[0].TableListCastle[jIndex[3]]));
                    CastlesOnTable[Index[3]].CastleThinking[0].AStarGreedy[CastlesOnTable[Index[3]].CastleThinking[0].AStarGreedy.Count - 1].SetRowColumn(0);
                    CastlesOnTable[Index[3]].CastleThinking[0].AStarGreedy[CastlesOnTable[Index[3]].CastleThinking[0].AStarGreedy.Count - 1].AStarGreedyString = this;
                    var H = Task.Factory.StartNew(() => CastlesOnTable[Index[3]].CastleThinking[0].AStarGreedy[CastlesOnTable[Index[3]].CastleThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt(iAStarGreedy, CastlesOnTable[Index[3]].CastleThinking[0].RowColumnCastle[jIndex[3]][0], CastlesOnTable[Index[3]].CastleThinking[0].RowColumnCastle[jIndex[3]][1], a, CastlesOnTable[Index[3]].CastleThinking[0].TableListCastle[jIndex[3]], Order, false, FOUND, LeafAStarGreedy));
                    H.Wait();
                    H.Dispose();
                }
            }
        }
        //blitz for determination about best movment of every objects
        void BlitzGameTreeCreationThinkingTreeMinister(Color a, int[] Index, int[] jIndex, int Order, int iAStarGreedy, int ik, int j, bool FOUND, int LeafAStarGreedy)
        {
            List<Task> tHA = new List<Task>();
            Object O1 = new Object();
            lock (O1)
            {
                //when do permite
                if (Index[4] != -1)
                {
                    if (MinisterOnTable[Index[4]].MinisterThinking[0].AStarGreedy.Count == 0)
                        MinisterOnTable[Index[4]].MinisterThinking[0].AStarGreedy.Add(new AllDraw(Order * -1, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged));
                    MinisterOnTable[Index[4]].MinisterThinking[0].AStarGreedy[MinisterOnTable[Index[4]].MinisterThinking[0].AStarGreedy.Count - 1].TableList.Clear();
                    MinisterOnTable[Index[4]].MinisterThinking[0].AStarGreedy[MinisterOnTable[Index[4]].MinisterThinking[0].AStarGreedy.Count - 1].TableList.Add(CloneATable(MinisterOnTable[Index[4]].MinisterThinking[0].TableListMinister[jIndex[4]]));
                    MinisterOnTable[Index[4]].MinisterThinking[0].AStarGreedy[MinisterOnTable[Index[4]].MinisterThinking[0].AStarGreedy.Count - 1].SetRowColumn(0);
                    MinisterOnTable[Index[4]].MinisterThinking[0].AStarGreedy[MinisterOnTable[Index[4]].MinisterThinking[0].AStarGreedy.Count - 1].AStarGreedyString = this;
                    var H = Task.Factory.StartNew(() => MinisterOnTable[Index[4]].MinisterThinking[0].AStarGreedy[MinisterOnTable[Index[4]].MinisterThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt(iAStarGreedy, MinisterOnTable[Index[4]].MinisterThinking[0].RowColumnMinister[jIndex[4]][0], MinisterOnTable[Index[4]].MinisterThinking[0].RowColumnMinister[jIndex[4]][1], a, MinisterOnTable[Index[4]].MinisterThinking[0].TableListMinister[jIndex[4]], Order, false, FOUND, LeafAStarGreedy));
                    H.Wait();
                    H.Dispose();
                }
            }
        }
        //blitz for determination about best movment of every objects
        void BlitzGameTreeCreationThinkingTreeKing(Color a, int[] Index, int[] jIndex, int Order, int iAStarGreedy, int ik, int j, bool FOUND, int LeafAStarGreedy)
        {
            Object O1 = new Object();
            lock (O1)
            {
                //when do permite
                if (Index[5] != -1)
                {
                    if (KingOnTable[Index[5]].KingThinking[0].AStarGreedy.Count == 0)
                        KingOnTable[Index[5]].KingThinking[0].AStarGreedy.Add(new AllDraw(Order * -1, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged));
                    KingOnTable[Index[5]].KingThinking[0].AStarGreedy[KingOnTable[Index[5]].KingThinking[0].AStarGreedy.Count - 1].TableList.Clear();
                    KingOnTable[Index[5]].KingThinking[0].AStarGreedy[KingOnTable[Index[5]].KingThinking[0].AStarGreedy.Count - 1].TableList.Add(CloneATable(KingOnTable[Index[5]].KingThinking[0].TableListKing[jIndex[5]]));
                    KingOnTable[Index[5]].KingThinking[0].AStarGreedy[KingOnTable[Index[5]].KingThinking[0].AStarGreedy.Count - 1].SetRowColumn(0);
                    KingOnTable[Index[5]].KingThinking[0].AStarGreedy[KingOnTable[Index[5]].KingThinking[0].AStarGreedy.Count - 1].AStarGreedyString = this;
                    var H = Task.Factory.StartNew(() => KingOnTable[Index[5]].KingThinking[0].AStarGreedy[KingOnTable[Index[5]].KingThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt(iAStarGreedy, KingOnTable[Index[5]].KingThinking[0].RowColumnKing[jIndex[5]][0], KingOnTable[Index[5]].KingThinking[0].RowColumnKing[jIndex[5]][1], a, KingOnTable[Index[5]].KingThinking[0].TableListKing[jIndex[5]], Order, false, FOUND, LeafAStarGreedy));
                    H.Wait();
                    H.Dispose();
                }
            }
        }//blitz for determination about best movment of every objects
        void BlitzGameTreeCreationThinkingTreeCastling(Color a, int[] Index, int[] jIndex, int Order, int iAStarGreedy, int ik, int j, bool FOUND, int LeafAStarGreedy)
        {
            Object O1 = new Object();
            lock (O1)
            {
                //when do permite
                if (Index[6] != -1)
                {
                    if (CastlingOnTable[Index[6]].CastlingThinking[0].AStarGreedy.Count == 0)
                        CastlingOnTable[Index[6]].CastlingThinking[0].AStarGreedy.Add(new AllDraw(Order * -1, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged));
                    CastlingOnTable[Index[6]].CastlingThinking[0].AStarGreedy[CastlingOnTable[Index[6]].CastlingThinking[0].AStarGreedy.Count - 1].TableList.Clear();
                    CastlingOnTable[Index[6]].CastlingThinking[0].AStarGreedy[CastlingOnTable[Index[6]].CastlingThinking[0].AStarGreedy.Count - 1].TableList.Add(CloneATable(CastlingOnTable[Index[6]].CastlingThinking[0].TableListCastling[jIndex[6]]));
                    CastlingOnTable[Index[6]].CastlingThinking[0].AStarGreedy[CastlingOnTable[Index[6]].CastlingThinking[0].AStarGreedy.Count - 1].SetRowColumn(0);
                    CastlingOnTable[Index[6]].CastlingThinking[0].AStarGreedy[CastlingOnTable[Index[6]].CastlingThinking[0].AStarGreedy.Count - 1].AStarGreedyString = this;
                    var H = Task.Factory.StartNew(() => CastlingOnTable[Index[6]].CastlingThinking[0].AStarGreedy[CastlingOnTable[Index[6]].CastlingThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt(iAStarGreedy, CastlingOnTable[Index[6]].CastlingThinking[0].RowColumnCastling[jIndex[6]][0], CastlingOnTable[Index[6]].CastlingThinking[0].RowColumnCastling[jIndex[6]][1], a, CastlingOnTable[Index[6]].CastlingThinking[0].TableListCastling[jIndex[6]], Order, false, FOUND, LeafAStarGreedy));
                    H.Wait();
                    H.Dispose();
                }
            }
        }
        //blitz for determination about best movment of every objects
        void BlitzGameThinkingTreeSolderBrown(ref int PreviousLessS, ref int[] Index, ref int[] jIndex, int Order, int iAStarGreedy, int ik, int j, bool FOUND, int LeafAStarGreedy)
        {
            for (ik = SodierMidle; ik < SodierHigh; ik++)
            {
                bool ac = false;
                var ah = Task.Factory.StartNew(() => ac = BlitzGameThinkingTreeBoundryConditions(ik, 1));
                ah.Wait();
                ah.Dispose();
                if (ac)
                    continue;
                //Soldier.
                //when there is computational lists
                for (j = 0; j < SolderesOnTable[ik].SoldierThinking[0].HeuristicListSolder.Count; j++)
                {
                    //when node is serving node continue
                    if (IsSupHuTrue(ik, j, 0, 1)
                   )
                        continue;
                    //when node is empty deeper and there is not computatiional node continue
                    var ah1 = Task.Factory.StartNew(() => ac = IsThereEmptyOrNonCalculatedAStarGreedyNode(Order, 1, ik, j));
                    ah1.Wait();
                    ah1.Dispose();
                    if (!ac)
                        continue;
                    //when node have kings dangoures ignore and continue.
                    var ah2 = Task.Factory.StartNew(() => ac = CheckeHuristci(CloneATable(SolderesOnTable[ik].SoldierThinking[0].TableListSolder[j]), Order, ik, j, 0));
                    ah2.Wait();
                    ah2.Dispose();
                    if (!ac)
                        continue;
                    //when is self
                    if (Order != AllDraw.OrderPlateDraw)
                    {
                        //when in learning autamata is penalty or Heuristic specified is less than specific dynamic programming var
                        if (UsedRestrictedBlitzMoveAstarGreedy(1, ik, j) || SolderesOnTable[ik].SoldierThinking[0].ReturnHeuristic(ik, j, Order, false, ref HaveKilled) < PreviousLessS || (SolderesOnTable[ik].SoldierThinking[0].PenaltyRegardListSolder[j].IsPenaltyAction() == 0 && UsePenaltyRegardMechnisamT))
                        {
                        }
                        else
                        {
                            Index[0] = ik;
                            jIndex[0] = j;
                            int Hav = HaveKilled;
                            int pre = PreviousLessS;
                            var ah3 = Task.Factory.StartNew(() => pre = SolderesOnTable[ik].SoldierThinking[0].ReturnHeuristic(ik, j, Order, false, ref Hav));
                            ah3.Wait();
                            ah3.Dispose();
                            HaveKilled = Hav;
                            PreviousLessS = pre;
                        }
                    }
                    else
                    {
                        //when in learning autamata is penalty or Heuristic specified is less than specific dynamic programming var
                        if (UsedRestrictedBlitzMoveAstarGreedy(1, ik, j) || SolderesOnTable[ik].SoldierThinking[0].ReturnHeuristic(ik, j, Order, false, ref HaveKilled) > PreviousLessS || (SolderesOnTable[ik].SoldierThinking[0].PenaltyRegardListSolder[j].IsPenaltyAction() == 0 && UsePenaltyRegardMechnisamT))
                        {
                        }
                        else
                        {
                            Index[0] = ik;
                            jIndex[0] = j;
                            int Hav = HaveKilled;
                            int pre = PreviousLessS;
                            var ah3 = Task.Factory.StartNew(() => pre = SolderesOnTable[ik].SoldierThinking[0].ReturnHeuristic(ik, j, Order, false, ref Hav));
                            ah3.Wait();
                            ah3.Dispose();
                            HaveKilled = Hav;
                            PreviousLessS = pre;
                        }
                    }
                }
            }
        }
        //blitz for determination about best movment of every objects
        void BlitzGameThinkingTreeElephantBrown(ref int PreviousLessE, ref int[] Index, ref int[] jIndex, int Order, int iAStarGreedy, int ik, int j, bool FOUND, int LeafAStarGreedy)
        {
            //Elephant
            for (ik = ElefantMidle; ik < ElefantHigh; ik++)
            {
                bool ac = false;
                var ah = Task.Factory.StartNew(() => ac = BlitzGameThinkingTreeBoundryConditions(ik, 2));
                ah.Wait();
                ah.Dispose();
                if (ac)
                    continue;
                //when there is computational lists
                for (j = 0; j < ElephantOnTable[ik].ElefantThinking[0].HeuristicListElefant.Count; j++)
                {
                    //when node is serving node continue
                    if (IsSupHuTrue(ik, j, 0, 2)
                 )
                        continue;
                    //when node is empty deeper and there is not computatiional node continue
                    var ah1 = Task.Factory.StartNew(() => ac = IsThereEmptyOrNonCalculatedAStarGreedyNode(Order, 2, ik, j));
                    ah1.Wait();
                    ah1.Dispose();
                    if (!ac)
                        continue;
                    //when node have kings dangoures ignore and continue.
                    var ah2 = Task.Factory.StartNew(() => ac = CheckeHuristci(CloneATable(ElephantOnTable[ik].ElefantThinking[0].TableListElefant[j]), Order, ik, j, 0));
                    ah2.Wait();
                    ah2.Dispose();
                    if (!ac)
                        continue;
                    //when is self
                    if (Order != AllDraw.OrderPlateDraw)
                    {
                        //when in learning autamata is penalty or Heuristic specified is less than specific dynamic programming var
                        if (UsedRestrictedBlitzMoveAstarGreedy(2, ik, j) || ElephantOnTable[ik].ElefantThinking[0].ReturnHeuristic(ik, j, Order, false, ref HaveKilled) < PreviousLessE || (ElephantOnTable[ik].ElefantThinking[0].PenaltyRegardListElefant[j].IsPenaltyAction() == 0 && UsePenaltyRegardMechnisamT))
                        {
                        }
                        else
                        {
                            Index[1] = ik;
                            jIndex[1] = j;
                            int Hav = HaveKilled;
                            int pre = PreviousLessE;
                            var ah3 = Task.Factory.StartNew(() => pre = ElephantOnTable[ik].ElefantThinking[0].ReturnHeuristic(ik, j, Order, false, ref Hav));
                            ah3.Wait();
                            ah3.Dispose();
                            HaveKilled = Hav;
                            PreviousLessE = pre;
                        }
                    }
                    else
                    {
                        //when in learning autamata is penalty or Heuristic specified is less than specific dynamic programming var
                        if (UsedRestrictedBlitzMoveAstarGreedy(2, ik, j) || ElephantOnTable[ik].ElefantThinking[0].ReturnHeuristic(ik, j, Order, false, ref HaveKilled) > PreviousLessE || (ElephantOnTable[ik].ElefantThinking[0].PenaltyRegardListElefant[j].IsPenaltyAction() == 0 && UsePenaltyRegardMechnisamT))
                        {
                        }
                        else
                        {
                            Index[1] = ik;
                            jIndex[1] = j;
                            int Hav = HaveKilled;
                            int pre = PreviousLessE;
                            var ah3 = Task.Factory.StartNew(() => pre = ElephantOnTable[ik].ElefantThinking[0].ReturnHeuristic(ik, j, Order, false, ref Hav));
                            ah3.Wait();
                            ah3.Dispose();
                            HaveKilled = Hav;
                            PreviousLessE = pre;
                        }
                    }
                }
            }
        }
        //blitz for determination about best movment of every objects
        void BlitzGameThinkingTreeHourseBrown(ref int PreviousLessH, ref int[] Index, ref int[] jIndex, int Order, int iAStarGreedy, int ik, int j, bool FOUND, int LeafAStarGreedy)
        {
            //Hourse.
            for (ik = HourseMidle; ik < HourseHight; ik++)
            {
                bool ac = false;
                var ah = Task.Factory.StartNew(() => ac = BlitzGameThinkingTreeBoundryConditions(ik, 3));
                ah.Wait();
                ah.Dispose();
                if (ac)
                    continue;
                //when there is computational lists
                for (j = 0; j < HoursesOnTable[ik].HourseThinking[0].HeuristicListHourse.Count; j++)
                {
                    //when node is serving node continue
                    if (HoursesOnTable[ik].HourseThinking[0].IsSupHu[j]
                    )
                        continue;
                    //when node is empty deeper and there is not computatiional node continue
                    var ah1 = Task.Factory.StartNew(() => ac = IsThereEmptyOrNonCalculatedAStarGreedyNode(Order, 3, ik, j));
                    ah1.Wait();
                    ah1.Dispose();
                    if (!ac)
                        continue;
                    //when node have kings dangoures ignore and continue.
                    var ah2 = Task.Factory.StartNew(() => ac = CheckeHuristci(CloneATable(HoursesOnTable[ik].HourseThinking[0].TableListHourse[j]), Order, ik, j, 0));
                    ah2.Wait();
                    ah2.Dispose();
                    if (!ac)
                        continue;
                    //when is self
                    if (Order != AllDraw.OrderPlateDraw)
                    {
                        //when in learning autamata is penalty or Heuristic specified is less than specific dynamic programming var
                        if (UsedRestrictedBlitzMoveAstarGreedy(3, ik, j) || HoursesOnTable[ik].HourseThinking[0].ReturnHeuristic(ik, j, Order, false, ref HaveKilled) < PreviousLessH || (HoursesOnTable[ik].HourseThinking[0].PenaltyRegardListHourse[j].IsPenaltyAction() == 0 && UsePenaltyRegardMechnisamT))
                        {
                        }
                        else
                        {
                            Index[2] = ik;
                            jIndex[2] = j;
                            int Hav = HaveKilled;
                            int pre = PreviousLessH;
                            var ah3 = Task.Factory.StartNew(() => pre = HoursesOnTable[ik].HourseThinking[0].ReturnHeuristic(ik, j, Order, false, ref Hav));
                            ah3.Wait();
                            ah3.Dispose();
                            HaveKilled = Hav;
                            PreviousLessH = pre;
                        }
                    }
                    else
                    {
                        //when in learning autamata is penalty or Heuristic specified is less than specific dynamic programming var
                        if (UsedRestrictedBlitzMoveAstarGreedy(3, ik, j) || HoursesOnTable[ik].HourseThinking[0].ReturnHeuristic(ik, j, Order, false, ref HaveKilled) > PreviousLessH || (HoursesOnTable[ik].HourseThinking[0].PenaltyRegardListHourse[j].IsPenaltyAction() == 0 && UsePenaltyRegardMechnisamT))
                        {
                        }
                        else
                        {
                            Index[2] = ik;
                            jIndex[2] = j;
                            int Hav = HaveKilled;
                            int pre = PreviousLessH;
                            var ah3 = Task.Factory.StartNew(() => pre = HoursesOnTable[ik].HourseThinking[0].ReturnHeuristic(ik, j, Order, false, ref Hav));
                            ah3.Wait();
                            ah3.Dispose();
                            HaveKilled = Hav;
                            PreviousLessH = pre;
                        }
                    }
                }
            }
        }
        bool AllIndexIsNull(int[] iIndex)
        {
            bool Is = true;
            for (int i = 0; i < 6; i++)
            {
                if (iIndex[i] != -1)
                    Is = false;
            }
            return Is;
        }
        //main blitz for determination about best movment of every objects
        public int FullGameMakimgBlitz(ref int[] Index, ref int[] jIndex, int Order, int LeafAStarGreedy)
        {
            int Kind = -1;
            int PS = Int32.MinValue, PE = Int32.MinValue, PH = Int32.MinValue, PB = Int32.MinValue, PM = Int32.MinValue, PK = Int32.MinValue, PA = Int32.MinValue;
            if (Order != AllDraw.OrderPlateDraw)
            {
                PS = Int32.MaxValue;
                PE = Int32.MaxValue;
                PH = Int32.MaxValue;
                PB = Int32.MaxValue;
                PM = Int32.MaxValue;
                PK = Int32.MaxValue;
                PA = Int32.MaxValue;
            }
            int[] index = { -1, -1, -1, -1, -1, -1, -1 };
            int[] jindex = { -1, -1, -1, -1, -1, -1, -1 };
            if (Order == 1)
            {
                Object O = new Object();
                lock (O)
                {

                    BlitzGameThinkingTreeSolderGray(ref PS, ref index, ref jindex, Order, 0, 0, 0, false, LeafAStarGreedy);
                    BlitzGameThinkingTreeElephantGray(ref PE, ref index, ref jindex, Order, 0, 0, 0, false, LeafAStarGreedy);
                    BlitzGameThinkingTreeHourseGray(ref PH, ref index, ref jindex, Order, 0, 0, 0, false, LeafAStarGreedy);
                    BlitzGameThinkingTreeCastleGray(ref PB, ref index, ref jindex, Order, 0, 0, 0, false, LeafAStarGreedy);
                    BlitzGameThinkingTreeMinisterGray(ref PM, ref index, ref jindex, Order, 0, 0, 0, false, LeafAStarGreedy);
                    BlitzGameThinkingTreeKingGray(ref PK, ref index, ref jindex, Order, 0, 0, 0, false, LeafAStarGreedy);
                    BlitzGameThinkingTreeCastlingGray(ref PA, ref index, ref jindex, Order, 0, 0, 0, false, LeafAStarGreedy);

                    if (AllIndexIsNull(index))
                    {
                        Kind = -1;
                        PS = Int32.MinValue; PE = Int32.MinValue; PH = Int32.MinValue; PB = Int32.MinValue; PM = Int32.MinValue; PK = Int32.MinValue; PA = Int32.MinValue;
                        if (Order != AllDraw.OrderPlateDraw)
                        {
                            PS = Int32.MaxValue;
                            PE = Int32.MaxValue;
                            PH = Int32.MaxValue;
                            PB = Int32.MaxValue;
                            PM = Int32.MaxValue;
                            PK = Int32.MaxValue;
                            PA = Int32.MaxValue;
                        }
                        for (int h = 0; h < 7; h++)
                        {
                            index[h] = -1;
                            jindex[h] = -1;
                        }
                        UsedRestrictedMoveBlitzAndFull = false;
                        BlitzGameThinkingTreeSolderGray(ref PS, ref index, ref jindex, Order, 0, 0, 0, false, LeafAStarGreedy);
                        BlitzGameThinkingTreeElephantGray(ref PE, ref index, ref jindex, Order, 0, 0, 0, false, LeafAStarGreedy);
                        BlitzGameThinkingTreeHourseGray(ref PH, ref index, ref jindex, Order, 0, 0, 0, false, LeafAStarGreedy);
                        BlitzGameThinkingTreeCastleGray(ref PB, ref index, ref jindex, Order, 0, 0, 0, false, LeafAStarGreedy);
                        BlitzGameThinkingTreeMinisterGray(ref PM, ref index, ref jindex, Order, 0, 0, 0, false, LeafAStarGreedy);
                        BlitzGameThinkingTreeKingGray(ref PK, ref index, ref jindex, Order, 0, 0, 0, false, LeafAStarGreedy);
                        BlitzGameThinkingTreeCastlingGray(ref PA, ref index, ref jindex, Order, 0, 0, 0, false, LeafAStarGreedy);
                    }
                }
            }
            else
            {
                Object O = new Object();
                lock (O)
                {
                    BlitzGameThinkingTreeSolderBrown(ref PS, ref index, ref jindex, Order, 0, 0, 0, false, LeafAStarGreedy);
                    BlitzGameThinkingTreeElephantBrown(ref PE, ref index, ref jindex, Order, 0, 0, 0, false, LeafAStarGreedy);
                    BlitzGameThinkingTreeHourseBrown(ref PH, ref index, ref jindex, Order, 0, 0, 0, false, LeafAStarGreedy);
                    BlitzGameThinkingTreeCastleBrown(ref PB, ref index, ref jindex, Order, 0, 0, 0, false, LeafAStarGreedy);
                    BlitzGameThinkingTreeMinisterBrown(ref PM, ref index, ref jindex, Order, 0, 0, 0, false, LeafAStarGreedy);
                    BlitzGameThinkingTreeKingBrown(ref PK, ref index, ref jindex, Order, 0, 0, 0, false, LeafAStarGreedy);
                    BlitzGameThinkingTreeCastlingBrown(ref PA, ref index, ref jindex, Order, 0, 0, 0, false, LeafAStarGreedy);
                    if (AllIndexIsNull(index))
                    {
                        Kind = -1;
                        PS = Int32.MinValue; PE = Int32.MinValue; PH = Int32.MinValue; PB = Int32.MinValue; PM = Int32.MinValue; PK = Int32.MinValue; PA = Int32.MinValue;
                        if (Order != AllDraw.OrderPlateDraw)
                        {
                            PS = Int32.MaxValue;
                            PE = Int32.MaxValue;
                            PH = Int32.MaxValue;
                            PB = Int32.MaxValue;
                            PM = Int32.MaxValue;
                            PK = Int32.MaxValue;
                            PA = Int32.MaxValue;
                        }
                        for (int h = 0; h < 7; h++)
                        {
                            index[h] = -1;
                            jindex[h] = -1;
                        }
                        UsedRestrictedMoveBlitzAndFull = false;
                        BlitzGameThinkingTreeSolderBrown(ref PS, ref index, ref jindex, Order, 0, 0, 0, false, LeafAStarGreedy);
                        BlitzGameThinkingTreeElephantBrown(ref PE, ref index, ref jindex, Order, 0, 0, 0, false, LeafAStarGreedy);
                        BlitzGameThinkingTreeHourseBrown(ref PH, ref index, ref jindex, Order, 0, 0, 0, false, LeafAStarGreedy);
                        BlitzGameThinkingTreeCastleBrown(ref PB, ref index, ref jindex, Order, 0, 0, 0, false, LeafAStarGreedy);
                        BlitzGameThinkingTreeMinisterBrown(ref PM, ref index, ref jindex, Order, 0, 0, 0, false, LeafAStarGreedy);
                        BlitzGameThinkingTreeKingBrown(ref PK, ref index, ref jindex, Order, 0, 0, 0, false, LeafAStarGreedy);
                        BlitzGameThinkingTreeCastlingBrown(ref PA, ref index, ref jindex, Order, 0, 0, 0, false, LeafAStarGreedy);
                    }
                }
            }
            int JI = -1;
            Object O1 = new Object();
            lock (O1)
            {
                if (Order == OrderPlate)
                    JI = MaxOfSixHeuristic(PS, PE, PH, PB, PM, PK, PA);
                else
                    JI = MinOfSixHeuristic(PS, PE, PH, PB, PM, PK, PA);
            }
            if (JI != -1)
            {
                Kind = JI;
                for (var i = 0; i < 7; i++)
                {
                    Object O = new Object();
                    lock (O)
                    {
                        Index[i] = index[i];
                        jIndex[i] = jindex[i];
                    }
                }
            }
            return System.Math.Abs(Kind);
        }
        //blitz for determination about best movment of every objects
        void BlitzGameThinkingTreeCastleBrown(ref int PreviousLessB, ref int[] Index, ref int[] jIndex, int Order, int iAStarGreedy, int ik, int j, bool FOUND, int LeafAStarGreedy)
        {
            //Castles.
            for (ik = CastleMidle; ik < CastleHigh; ik++)
            {
                bool ac = false;
                var ah = Task.Factory.StartNew(() => ac = BlitzGameThinkingTreeBoundryConditions(ik, 4));
                ah.Wait();
                ah.Dispose();
                if (ac)
                    continue;
                //when there is computational lists
                for (j = 0; j < CastlesOnTable[ik].CastleThinking[0].HeuristicListCastle.Count; j++)
                {
                    //when node is serving node continue
                    if (IsSupHuTrue(ik, j, 0, 4)
                    )
                        continue;
                    //when node is empty deeper and there is not computatiional node continue
                    var ah1 = Task.Factory.StartNew(() => ac = IsThereEmptyOrNonCalculatedAStarGreedyNode(Order, 4, ik, j));
                    ah1.Wait();
                    ah1.Dispose();
                    if (!ac)
                        continue;
                    //when node have kings dangoures ignore and continue.
                    var ah2 = Task.Factory.StartNew(() => ac = CheckeHuristci(CloneATable(CastlesOnTable[ik].CastleThinking[0].TableListCastle[j]), Order, ik, j, 0));
                    ah2.Wait();
                    ah2.Dispose();
                    if (!ac)
                        continue;
                    //when is self
                    if (Order != AllDraw.OrderPlateDraw)
                    {
                        //when in learning autamata is penalty or Heuristic specified is less than specific dynamic programming var
                        if (UsedRestrictedBlitzMoveAstarGreedy(4, ik, j) || CastlesOnTable[ik].CastleThinking[0].ReturnHeuristic(ik, j, Order, false, ref HaveKilled) < PreviousLessB || (CastlesOnTable[ik].CastleThinking[0].PenaltyRegardListCastle[j].IsPenaltyAction() == 0 && UsePenaltyRegardMechnisamT))
                        {
                        }
                        else
                        {
                            Index[3] = ik;
                            jIndex[3] = j;
                            int Hav = HaveKilled;
                            int pre = PreviousLessB;

                            var ah3 = Task.Factory.StartNew(() => pre = CastlesOnTable[ik].CastleThinking[0].ReturnHeuristic(ik, j, Order, false, ref Hav));
                            ah3.Wait();
                            ah3.Dispose();
                            HaveKilled = Hav;
                            PreviousLessB = pre;

                        }
                    }
                    else
                    {
                        //when in learning autamata is penalty or Heuristic specified is less than specific dynamic programming var
                        if (UsedRestrictedBlitzMoveAstarGreedy(4, ik, j) || CastlesOnTable[ik].CastleThinking[0].ReturnHeuristic(ik, j, Order, false, ref HaveKilled) > PreviousLessB || (CastlesOnTable[ik].CastleThinking[0].PenaltyRegardListCastle[j].IsPenaltyAction() == 0 && UsePenaltyRegardMechnisamT))
                        {
                        }
                        else
                        {
                            Index[3] = ik;
                            jIndex[3] = j;
                            int Hav = HaveKilled;
                            int pre = PreviousLessB;
                            var ah3 = Task.Factory.StartNew(() => pre = CastlesOnTable[ik].CastleThinking[0].ReturnHeuristic(ik, j, Order, false, ref Hav));
                            ah3.Wait();
                            ah3.Dispose();
                            HaveKilled = Hav;
                            PreviousLessB = pre;
                        }
                    }
                }
            }
        }
        //blitz for determination about best movment of every objects
        void BlitzGameThinkingTreeMinisterBrown(ref int PreviousLessM, ref int[] Index, ref int[] jIndex, int Order, int iAStarGreedy, int ik, int j, bool FOUND, int LeafAStarGreedy)
        {
            //Minister.
            for (ik = MinisterMidle; ik < MinisterHigh; ik++)
            {
                bool ac = false;
                var ah = Task.Factory.StartNew(() => ac = BlitzGameThinkingTreeBoundryConditions(ik, 5));
                ah.Wait();
                ah.Dispose();
                if (ac)
                    continue;
                //when there is computational lists
                for (j = 0; j < MinisterOnTable[ik].MinisterThinking[0].HeuristicListMinister.Count; j++)
                {
                    //when node is serving node continue
                    if (IsSupHuTrue(ik, j, 0, 5)
                      )
                        continue;
                    //when node is empty deeper and there is not computatiional node continue
                    var ah1 = Task.Factory.StartNew(() => ac = IsThereEmptyOrNonCalculatedAStarGreedyNode(Order, 5, ik, j));
                    ah1.Wait();
                    ah1.Dispose();
                    if (!ac)
                        continue;
                    //when node have kings dangoures ignore and continue.
                    var ah2 = Task.Factory.StartNew(() => ac = CheckeHuristci(CloneATable(MinisterOnTable[ik].MinisterThinking[0].TableListMinister[j]), Order, ik, j, 0));
                    ah2.Wait();
                    ah2.Dispose();
                    if (!ac)
                        continue;
                    //when is self
                    if (Order != AllDraw.OrderPlateDraw)
                    {
                        //when in learning autamata is penalty or Heuristic specified is less than specific dynamic programming var
                        if (UsedRestrictedBlitzMoveAstarGreedy(5, ik, j) || MinisterOnTable[ik].MinisterThinking[0].ReturnHeuristic(ik, j, Order, false, ref HaveKilled) < PreviousLessM || (MinisterOnTable[ik].MinisterThinking[0].PenaltyRegardListMinister[j].IsPenaltyAction() == 0 && UsePenaltyRegardMechnisamT))
                        {
                        }
                        else
                        //if (KingDan(MinisterOnTable[ik].MinisterThinking[0].TableListMinister[j], Order))
                        {
                            Index[4] = ik;
                            jIndex[4] = j;
                            int Hav = HaveKilled;
                            int pre = PreviousLessM;
                            var ah3 = Task.Factory.StartNew(() => pre = MinisterOnTable[ik].MinisterThinking[0].ReturnHeuristic(ik, j, Order, false, ref Hav));
                            ah3.Wait();
                            ah3.Dispose();
                            HaveKilled = Hav;
                            PreviousLessM = pre;
                        }
                    }
                    else
                    {
                        //when in learning autamata is penalty or Heuristic specified is less than specific dynamic programming var
                        if (UsedRestrictedBlitzMoveAstarGreedy(5, ik, j) || MinisterOnTable[ik].MinisterThinking[0].ReturnHeuristic(ik, j, Order, false, ref HaveKilled) > PreviousLessM || (MinisterOnTable[ik].MinisterThinking[0].PenaltyRegardListMinister[j].IsPenaltyAction() == 0 && UsePenaltyRegardMechnisamT))
                        {
                        }
                        else
                        //if (KingDan(MinisterOnTable[ik].MinisterThinking[0].TableListMinister[j], Order))
                        {
                            Index[4] = ik;
                            jIndex[4] = j;
                            int Hav = HaveKilled;
                            int pre = PreviousLessM;
                            var ah3 = Task.Factory.StartNew(() => pre = MinisterOnTable[ik].MinisterThinking[0].ReturnHeuristic(ik, j, Order, false, ref Hav));
                            ah3.Wait();
                            ah3.Dispose();
                            HaveKilled = Hav;
                            PreviousLessM = pre;
                        }
                    }
                }
            }
        }
        //blitz for determination about best movment of every objects
        void BlitzGameThinkingTreeKingBrown(ref int PreviousLessK, ref int[] Index, ref int[] jIndex, int Order, int iAStarGreedy, int ik, int j, bool FOUND, int LeafAStarGreedy)
        {
            //King.
            for (ik = KingMidle; ik < KingHigh; ik++)
            {
                bool ac = false;
                var ah = Task.Factory.StartNew(() => ac = BlitzGameThinkingTreeBoundryConditions(ik, 6));
                ah.Wait();
                ah.Dispose();
                if (ac) continue;
                //when there is computational lists
                for (j = 0; j < KingOnTable[ik].KingThinking[0].HeuristicListKing.Count; j++)
                {
                    //when node is serving node continue
                    if (IsSupHuTrue(ik, j, 0, 6)
                     )
                        continue;
                    //when node is empty deeper and there is not computatiional node continue
                    var ah1 = Task.Factory.StartNew(() => ac = IsThereEmptyOrNonCalculatedAStarGreedyNode(Order, 6, ik, j));
                    ah1.Wait();
                    ah1.Dispose();
                    if (!ac)
                        continue;
                    //when node have kings dangoures ignore and continue.
                    var ah2 = Task.Factory.StartNew(() => ac = CheckeHuristci(CloneATable(KingOnTable[ik].KingThinking[0].TableListKing[j]), Order, ik, j, 0));
                    ah2.Wait();
                    ah2.Dispose();
                    if (!ac)
                        continue;
                    //when is self
                    if (Order != AllDraw.OrderPlateDraw)
                    {
                        //when in learning autamata is penalty or Heuristic specified is less than specific dynamic programming var
                        if (UsedRestrictedBlitzMoveAstarGreedy(6, ik, j) || KingOnTable[ik].KingThinking[0].ReturnHeuristic(ik, j, Order, false, ref HaveKilled) < PreviousLessK || (KingOnTable[ik].KingThinking[0].PenaltyRegardListKing[j].IsPenaltyAction() == 0 && UsePenaltyRegardMechnisamT))
                        {
                        }
                        else
                        {
                            Index[5] = ik;
                            jIndex[5] = j;
                            int Hav = HaveKilled;
                            int pre = PreviousLessK;
                            var ah3 = Task.Factory.StartNew(() => pre = KingOnTable[ik].KingThinking[0].ReturnHeuristic(ik, j, Order, false, ref Hav));
                            ah3.Wait();
                            ah3.Dispose();
                            HaveKilled = Hav;
                            PreviousLessK = pre;

                        }
                    }
                    else
                    {
                        //when in learning autamata is penalty or Heuristic specified is less than specific dynamic programming var
                        if (UsedRestrictedBlitzMoveAstarGreedy(6, ik, j) || KingOnTable[ik].KingThinking[0].ReturnHeuristic(ik, j, Order, false, ref HaveKilled) > PreviousLessK || (KingOnTable[ik].KingThinking[0].PenaltyRegardListKing[j].IsPenaltyAction() == 0 && UsePenaltyRegardMechnisamT))
                        {
                        }
                        else
                        {
                            Index[5] = ik;
                            jIndex[5] = j;
                            int Hav = HaveKilled;
                            int pre = PreviousLessK;
                            var ah3 = Task.Factory.StartNew(() => pre = KingOnTable[ik].KingThinking[0].ReturnHeuristic(ik, j, Order, false, ref Hav));
                            ah3.Wait();
                            ah3.Dispose();
                            HaveKilled = Hav;
                            PreviousLessK = pre;
                        }
                    }
                }
            }
        }
        //blitz for determination about best movment of every objects
        void BlitzGameThinkingTreeCastlingBrown(ref int PreviousLessK, ref int[] Index, ref int[] jIndex, int Order, int iAStarGreedy, int ik, int j, bool FOUND, int LeafAStarGreedy)
        {
            //Castling.
            for (ik = 0; ik < 1; ik++)
            {
                bool ac = false;
                var ah = Task.Factory.StartNew(() => ac = BlitzGameThinkingTreeBoundryConditions(ik, -7));
                ah.Wait();
                ah.Dispose();
                if (ac)
                    continue;
                //when there is computational lists
                for (j = 0; j < CastlingOnTable[ik].CastlingThinking[0].HeuristicListCastling.Count; j++)
                {
                    //when node is serving node continue
                    if (IsSupHuTrue(ik, j, 0, 7)
                      )
                        continue;
                    Object O = new Object();
                    lock (O)
                    {
                        //when node is empty deeper and there is not computatiional node continue
                        var ah1 = Task.Factory.StartNew(() => ac = IsThereEmptyOrNonCalculatedAStarGreedyNode(Order, 7, ik, j));
                        ah1.Wait();
                        ah1.Dispose();
                        if (!ac)
                            continue;
                        //when node have Castlings dangoures ignore and continue.
                        var ah2 = Task.Factory.StartNew(() => ac = CheckeHuristci(CloneATable(CastlingOnTable[ik].CastlingThinking[0].TableListCastling[j]), Order, ik, j, 0));
                        ah2.Wait();
                        ah2.Dispose();
                        if (!ac)
                            continue;
                        //when is self
                        if (Order != AllDraw.OrderPlateDraw)
                        {
                            //when in learning autamata is penalty or Heuristic specified is less than specific dynamic programming var
                            if (UsedRestrictedBlitzMoveAstarGreedy(7, ik, j) || CastlingOnTable[ik].CastlingThinking[0].ReturnHeuristic(ik, j, Order, false, ref HaveKilled) < PreviousLessK || (CastlingOnTable[ik].CastlingThinking[0].PenaltyRegardListCastling[j].IsPenaltyAction() == 0 && UsePenaltyRegardMechnisamT))
                            {
                            }
                            else
                            {
                                Index[6] = ik;
                                jIndex[6] = j;
                                int Hav = HaveKilled;
                                int pre = PreviousLessK;
                                var ah3 = Task.Factory.StartNew(() => pre = CastlingOnTable[ik].CastlingThinking[0].ReturnHeuristic(ik, j, Order, false, ref Hav));
                                ah3.Wait();
                                ah3.Dispose();
                                HaveKilled = Hav;
                                PreviousLessK = pre;
                            }
                        }
                        else
                        {
                            //when in learning autamata is penalty or Heuristic specified is less than specific dynamic programming var
                            if (UsedRestrictedBlitzMoveAstarGreedy(6, ik, j) || CastlingOnTable[ik].CastlingThinking[0].ReturnHeuristic(ik, j, Order, false, ref HaveKilled) > PreviousLessK || (CastlingOnTable[ik].CastlingThinking[0].PenaltyRegardListCastling[j].IsPenaltyAction() == 0 && UsePenaltyRegardMechnisamT))
                            {
                            }
                            else
                            {
                                Index[6] = ik;
                                jIndex[6] = j;
                                int Hav = HaveKilled;
                                int pre = PreviousLessK;
                                var ah3 = Task.Factory.StartNew(() => pre = CastlingOnTable[ik].CastlingThinking[0].ReturnHeuristic(ik, j, Order, false, ref Hav));
                                ah3.Wait();
                                ah3.Dispose();
                                HaveKilled = Hav;
                                PreviousLessK = pre;
                            }
                        }
                    }
                }
            }
        }
        void BlitzGameThinkingTree(int Order, int iAStarGreedy, int ik, int j, bool FOUND, int LeafAStarGreedy)
        {

            //Initiatye Variables.
            int DummyOrder = Order;
            int DummyCurrentOrder = ChessRules.CurrentOrder;
            Color a;
            if (Order == 1)
                a = Color.Gray;
            else
                a = Color.Brown;


            int[] Index = new int[7];
            int[] jIndex = new int[7];
            int PreviousLessS = Int32.MinValue, PreviousLessE = Int32.MinValue, PreviousLessH = Int32.MinValue, PreviousLessB = Int32.MinValue, PreviousLessM = Int32.MinValue, PreviousLessK = Int32.MinValue, PreviousLessA = Int32.MinValue;
            if (Order != OrderPlate)
            {
                PreviousLessS = Int32.MaxValue;
                PreviousLessE = Int32.MaxValue;
                PreviousLessH = Int32.MaxValue;
                PreviousLessB = Int32.MaxValue;
                PreviousLessM = Int32.MaxValue;
                PreviousLessK = Int32.MaxValue;
                PreviousLessA = Int32.MaxValue;
            }

            if (Order == 1)
            {
                Object O1 = new Object();
                lock (O1)
                {
                    Index[0] = -1;
                    BlitzGameThinkingTreeSolderGray(ref PreviousLessS, ref Index, ref jIndex, Order, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ik, j, FOUND, LeafAStarGreedy);
                    Index[1] = -1;
                    BlitzGameThinkingTreeElephantGray(ref PreviousLessE, ref Index, ref jIndex, Order, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ik, j, FOUND, LeafAStarGreedy);
                    Index[2] = -1;
                    BlitzGameThinkingTreeHourseGray(ref PreviousLessH, ref Index, ref jIndex, Order, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ik, j, FOUND, LeafAStarGreedy);
                    Index[3] = -1;
                    BlitzGameThinkingTreeCastleGray(ref PreviousLessB, ref Index, ref jIndex, Order, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ik, j, FOUND, LeafAStarGreedy);
                    Index[4] = -1;
                    BlitzGameThinkingTreeMinisterGray(ref PreviousLessM, ref Index, ref jIndex, Order, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ik, j, FOUND, LeafAStarGreedy);
                    Index[5] = -1;
                    BlitzGameThinkingTreeKingGray(ref PreviousLessK, ref Index, ref jIndex, Order, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ik, j, FOUND, LeafAStarGreedy);
                    Index[6] = -1;
                    BlitzGameThinkingTreeCastlingGray(ref PreviousLessA, ref Index, ref jIndex, Order, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ik, j, FOUND, LeafAStarGreedy);
                }
                int JI = -1;
                Object O2 = new Object();
                lock (O2)
                {
                    JI = MaxOfSixHeuristic(PreviousLessS, PreviousLessE, PreviousLessH, PreviousLessB, PreviousLessM, PreviousLessK, PreviousLessA);
                }
                Object O3 = new Object();
                lock (O3)
                {
                    if (JI != -1)
                    {
                        if (JI == 0)
                            BlitzGameTreeCreationThinkingTreeSolder(a, Index, jIndex, Order * -1, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ik, j, FOUND, LeafAStarGreedy);
                        //Initiatye Variables.
                        Order = DummyOrder;
                        ChessRules.CurrentOrder = DummyCurrentOrder;

                        if (Order == 1)
                            a = Color.Gray;
                        else
                            a = Color.Brown;


                        if (JI == 1)
                            BlitzGameTreeCreationThinkingTreeElephant(a, Index, jIndex, Order * -1, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ik, j, FOUND, LeafAStarGreedy);
                        //Initiatye Variables.
                        Order = DummyOrder;
                        ChessRules.CurrentOrder = DummyCurrentOrder;

                        if (Order == 1)
                            a = Color.Gray;
                        else
                            a = Color.Brown;


                        if (JI == 2)
                            BlitzGameTreeCreationThinkingTreeHourse(a, Index, jIndex, Order * -1, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ik, j, FOUND, LeafAStarGreedy);
                        //Initiatye Variables.
                        Order = DummyOrder;
                        ChessRules.CurrentOrder = DummyCurrentOrder;

                        if (Order == 1)
                            a = Color.Gray;
                        else
                            a = Color.Brown;


                        if (JI == 3)
                            BlitzGameTreeCreationThinkingTreeCastle(a, Index, jIndex, Order * -1, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ik, j, FOUND, LeafAStarGreedy);
                        //Initiatye Variables.
                        Order = DummyOrder;
                        ChessRules.CurrentOrder = DummyCurrentOrder;

                        if (Order == 1)
                            a = Color.Gray;
                        else
                            a = Color.Brown;


                        if (JI == 4)
                            BlitzGameTreeCreationThinkingTreeMinister(a, Index, jIndex, Order * -1, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ik, j, FOUND, LeafAStarGreedy);
                        //Initiatye Variables.
                        Order = DummyOrder;
                        ChessRules.CurrentOrder = DummyCurrentOrder;

                        if (Order == 1)
                            a = Color.Gray;
                        else
                            a = Color.Brown;


                        if (JI == 5)
                            BlitzGameTreeCreationThinkingTreeKing(a, Index, jIndex, Order * -1, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ik, j, FOUND, LeafAStarGreedy);
                        Order = DummyOrder;
                        ChessRules.CurrentOrder = DummyCurrentOrder;

                        if (Order == 1)
                            a = Color.Gray;
                        else
                            a = Color.Brown;


                        if (JI == 6)
                            BlitzGameTreeCreationThinkingTreeCastling(a, Index, jIndex, Order * -1, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ik, j, FOUND, LeafAStarGreedy);
                    }
                }
            }
            //For Brown Order Blitz Game Calculate Maximum Heuristic Inclusive AStarGreedy First Game Search.
            else
            {
                Object O1 = new Object();
                lock (O1)
                {
                    Index[0] = -1;
                    BlitzGameThinkingTreeSolderBrown(ref PreviousLessS, ref Index, ref jIndex, Order, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ik, j, FOUND, LeafAStarGreedy);
                    Index[1] = -1;
                    BlitzGameThinkingTreeElephantBrown(ref PreviousLessE, ref Index, ref jIndex, Order, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ik, j, FOUND, LeafAStarGreedy);
                    Index[2] = -1;
                    BlitzGameThinkingTreeHourseBrown(ref PreviousLessH, ref Index, ref jIndex, Order, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ik, j, FOUND, LeafAStarGreedy);
                    Index[3] = -1;
                    BlitzGameThinkingTreeCastleBrown(ref PreviousLessB, ref Index, ref jIndex, Order, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ik, j, FOUND, LeafAStarGreedy);
                    Index[4] = -1;
                    BlitzGameThinkingTreeMinisterBrown(ref PreviousLessM, ref Index, ref jIndex, Order, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ik, j, FOUND, LeafAStarGreedy);
                    Index[5] = -1;
                    BlitzGameThinkingTreeKingBrown(ref PreviousLessK, ref Index, ref jIndex, Order, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ik, j, FOUND, LeafAStarGreedy);
                    Index[6] = -1;
                    BlitzGameThinkingTreeCastlingBrown(ref PreviousLessA, ref Index, ref jIndex, Order, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ik, j, FOUND, LeafAStarGreedy);
                }
                int JI = -1;
                Object O2 = new Object();
                lock (O2)
                {
                    JI = MaxOfSixHeuristic(PreviousLessS, PreviousLessE, PreviousLessH, PreviousLessB, PreviousLessM, PreviousLessK, PreviousLessA);
                }
                Object O3 = new Object();
                lock (O3)
                {
                    if (JI != -1)
                    {
                        BlitzGameTreeCreationThinkingTreeSolder(a, Index, jIndex, Order * -1, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ik, j, FOUND, LeafAStarGreedy);
                        //Initiatye Variables.
                        Order = DummyOrder;
                        ChessRules.CurrentOrder = DummyCurrentOrder;

                        if (Order == 1)
                            a = Color.Gray;
                        else
                            a = Color.Brown;
                        BlitzGameTreeCreationThinkingTreeElephant(a, Index, jIndex, Order * -1, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ik, j, FOUND, LeafAStarGreedy);
                        //Initiatye Variables.
                        Order = DummyOrder;
                        ChessRules.CurrentOrder = DummyCurrentOrder;

                        if (Order == 1)
                            a = Color.Gray;
                        else
                            a = Color.Brown;
                        if (JI == 2)
                            BlitzGameTreeCreationThinkingTreeHourse(a, Index, jIndex, Order * -1, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ik, j, FOUND, LeafAStarGreedy);
                        //Initiatye Variables.
                        Order = DummyOrder;
                        ChessRules.CurrentOrder = DummyCurrentOrder;

                        if (Order == 1)
                            a = Color.Gray;
                        else
                            a = Color.Brown;
                        if (JI == 3)
                            BlitzGameTreeCreationThinkingTreeCastle(a, Index, jIndex, Order * -1, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ik, j, FOUND, LeafAStarGreedy);
                        //Initiatye Variables.
                        Order = DummyOrder;
                        ChessRules.CurrentOrder = DummyCurrentOrder;

                        if (Order == 1)
                            a = Color.Gray;
                        else
                            a = Color.Brown;


                        if (JI == 4)
                            BlitzGameTreeCreationThinkingTreeMinister(a, Index, jIndex, Order * -1, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ik, j, FOUND, LeafAStarGreedy);
                        //Initiatye Variables.
                        Order = DummyOrder;
                        ChessRules.CurrentOrder = DummyCurrentOrder;

                        if (Order == 1)
                            a = Color.Gray;
                        else
                            a = Color.Brown;
                        if (JI == 5)
                            BlitzGameTreeCreationThinkingTreeKing(a, Index, jIndex, Order * -1, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ik, j, FOUND, LeafAStarGreedy);

                        Order = DummyOrder;
                        ChessRules.CurrentOrder = DummyCurrentOrder;

                        if (Order == 1)
                            a = Color.Gray;
                        else
                            a = Color.Brown;


                        if (JI == 6)
                            BlitzGameTreeCreationThinkingTreeCastling(a, Index, jIndex, Order * -1, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ik, j, FOUND, LeafAStarGreedy);
                    }
                }
            }

        }
        //calculate statistic move
        String Alphabet(int RowRealesed)
        {

            String A = "";
            if (RowRealesed == 0)
                A = "a";
            else
                if (RowRealesed == 1)
                A = "b";
            else
                    if (RowRealesed == 2)
                A = "c";
            else
                        if (RowRealesed == 3)
                A = "d";
            else
                            if (RowRealesed == 4)
                A = "e";
            else
                                if (RowRealesed == 5)
                A = "f";
            else
                                    if (RowRealesed == 6)
                A = "g";
            else
                                        if (RowRealesed == 7)
                A = "h";

            return A;


        }
        //calculate statistic move
        String Number(int ColumnRealeased)
        {

            String A = "";
            if (ColumnRealeased == 7)
                A = "0";
            else
                if (ColumnRealeased == 6)
                A = "1";
            else
                    if (ColumnRealeased == 5)
                A = "2";
            else
                        if (ColumnRealeased == 4)
                A = "3";
            else
                            if (ColumnRealeased == 3)
                A = "4";
            else
                                if (ColumnRealeased == 2)
                A = "5";
            else
                                    if (ColumnRealeased == 1)
                A = "6";
            else
                                        if (ColumnRealeased == 0)
                A = "7";

            return A;


        }
        //number of bounry object
        int SumOfObjects(AllDraw A, int Order)
        {

            int Sum = 0;
            if (A == null)
                return Sum;
            if (Order == 1)
            {
                for (var i = 0; i < A.SodierMidle; i++)
                {
                    if (A.SolderesOnTable != null && A.SolderesOnTable[i] != null)
                        Sum += A.SolderesOnTable[i].WinOcuuredatChiled;
                }
                for (var i = 0; i < A.ElefantMidle; i++)
                {
                    if (A.ElephantOnTable != null && A.ElephantOnTable[i] != null)
                        Sum += A.ElephantOnTable[i].WinOcuuredatChiled;
                }
                for (var i = 0; i < A.HourseMidle; i++)
                {
                    if (A.HoursesOnTable != null && A.HoursesOnTable[i] != null)
                        Sum += A.HoursesOnTable[i].WinOcuuredatChiled;
                }
                for (var i = 0; i < A.CastleMidle; i++)
                {
                    if (A.CastlesOnTable != null && A.CastlesOnTable[i] != null)
                        Sum += A.CastlesOnTable[i].WinOcuuredatChiled;
                }
                for (var i = 0; i < A.MinisterMidle; i++)
                {
                    if (A.MinisterOnTable != null && A.MinisterOnTable[i] != null)
                        Sum += A.MinisterOnTable[i].WinOcuuredatChiled;
                }
                for (var i = 0; i < A.KingMidle; i++)
                {
                    if (A.KingOnTable != null && A.KingOnTable[i] != null)
                        Sum += A.KingOnTable[i].WinOcuuredatChiled;
                }
                for (var i = 0; i < 1; i++)
                {
                    if (A.CastlingOnTable != null && A.CastlingOnTable[i] != null)
                        Sum += A.CastlingOnTable[i].WinOcuuredatChiled;
                }
            }
            else
            {
                for (var i = A.SodierMidle; i < A.SodierHigh; i++)
                {
                    if (A.SolderesOnTable != null && A.SolderesOnTable[i] != null)
                        Sum += A.SolderesOnTable[i].WinOcuuredatChiled;
                }
                for (var i = A.ElefantMidle; i < A.ElefantHigh; i++)
                {
                    if (A.ElephantOnTable != null && A.ElephantOnTable[i] != null)
                        Sum += A.ElephantOnTable[i].WinOcuuredatChiled;
                }
                for (var i = A.HourseMidle; i < A.HourseHight; i++)
                {
                    if (A.HoursesOnTable != null && A.HoursesOnTable[i] != null)
                        Sum += A.HoursesOnTable[i].WinOcuuredatChiled;
                }
                for (var i = A.CastleMidle; i < A.CastleHigh; i++)
                {
                    if (A.CastlesOnTable != null && A.CastlesOnTable[i] != null)
                        Sum += A.CastlesOnTable[i].WinOcuuredatChiled;
                }
                for (var i = A.MinisterMidle; i < A.MinisterHigh; i++)
                {
                    if (A.MinisterOnTable != null && A.MinisterOnTable[i] != null)
                        Sum += A.MinisterOnTable[i].WinOcuuredatChiled;
                }
                for (var i = A.KingMidle; i < A.KingHigh; i++)
                {
                    if (A.KingOnTable != null && A.KingOnTable[i] != null)
                        Sum += A.KingOnTable[i].WinOcuuredatChiled;
                }
                for (var i = 0; i < 1; i++)
                {
                    if (A.CastlingOnTable != null && A.CastlingOnTable[i] != null)
                        Sum += A.CastlingOnTable[i].WinOcuuredatChiled;
                }
            }

            return Sum;
        }
        bool IsAtleastAWin(AllDraw A, int Order)
        {
            bool Sum = false;
            if (A == null)
                return Sum;
            if (Order == 1)
            {
                for (var i = 0; i < A.SodierMidle; i++)
                {
                    if (A.SolderesOnTable != null && A.SolderesOnTable[i] != null)
                        if (A.SolderesOnTable[i].WinOcuuredatChiled != 0)
                            Sum = true;
                }
                for (var i = 0; i < A.ElefantMidle; i++)
                {
                    if (A.ElephantOnTable != null && A.ElephantOnTable[i] != null)
                        if (A.ElephantOnTable[i].WinOcuuredatChiled != 0)
                            Sum = true;
                }
                for (var i = 0; i < A.HourseMidle; i++)
                {
                    if (A.HoursesOnTable != null && A.HoursesOnTable[i] != null)
                        if (A.HoursesOnTable[i].WinOcuuredatChiled != 0)
                            Sum = true;
                }
                for (var i = 0; i < A.CastleMidle; i++)
                {
                    if (A.CastlesOnTable != null && A.CastlesOnTable[i] != null)
                        if (A.CastlesOnTable[i].WinOcuuredatChiled != 0)
                            Sum = true;
                }
                for (var i = 0; i < A.MinisterMidle; i++)
                {
                    if (A.MinisterOnTable != null && A.MinisterOnTable[i] != null)
                        if (A.MinisterOnTable[i].WinOcuuredatChiled != 0)
                            Sum = true;
                }
                for (var i = 0; i < A.KingMidle; i++)
                {
                    if (A.KingOnTable != null && A.KingOnTable[i] != null)
                        if (A.KingOnTable[i].WinOcuuredatChiled != 0)
                            Sum = true;
                }
                for (var i = 0; i < 1; i++)
                {
                    if (A.CastlingOnTable != null && A.CastlingOnTable[i] != null)
                        if (A.CastlingOnTable[i].WinOcuuredatChiled != 0)
                            Sum = true;
                }
            }
            else
            {
                for (var i = A.SodierMidle; i < A.SodierHigh; i++)
                {
                    if (A.SolderesOnTable != null && A.SolderesOnTable[i] != null)
                        if (A.SolderesOnTable[i].WinOcuuredatChiled != 0)
                            Sum = true;
                }
                for (var i = A.ElefantMidle; i < A.ElefantHigh; i++)
                {
                    if (A.ElephantOnTable != null && A.ElephantOnTable[i] != null)
                        if (A.ElephantOnTable[i].WinOcuuredatChiled != 0)
                            Sum = true;
                }
                for (var i = A.HourseMidle; i < A.HourseHight; i++)
                {
                    if (A.HoursesOnTable != null && A.HoursesOnTable[i] != null)
                        if (A.HoursesOnTable[i].WinOcuuredatChiled != 0)
                            Sum = true;
                }
                for (var i = A.CastleMidle; i < A.CastleHigh; i++)
                {
                    if (A.CastlesOnTable != null && A.CastlesOnTable[i] != null)
                        if (A.CastlesOnTable[i].WinOcuuredatChiled != 0)
                            Sum = true;
                }
                for (var i = A.MinisterMidle; i < A.MinisterHigh; i++)
                {
                    if (A.MinisterOnTable != null && A.MinisterOnTable[i] != null)
                        if (A.MinisterOnTable[i].WinOcuuredatChiled != 0)
                            Sum = true;
                }
                for (var i = A.KingMidle; i < A.KingHigh; i++)
                {
                    if (A.KingOnTable != null && A.KingOnTable[i] != null)
                        if (A.KingOnTable[i].WinOcuuredatChiled != 0)
                            Sum = true;
                }
                for (var i = 0; i < 1; i++)
                {
                    if (A.CastlingOnTable != null && A.CastlingOnTable[i] != null)
                        if (A.CastlingOnTable[i].WinOcuuredatChiled != 0)
                            Sum = true;
                }
            }
            return Sum;
        }
        //victome transfer leafs to rooots chiled
        int SumMinusOfObjects(AllDraw A, int Order)
        {
            int Sum = 0;
            if (!IsAtleastAWin(A, Order))
            {
                if (A == null)
                    return Sum;
                if (Order == 1)
                {
                    for (var i = 0; i < A.SodierMidle; i++)
                    {
                        if (A.SolderesOnTable != null && A.SolderesOnTable[i] != null && A.SolderesOnTable[i].LoseOcuuredatChiled[0] <= 0)
                            Sum += A.SolderesOnTable[i].LoseOcuuredatChiled[0];
                        else if (A.SolderesOnTable != null && A.SolderesOnTable[i] != null && A.SolderesOnTable[i].LoseOcuuredatChiled[0] == 5)
                            Sum = A.SolderesOnTable[i].LoseOcuuredatChiled[0];
                        if (Sum == 5)
                        {
                            if (IsMovableLoseOcuuredatChiled(CloneATable(TableList[0]), 1, Order, i))
                            {
                                A.SolderesOnTable[i].WinOcuuredatChiled = Sum = 5;
                                return 5;
                            }
                        }
                    }
                    for (var i = 0; i < A.ElefantMidle; i++)
                    {
                        if (A.ElephantOnTable != null && A.ElephantOnTable[i] != null && A.ElephantOnTable[i].LoseOcuuredatChiled[0] <= 0)
                            Sum += A.ElephantOnTable[i].LoseOcuuredatChiled[0];
                        else if (A.ElephantOnTable != null && A.ElephantOnTable[i] != null && A.ElephantOnTable[i].LoseOcuuredatChiled[0] == 5)
                            Sum = A.ElephantOnTable[i].LoseOcuuredatChiled[0];
                        if (Sum == 5)
                        {
                            if (IsMovableLoseOcuuredatChiled(CloneATable(TableList[0]), 2, Order, i))
                            {
                                A.ElephantOnTable[i].WinOcuuredatChiled = Sum = 5;
                                return 5;
                            }
                        }
                    }
                    for (var i = 0; i < A.HourseMidle; i++)
                    {
                        if (A.HoursesOnTable != null && A.HoursesOnTable[i] != null && A.HoursesOnTable[i].LoseOcuuredatChiled[0] <= 0)
                            Sum += A.HoursesOnTable[i].LoseOcuuredatChiled[0];
                        else if (A.HoursesOnTable != null && A.HoursesOnTable[i] != null && A.HoursesOnTable[i].LoseOcuuredatChiled[0] == 5)
                            Sum = A.HoursesOnTable[i].LoseOcuuredatChiled[0];
                        if (Sum == 5)
                        {
                            if (IsMovableLoseOcuuredatChiled(CloneATable(TableList[0]), 3, Order, i))
                            {
                                A.SolderesOnTable[i].WinOcuuredatChiled = Sum = 5;
                                return 5;
                            }
                        }
                    }
                    for (var i = 0; i < A.CastleMidle; i++)
                    {
                        if (A.HoursesOnTable != null && A.HoursesOnTable[i] != null && A.HoursesOnTable[i].LoseOcuuredatChiled[0] <= 0)
                            Sum += A.HoursesOnTable[i].LoseOcuuredatChiled[0];
                        else if (A.HoursesOnTable != null && A.HoursesOnTable[i] != null && A.HoursesOnTable[i].LoseOcuuredatChiled[0] == 5)
                            Sum = A.HoursesOnTable[i].LoseOcuuredatChiled[0];
                        if (Sum == 5)
                        {
                            if (IsMovableLoseOcuuredatChiled(CloneATable(TableList[0]), 4, Order, i))
                            {
                                A.HoursesOnTable[i].WinOcuuredatChiled = Sum = 5;
                                return 5;
                            }
                        }
                    }
                    for (var i = 0; i < A.MinisterMidle; i++)
                    {
                        if (A.MinisterOnTable != null && A.MinisterOnTable[i] != null && A.MinisterOnTable[i].LoseOcuuredatChiled[0] <= 0)
                            Sum += A.MinisterOnTable[i].LoseOcuuredatChiled[0];
                        else if (A.MinisterOnTable != null && A.MinisterOnTable[i] != null && A.MinisterOnTable[i].LoseOcuuredatChiled[0] == 5)
                            Sum = A.MinisterOnTable[i].LoseOcuuredatChiled[0];
                        if (Sum == 5)
                        {
                            if (IsMovableLoseOcuuredatChiled(CloneATable(TableList[0]), 5, Order, i))
                            {
                                A.MinisterOnTable[i].WinOcuuredatChiled = Sum = 5;
                                return 5;
                            }
                        }
                    }
                    for (var i = 0; i < A.KingMidle; i++)
                    {
                        if (A.KingOnTable != null && A.KingOnTable[i] != null && A.KingOnTable[i].LoseOcuuredatChiled[0] <= 0)
                            Sum += A.KingOnTable[i].LoseOcuuredatChiled[0];
                        else if (A.KingOnTable != null && A.KingOnTable[i] != null && A.KingOnTable[i].LoseOcuuredatChiled[0] == 5)
                            Sum = A.KingOnTable[i].LoseOcuuredatChiled[0];
                        if (Sum == 5)
                        {
                            if (IsMovableLoseOcuuredatChiled(CloneATable(TableList[0]), 6, Order, i))
                            {
                                A.KingOnTable[i].WinOcuuredatChiled = Sum = 5;
                                return 5;
                            }
                        }
                    }
                    for (var i = 0; i < 1; i++)
                    {
                        if (A.CastlingOnTable != null && A.CastlingOnTable[i] != null && A.CastlingOnTable[i].LoseOcuuredatChiled[0] <= 0)
                            Sum += A.CastlingOnTable[i].LoseOcuuredatChiled[0];
                        else if (A.CastlingOnTable != null && A.CastlingOnTable[i] != null && A.CastlingOnTable[i].LoseOcuuredatChiled[0] == 5)
                            Sum = A.CastlingOnTable[i].LoseOcuuredatChiled[0];
                        if (Sum == 5)
                        {
                            if (IsMovableLoseOcuuredatChiled(CloneATable(TableList[0]), 7, Order, i))
                            {
                                A.CastlingOnTable[i].WinOcuuredatChiled = Sum = 5;
                                return 5;
                            }
                        }
                    }
                }
                else
                {
                    for (var i = A.SodierMidle; i < A.SodierHigh; i++)
                    {
                        if (A.SolderesOnTable != null && A.SolderesOnTable[i] != null && A.SolderesOnTable[i].LoseOcuuredatChiled[0] <= 0)
                            Sum += A.SolderesOnTable[i].LoseOcuuredatChiled[0];
                        else if (A.SolderesOnTable != null && A.SolderesOnTable[i] != null && A.SolderesOnTable[i].LoseOcuuredatChiled[0] == 5)
                            Sum = A.SolderesOnTable[i].LoseOcuuredatChiled[0];
                        if (Sum == 5)
                        {
                            if (IsMovableLoseOcuuredatChiled(CloneATable(TableList[0]), 1, Order, i))
                            {
                                A.SolderesOnTable[i].WinOcuuredatChiled = Sum = 5;
                                return 5;
                            }
                        }
                    }
                    for (var i = A.ElefantMidle; i < A.ElefantHigh; i++)
                    {
                        if (A.ElephantOnTable != null && A.ElephantOnTable[i] != null && A.ElephantOnTable[i].LoseOcuuredatChiled[0] <= 0)
                            Sum += A.ElephantOnTable[i].LoseOcuuredatChiled[0];
                        else if (A.ElephantOnTable != null && A.ElephantOnTable[i] != null && A.ElephantOnTable[i].LoseOcuuredatChiled[0] == 5)
                            Sum = A.ElephantOnTable[i].LoseOcuuredatChiled[0];
                        if (Sum == 5)
                        {
                            if (IsMovableLoseOcuuredatChiled(CloneATable(TableList[0]), 2, Order, i))
                            {
                                A.ElephantOnTable[i].WinOcuuredatChiled = Sum = 5;
                                return 5;
                            }
                        }
                    }
                    for (var i = A.HourseMidle; i < A.HourseHight; i++)
                    {
                        if (A.HoursesOnTable != null && A.HoursesOnTable[i] != null && A.HoursesOnTable[i].LoseOcuuredatChiled[0] <= 0)
                            Sum += A.HoursesOnTable[i].LoseOcuuredatChiled[0];
                        else if (A.HoursesOnTable != null && A.HoursesOnTable[i] != null && A.HoursesOnTable[i].LoseOcuuredatChiled[0] == 5)
                            Sum = A.HoursesOnTable[i].LoseOcuuredatChiled[0];
                        if (Sum == 5)
                        {
                            if (IsMovableLoseOcuuredatChiled(CloneATable(TableList[0]), 3, Order, i))
                            {
                                A.HoursesOnTable[i].WinOcuuredatChiled = Sum = 5;
                                return 5;
                            }
                        }
                    }
                    for (var i = A.CastleMidle; i < A.CastleHigh; i++)
                    {
                        if (A.CastlesOnTable != null && A.CastlesOnTable[i] != null && A.CastlesOnTable[i].LoseOcuuredatChiled[0] <= 0)
                            Sum += A.CastlesOnTable[i].LoseOcuuredatChiled[0];
                        else if (A.CastlesOnTable != null && A.CastlesOnTable[i] != null && A.CastlesOnTable[i].LoseOcuuredatChiled[0] == 5)
                            Sum = A.CastlesOnTable[i].LoseOcuuredatChiled[0];
                        if (Sum == 5)
                        {
                            if (IsMovableLoseOcuuredatChiled(CloneATable(TableList[0]), 4, Order, i))
                            {
                                A.CastlesOnTable[i].WinOcuuredatChiled = Sum = 5;
                                return 5;
                            }
                        }
                    }
                    for (var i = A.MinisterMidle; i < A.MinisterHigh; i++)
                    {
                        if (A.MinisterOnTable != null && A.MinisterOnTable[i] != null && A.MinisterOnTable[i].LoseOcuuredatChiled[0] <= 0)
                            Sum += A.MinisterOnTable[i].LoseOcuuredatChiled[0];
                        else if (A.MinisterOnTable != null && A.MinisterOnTable[i] != null && A.MinisterOnTable[i].LoseOcuuredatChiled[0] == 5)
                            Sum = A.MinisterOnTable[i].LoseOcuuredatChiled[0];
                        if (Sum == 5)
                        {
                            if (IsMovableLoseOcuuredatChiled(CloneATable(TableList[0]), 5, Order, i))
                            {
                                A.MinisterOnTable[i].WinOcuuredatChiled = Sum = 5;
                                return 5;
                            }
                        }
                    }
                    for (var i = A.KingMidle; i < A.KingHigh; i++)
                    {
                        if (A.KingOnTable != null && A.KingOnTable[i] != null && A.KingOnTable[i].LoseOcuuredatChiled[0] <= 0)
                            Sum += A.KingOnTable[i].LoseOcuuredatChiled[0];
                        else if (A.KingOnTable != null && A.KingOnTable[i] != null && A.KingOnTable[i].LoseOcuuredatChiled[0] == 5)
                            Sum = A.KingOnTable[i].LoseOcuuredatChiled[0];
                        if (Sum == 5)
                        {
                            if (IsMovableLoseOcuuredatChiled(CloneATable(TableList[0]), 6, Order, i))
                            {
                                A.KingOnTable[i].WinOcuuredatChiled = Sum = 5;
                                return 5;
                            }
                        }
                    }
                    for (var i = 0; i < 1; i++)
                    {
                        if (A.CastlingOnTable != null && A.CastlingOnTable[i] != null && A.CastlingOnTable[i].LoseOcuuredatChiled[0] <= 0)
                            Sum += A.CastlingOnTable[i].LoseOcuuredatChiled[0];
                        else if (A.CastlingOnTable != null && A.CastlingOnTable[i] != null && A.CastlingOnTable[i].LoseOcuuredatChiled[0] == 5)
                            Sum = A.CastlingOnTable[i].LoseOcuuredatChiled[0];
                        if (Sum == 5)
                        {
                            if (IsMovableLoseOcuuredatChiled(CloneATable(TableList[0]), 7, Order, i))
                            {
                                A.CastlingOnTable[i].WinOcuuredatChiled = Sum = 5;
                                return 5;
                            }
                        }
                    }
                }
            }
            return Sum;
        }
        //Semaphore determination about Thinking operational completed.
        bool ReturnFullGameThinkingTreeSemaphore(int ik, int kind)
        {

            //soldier
            if (kind == 1)
            {
                if (SolderesOnTable[ik].SoldierThinking[0].ThinkingBegin && (!SolderesOnTable[ik].SoldierThinking[0].ThinkingFinished))
                    return true;
            }
            else//elephant
                if (kind == 2)
            {
                if (ElephantOnTable[ik].ElefantThinking[0].ThinkingBegin && (!ElephantOnTable[ik].ElefantThinking[0].ThinkingFinished))
                    return true;
            }
            else if (kind == 3)//hourse
            {
                if (HoursesOnTable[ik].HourseThinking[0].ThinkingBegin && (!HoursesOnTable[ik].HourseThinking[0].ThinkingFinished))
                    return true;
            }
            else if (kind == 4)//Castle
            {
                if (CastlesOnTable[ik].CastleThinking[0].ThinkingBegin && (!CastlesOnTable[ik].CastleThinking[0].ThinkingFinished))
                    return true;
            }
            else
                if (kind == 5)//minister
            {
                if (MinisterOnTable[ik].MinisterThinking[0].ThinkingBegin && (!MinisterOnTable[ik].MinisterThinking[0].ThinkingFinished))
                    return true;
            }
            else if (kind == 6)//king
            {
                if (KingOnTable[ik].KingThinking[0].ThinkingBegin && (!KingOnTable[ik].KingThinking[0].ThinkingFinished))
                    return true;
            }
            else if (kind == 7 || kind == -7)//king
            {
                if (CastlingOnTable[ik].CastlingThinking[0].ThinkingBegin && (!CastlingOnTable[ik].CastlingThinking[0].ThinkingFinished))
                    return true;
            }

            return false;
        }
        //determination about learning autamata semaphores permit of operational computational 
        bool ReturnConsiderationOfPermitForValidationOfLearningInFullGameThinkingTree(int ik, int kind, bool Penalty, int j)
        {

            //when is learning autamata
            if (Penalty)
            {
                //soldier
                if (kind == 1)
                {
                    if (SolderesOnTable[ik].SoldierThinking[0].PenaltyRegardListSolder[j].IsPenaltyAction() != 0 || (!UsePenaltyRegardMechnisamT))
                        return true;
                }
                else//elephant
                                if (kind == 2)
                {
                    if (ElephantOnTable[ik].ElefantThinking[0].PenaltyRegardListElefant[j].IsPenaltyAction() != 0 || (!UsePenaltyRegardMechnisamT))
                        return true;
                }
                else if (kind == 3)//hourse
                {
                    if (HoursesOnTable[ik].HourseThinking[0].PenaltyRegardListHourse[j].IsPenaltyAction() != 0 || (!UsePenaltyRegardMechnisamT))
                        return true;
                }
                else if (kind == 4)//Castle
                {
                    if (CastlesOnTable[ik].CastleThinking[0].PenaltyRegardListCastle[j].IsPenaltyAction() != 0 || (!UsePenaltyRegardMechnisamT))
                        return true;
                }
                else
                    if (kind == 5)//minister
                {
                    if (MinisterOnTable[ik].MinisterThinking[0].PenaltyRegardListMinister[j].IsPenaltyAction() != 0 || (!UsePenaltyRegardMechnisamT))
                        return true;
                }
                else if (kind == 6)//king
                {
                    if (KingOnTable[ik].KingThinking[0].PenaltyRegardListKing[j].IsPenaltyAction() != 0 || (!UsePenaltyRegardMechnisamT))
                        return true;
                }
                else if (kind == 7 || kind == -7)//king
                {
                    if (CastlingOnTable[ik].CastlingThinking[0].PenaltyRegardListCastling[j].IsRewardAction() != 1 || (!UsePenaltyRegardMechnisamT))
                        return true;
                }
            }
            else//Brown
            {
                if (kind == 1)//soldier
                {
                    if (SolderesOnTable[ik].SoldierThinking[0].PenaltyRegardListSolder[j].IsRewardAction() != 1 || (!UsePenaltyRegardMechnisamT))
                        return true;
                }
                else
                         if (kind == 2)//elephant
                {
                    if (ElephantOnTable[ik].ElefantThinking[0].PenaltyRegardListElefant[j].IsRewardAction() != 1 || (!UsePenaltyRegardMechnisamT))
                        return true;
                }
                else if (kind == 3)//hourse
                {
                    if (HoursesOnTable[ik].HourseThinking[0].PenaltyRegardListHourse[j].IsRewardAction() != 1 || (!UsePenaltyRegardMechnisamT))
                        return true;
                }
                else if (kind == 4)//Castle
                {
                    if (CastlesOnTable[ik].CastleThinking[0].PenaltyRegardListCastle[j].IsRewardAction() != 1 || (!UsePenaltyRegardMechnisamT))
                        return true;
                }
                else
                    if (kind == 5)//minister
                {
                    if (MinisterOnTable[ik].MinisterThinking[0].PenaltyRegardListMinister[j].IsRewardAction() != 1 || (!UsePenaltyRegardMechnisamT))
                        return true;
                }
                else if (kind == 6)//king
                {
                    if (KingOnTable[ik].KingThinking[0].PenaltyRegardListKing[j].IsRewardAction() != 1 || (!UsePenaltyRegardMechnisamT))
                        return true;
                }
                else if (kind == 7 || kind == -7)//king
                {
                    if (CastlingOnTable[ik].CastlingThinking[0].PenaltyRegardListCastling[j].IsRewardAction() != 1 || (!UsePenaltyRegardMechnisamT))
                        return true;
                }
            }

            return false;
        }
        //determiniation about deeper increamental of a part
        void BlitzNotValidFullGameThinkingTreePartOne(int ik, int Order, int kind)
        {

            //soldier
            if (kind == 1)
            {
                //when valid 
                if (SolderesOnTable[ik].SoldierThinking[0].TableListSolder.Count > SolderesOnTable[ik].SoldierThinking[0].AStarGreedy.Count)
                {
                    if (SolderesOnTable[ik].SoldierThinking[0].AStarGreedy.Count == 0)
                        SolderesOnTable[ik].SoldierThinking[0].AStarGreedy = new List<AllDraw>();
                    SolderesOnTable[ik].SoldierThinking[0].AStarGreedy.Add(new AllDraw(Order * -1, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged));
                    SolderesOnTable[ik].SoldierThinking[0].AStarGreedy[SolderesOnTable[ik].SoldierThinking[0].AStarGreedy.Count - 1].AStarGreedyString = this;
                }
            }
            else if (kind == 2)///elephant
            {
                //when valid 
                if (ElephantOnTable[ik].ElefantThinking[0].TableListElefant.Count > ElephantOnTable[ik].ElefantThinking[0].AStarGreedy.Count)
                {
                    if (ElephantOnTable[ik].ElefantThinking[0].AStarGreedy.Count == 0)
                        ElephantOnTable[ik].ElefantThinking[0].AStarGreedy = new List<AllDraw>();
                    ElephantOnTable[ik].ElefantThinking[0].AStarGreedy.Add(new AllDraw(Order * -1, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged));
                    ElephantOnTable[ik].ElefantThinking[0].AStarGreedy[ElephantOnTable[ik].ElefantThinking[0].AStarGreedy.Count - 1].AStarGreedyString = this;
                }
            }
            else if (kind == 3)//hourse
            {
                //when valid 
                if (HoursesOnTable[ik].HourseThinking[0].TableListHourse.Count > HoursesOnTable[ik].HourseThinking[0].AStarGreedy.Count)
                {
                    if (HoursesOnTable[ik].HourseThinking[0].AStarGreedy.Count == 0)
                        HoursesOnTable[ik].HourseThinking[0].AStarGreedy = new List<AllDraw>();
                    HoursesOnTable[ik].HourseThinking[0].AStarGreedy.Add(new AllDraw(Order * -1, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged));
                    HoursesOnTable[ik].HourseThinking[0].AStarGreedy[HoursesOnTable[ik].HourseThinking[0].AStarGreedy.Count - 1].AStarGreedyString = this;
                }
            }
            else if (kind == 4)//Castle
            {
                //when valid 
                if (CastlesOnTable[ik].CastleThinking[0].TableListCastle.Count > CastlesOnTable[ik].CastleThinking[0].AStarGreedy.Count)
                {
                    if (CastlesOnTable[ik].CastleThinking[0].AStarGreedy.Count == 0)
                        CastlesOnTable[ik].CastleThinking[0].AStarGreedy = new List<AllDraw>();
                    CastlesOnTable[ik].CastleThinking[0].AStarGreedy.Add(new AllDraw(Order * -1, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged));
                    CastlesOnTable[ik].CastleThinking[0].AStarGreedy[CastlesOnTable[ik].CastleThinking[0].AStarGreedy.Count - 1].AStarGreedyString = this;
                }
            }
            else if (kind == 5)//minister
            {
                //when valid 
                if (MinisterOnTable[ik].MinisterThinking[0].TableListMinister.Count > MinisterOnTable[ik].MinisterThinking[0].AStarGreedy.Count)
                {
                    if (MinisterOnTable[ik].MinisterThinking[0].AStarGreedy.Count == 0)
                        MinisterOnTable[ik].MinisterThinking[0].AStarGreedy = new List<AllDraw>();
                    MinisterOnTable[ik].MinisterThinking[0].AStarGreedy.Add(new AllDraw(Order * -1, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged));
                    MinisterOnTable[ik].MinisterThinking[0].AStarGreedy[MinisterOnTable[ik].MinisterThinking[0].AStarGreedy.Count - 1].AStarGreedyString = this;
                }
            }
            else if (kind == 6)//king
            {
                //when valid 
                if (KingOnTable[ik].KingThinking[0].TableListKing.Count > KingOnTable[ik].KingThinking[0].AStarGreedy.Count)
                {
                    if (KingOnTable[ik].KingThinking[0].AStarGreedy.Count == 0)
                        KingOnTable[ik].KingThinking[0].AStarGreedy = new List<AllDraw>();
                    KingOnTable[ik].KingThinking[0].AStarGreedy.Add(new AllDraw(Order * -1, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged));
                    KingOnTable[ik].KingThinking[0].AStarGreedy[KingOnTable[ik].KingThinking[0].AStarGreedy.Count - 1].AStarGreedyString = this;
                }
            }
            else if (kind == 7 || kind == -7)//king
            {
                //when valid 
                if (CastlingOnTable[ik].CastlingThinking[0].TableListCastling.Count > CastlingOnTable[ik].CastlingThinking[0].AStarGreedy.Count)
                {
                    if (CastlingOnTable[ik].CastlingThinking[0].AStarGreedy.Count == 0)
                        CastlingOnTable[ik].CastlingThinking[0].AStarGreedy = new List<AllDraw>();
                    CastlingOnTable[ik].CastlingThinking[0].AStarGreedy.Add(new AllDraw(Order * -1, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged));
                    CastlingOnTable[ik].CastlingThinking[0].AStarGreedy[CastlingOnTable[ik].CastlingThinking[0].AStarGreedy.Count - 1].AStarGreedyString = this;
                }
            }

        }
        //determiniation about deeper increamental of a part
        void BlitzNotValidFullGameThinkingTreePartTow(int ik, int Order, int kind)
        {

            if (kind == 1)//soldier
            {
                //when valid 
                if (SolderesOnTable[ik].SoldierThinking[0].TableListSolder.Count > SolderesOnTable[ik].SoldierThinking[0].AStarGreedy.Count)
                {
                    if (SolderesOnTable[ik].SoldierThinking[0].AStarGreedy.Count == 0)
                        SolderesOnTable[ik].SoldierThinking[0].AStarGreedy = new List<AllDraw>();
                    SolderesOnTable[ik].SoldierThinking[0].AStarGreedy.Add(new AllDraw(Order * -1, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged));
                    SolderesOnTable[ik].SoldierThinking[0].AStarGreedy[SolderesOnTable[ik].SoldierThinking[0].AStarGreedy.Count - 1].AStarGreedyString = this;
                }
            }
            else if (kind == 2)//elephant
            {
                //when valid 
                if (ElephantOnTable[ik].ElefantThinking[0].TableListElefant.Count > ElephantOnTable[ik].ElefantThinking[0].AStarGreedy.Count)
                {
                    if (ElephantOnTable[ik].ElefantThinking[0].AStarGreedy.Count == 0)
                        ElephantOnTable[ik].ElefantThinking[0].AStarGreedy = new List<AllDraw>();
                    ElephantOnTable[ik].ElefantThinking[0].AStarGreedy.Add(new AllDraw(Order * -1, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged));
                    ElephantOnTable[ik].ElefantThinking[0].AStarGreedy[ElephantOnTable[ik].ElefantThinking[0].AStarGreedy.Count - 1].AStarGreedyString = this;
                }
            }
            else if (kind == 3)//hourse
            {
                //when valid 
                if (HoursesOnTable[ik].HourseThinking[0].TableListHourse.Count > HoursesOnTable[ik].HourseThinking[0].AStarGreedy.Count)
                {
                    if (HoursesOnTable[ik].HourseThinking[0].AStarGreedy.Count == 0)
                        HoursesOnTable[ik].HourseThinking[0].AStarGreedy = new List<AllDraw>();
                    HoursesOnTable[ik].HourseThinking[0].AStarGreedy.Add(new AllDraw(Order * -1, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged));
                    HoursesOnTable[ik].HourseThinking[0].AStarGreedy[HoursesOnTable[ik].HourseThinking[0].AStarGreedy.Count - 1].AStarGreedyString = this;
                }
            }
            else if (kind == 4)//Castle
            {
                //when valid 
                if (CastlesOnTable[ik].CastleThinking[0].TableListCastle.Count > CastlesOnTable[ik].CastleThinking[0].AStarGreedy.Count)
                {
                    if (CastlesOnTable[ik].CastleThinking[0].AStarGreedy.Count == 0)
                        CastlesOnTable[ik].CastleThinking[0].AStarGreedy = new List<AllDraw>();
                    CastlesOnTable[ik].CastleThinking[0].AStarGreedy.Add(new AllDraw(Order * -1, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged));
                    CastlesOnTable[ik].CastleThinking[0].AStarGreedy[CastlesOnTable[ik].CastleThinking[0].AStarGreedy.Count - 1].AStarGreedyString = this;
                }
            }
            else if (kind == 5)//minister
            {
                //when valid 
                if (MinisterOnTable[ik].MinisterThinking[0].TableListMinister.Count > MinisterOnTable[ik].MinisterThinking[0].AStarGreedy.Count)
                {
                    if (MinisterOnTable[ik].MinisterThinking[0].AStarGreedy.Count == 0)
                        MinisterOnTable[ik].MinisterThinking[0].AStarGreedy = new List<AllDraw>();
                    MinisterOnTable[ik].MinisterThinking[0].AStarGreedy.Add(new AllDraw(Order * -1, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged));
                    MinisterOnTable[ik].MinisterThinking[0].AStarGreedy[MinisterOnTable[ik].MinisterThinking[0].AStarGreedy.Count - 1].AStarGreedyString = this;
                }
            }
            else if (kind == 6)//king
            {
                //when valid 
                if (KingOnTable[ik].KingThinking[0].TableListKing.Count > KingOnTable[ik].KingThinking[0].AStarGreedy.Count)
                {
                    if (KingOnTable[ik].KingThinking[0].AStarGreedy.Count == 0)
                        KingOnTable[ik].KingThinking[0].AStarGreedy = new List<AllDraw>();
                    KingOnTable[ik].KingThinking[0].AStarGreedy.Add(new AllDraw(Order * -1, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged));
                    KingOnTable[ik].KingThinking[0].AStarGreedy[KingOnTable[ik].KingThinking[0].AStarGreedy.Count - 1].AStarGreedyString = this;
                }
            }
            else if (kind == 7 || kind == -7)//king
            {
                //when valid 
                if (CastlingOnTable[ik].CastlingThinking[0].TableListCastling.Count > CastlingOnTable[ik].CastlingThinking[0].AStarGreedy.Count)
                {
                    if (CastlingOnTable[ik].CastlingThinking[0].AStarGreedy.Count == 0)
                        CastlingOnTable[ik].CastlingThinking[0].AStarGreedy = new List<AllDraw>();
                    CastlingOnTable[ik].CastlingThinking[0].AStarGreedy.Add(new AllDraw(Order * -1, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged));
                    CastlingOnTable[ik].CastlingThinking[0].AStarGreedy[CastlingOnTable[ik].CastlingThinking[0].AStarGreedy.Count - 1].AStarGreedyString = this;
                }
            }

        }
        //determiniation about deeper increamental of a part
        void BlitzNotValidFullGameThinkingTreePartThree(int ik, int Order, int kind)
        {


            //soldier
            if (kind == 1)
            {
                //when valid 
                if (SolderesOnTable[ik].SoldierThinking[0].TableListSolder.Count > SolderesOnTable[ik].SoldierThinking[0].AStarGreedy.Count)
                {
                    if (SolderesOnTable[ik].SoldierThinking[0].AStarGreedy.Count == 0)
                        SolderesOnTable[ik].SoldierThinking[0].AStarGreedy = new List<AllDraw>();
                    SolderesOnTable[ik].SoldierThinking[0].AStarGreedy.Add(new AllDraw(Order * -1, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged));
                    SolderesOnTable[ik].SoldierThinking[0].AStarGreedy[SolderesOnTable[ik].SoldierThinking[0].AStarGreedy.Count - 1].AStarGreedyString = this;
                }
            }
            else if (kind == 2)//elephant
            {
                //when valid 
                if (ElephantOnTable[ik].ElefantThinking[0].TableListElefant.Count > ElephantOnTable[ik].ElefantThinking[0].AStarGreedy.Count)
                {
                    if (ElephantOnTable[ik].ElefantThinking[0].AStarGreedy.Count == 0)
                        ElephantOnTable[ik].ElefantThinking[0].AStarGreedy = new List<AllDraw>();
                    ElephantOnTable[ik].ElefantThinking[0].AStarGreedy.Add(new AllDraw(Order * -1, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged));
                    ElephantOnTable[ik].ElefantThinking[0].AStarGreedy[ElephantOnTable[ik].ElefantThinking[0].AStarGreedy.Count - 1].AStarGreedyString = this;
                }
            }
            else if (kind == 3)//hourse
            {
                //when valid 
                if (HoursesOnTable[ik].HourseThinking[0].TableListHourse.Count > HoursesOnTable[ik].HourseThinking[0].AStarGreedy.Count)
                {
                    if (HoursesOnTable[ik].HourseThinking[0].AStarGreedy.Count == 0)
                        HoursesOnTable[ik].HourseThinking[0].AStarGreedy = new List<AllDraw>();
                    HoursesOnTable[ik].HourseThinking[0].AStarGreedy.Add(new AllDraw(Order * -1, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged));
                    HoursesOnTable[ik].HourseThinking[0].AStarGreedy[HoursesOnTable[ik].HourseThinking[0].AStarGreedy.Count - 1].AStarGreedyString = this;
                }
            }
            else if (kind == 4)//Castle
            {
                //when valid 
                if (CastlesOnTable[ik].CastleThinking[0].TableListCastle.Count > CastlesOnTable[ik].CastleThinking[0].AStarGreedy.Count)
                {
                    if (CastlesOnTable[ik].CastleThinking[0].AStarGreedy.Count == 0)
                        CastlesOnTable[ik].CastleThinking[0].AStarGreedy = new List<AllDraw>();
                    CastlesOnTable[ik].CastleThinking[0].AStarGreedy.Add(new AllDraw(Order * -1, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged));
                    CastlesOnTable[ik].CastleThinking[0].AStarGreedy[CastlesOnTable[ik].CastleThinking[0].AStarGreedy.Count - 1].AStarGreedyString = this;
                }
            }
            else if (kind == 5)//minister
            {
                //when valid 
                if (MinisterOnTable[ik].MinisterThinking[0].TableListMinister.Count > MinisterOnTable[ik].MinisterThinking[0].AStarGreedy.Count)
                {
                    if (MinisterOnTable[ik].MinisterThinking[0].AStarGreedy.Count == 0)
                        MinisterOnTable[ik].MinisterThinking[0].AStarGreedy = new List<AllDraw>();
                    MinisterOnTable[ik].MinisterThinking[0].AStarGreedy.Add(new AllDraw(Order * -1, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged));
                    MinisterOnTable[ik].MinisterThinking[0].AStarGreedy[MinisterOnTable[ik].MinisterThinking[0].AStarGreedy.Count - 1].AStarGreedyString = this;
                }
            }
            else if (kind == 6)//king
            {
                //when valid 
                if (KingOnTable[ik].KingThinking[0].TableListKing.Count > KingOnTable[ik].KingThinking[0].AStarGreedy.Count)
                {
                    if (KingOnTable[ik].KingThinking[0].AStarGreedy.Count == 0)
                        KingOnTable[ik].KingThinking[0].AStarGreedy = new List<AllDraw>();
                    KingOnTable[ik].KingThinking[0].AStarGreedy.Add(new AllDraw(Order * -1, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged));
                    KingOnTable[ik].KingThinking[0].AStarGreedy[KingOnTable[ik].KingThinking[0].AStarGreedy.Count - 1].AStarGreedyString = this;
                }
            }
            else if (kind == 7 || kind == -7)//king
            {
                //when valid 
                if (CastlingOnTable[ik].CastlingThinking[0].TableListCastling.Count > CastlingOnTable[ik].CastlingThinking[0].AStarGreedy.Count)
                {
                    if (CastlingOnTable[ik].CastlingThinking[0].AStarGreedy.Count == 0)
                        CastlingOnTable[ik].CastlingThinking[0].AStarGreedy = new List<AllDraw>();
                    CastlingOnTable[ik].CastlingThinking[0].AStarGreedy.Add(new AllDraw(Order * -1, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged));
                    CastlingOnTable[ik].CastlingThinking[0].AStarGreedy[CastlingOnTable[ik].CastlingThinking[0].AStarGreedy.Count - 1].AStarGreedyString = this;
                }
            }

        }
        //operantinal of creation of current deeper node and set string making
        void FullGameThinkingTreeInitialization(int ik, int j, int Order, int kind)
        {

            //soldier
            if (kind == 1)
            {
                //when valid do create of deeper node and string making
                if (SolderesOnTable[ik].SoldierThinking[0].TableListSolder.Count == SolderesOnTable[ik].SoldierThinking[0].AStarGreedy.Count)
                {
                    if (SolderesOnTable[ik].SoldierThinking[0].AStarGreedy.Count == 0)
                        SolderesOnTable[ik].SoldierThinking[0].AStarGreedy = new List<AllDraw>();
                    SolderesOnTable[ik].SoldierThinking[0].AStarGreedy[j].TableList.Clear();
                    SolderesOnTable[ik].SoldierThinking[0].AStarGreedy[j].TableList.Add(CloneATable(SolderesOnTable[ik].SoldierThinking[0].TableListSolder[j]));
                    SolderesOnTable[ik].SoldierThinking[0].AStarGreedy[j].SetRowColumn(0);
                    SolderesOnTable[ik].SoldierThinking[0].AStarGreedy[j].SetRowColumnFinishedWait();
                    SolderesOnTable[ik].SoldierThinking[0].AStarGreedy[j].AStarGreedyString = this;
                }
            }
            else if (kind == 2)//elephant 
            {
                //when valid do create of deeper node and string making
                if (ElephantOnTable[ik].ElefantThinking[0].TableListElefant.Count == ElephantOnTable[ik].ElefantThinking[0].AStarGreedy.Count)
                {
                    if (ElephantOnTable[ik].ElefantThinking[0].AStarGreedy.Count == 0)
                        ElephantOnTable[ik].ElefantThinking[0].AStarGreedy = new List<AllDraw>();
                    ElephantOnTable[ik].ElefantThinking[0].AStarGreedy[j].TableList.Clear();
                    ElephantOnTable[ik].ElefantThinking[0].AStarGreedy[j].TableList.Add(CloneATable(ElephantOnTable[ik].ElefantThinking[0].TableListElefant[j]));
                    ElephantOnTable[ik].ElefantThinking[0].AStarGreedy[j].SetRowColumn(0);
                    ElephantOnTable[ik].ElefantThinking[0].AStarGreedy[j].SetRowColumnFinishedWait();
                    ElephantOnTable[ik].ElefantThinking[0].AStarGreedy[j].AStarGreedyString = this;
                }
            }
            else if (kind == 3)//hourse
            {
                //when valid do create of deeper node and string making
                if (HoursesOnTable[ik].HourseThinking[0].TableListHourse.Count == HoursesOnTable[ik].HourseThinking[0].AStarGreedy.Count)
                {
                    if (HoursesOnTable[ik].HourseThinking[0].AStarGreedy.Count == 0)
                        HoursesOnTable[ik].HourseThinking[0].AStarGreedy = new List<AllDraw>();
                    HoursesOnTable[ik].HourseThinking[0].AStarGreedy[j].TableList.Clear();
                    HoursesOnTable[ik].HourseThinking[0].AStarGreedy[j].TableList.Add(CloneATable(HoursesOnTable[ik].HourseThinking[0].TableListHourse[j]));
                    HoursesOnTable[ik].HourseThinking[0].AStarGreedy[j].SetRowColumn(0);
                    HoursesOnTable[ik].HourseThinking[0].AStarGreedy[j].SetRowColumnFinishedWait();
                    HoursesOnTable[ik].HourseThinking[0].AStarGreedy[j].AStarGreedyString = this;
                }
            }
            else if (kind == 4)//Castle
            {
                //when valid do create of deeper node and string making
                if (CastlesOnTable[ik].CastleThinking[0].TableListCastle.Count == CastlesOnTable[ik].CastleThinking[0].AStarGreedy.Count)
                {
                    if (CastlesOnTable[ik].CastleThinking[0].AStarGreedy.Count == 0)
                        CastlesOnTable[ik].CastleThinking[0].AStarGreedy = new List<AllDraw>();
                    CastlesOnTable[ik].CastleThinking[0].AStarGreedy[j].TableList.Clear();
                    CastlesOnTable[ik].CastleThinking[0].AStarGreedy[j].TableList.Add(CloneATable(CastlesOnTable[ik].CastleThinking[0].TableListCastle[j]));
                    CastlesOnTable[ik].CastleThinking[0].AStarGreedy[j].SetRowColumn(0);
                    CastlesOnTable[ik].CastleThinking[0].AStarGreedy[j].SetRowColumnFinishedWait();
                    CastlesOnTable[ik].CastleThinking[0].AStarGreedy[j].AStarGreedyString = this;
                }
            }
            else if (kind == 5)//minister
            {
                //when valid do create of deeper node and string making
                if (MinisterOnTable[ik].MinisterThinking[0].TableListMinister.Count == MinisterOnTable[ik].MinisterThinking[0].AStarGreedy.Count)
                {
                    if (MinisterOnTable[ik].MinisterThinking[0].AStarGreedy.Count == 0)
                        MinisterOnTable[ik].MinisterThinking[0].AStarGreedy = new List<AllDraw>();
                    MinisterOnTable[ik].MinisterThinking[0].AStarGreedy[j].TableList.Clear();
                    MinisterOnTable[ik].MinisterThinking[0].AStarGreedy[j].TableList.Add(CloneATable(MinisterOnTable[ik].MinisterThinking[0].TableListMinister[j]));
                    MinisterOnTable[ik].MinisterThinking[0].AStarGreedy[j].SetRowColumn(0);
                    MinisterOnTable[ik].MinisterThinking[0].AStarGreedy[j].SetRowColumnFinishedWait();
                    MinisterOnTable[ik].MinisterThinking[0].AStarGreedy[j].AStarGreedyString = this;
                }
            }
            else if (kind == 6)//king
            {
                //when valid do create of deeper node and string making
                if (KingOnTable[ik].KingThinking[0].TableListKing.Count == KingOnTable[ik].KingThinking[0].AStarGreedy.Count)
                {
                    if (KingOnTable[ik].KingThinking[0].AStarGreedy.Count == 0)
                        KingOnTable[ik].KingThinking[0].AStarGreedy = new List<AllDraw>();
                    KingOnTable[ik].KingThinking[0].AStarGreedy[j].TableList.Clear();
                    KingOnTable[ik].KingThinking[0].AStarGreedy[j].TableList.Add(CloneATable(KingOnTable[ik].KingThinking[0].TableListKing[j]));
                    KingOnTable[ik].KingThinking[0].AStarGreedy[j].SetRowColumn(0);
                    KingOnTable[ik].KingThinking[0].AStarGreedy[j].SetRowColumnFinishedWait();
                    KingOnTable[ik].KingThinking[0].AStarGreedy[j].AStarGreedyString = this;
                }
            }
            else if (kind == 7 || kind == -7)//king
            {
                //when valid do create of deeper node and string making
                if (CastlingOnTable[ik].CastlingThinking[0].TableListCastling.Count == CastlingOnTable[ik].CastlingThinking[0].AStarGreedy.Count)
                {
                    if (CastlingOnTable[ik].CastlingThinking[0].AStarGreedy.Count == 0)
                        CastlingOnTable[ik].CastlingThinking[0].AStarGreedy = new List<AllDraw>();
                    CastlingOnTable[ik].CastlingThinking[0].AStarGreedy[j].TableList.Clear();
                    CastlingOnTable[ik].CastlingThinking[0].AStarGreedy[j].TableList.Add(CloneATable(CastlingOnTable[ik].CastlingThinking[0].TableListCastling[j]));
                    CastlingOnTable[ik].CastlingThinking[0].AStarGreedy[j].SetRowColumn(0);
                    CastlingOnTable[ik].CastlingThinking[0].AStarGreedy[j].SetRowColumnFinishedWait();
                    CastlingOnTable[ik].CastlingThinking[0].AStarGreedy[j].AStarGreedyString = this;
                }
            }

        }
        //main operation of full game deeper created compuational to deeper need.
        void OpOfFullGameThinkingTree(int ik, int j, int Order, int iAStarGreedy, int ii, int jj, Color a, int kind, bool FOUND, int LeafAStarGreedy)
        {
            if (UsedRestrictedBlitzMoveAstarGreedy(kind, ik, j))
                return;
            NumberOfnewMove++;
            //soldier
            if (kind == 1)
            {
                //when verfied is not valied return
                //if (!IsNotAStarGreedyConanaied(ik, j, 1))

                //minitor
                OutPutAction = " " + Alphabet(SolderesOnTable[ik].SoldierThinking[0].Row) + Number(SolderesOnTable[ik].SoldierThinking[0].Column) + Alphabet(SolderesOnTable[ik].SoldierThinking[0].RowColumnSoldier[j][0]) + Number(SolderesOnTable[ik].SoldierThinking[0].RowColumnSoldier[j][1]);
                //if (Order == 1)
                //else

                //operational 
                PerceptionCount++;
                var iii = SolderesOnTable[ik].SoldierThinking[0].RowColumnSoldier[j][0];
                var jjj = SolderesOnTable[ik].SoldierThinking[0].RowColumnSoldier[j][1];
                Color aa = a;
                int[,] Tab = CloneATable(SolderesOnTable[ik].SoldierThinking[0].TableListSolder[j]);
                int Ord = Order;
                SolderesOnTable[ik].SoldierThinking[0].AStarGreedy[SolderesOnTable[ik].SoldierThinking[0].AStarGreedy.Count - 1].CurrentMaxLevel = CurrentMaxLevel + 1;
                //StoreInitMaxAStarGreedy = CurrentMaxLevel; MaxAStarGreedy = CurrentMaxLevel;
                var array1 = Task.Factory.StartNew(() => SolderesOnTable[ik].SoldierThinking[0].AStarGreedy[SolderesOnTable[ik].SoldierThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt(PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ii, jj, a, CloneATable(SolderesOnTable[ik].SoldierThinking[0].TableListSolder[j]), Ord * -1, false, FOUND, LeafAStarGreedy));
                array1.Wait(); array1.Dispose();
                SolderesOnTable[ik].SoldierThinking[0].AStarGreedy[SolderesOnTable[ik].SoldierThinking[0].AStarGreedy.Count - 1].AStarGreedyString = this;
                if (SolderesOnTable[ik].SoldierThinking[0].AStarGreedyMove.Count > 0)
                    SolderesOnTable[ik].SoldierThinking[0].AStarGreedyMove[SolderesOnTable[ik].SoldierThinking[0].AStarGreedy.Count - 1] = true;
            }
            else if (kind == 2)//elephant 
            {
                //when verfied is not valied return
                //if (!IsNotAStarGreedyConanaied(ik, j, 2))

                //minitor
                OutPutAction = " " + Alphabet(ElephantOnTable[ik].ElefantThinking[0].Row) + Number(ElephantOnTable[ik].ElefantThinking[0].Column) + Alphabet(ElephantOnTable[ik].ElefantThinking[0].RowColumnElefant[j][0]) + Number(ElephantOnTable[ik].ElefantThinking[0].RowColumnElefant[j][1]);
                //if (Order == 1)
                //else

                //operational 
                PerceptionCount++;
                var iii = ElephantOnTable[ik].ElefantThinking[0].RowColumnElefant[j][0];
                var jjj = ElephantOnTable[ik].ElefantThinking[0].RowColumnElefant[j][1];
                Color aa = a;
                int[,] Tab = CloneATable(ElephantOnTable[ik].ElefantThinking[0].TableListElefant[j]);
                int Ord = Order;
                ElephantOnTable[ik].ElefantThinking[0].AStarGreedy[ElephantOnTable[ik].ElefantThinking[0].AStarGreedy.Count - 1].CurrentMaxLevel = CurrentMaxLevel + 1;
                //StoreInitMaxAStarGreedy = CurrentMaxLevel; MaxAStarGreedy = CurrentMaxLevel;
                var array1 = Task.Factory.StartNew(() => ElephantOnTable[ik].ElefantThinking[0].AStarGreedy[ElephantOnTable[ik].ElefantThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt(PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, iii, jjj, aa, CloneATable(ElephantOnTable[ik].ElefantThinking[0].TableListElefant[j]), Ord * -1, false, FOUND, LeafAStarGreedy));
                array1.Wait(); array1.Dispose();
                ElephantOnTable[ik].ElefantThinking[0].AStarGreedy[ElephantOnTable[ik].ElefantThinking[0].AStarGreedy.Count - 1].AStarGreedyString = this;
                if (ElephantOnTable[ik].ElefantThinking[0].AStarGreedyMove.Count > 0)
                    ElephantOnTable[ik].ElefantThinking[0].AStarGreedyMove[ElephantOnTable[ik].ElefantThinking[0].AStarGreedy.Count - 1] = true;
            }
            else if (kind == 3)//hourse
            {
                //when verfied is not valied return
                //if (!IsNotAStarGreedyConanaied(ik, j, 3))

                //minitor
                OutPutAction = " " + Alphabet(HoursesOnTable[ik].HourseThinking[0].Row) + Number(HoursesOnTable[ik].HourseThinking[0].Column) + Alphabet(HoursesOnTable[ik].HourseThinking[0].RowColumnHourse[j][0]) + Number(HoursesOnTable[ik].HourseThinking[0].RowColumnHourse[j][1]);
                //if (Order == 1)
                //else

                //operational 
                PerceptionCount++;
                var iii = HoursesOnTable[ik].HourseThinking[0].RowColumnHourse[j][0];
                var jjj = HoursesOnTable[ik].HourseThinking[0].RowColumnHourse[j][1];
                Color aa = a;
                int[,] Tab = CloneATable(HoursesOnTable[ik].HourseThinking[0].TableListHourse[j]);
                int Ord = Order;
                HoursesOnTable[ik].HourseThinking[0].AStarGreedy[HoursesOnTable[ik].HourseThinking[0].AStarGreedy.Count - 1].CurrentMaxLevel = CurrentMaxLevel + 1;
                //StoreInitMaxAStarGreedy = CurrentMaxLevel; MaxAStarGreedy = CurrentMaxLevel;
                var array1 = Task.Factory.StartNew(() => HoursesOnTable[ik].HourseThinking[0].AStarGreedy[HoursesOnTable[ik].HourseThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt(PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, iii, jjj, aa, CloneATable(HoursesOnTable[ik].HourseThinking[0].TableListHourse[j]), Ord * -1, false, FOUND, LeafAStarGreedy));
                array1.Wait(); array1.Dispose();
                HoursesOnTable[ik].HourseThinking[0].AStarGreedy[HoursesOnTable[ik].HourseThinking[0].AStarGreedy.Count - 1].AStarGreedyString = this;
                if (HoursesOnTable[ik].HourseThinking[0].AStarGreedyMove.Count > 0)
                    HoursesOnTable[ik].HourseThinking[0].AStarGreedyMove[HoursesOnTable[ik].HourseThinking[0].AStarGreedy.Count - 1] = true;
            }
            else if (kind == 4)//Castle
            {
                //when verfied is not valied return
                //if (!IsNotAStarGreedyConanaied(ik, j, 4))

                //minitor
                OutPutAction = " " + Alphabet(CastlesOnTable[ik].CastleThinking[0].Row) + Number(CastlesOnTable[ik].CastleThinking[0].Column) + Alphabet(CastlesOnTable[ik].CastleThinking[0].RowColumnCastle[j][0]) + Number(CastlesOnTable[ik].CastleThinking[0].RowColumnCastle[j][1]);
                //if (Order == 1)
                //else

                //operational 
                PerceptionCount++;
                var iii = CastlesOnTable[ik].CastleThinking[0].RowColumnCastle[j][0];
                var jjj = CastlesOnTable[ik].CastleThinking[0].RowColumnCastle[j][1];
                Color aa = a;
                int[,] Tab = CloneATable(CastlesOnTable[ik].CastleThinking[0].TableListCastle[j]);
                int Ord = Order;
                CastlesOnTable[ik].CastleThinking[0].AStarGreedy[CastlesOnTable[ik].CastleThinking[0].AStarGreedy.Count - 1].CurrentMaxLevel = CurrentMaxLevel + 1;
                //StoreInitMaxAStarGreedy = CurrentMaxLevel; MaxAStarGreedy = CurrentMaxLevel;
                var array1 = Task.Factory.StartNew(() => CastlesOnTable[ik].CastleThinking[0].AStarGreedy[CastlesOnTable[ik].CastleThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt(PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, iii, jjj, aa, CloneATable(CastlesOnTable[ik].CastleThinking[0].TableListCastle[j]), Ord * -1, false, FOUND, LeafAStarGreedy));
                array1.Wait(); array1.Dispose();
                CastlesOnTable[ik].CastleThinking[0].AStarGreedy[CastlesOnTable[ik].CastleThinking[0].AStarGreedy.Count - 1].AStarGreedyString = this;
                if (CastlesOnTable[ik].CastleThinking[0].AStarGreedyMove.Count > 0)
                    CastlesOnTable[ik].CastleThinking[0].AStarGreedyMove[CastlesOnTable[ik].CastleThinking[0].AStarGreedy.Count - 1] = true;
            }
            else if (kind == 5)//minister
            {
                //when verfied is not valied return
                //if (!IsNotAStarGreedyConanaied(ik, j, 5))

                //minitor
                OutPutAction = " " + Alphabet(MinisterOnTable[ik].MinisterThinking[0].Row) + Number(MinisterOnTable[ik].MinisterThinking[0].Column) + Alphabet(MinisterOnTable[ik].MinisterThinking[0].RowColumnMinister[j][0]) + Number(MinisterOnTable[ik].MinisterThinking[0].RowColumnMinister[j][1]);
                //if (Order == 1)
                //else

                //operational 
                PerceptionCount++;
                var iii = MinisterOnTable[ik].MinisterThinking[0].RowColumnMinister[j][0];
                var jjj = MinisterOnTable[ik].MinisterThinking[0].RowColumnMinister[j][1];
                Color aa = a;
                int[,] Tab = CloneATable(MinisterOnTable[ik].MinisterThinking[0].TableListMinister[j]);
                int Ord = Order;
                MinisterOnTable[ik].MinisterThinking[0].AStarGreedy[MinisterOnTable[ik].MinisterThinking[0].AStarGreedy.Count - 1].CurrentMaxLevel = CurrentMaxLevel + 1;
                //StoreInitMaxAStarGreedy = CurrentMaxLevel; MaxAStarGreedy = CurrentMaxLevel;
                var array1 = Task.Factory.StartNew(() => MinisterOnTable[ik].MinisterThinking[0].AStarGreedy[MinisterOnTable[ik].MinisterThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt(PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, iii, jjj, aa, CloneATable(MinisterOnTable[ik].MinisterThinking[0].TableListMinister[j]), Ord * -1, false, FOUND, LeafAStarGreedy));
                array1.Wait(); array1.Dispose();
                MinisterOnTable[ik].MinisterThinking[0].AStarGreedy[MinisterOnTable[ik].MinisterThinking[0].AStarGreedy.Count - 1].AStarGreedyString = this;
                if (MinisterOnTable[ik].MinisterThinking[0].AStarGreedyMove.Count > 0)
                    MinisterOnTable[ik].MinisterThinking[0].AStarGreedyMove[MinisterOnTable[ik].MinisterThinking[0].AStarGreedy.Count - 1] = true;
            }
            else if (kind == 6)//king
            {
                //when verfied is not valied return
                //if (!IsNotAStarGreedyConanaied(ik, j, 6))

                //minitor
                OutPutAction = " " + Alphabet(KingOnTable[ik].KingThinking[0].Row) + Number(KingOnTable[ik].KingThinking[0].Column) + Alphabet(KingOnTable[ik].KingThinking[0].RowColumnKing[j][0]) + Number(KingOnTable[ik].KingThinking[0].RowColumnKing[j][1]);
                //if (Order == 1)
                //else

                //operational 
                PerceptionCount++;
                var iii = KingOnTable[ik].KingThinking[0].RowColumnKing[j][0];
                var jjj = KingOnTable[ik].KingThinking[0].RowColumnKing[j][1];
                Color aa = a;
                int[,] Tab = CloneATable(KingOnTable[ik].KingThinking[0].TableListKing[j]);
                int Ord = Order;
                KingOnTable[ik].KingThinking[0].AStarGreedy[KingOnTable[ik].KingThinking[0].AStarGreedy.Count - 1].CurrentMaxLevel = CurrentMaxLevel + 1;
                //StoreInitMaxAStarGreedy = CurrentMaxLevel; MaxAStarGreedy = CurrentMaxLevel;
                var array1 = Task.Factory.StartNew(() => KingOnTable[ik].KingThinking[0].AStarGreedy[KingOnTable[ik].KingThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt(PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, iii, jjj, aa, CloneATable(KingOnTable[ik].KingThinking[0].TableListKing[j]), Ord * -1, false, FOUND, LeafAStarGreedy));

                array1.Wait(); array1.Dispose();
                KingOnTable[ik].KingThinking[0].AStarGreedy[KingOnTable[ik].KingThinking[0].AStarGreedy.Count - 1].AStarGreedyString = this;
                if (KingOnTable[ik].KingThinking[0].AStarGreedyMove.Count > 0)
                    KingOnTable[ik].KingThinking[0].AStarGreedyMove[KingOnTable[ik].KingThinking[0].AStarGreedy.Count - 1] = true;
            }
            else if (kind == 7 || kind == -7)//king
            {
                //when verfied is not valied return
                //if (!IsNotAStarGreedyConanaied(ik, j, 6))

                //minitor
                OutPutAction = " " + Alphabet(CastlingOnTable[ik].CastlingThinking[0].Row) + Number(CastlingOnTable[ik].CastlingThinking[0].Column) + Alphabet(CastlingOnTable[ik].CastlingThinking[0].RowColumnCastling[j][0]) + Number(CastlingOnTable[ik].CastlingThinking[0].RowColumnCastling[j][1]);
                //if (Order == 1)
                //else

                //operational 
                PerceptionCount++;
                var iii = CastlingOnTable[ik].CastlingThinking[0].RowColumnCastling[j][0];
                var jjj = CastlingOnTable[ik].CastlingThinking[0].RowColumnCastling[j][1];
                Color aa = a;
                int[,] Tab = CloneATable(CastlingOnTable[ik].CastlingThinking[0].TableListCastling[j]);
                int Ord = Order;
                CastlingOnTable[ik].CastlingThinking[0].AStarGreedy[CastlingOnTable[ik].CastlingThinking[0].AStarGreedy.Count - 1].CurrentMaxLevel = CurrentMaxLevel + 1;
                //StoreInitMaxAStarGreedy = CurrentMaxLevel; MaxAStarGreedy = CurrentMaxLevel;
                var array1 = Task.Factory.StartNew(() => CastlingOnTable[ik].CastlingThinking[0].AStarGreedy[CastlingOnTable[ik].CastlingThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt(PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, iii, jjj, aa, CloneATable(CastlingOnTable[ik].CastlingThinking[0].TableListCastling[j]), Ord * -1, false, FOUND, LeafAStarGreedy));

                array1.Wait(); array1.Dispose();
                CastlingOnTable[ik].CastlingThinking[0].AStarGreedy[CastlingOnTable[ik].CastlingThinking[0].AStarGreedy.Count - 1].AStarGreedyString = this;
                if (CastlingOnTable[ik].CastlingThinking[0].AStarGreedyMove.Count > 0)
                    CastlingOnTable[ik].CastlingThinking[0].AStarGreedyMove[CastlingOnTable[ik].CastlingThinking[0].AStarGreedy.Count - 1] = true;
            }
        }
        bool ReturnFullGameThinkingTreeIligalSemaphore(int ik, int kind)
        {
            if (kind == 1)
            {
                if (SolderesOnTable[ik].SoldierThinking[0].TableListSolder.Count == 0)
                    return true;
            }
            else//elephant
              if (kind == 2)
            {
                if (ElephantOnTable[ik].ElefantThinking[0].TableListElefant.Count == 0)
                    return true;
            }
            else if (kind == 3)//hourse
            {
                if (HoursesOnTable[ik].HourseThinking[0].TableListHourse.Count == 0)
                    return true;
            }
            else if (kind == 4)//Castle
            {
                if (CastlesOnTable[ik].CastleThinking[0].TableListCastle.Count == 0)
                    return true;
            }
            else
                if (kind == 5)//minister
            {
                if (MinisterOnTable[ik].MinisterThinking[0].TableListMinister.Count == 0)
                    return true;
            }
            else if (kind == 6)//king
            {
                if (KingOnTable[ik].KingThinking[0].TableListKing.Count == 0)
                    return true;
            }
            else if (kind == 7 || kind == -7)//king
            {
                if (CastlingOnTable[ik].CastlingThinking[0].TableListCastling.Count == 0)
                    return true;
            }
            return false;
        }
        //decicion for deeper satisfied boundry condition of full game methods group
        void ReturnFullGameThinkingTreeSemaphoreAs(int Order, int iAStarGreedy, int ik, int Kind)
        {
            Object OO1 = new Object();
            lock (OO1)
            {
                TaskBegin++;
                //main decistion
                while (ReturnFullGameThinkingTreeSemaphore(ik, Kind))
                {
                    //when search finished stop and return
                    if (FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy))
                        break;
                }

            }
        }
        public int FullGameThinkingTreeWin(int Order)
        {

            if (Order == 1)
            {
                for (int ik = 0; ik < SodierMidle; ik++)
                {
                    if (SolderesOnTable != null
                                )
                    {
                        if (SolderesOnTable[ik] != null
                                 )
                        {
                            if (SolderesOnTable[ik].SoldierThinking != null
                                    )
                            {
                                if (SolderesOnTable[ik].SoldierThinking[0] != null
                                           )
                                {   //non learning autamata victory leafs
                                    for (int h = 0; h < SolderesOnTable[ik].SoldierThinking[0].AStarGreedy.Count && SolderesOnTable[ik].SoldierThinking[0].AStarGreedy != null; h++)
                                        SolderesOnTable[ik].WinOcuuredatChiled += SolderesOnTable[ik].SoldierThinking[0].AStarGreedy[h].FullGameThinkingTreeWin(Order * -1);
                                    SolderesOnTable[ik].SoldierThinking[0].TowDistrurbProperUse(ref SolderesOnTable[ik].LoseOcuuredatChiled);
                                }
                            }
                        }
                    }
                }
                for (int ik = 0; ik < ElefantMidle; ik++)
                {
                    if (ElephantOnTable != null
                      )
                    {
                        if (ElephantOnTable[ik] != null
                                 )
                        {
                            if (ElephantOnTable[ik].ElefantThinking != null
                                         )
                            {
                                if (ElephantOnTable[ik].ElefantThinking[0] != null
                                            )
                                {      //non learning autamata victory leafs
                                    for (int h = 0; h < ElephantOnTable[ik].ElefantThinking[0].AStarGreedy.Count && ElephantOnTable[ik].ElefantThinking[0].AStarGreedy != null; h++)
                                        ElephantOnTable[ik].WinOcuuredatChiled += ElephantOnTable[ik].ElefantThinking[0].AStarGreedy[h].FullGameThinkingTreeWin(Order * -1);
                                    ElephantOnTable[ik].ElefantThinking[0].TowDistrurbProperUse(ref ElephantOnTable[ik].LoseOcuuredatChiled);
                                }
                            }
                        }
                    }
                }
                for (int ik = 0; ik < HourseMidle; ik++)
                {
                    if (HoursesOnTable != null)
                    {
                        if (HoursesOnTable[ik] != null
                       )
                        {
                            if (HoursesOnTable[ik].HourseThinking != null
                        )
                            {
                                if (HoursesOnTable[ik].HourseThinking[0] != null
                             )
                                {     //non learning autamata victory leafs
                                    for (int h = 0; h < HoursesOnTable[ik].HourseThinking[0].AStarGreedy.Count && HoursesOnTable[ik].HourseThinking[0].AStarGreedy != null; h++)
                                        HoursesOnTable[ik].WinOcuuredatChiled += HoursesOnTable[ik].HourseThinking[0].AStarGreedy[h].FullGameThinkingTreeWin(Order * -1);

                                    HoursesOnTable[ik].HourseThinking[0].TowDistrurbProperUse(ref HoursesOnTable[ik].LoseOcuuredatChiled);
                                }
                            }
                        }
                    }
                }
                for (int ik = 0; ik < CastleMidle; ik++)
                {
                    if (CastlesOnTable != null
           )
                    {
                        if (CastlesOnTable[ik] != null
                     )
                        {
                            if (CastlesOnTable[ik].CastleThinking != null
                         )
                            {
                                if (CastlesOnTable[ik].CastleThinking[0] != null
                             )
                                {      //non learning autamata victory leafs
                                    for (int h = 0; h < CastlesOnTable[ik].CastleThinking[0].AStarGreedy.Count && CastlesOnTable[ik].CastleThinking[0].AStarGreedy != null; h++)
                                        CastlesOnTable[ik].WinOcuuredatChiled += CastlesOnTable[ik].CastleThinking[0].AStarGreedy[h].FullGameThinkingTreeWin(Order * -1);
                                    CastlesOnTable[ik].CastleThinking[0].TowDistrurbProperUse(ref CastlesOnTable[ik].LoseOcuuredatChiled);
                                }
                            }
                        }
                    }
                }
                for (int ik = 0; ik < MinisterMidle; ik++)
                {
                    if (MinisterOnTable != null
           )
                    {
                        if (MinisterOnTable[ik] != null
              )
                        {
                            if (MinisterOnTable[ik].MinisterThinking != null
       )
                            {
                                if (MinisterOnTable[ik].MinisterThinking[0] != null
                             )
                                {      //non learning autamata victory leafs
                                    for (int h = 0; h < MinisterOnTable[ik].MinisterThinking[0].AStarGreedy.Count && MinisterOnTable[ik].MinisterThinking[0].AStarGreedy != null; h++)
                                        MinisterOnTable[ik].WinOcuuredatChiled += MinisterOnTable[ik].MinisterThinking[0].AStarGreedy[h].FullGameThinkingTreeWin(Order * -1);
                                    MinisterOnTable[ik].MinisterThinking[0].TowDistrurbProperUse(ref MinisterOnTable[ik].LoseOcuuredatChiled);
                                }
                            }
                        }
                    }
                }
                for (int ik = 0; ik < KingMidle; ik++)
                {
                    if (KingOnTable != null
)
                    {
                        if (KingOnTable[ik] != null
  )
                        {
                            if (KingOnTable[ik].KingThinking != null
                     )
                            {
                                if (KingOnTable[ik].KingThinking[0] != null
                             )
                                {    //non learning autamata victory leafs
                                    for (int h = 0; h < KingOnTable[ik].KingThinking[0].AStarGreedy.Count && KingOnTable[ik].KingThinking[0].AStarGreedy != null; h++)
                                        KingOnTable[ik].WinOcuuredatChiled += KingOnTable[ik].KingThinking[0].AStarGreedy[h].FullGameThinkingTreeWin(Order * -1);
                                    KingOnTable[ik].KingThinking[0].TowDistrurbProperUse(ref KingOnTable[ik].LoseOcuuredatChiled);
                                }
                            }
                        }
                    }
                }
                for (int ik = 0; ik < 1; ik++)
                {
                    if (CastlingOnTable != null
)
                    {
                        if (CastlingOnTable[ik] != null
  )
                        {
                            if (CastlingOnTable[ik].CastlingThinking != null
                     )
                            {
                                if (CastlingOnTable[ik].CastlingThinking[0] != null
                             )
                                {    //non learning autamata victory leafs
                                    for (int h = 0; h < CastlingOnTable[ik].CastlingThinking[0].AStarGreedy.Count && CastlingOnTable[ik].CastlingThinking[0].AStarGreedy != null; h++)
                                        CastlingOnTable[ik].WinOcuuredatChiled += CastlingOnTable[ik].CastlingThinking[0].AStarGreedy[h].FullGameThinkingTreeWin(Order * -1);
                                    CastlingOnTable[ik].CastlingThinking[0].TowDistrurbProperUse(ref CastlingOnTable[ik].LoseOcuuredatChiled);
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                for (int ik = SodierMidle; ik < SodierHigh; ik++)
                {
                    if (SolderesOnTable != null
                         )
                    {
                        if (SolderesOnTable[ik] != null
                                 )
                        {
                            if (SolderesOnTable[ik].SoldierThinking != null
                                    )
                            {
                                if (SolderesOnTable[ik].SoldierThinking[0] != null
                                           )
                                {   //non learning autamata victory leafs
                                    for (int h = 0; h < SolderesOnTable[ik].SoldierThinking[0].AStarGreedy.Count && SolderesOnTable[ik].SoldierThinking[0].AStarGreedy != null; h++)
                                        SolderesOnTable[ik].WinOcuuredatChiled += SolderesOnTable[ik].SoldierThinking[0].AStarGreedy[h].FullGameThinkingTreeWin(Order * -1);
                                    SolderesOnTable[ik].SoldierThinking[0].TowDistrurbProperUse(ref SolderesOnTable[ik].LoseOcuuredatChiled);
                                }
                            }
                        }
                    }

                }
                for (int ik = ElefantMidle; ik < ElefantMidle; ik++)
                {
                    if (ElephantOnTable != null
            )
                    {
                        if (ElephantOnTable[ik] != null
                                 )
                        {
                            if (ElephantOnTable[ik].ElefantThinking != null
                                         )
                            {
                                if (ElephantOnTable[ik].ElefantThinking[0] != null
                                            )
                                {      //non learning autamata victory leafs
                                    for (int h = 0; h < ElephantOnTable[ik].ElefantThinking[0].AStarGreedy.Count && ElephantOnTable[ik].ElefantThinking[0].AStarGreedy != null; h++)
                                        ElephantOnTable[ik].WinOcuuredatChiled += ElephantOnTable[ik].ElefantThinking[0].AStarGreedy[h].FullGameThinkingTreeWin(Order * -1);
                                    ElephantOnTable[ik].ElefantThinking[0].TowDistrurbProperUse(ref ElephantOnTable[ik].LoseOcuuredatChiled);
                                }
                            }
                        }
                    }

                }
                for (int ik = HourseMidle; ik < HourseHight; ik++)
                {
                    if (HoursesOnTable != null)
                    {
                        if (HoursesOnTable[ik] != null
                       )
                        {
                            if (HoursesOnTable[ik].HourseThinking != null
                        )
                            {
                                if (HoursesOnTable[ik].HourseThinking[0] != null
                             )
                                {     //non learning autamata victory leafs
                                    for (int h = 0; h < HoursesOnTable[ik].HourseThinking[0].AStarGreedy.Count && HoursesOnTable[ik].HourseThinking[0].AStarGreedy != null; h++)
                                        HoursesOnTable[ik].WinOcuuredatChiled += HoursesOnTable[ik].HourseThinking[0].AStarGreedy[h].FullGameThinkingTreeWin(Order * -1);

                                    HoursesOnTable[ik].HourseThinking[0].TowDistrurbProperUse(ref HoursesOnTable[ik].LoseOcuuredatChiled);
                                }
                            }
                        }
                    }
                }


                for (int ik = CastleMidle; ik < CastleHigh; ik++)
                {
                    if (CastlesOnTable != null
          )
                    {
                        if (CastlesOnTable[ik] != null
                     )
                        {
                            if (CastlesOnTable[ik].CastleThinking != null
                         )
                            {
                                if (CastlesOnTable[ik].CastleThinking[0] != null
                             )
                                {      //non learning autamata victory leafs
                                    for (int h = 0; h < CastlesOnTable[ik].CastleThinking[0].AStarGreedy.Count && CastlesOnTable[ik].CastleThinking[0].AStarGreedy != null; h++)
                                        CastlesOnTable[ik].WinOcuuredatChiled += CastlesOnTable[ik].CastleThinking[0].AStarGreedy[h].FullGameThinkingTreeWin(Order * -1);
                                    CastlesOnTable[ik].CastleThinking[0].TowDistrurbProperUse(ref CastlesOnTable[ik].LoseOcuuredatChiled);
                                }
                            }
                        }
                    }
                }

                for (int ik = MinisterMidle; ik < MinisterHigh; ik++)
                {
                    if (MinisterOnTable != null
         )
                    {
                        if (MinisterOnTable[ik] != null
              )
                        {
                            if (MinisterOnTable[ik].MinisterThinking != null
       )
                            {
                                if (MinisterOnTable[ik].MinisterThinking[0] != null
                             )
                                {      //non learning autamata victory leafs
                                    for (int h = 0; h < MinisterOnTable[ik].MinisterThinking[0].AStarGreedy.Count && MinisterOnTable[ik].MinisterThinking[0].AStarGreedy != null; h++)
                                        MinisterOnTable[ik].WinOcuuredatChiled += MinisterOnTable[ik].MinisterThinking[0].AStarGreedy[h].FullGameThinkingTreeWin(Order * -1);
                                    MinisterOnTable[ik].MinisterThinking[0].TowDistrurbProperUse(ref MinisterOnTable[ik].LoseOcuuredatChiled);
                                }
                            }
                        }
                    }
                }
                for (int ik = KingMidle; ik < KingHigh; ik++)
                {
                    if (KingOnTable != null
)
                    {
                        if (KingOnTable[ik] != null
  )
                        {
                            if (KingOnTable[ik].KingThinking != null
                     )
                            {
                                if (KingOnTable[ik].KingThinking[0] != null
                             )
                                {    //non learning autamata victory leafs
                                    for (int h = 0; h < KingOnTable[ik].KingThinking[0].AStarGreedy.Count && KingOnTable[ik].KingThinking[0].AStarGreedy != null; h++)
                                        KingOnTable[ik].WinOcuuredatChiled += KingOnTable[ik].KingThinking[0].AStarGreedy[h].FullGameThinkingTreeWin(Order * -1);
                                    KingOnTable[ik].KingThinking[0].TowDistrurbProperUse(ref KingOnTable[ik].LoseOcuuredatChiled);
                                }
                            }
                        }
                    }

                }
                for (int ik = 0; ik < 1; ik++)
                {
                    if (CastlingOnTable != null
)
                    {
                        if (CastlingOnTable[ik] != null
  )
                        {
                            if (CastlingOnTable[ik].CastlingThinking != null
                     )
                            {
                                if (CastlingOnTable[ik].CastlingThinking[0] != null
                             )
                                {    //non learning autamata victory leafs
                                    for (int h = 0; h < CastlingOnTable[ik].CastlingThinking[0].AStarGreedy.Count && CastlingOnTable[ik].CastlingThinking[0].AStarGreedy != null; h++)
                                        CastlingOnTable[ik].WinOcuuredatChiled += CastlingOnTable[ik].CastlingThinking[0].AStarGreedy[h].FullGameThinkingTreeWin(Order * -1);
                                    CastlingOnTable[ik].CastlingThinking[0].TowDistrurbProperUse(ref CastlingOnTable[ik].LoseOcuuredatChiled);
                                }
                            }
                        }
                    }
                }
            }
            int Sum = 0;
            //if (this.AStarGreedyString != null)
            {
                if (Order == 1)
                {
                    for (var i = 0; i < this.SodierMidle; i++)
                    {
                        if (this.SolderesOnTable != null && this.SolderesOnTable[i] != null)
                            Sum += this.SolderesOnTable[i].WinOcuuredatChiled;
                    }
                    for (var i = 0; i < this.ElefantMidle; i++)
                    {
                        if (this.ElephantOnTable != null && this.ElephantOnTable[i] != null)
                            Sum += this.ElephantOnTable[i].WinOcuuredatChiled;
                    }
                    for (var i = 0; i < this.HourseMidle; i++)
                    {
                        if (this.HoursesOnTable != null && this.HoursesOnTable[i] != null)
                            Sum += this.HoursesOnTable[i].WinOcuuredatChiled;
                    }
                    for (var i = 0; i < this.CastleMidle; i++)
                    {
                        if (this.CastlesOnTable != null && this.CastlesOnTable[i] != null)
                            Sum += this.CastlesOnTable[i].WinOcuuredatChiled;
                    }
                    for (var i = 0; i < this.MinisterMidle; i++)
                    {
                        if (this.MinisterOnTable != null && this.MinisterOnTable[i] != null)
                            Sum += this.MinisterOnTable[i].WinOcuuredatChiled;
                    }
                    for (var i = 0; i < this.KingMidle; i++)
                    {
                        if (this.KingOnTable != null && this.KingOnTable[i] != null)
                            Sum += this.KingOnTable[i].WinOcuuredatChiled;
                    }

                    for (var i = 0; i < 1; i++)
                    {
                        if (this.CastlingOnTable != null && this.CastlingOnTable[i] != null)
                            Sum += this.CastlingOnTable[i].WinOcuuredatChiled;
                    }

                }
                else
                {
                    for (var i = this.SodierMidle; i < this.SodierHigh; i++)
                    {
                        if (this.SolderesOnTable != null && this.SolderesOnTable[i] != null)
                            Sum += this.SolderesOnTable[i].WinOcuuredatChiled;
                    }
                    for (var i = this.ElefantMidle; i < this.ElefantHigh; i++)
                    {
                        if (this.ElephantOnTable != null && this.ElephantOnTable[i] != null)
                            Sum += this.ElephantOnTable[i].WinOcuuredatChiled;
                    }
                    for (var i = this.HourseMidle; i < this.HourseHight; i++)
                    {
                        if (this.HoursesOnTable != null && this.HoursesOnTable[i] != null)
                            Sum += this.HoursesOnTable[i].WinOcuuredatChiled;
                    }
                    for (var i = this.CastleMidle; i < this.CastleHigh; i++)
                    {
                        if (this.CastlesOnTable != null && this.CastlesOnTable[i] != null)
                            Sum += this.CastlesOnTable[i].WinOcuuredatChiled;
                    }
                    for (var i = this.MinisterMidle; i < this.MinisterHigh; i++)
                    {
                        if (this.MinisterOnTable != null && this.MinisterOnTable[i] != null)
                            Sum += this.MinisterOnTable[i].WinOcuuredatChiled;
                    }
                    for (var i = this.KingMidle; i < this.KingHigh; i++)
                    {
                        if (this.KingOnTable != null && this.KingOnTable[i] != null)
                            Sum += this.KingOnTable[i].WinOcuuredatChiled;
                    }
                    for (var i = 0; i < 1; i++)
                    {
                        if (this.CastlingOnTable != null && this.CastlingOnTable[i] != null)
                            Sum += this.CastlingOnTable[i].WinOcuuredatChiled;
                    }
                }
            }
            return Sum;
        }
        public int FullGameThinkingTreeLose(int Order)
        {
            if (Order == 1)
            {
                for (int ik = 0; ik < SodierMidle; ik++)
                {
                    if (SolderesOnTable != null
                                )
                    {
                        if (SolderesOnTable[ik] != null
                                 )
                        {
                            if (SolderesOnTable[ik].SoldierThinking != null
                                    )
                            {
                                if (SolderesOnTable[ik].SoldierThinking[0] != null
                                           )
                                {   //non learning autamata victory leafs
                                    for (int h = 0; h < SolderesOnTable[ik].SoldierThinking[0].AStarGreedy.Count && SolderesOnTable[ik].SoldierThinking[0].AStarGreedy != null; h++)
                                        SolderesOnTable[ik].LoseOcuuredatChiled[0] += SolderesOnTable[ik].SoldierThinking[0].AStarGreedy[h].FullGameThinkingTreeLose(Order * -1);
                                }
                            }
                        }
                    }
                }
                for (int ik = 0; ik < ElefantMidle; ik++)
                {
                    if (ElephantOnTable != null
                      )
                    {
                        if (ElephantOnTable[ik] != null
                                 )
                        {
                            if (ElephantOnTable[ik].ElefantThinking != null
                                         )
                            {
                                if (ElephantOnTable[ik].ElefantThinking[0] != null
                                            )
                                {      //non learning autamata victory leafs
                                    for (int h = 0; h < ElephantOnTable[ik].ElefantThinking[0].AStarGreedy.Count && ElephantOnTable[ik].ElefantThinking[0].AStarGreedy != null; h++)
                                        ElephantOnTable[ik].LoseOcuuredatChiled[0] += ElephantOnTable[ik].ElefantThinking[0].AStarGreedy[h].FullGameThinkingTreeLose(Order * -1);
                                }
                            }
                        }
                    }
                }
                for (int ik = 0; ik < HourseMidle; ik++)
                {
                    if (HoursesOnTable != null)
                    {
                        if (HoursesOnTable[ik] != null
                       )
                        {
                            if (HoursesOnTable[ik].HourseThinking != null
                        )
                            {
                                if (HoursesOnTable[ik].HourseThinking[0] != null
                             )
                                {     //non learning autamata victory leafs
                                    for (int h = 0; h < HoursesOnTable[ik].HourseThinking[0].AStarGreedy.Count && HoursesOnTable[ik].HourseThinking[0].AStarGreedy != null; h++)
                                        HoursesOnTable[ik].LoseOcuuredatChiled[0] += HoursesOnTable[ik].HourseThinking[0].AStarGreedy[h].FullGameThinkingTreeLose(Order * -1);

                                }
                            }
                        }
                    }
                }
                for (int ik = 0; ik < CastleMidle; ik++)
                {
                    if (CastlesOnTable != null
           )
                    {
                        if (CastlesOnTable[ik] != null
                     )
                        {
                            if (CastlesOnTable[ik].CastleThinking != null
                         )
                            {
                                if (CastlesOnTable[ik].CastleThinking[0] != null
                             )
                                {      //non learning autamata victory leafs
                                    for (int h = 0; h < CastlesOnTable[ik].CastleThinking[0].AStarGreedy.Count && CastlesOnTable[ik].CastleThinking[0].AStarGreedy != null; h++)
                                        CastlesOnTable[ik].LoseOcuuredatChiled[0] += CastlesOnTable[ik].CastleThinking[0].AStarGreedy[h].FullGameThinkingTreeLose(Order * -1);
                                }
                            }
                        }
                    }
                }
                for (int ik = 0; ik < MinisterMidle; ik++)
                {
                    if (MinisterOnTable != null
           )
                    {
                        if (MinisterOnTable[ik] != null
              )
                        {
                            if (MinisterOnTable[ik].MinisterThinking != null
       )
                            {
                                if (MinisterOnTable[ik].MinisterThinking[0] != null
                             )
                                {      //non learning autamata victory leafs
                                    for (int h = 0; h < MinisterOnTable[ik].MinisterThinking[0].AStarGreedy.Count && MinisterOnTable[ik].MinisterThinking[0].AStarGreedy != null; h++)
                                        MinisterOnTable[ik].LoseOcuuredatChiled[0] += MinisterOnTable[ik].MinisterThinking[0].AStarGreedy[h].FullGameThinkingTreeLose(Order * -1);
                                }
                            }
                        }
                    }
                }
                for (int ik = 0; ik < KingMidle; ik++)
                {
                    if (KingOnTable != null
)
                    {
                        if (KingOnTable[ik] != null
  )
                        {
                            if (KingOnTable[ik].KingThinking != null
                     )
                            {
                                if (KingOnTable[ik].KingThinking[0] != null
                             )
                                {    //non learning autamata victory leafs
                                    for (int h = 0; h < KingOnTable[ik].KingThinking[0].AStarGreedy.Count && KingOnTable[ik].KingThinking[0].AStarGreedy != null; h++)
                                        KingOnTable[ik].LoseOcuuredatChiled[0] += KingOnTable[ik].KingThinking[0].AStarGreedy[h].FullGameThinkingTreeLose(Order * -1);
                                }
                            }
                        }
                    }
                }
                for (int ik = 0; ik < 1; ik++)
                {
                    if (CastlingOnTable != null
)
                    {
                        if (CastlingOnTable[ik] != null
  )
                        {
                            if (CastlingOnTable[ik].CastlingThinking != null
                     )
                            {
                                if (CastlingOnTable[ik].CastlingThinking[0] != null
                             )
                                {    //non learning autamata victory leafs
                                    for (int h = 0; h < CastlingOnTable[ik].CastlingThinking[0].AStarGreedy.Count && CastlingOnTable[ik].CastlingThinking[0].AStarGreedy != null; h++)
                                        CastlingOnTable[ik].LoseOcuuredatChiled[0] += CastlingOnTable[ik].CastlingThinking[0].AStarGreedy[h].FullGameThinkingTreeLose(Order * -1);
                                }
                            }
                        }
                    }

                }
            }
            else
            {
                for (int ik = SodierMidle; ik < SodierHigh; ik++)
                {
                    if (SolderesOnTable != null
                         )
                    {
                        if (SolderesOnTable[ik] != null
                                 )
                        {
                            if (SolderesOnTable[ik].SoldierThinking != null
                                    )
                            {
                                if (SolderesOnTable[ik].SoldierThinking[0] != null
                                           )
                                {   //non learning autamata victory leafs
                                    for (int h = 0; h < SolderesOnTable[ik].SoldierThinking[0].AStarGreedy.Count && SolderesOnTable[ik].SoldierThinking[0].AStarGreedy != null; h++)
                                        SolderesOnTable[ik].LoseOcuuredatChiled[0] += SolderesOnTable[ik].SoldierThinking[0].AStarGreedy[h].FullGameThinkingTreeLose(Order * -1);
                                }
                            }
                        }
                    }

                }
                for (int ik = ElefantMidle; ik < ElefantMidle; ik++)
                {
                    if (ElephantOnTable != null
            )
                    {
                        if (ElephantOnTable[ik] != null
                                 )
                        {
                            if (ElephantOnTable[ik].ElefantThinking != null
                                         )
                            {
                                if (ElephantOnTable[ik].ElefantThinking[0] != null
                                            )
                                {      //non learning autamata victory leafs
                                    for (int h = 0; h < ElephantOnTable[ik].ElefantThinking[0].AStarGreedy.Count && ElephantOnTable[ik].ElefantThinking[0].AStarGreedy != null; h++)
                                        ElephantOnTable[ik].LoseOcuuredatChiled[0] += ElephantOnTable[ik].ElefantThinking[0].AStarGreedy[h].FullGameThinkingTreeLose(Order * -1);
                                }
                            }
                        }
                    }

                }
                for (int ik = HourseMidle; ik < HourseHight; ik++)
                {
                    if (HoursesOnTable != null)
                    {
                        if (HoursesOnTable[ik] != null
                       )
                        {
                            if (HoursesOnTable[ik].HourseThinking != null
                        )
                            {
                                if (HoursesOnTable[ik].HourseThinking[0] != null
                             )
                                {     //non learning autamata victory leafs
                                    for (int h = 0; h < HoursesOnTable[ik].HourseThinking[0].AStarGreedy.Count && HoursesOnTable[ik].HourseThinking[0].AStarGreedy != null; h++)
                                        HoursesOnTable[ik].LoseOcuuredatChiled[0] += HoursesOnTable[ik].HourseThinking[0].AStarGreedy[h].FullGameThinkingTreeLose(Order * -1);

                                }
                            }
                        }
                    }
                }


                for (int ik = CastleMidle; ik < CastleHigh; ik++)
                {
                    if (CastlesOnTable != null
          )
                    {
                        if (CastlesOnTable[ik] != null
                     )
                        {
                            if (CastlesOnTable[ik].CastleThinking != null
                         )
                            {
                                if (CastlesOnTable[ik].CastleThinking[0] != null
                             )
                                {      //non learning autamata victory leafs
                                    for (int h = 0; h < CastlesOnTable[ik].CastleThinking[0].AStarGreedy.Count && CastlesOnTable[ik].CastleThinking[0].AStarGreedy != null; h++)
                                        CastlesOnTable[ik].LoseOcuuredatChiled[0] += CastlesOnTable[ik].CastleThinking[0].AStarGreedy[h].FullGameThinkingTreeLose(Order * -1);
                                }
                            }
                        }
                    }
                }

                for (int ik = MinisterMidle; ik < MinisterHigh; ik++)
                {
                    if (MinisterOnTable != null
         )
                    {
                        if (MinisterOnTable[ik] != null
              )
                        {
                            if (MinisterOnTable[ik].MinisterThinking != null
       )
                            {
                                if (MinisterOnTable[ik].MinisterThinking[0] != null
                             )
                                {      //non learning autamata victory leafs
                                    for (int h = 0; h < MinisterOnTable[ik].MinisterThinking[0].AStarGreedy.Count && MinisterOnTable[ik].MinisterThinking[0].AStarGreedy != null; h++)
                                        MinisterOnTable[ik].LoseOcuuredatChiled[0] += MinisterOnTable[ik].MinisterThinking[0].AStarGreedy[h].FullGameThinkingTreeLose(Order * -1);
                                }
                            }
                        }
                    }
                }
                for (int ik = KingMidle; ik < KingHigh; ik++)
                {
                    if (KingOnTable != null
)
                    {
                        if (KingOnTable[ik] != null
  )
                        {
                            if (KingOnTable[ik].KingThinking != null
                     )
                            {
                                if (KingOnTable[ik].KingThinking[0] != null
                             )
                                {    //non learning autamata victory leafs
                                    for (int h = 0; h < KingOnTable[ik].KingThinking[0].AStarGreedy.Count && KingOnTable[ik].KingThinking[0].AStarGreedy != null; h++)
                                        KingOnTable[ik].LoseOcuuredatChiled[0] += KingOnTable[ik].KingThinking[0].AStarGreedy[h].FullGameThinkingTreeLose(Order * -1);
                                }
                            }
                        }
                    }

                }
                for (int ik = 0; ik < 1; ik++)
                {
                    if (CastlingOnTable != null
)
                    {
                        if (CastlingOnTable[ik] != null
  )
                        {
                            if (CastlingOnTable[ik].CastlingThinking != null
                     )
                            {
                                if (CastlingOnTable[ik].CastlingThinking[0] != null
                             )
                                {    //non learning autamata victory leafs
                                    for (int h = 0; h < CastlingOnTable[ik].CastlingThinking[0].AStarGreedy.Count && CastlingOnTable[ik].CastlingThinking[0].AStarGreedy != null; h++)
                                        CastlingOnTable[ik].LoseOcuuredatChiled[0] += CastlingOnTable[ik].CastlingThinking[0].AStarGreedy[h].FullGameThinkingTreeLose(Order * -1);
                                }
                            }
                        }
                    }

                }

            }
            int Sum = 0;
            //if (this.AStarGreedyString != null)
            {
                //if (!IsAtleastAWin(this, Order))
                {
                    if (Order == 1)
                    {
                        for (var i = 0; i < this.SodierMidle; i++)
                        {
                            if (this.SolderesOnTable != null && this.SolderesOnTable[i] != null)
                                Sum += this.SolderesOnTable[i].LoseOcuuredatChiled[0];
                        }
                        for (var i = 0; i < this.ElefantMidle; i++)
                        {
                            if (this.ElephantOnTable != null && this.ElephantOnTable[i] != null)
                                Sum += this.ElephantOnTable[i].LoseOcuuredatChiled[0];
                        }
                        for (var i = 0; i < this.HourseMidle; i++)
                        {
                            if (this.HoursesOnTable != null && this.HoursesOnTable[i] != null)
                                Sum += this.HoursesOnTable[i].LoseOcuuredatChiled[0];
                        }
                        for (var i = 0; i < this.CastleMidle; i++)
                        {
                            if (this.CastlesOnTable != null && this.CastlesOnTable[i] != null)
                                Sum += this.CastlesOnTable[i].LoseOcuuredatChiled[0];
                        }
                        for (var i = 0; i < this.MinisterMidle; i++)
                        {
                            if (this.MinisterOnTable != null && this.MinisterOnTable[i] != null)
                                Sum += this.MinisterOnTable[i].LoseOcuuredatChiled[0];
                        }
                        for (var i = 0; i < this.KingMidle; i++)
                        {
                            if (this.KingOnTable != null && this.KingOnTable[i] != null)
                                Sum += this.KingOnTable[i].LoseOcuuredatChiled[0];
                        }
                        for (var i = 0; i < 1; i++)
                        {
                            if (this.CastlingOnTable != null && this.CastlingOnTable[i] != null)
                                Sum += this.CastlingOnTable[i].LoseOcuuredatChiled[0];
                        }
                    }
                    else
                    {
                        for (var i = this.SodierMidle; i < this.SodierHigh; i++)
                        {
                            if (this.SolderesOnTable != null && this.SolderesOnTable[i] != null)
                                Sum += this.SolderesOnTable[i].LoseOcuuredatChiled[0];
                        }
                        for (var i = this.ElefantMidle; i < this.ElefantHigh; i++)
                        {
                            if (this.ElephantOnTable != null && this.ElephantOnTable[i] != null)
                                Sum += this.ElephantOnTable[i].LoseOcuuredatChiled[0];
                        }
                        for (var i = this.HourseMidle; i < this.HourseHight; i++)
                        {
                            if (this.HoursesOnTable != null && this.HoursesOnTable[i] != null)
                                Sum += this.HoursesOnTable[i].LoseOcuuredatChiled[0];
                        }
                        for (var i = this.CastleMidle; i < this.CastleHigh; i++)
                        {
                            if (this.CastlesOnTable != null && this.CastlesOnTable[i] != null)
                                Sum += this.CastlesOnTable[i].LoseOcuuredatChiled[0];
                        }
                        for (var i = this.MinisterMidle; i < this.MinisterHigh; i++)
                        {
                            if (this.MinisterOnTable != null && this.MinisterOnTable[i] != null)
                                Sum += this.MinisterOnTable[i].LoseOcuuredatChiled[0];
                        }
                        for (var i = this.KingMidle; i < this.KingHigh; i++)
                        {
                            if (this.KingOnTable != null && this.KingOnTable[i] != null)
                                Sum += this.KingOnTable[i].LoseOcuuredatChiled[0];
                        }
                        for (var i = 0; i < 1; i++)
                        {
                            if (this.CastlingOnTable != null && this.CastlingOnTable[i] != null)
                                Sum += this.CastlingOnTable[i].LoseOcuuredatChiled[0];
                        }
                    }

                }
            }
            return Sum;
        }
        //deeper for soldier
        bool FullGameThinkingTreeSoldier(int ik, Color a, int Order, int iAStarGreedy, int ii, int jj, int ik1, int j1, bool FOUND, int LeafAStarGreedy)
        {

            bool Do = false;
            Object O1 = new Object();
            lock (O1)
            {
                if (ReturnFullGameThinkingTreeIligalSemaphore(ik, 1))
                    return false;
                //semaphore
                var array = Task.Factory.StartNew(() => ReturnFullGameThinkingTreeSemaphoreAs(Order, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ik, 1));

                array.Wait(); array.Dispose();
                Object OOOO = new Object();
                lock (OOOO)
                {
                    //when search finished stop and return
                    if (FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy))
                        return false;
                }
                //ParallelOptions po = new ParallelOptions();       po.MaxDegreeOfParallelism =PlatformHelper.ProcessorCount;                    Parallel.For(0, SolderesOnTable[ik].SoldierThinking[0].TableListSolder.Count, j =>
                //operational computation secxistence
                for (var j = 0; j < SolderesOnTable[ik].SoldierThinking[0].TableListSolder.Count; j++)
                {
                    if (IsSupHuTrue(ik, j, 0, 1))
                        continue;
                    Object OOOOO = new Object();
                    lock (OOOOO)
                    {
                        //when search finished stop and return
                        if (FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy))
                            return false;
                    }
                    Object ooo = new Object();
                    lock (ooo)
                    {
                        //when node have kings dangoures ignore and continue.
                        if (CheckeHuristci(CloneATable(SolderesOnTable[ik].SoldierThinking[0].TableListSolder[j]), Order, ik, j, 0))
                            continue;
                        //sereved continuce
                        if (IsSupHuTrue(ik, j, 0, 1))
                            continue;

                        bool ac = false;
                        var ah3 = Task.Factory.StartNew(() => ac = Lose(1, ik, j, Order));
                        ah3.Wait();
                        ah3.Dispose();
                        if (ac)
                            continue;

                        //self do
                        if (Order != AllDraw.OrderPlateDraw)
                        {
                            //when certification for continued of code satisfied
                            if (ReturnConsiderationOfPermitForValidationOfLearningInFullGameThinkingTree(ik, 1, true, j)
                            )
                            {
                                //when blitz game (limited game)
                                if (AllDraw.Blitz)
                                {
                                    //when do permite
                                    if (Index[0] != -1)
                                    {
                                        //object kind semaphore
                                        if (ik != Index[0])
                                        {
                                            //satisfied of created deeper one
                                            BlitzNotValidFullGameThinkingTreePartOne(ik, Order, 1);
                                            continue;
                                        }
                                        else//computational lists semaphore
                                        if (j != jindex[0])
                                        {
                                            //satisfied of created deeper tow
                                            BlitzNotValidFullGameThinkingTreePartTow(ik, Order, 1);
                                            continue;
                                        }
                                    }
                                    else
                                    {
                                        //satisfied of created deeper three
                                        BlitzNotValidFullGameThinkingTreePartThree(ik, Order, 1);
                                        continue;
                                    }
                                }
                                else
                                    BlitzNotValidFullGameThinkingTreePartOne(ik, Order, 1);
                                Object O3 = new Object();
                                lock (O3)
                                {
                                    //initiate for satisfied full game primary conditions

                                }
                                //when deeper is valid
                                if (SolderesOnTable[ik].SoldierThinking[0].AStarGreedy.Count > 0)
                                {
                                    Object O = new Object();
                                    lock (O)
                                    {
                                        //do deeper
                                        OpOfFullGameThinkingTree(ik, j, Order, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ii, jj, a, 1, FOUND, LeafAStarGreedy);
                                        Do = true;
                                    }
                                }
                            }
                        }
                        else
                        {
                            //when certification for continued of code satisfied
                            if (ReturnConsiderationOfPermitForValidationOfLearningInFullGameThinkingTree(ik, 1, false, j)
                            )
                            {
                                //when do permite
                                //when blitz game (limited game)
                                if (AllDraw.Blitz)
                                {
                                    //when do permite
                                    if (Index[0] != -1)
                                    {
                                        //object kind semaphore
                                        if (ik != Index[0])
                                        {
                                            //satisfied of created deeper one
                                            BlitzNotValidFullGameThinkingTreePartOne(ik, Order, 1);
                                            continue;
                                        }
                                        else//computational lists semaphore
                                        if (j != jindex[0])
                                        {
                                            //satisfied of created deeper tow
                                            BlitzNotValidFullGameThinkingTreePartTow(ik, Order, 1);
                                            continue;
                                        }
                                    }
                                    else
                                    {
                                        //satisfied of created deeper three
                                        BlitzNotValidFullGameThinkingTreePartThree(ik, Order, 1);
                                        continue;
                                    }
                                }
                                else
                                    BlitzNotValidFullGameThinkingTreePartOne(ik, Order, 1);
                                Object O3 = new Object();
                                lock (O3)
                                {
                                    //initiate for satisfied full game primary conditions

                                }
                                //when deeper is valid
                                if (SolderesOnTable[ik].SoldierThinking[0].AStarGreedy.Count > 0)
                                {
                                    Object O = new Object();
                                    lock (O)
                                    {
                                        //do deeper
                                        OpOfFullGameThinkingTree(ik, j, Order, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ii, jj, a, 1, FOUND, LeafAStarGreedy);
                                        Do = true;
                                    }
                                }

                            }
                        }
                    }
                }
                Object O2 = new Object();
                lock (O2)
                {
                    TaskEnd++;
                }
            }
            return Do;
            //Elephant
        }
        //collection objects calling full game specific game 
        bool FullGameThinkingTreeSoldierGray(Color a, int Order, int iAStarGreedy, int ii, int jj, int ik1, int j1, bool FOUND, int LeafAStarGreedy)
        {

            bool Do = false;
            Object O1 = new Object();
            lock (O1)
            {
                ThinkingAllowed[0] = true;

                ParallelOptions po = new ParallelOptions(); po.MaxDegreeOfParallelism = System.Threading.PlatformHelper.ProcessorCount; Parallel.For(0, SodierMidle, ik =>

 {
     if (SolderesOnTable != null && SolderesOnTable[ik] != null && SolderesOnTable[ik].SoldierThinking != null && SolderesOnTable[ik].SoldierThinking[0] != null
    )
     {
         Object O = new Object();
         lock (O)
         {
             var array = Task.Factory.StartNew(() => Do = FullGameThinkingTreeSoldier(ik, a, Order, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ii, jj, ik1, j1, FOUND, LeafAStarGreedy));
             array.Wait(); array.Dispose();
            //TH.Add(array);
        }
     }
 });
            }

            return Do;
        }
        bool FullGameThinkingTreeElephant(int ik, Color a, int Order, int iAStarGreedy, int ii, int jj, int ik1, int j1, bool FOUND, int LeafAStarGreedy)
        {

            bool Do = false;
            Object O1 = new Object();
            lock (O1)
            {
                if (ReturnFullGameThinkingTreeIligalSemaphore(ik, 2))
                    return false;
                //semaphore
                var array = Task.Factory.StartNew(() => ReturnFullGameThinkingTreeSemaphoreAs(Order, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ik, 2));
                array.Wait(); array.Dispose();
                Object OOOO = new Object();
                lock (OOOO)
                {

                    //when search finished stop and return
                    if (FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy))
                        return false;

                }
                ////ParallelOptions po = new ParallelOptions();       po.MaxDegreeOfParallelism =PlatformHelper.ProcessorCount;                    Parallel.For(0, ElephantOnTable[ik].ElefantThinking[0].TableListElefant.Count, j =>
                //operational computation secxistence
                for (var j = 0; j < ElephantOnTable[ik].ElefantThinking[0].TableListElefant.Count; j++)
                {
                    Object OOOOO = new Object();
                    lock (OOOOO)
                    {
                        if (IsSupHuTrue(ik, j, 0, 2))
                            continue;
                        //when search finished stop and return
                        if (FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy))
                            return false;
                    }
                    Object ooo = new Object();
                    lock (ooo)
                    {
                        //when node have kings dangoures ignore and continue.
                        if (CheckeHuristci(CloneATable(ElephantOnTable[ik].ElefantThinking[0].TableListElefant[j]), Order, ik, j, 0))
                            continue;
                        //sereved continuce
                        if (IsSupHuTrue(ik, j, 0, 2))
                            continue;

                        bool ac = false;
                        var ah3 = Task.Factory.StartNew(() => ac = Lose(2, ik, j, Order));
                        ah3.Wait();
                        ah3.Dispose();
                        if (ac)
                            continue;

                        //self do
                        if (Order != AllDraw.OrderPlateDraw)
                        {
                            //when certification for continued of code satisfied
                            if (ReturnConsiderationOfPermitForValidationOfLearningInFullGameThinkingTree(ik, 2, true, j)
                            )
                            {
                                //when blitz game (limited game)
                                if (AllDraw.Blitz)
                                {
                                    //when do permite
                                    if (Index[1] != -1)
                                    {
                                        //object kind semaphore
                                        if (ik != Index[1])
                                        {
                                            //satisfied of created deeper one
                                            BlitzNotValidFullGameThinkingTreePartOne(ik, Order, 2);
                                            continue;
                                        }
                                        else
                                            if (j != jindex[1])
                                        {
                                            //satisfied of created deeper tow
                                            BlitzNotValidFullGameThinkingTreePartTow(ik, Order, 2);
                                            continue;
                                        }
                                    }
                                    else
                                    {
                                        //satisfied of created deeper three
                                        BlitzNotValidFullGameThinkingTreePartThree(ik, Order, 2);
                                        continue;
                                    }
                                }
                                else
                                    BlitzNotValidFullGameThinkingTreePartOne(ik, Order, 2);
                                Object O3 = new Object();
                                lock (O3)
                                {
                                    //initiate for satisfied full game primary conditions

                                    //when deeper is valid
                                    if (ElephantOnTable[ik].ElefantThinking[0].AStarGreedy.Count > 0)
                                    {
                                        Object O = new Object();
                                        lock (O)
                                        {
                                            //do deeper
                                            OpOfFullGameThinkingTree(ik, j, Order, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ii, jj, a, 2, FOUND, LeafAStarGreedy);
                                            Do = true;
                                        }
                                    }
                                }
                            }
                        }
                        else
                        {
                            //when certification for continued of code satisfied
                            if (ReturnConsiderationOfPermitForValidationOfLearningInFullGameThinkingTree(ik, 2, false, j)
                            )
                            {
                                //when blitz game (limited game)
                                if (AllDraw.Blitz)
                                {
                                    //when do permite
                                    if (Index[1] != -1)
                                    {
                                        //object kind semaphore
                                        if (ik != Index[1])
                                        {
                                            //satisfied of created deeper one
                                            BlitzNotValidFullGameThinkingTreePartOne(ik, Order, 2);
                                            continue;
                                        }
                                        else
                                            if (j != jindex[1])
                                        {
                                            //satisfied of created deeper tow
                                            BlitzNotValidFullGameThinkingTreePartTow(ik, Order, 2);
                                            continue;
                                        }
                                    }
                                    else
                                    {
                                        //satisfied of created deeper three
                                        BlitzNotValidFullGameThinkingTreePartThree(ik, Order, 2);
                                        continue;
                                    }
                                }
                                else
                                    BlitzNotValidFullGameThinkingTreePartOne(ik, Order, 2);
                                Object O3 = new Object();
                                lock (O3)
                                {
                                    //initiate for satisfied full game primary conditions

                                    //when deeper is valid
                                    if (ElephantOnTable[ik].ElefantThinking[0].AStarGreedy.Count > 0)
                                    {
                                        Object O = new Object();
                                        lock (O)
                                        {
                                            //do deeper
                                            OpOfFullGameThinkingTree(ik, j, Order, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ii, jj, a, 2, FOUND, LeafAStarGreedy);
                                            Do = true;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }

                Object O2 = new Object();
                lock (O2)
                {
                    TaskEnd++;
                }
            }

            return Do;
        }
        //collection objects calling full game specific game 
        bool FullGameThinkingTreeElephantGray(Color a, int Order, int iAStarGreedy, int ii, int jj, int ik1, int j1, bool FOUND, int LeafAStarGreedy)
        {

            bool Do = false;
            Object O1 = new Object();
            lock (O1)
            {
                ThinkingAllowed[1] = true;
                //Elephant
                ParallelOptions po = new ParallelOptions(); po.MaxDegreeOfParallelism = System.Threading.PlatformHelper.ProcessorCount; Parallel.For(0, ElefantMidle, ik =>

 {
     if (ElephantOnTable != null && ElephantOnTable[ik] != null && ElephantOnTable[ik].ElefantThinking != null && ElephantOnTable[ik].ElefantThinking[0] != null
    )
     {
         Object O = new Object();
         lock (O)
         {
             var array = Task.Factory.StartNew(() => Do = FullGameThinkingTreeElephant(ik, a, Order, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ii, jj, ik1, j1, FOUND, LeafAStarGreedy));
             array.Wait(); array.Dispose();
            //TH.Add(array);
        }
     }
 });
            }

            return Do;
        }
        bool FullGameThinkingTreeHourse(int ik, Color a, int Order, int iAStarGreedy, int ii, int jj, int ik1, int j1, bool FOUND, int LeafAStarGreedy)
        {

            bool Do = false;
            Object O1 = new Object();
            lock (O1)
            {
                if (ReturnFullGameThinkingTreeIligalSemaphore(ik, 3))
                    return false;
                //semaphore
                var array = Task.Factory.StartNew(() => ReturnFullGameThinkingTreeSemaphoreAs(Order, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ik, 3));
                array.Wait(); array.Dispose();

                Object OOOO = new Object();
                lock (OOOO)
                {

                    //when search finished stop and return
                    if (FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy))
                        return false;

                }
                ////ParallelOptions po = new ParallelOptions();       po.MaxDegreeOfParallelism =PlatformHelper.ProcessorCount;                    Parallel.For(0, HoursesOnTable[ik].HourseThinking[0].TableListHourse.Count, j =>
                //operational computation secxistence
                for (var j = 0; j < HoursesOnTable[ik].HourseThinking[0].TableListHourse.Count; j++)
                {
                    Object OOOOO = new Object();
                    lock (OOOOO)
                    {
                        if (IsSupHuTrue(ik, j, 0, 3))
                            continue;
                        bool ac = false;
                        var ah3 = Task.Factory.StartNew(() => ac = Lose(3, ik, j, Order));
                        ah3.Wait();
                        ah3.Dispose();
                        if (ac)
                            continue;


                        //when search finished stop and return
                        if (FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy))
                            return false;
                    }
                    Object ooo = new Object();
                    lock (ooo)
                    {
                        //when node have kings dangoures ignore and continue.
                        if (CheckeHuristci(CloneATable(HoursesOnTable[ik].HourseThinking[0].TableListHourse[j]), Order, ik, j, 0))
                            continue;
                        //sereved continuce
                        if (HoursesOnTable[ik].HourseThinking[0].IsSupHu[j])
                            continue;

                        //self do
                        if (Order != AllDraw.OrderPlateDraw)
                        {
                            //when certification for continued of code satisfied
                            if (ReturnConsiderationOfPermitForValidationOfLearningInFullGameThinkingTree(ik, 3, true, j)
                            )
                            {
                                //when blitz game (limited game)
                                if (AllDraw.Blitz)
                                {
                                    //when do permite
                                    if (Index[2] != -1)
                                    {
                                        //object kind semaphore
                                        if (ik != Index[2])
                                        {
                                            //satisfied of created deeper one
                                            BlitzNotValidFullGameThinkingTreePartOne(ik, Order, 3);
                                            continue;
                                        }
                                        else
                                            if (j != jindex[2])
                                        {
                                            //satisfied of created deeper tow
                                            BlitzNotValidFullGameThinkingTreePartTow(ik, Order, 3);
                                            continue;
                                        }
                                    }
                                    else
                                    {
                                        //satisfied of created deeper three
                                        BlitzNotValidFullGameThinkingTreePartThree(ik, Order, 3);
                                        continue;
                                    }
                                }
                                else
                                    BlitzNotValidFullGameThinkingTreePartOne(ik, Order, 3);

                                Object O3 = new Object();
                                lock (O3)
                                {

                                }


                                if (HoursesOnTable[ik].HourseThinking[0].AStarGreedy.Count > 0)
                                {
                                    Object O = new Object();
                                    lock (O)
                                    {
                                        //do deeper
                                        OpOfFullGameThinkingTree(ik, j, Order, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ii, jj, a, 3, FOUND, LeafAStarGreedy);
                                        Do = true;
                                    }
                                }
                            }
                            else
                            {
                                //when certification for continued of code satisfied
                                if (ReturnConsiderationOfPermitForValidationOfLearningInFullGameThinkingTree(ik, 3, false, j)
                                )
                                {
                                    //when blitz game (limited game)
                                    if (AllDraw.Blitz)
                                    {
                                        //when do permite
                                        if (Index[2] != -1)
                                        {
                                            //object kind semaphore
                                            if (ik != Index[2])
                                            {
                                                //satisfied of created deeper one
                                                BlitzNotValidFullGameThinkingTreePartOne(ik, Order, 3);
                                                continue;
                                            }
                                            else
                                                if (j != jindex[2])
                                            {
                                                //satisfied of created deeper tow
                                                BlitzNotValidFullGameThinkingTreePartTow(ik, Order, 3);
                                                continue;
                                            }
                                        }
                                        else
                                        {
                                            //satisfied of created deeper three
                                            BlitzNotValidFullGameThinkingTreePartThree(ik, Order, 3);
                                            continue;
                                        }
                                    }
                                    else
                                        BlitzNotValidFullGameThinkingTreePartOne(ik, Order, 3);

                                    Object O3 = new Object();
                                    lock (O3)
                                    {
                                        //initiate for satisfied full game primary conditions

                                    }


                                    //when deeper is valid
                                    if (HoursesOnTable[ik].HourseThinking[0].AStarGreedy.Count > 0)
                                    {
                                        Object O = new Object();
                                        lock (O)
                                        {
                                            //do deeper
                                            OpOfFullGameThinkingTree(ik, j, Order, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ii, jj, a, 3, FOUND, LeafAStarGreedy);
                                            Do = true;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }

                Object O2 = new Object();
                lock (O2)
                {
                    TaskEnd++;
                }
            }

            return Do;
        }
        //collection objects calling full game specific game 
        bool FullGameThinkingTreeHourseGray(Color a, int Order, int iAStarGreedy, int ii, int jj, int ik1, int j1, bool FOUND, int LeafAStarGreedy)
        {

            bool Do = false;
            Object O1 = new Object();
            lock (O1)
            {
                ThinkingAllowed[2] = true;
                //Hourse.
                ParallelOptions po = new ParallelOptions(); po.MaxDegreeOfParallelism = System.Threading.PlatformHelper.ProcessorCount; Parallel.For(0, HourseMidle, ik =>

 {
     if (HoursesOnTable != null && HoursesOnTable[ik] != null && HoursesOnTable[ik].HourseThinking != null && HoursesOnTable[ik].HourseThinking[0] != null
    )
     {
         Object O = new Object();
         lock (O)
         {
             var array = Task.Factory.StartNew(() => Do = FullGameThinkingTreeHourse(ik, a, Order, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ii, jj, ik1, j1, FOUND, LeafAStarGreedy));
             array.Wait(); array.Dispose();
            //TH.Add(array);

        }
     }
 });
            }

            return Do;
        }
        bool FullGameThinkingTreeCastle(int ik, Color a, int Order, int iAStarGreedy, int ii, int jj, int ik1, int j1, bool FOUND, int LeafAStarGreedy)
        {

            bool Do = false;
            Object O1 = new Object();
            lock (O1)
            {
                if (ReturnFullGameThinkingTreeIligalSemaphore(ik, 4))
                    return false;
                //semaphore
                var array = Task.Factory.StartNew(() => ReturnFullGameThinkingTreeSemaphoreAs(Order, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ik, 4));
                array.Wait(); array.Dispose();
                Object OOOO = new Object();
                lock (OOOO)
                {

                    //when search finished stop and return
                    if (FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy))
                        return false;

                }
                ////ParallelOptions po = new ParallelOptions();       po.MaxDegreeOfParallelism =PlatformHelper.ProcessorCount;                    Parallel.For(0, CastlesOnTable[ik].CastleThinking[0].TableListCastle.Count, j =>
                //operational computation secxistence
                for (var j = 0; j < CastlesOnTable[ik].CastleThinking[0].TableListCastle.Count; j++)
                {
                    if (IsSupHuTrue(ik, j, 0, 4))
                        continue;

                    bool ac = false;
                    var ah3 = Task.Factory.StartNew(() => ac = Lose(4, ik, j, Order));
                    ah3.Wait();
                    ah3.Dispose();
                    if (ac)
                        continue;

                    Object OOOOO = new Object();
                    lock (OOOOO)
                    {
                        //when search finished stop and return
                        if (FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy))
                            return false;
                    }
                    //when node have kings dangoures ignore and continue.
                    if (CheckeHuristci(CloneATable(CastlesOnTable[ik].CastleThinking[0].TableListCastle[j]), Order, ik, j, 0))
                        continue;
                    //sereved continuce
                    if (IsSupHuTrue(ik, j, 0, 4))
                        continue;
                    Object ooo = new Object();
                    lock (ooo)
                    {
                        //self do
                        if (Order != AllDraw.OrderPlateDraw)
                        {
                            //when certification for continued of code satisfied
                            if (ReturnConsiderationOfPermitForValidationOfLearningInFullGameThinkingTree(ik, 4, true, j)
                            )
                            {
                                //when blitz game (limited game)
                                if (AllDraw.Blitz)
                                {
                                    //when do permite
                                    if (Index[3] != -1)
                                    {
                                        //object kind semaphore
                                        if (ik != Index[3])
                                        {
                                            //satisfied of created deeper one
                                            BlitzNotValidFullGameThinkingTreePartOne(ik, Order, 4);
                                            continue;
                                        }
                                        else
                                            if (j != jindex[0])
                                        {
                                            //satisfied of created deeper tow
                                            BlitzNotValidFullGameThinkingTreePartTow(ik, Order, 4);
                                            continue;
                                        }
                                    }
                                    else
                                    {
                                        //satisfied of created deeper three
                                        BlitzNotValidFullGameThinkingTreePartThree(ik, Order, 4);
                                        continue;
                                    }
                                }
                                else
                                    BlitzNotValidFullGameThinkingTreePartOne(ik, Order, 4);
                                Object O3 = new Object();
                                lock (O3)
                                {
                                    //initiate for satisfied full game primary conditions

                                }


                                //when deeper is valid
                                if (CastlesOnTable[ik].CastleThinking[0].AStarGreedy.Count > 0)
                                {
                                    Object O = new Object();
                                    lock (O)
                                    {
                                        //do deeper
                                        OpOfFullGameThinkingTree(ik, j, Order, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ii, jj, a, 4, FOUND, LeafAStarGreedy);
                                        Do = true;
                                    }
                                }
                            }
                        }
                        else
                        {
                            //when certification for continued of code satisfied
                            if (ReturnConsiderationOfPermitForValidationOfLearningInFullGameThinkingTree(ik, 4, false, j)
                            )
                            {
                                //when blitz game (limited game)
                                if (AllDraw.Blitz)
                                {
                                    //when do permite
                                    if (Index[3] != -1)
                                    {
                                        //object kind semaphore
                                        if (ik != Index[3])
                                        {
                                            //satisfied of created deeper one
                                            BlitzNotValidFullGameThinkingTreePartOne(ik, Order, 4);
                                            continue;
                                        }
                                        else
                                            if (j != jindex[0])
                                        {
                                            //satisfied of created deeper tow
                                            BlitzNotValidFullGameThinkingTreePartTow(ik, Order, 4);
                                            continue;
                                        }
                                    }
                                    else
                                    {
                                        //satisfied of created deeper three
                                        BlitzNotValidFullGameThinkingTreePartThree(ik, Order, 4);
                                        continue;
                                    }
                                }
                                else
                                    BlitzNotValidFullGameThinkingTreePartOne(ik, Order, 4);
                                Object O3 = new Object();
                                lock (O3)
                                {
                                    //initiate for satisfied full game primary conditions

                                }


                                //when deeper is valid
                                if (CastlesOnTable[ik].CastleThinking[0].AStarGreedy.Count > 0)
                                {
                                    Object O = new Object();
                                    lock (O)
                                    {
                                        //do deeper
                                        OpOfFullGameThinkingTree(ik, j, Order, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ii, jj, a, 4, FOUND, LeafAStarGreedy);
                                        Do = true;
                                    }
                                }
                            }
                        }
                    }
                }

                Object O2 = new Object();
                lock (O2)
                {
                    TaskEnd++;
                }
            }

            return Do;
        }
        //collection objects calling full game specific game 
        bool FullGameThinkingTreeCastleGray(Color a, int Order, int iAStarGreedy, int ii, int jj, int ik1, int j1, bool FOUND, int LeafAStarGreedy)
        {

            bool Do = false;
            Object O1 = new Object();
            lock (O1)
            {
                ThinkingAllowed[3] = true;
                //Castle.
                ParallelOptions po = new ParallelOptions(); po.MaxDegreeOfParallelism = System.Threading.PlatformHelper.ProcessorCount; Parallel.For(0, CastleMidle, ik =>

 {
     if (CastlesOnTable != null && CastlesOnTable[ik] != null && CastlesOnTable[ik].CastleThinking != null && CastlesOnTable[ik].CastleThinking[0] != null
    )
     {
         Object O = new Object();
         lock (O)
         {
             var array = Task.Factory.StartNew(() => Do = FullGameThinkingTreeCastle(ik, a, Order, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ii, jj, ik1, j1, FOUND, LeafAStarGreedy));
             array.Wait(); array.Dispose();
            //TH.Add(array);

        }
     }
 });
            }

            return Do;
        }
        bool FullGameThinkingTreeMinister(int ik, Color a, int Order, int iAStarGreedy, int ii, int jj, int ik1, int j1, bool FOUND, int LeafAStarGreedy)
        {

            bool Do = false;
            Object O1 = new Object();
            lock (O1)
            {
                if (ReturnFullGameThinkingTreeIligalSemaphore(ik, 5))
                    return false;
                //semaphore
                var array = Task.Factory.StartNew(() => ReturnFullGameThinkingTreeSemaphoreAs(Order, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ik, 5));
                array.Wait(); array.Dispose();

                Object OOOO = new Object();
                lock (OOOO)
                {

                    //when search finished stop and return
                    if (FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy))
                        return false;

                }
                ////ParallelOptions po = new ParallelOptions();       po.MaxDegreeOfParallelism =PlatformHelper.ProcessorCount;                    Parallel.For(0, MinisterOnTable[ik].MinisterThinking[0].TableListMinister.Count, j =>
                //operational computation secxistence
                for (var j = 0; j < MinisterOnTable[ik].MinisterThinking[0].TableListMinister.Count; j++)
                {
                    Object OOOOO = new Object();
                    lock (OOOOO)
                    {
                        if (IsSupHuTrue(ik, j, 0, 5))
                            continue;

                        bool ac = false;
                        var ah3 = Task.Factory.StartNew(() => ac = Lose(5, ik, j, Order));
                        ah3.Wait();
                        ah3.Dispose();
                        if (ac)
                            continue;


                        //when search finished stop and return
                        if (FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy))
                            return false;
                    }
                    Object ooo = new Object();
                    lock (ooo)
                    {
                        //when node have kings dangoures ignore and continue.
                        if (CheckeHuristci(CloneATable(MinisterOnTable[ik].MinisterThinking[0].TableListMinister[j]), Order, ik, j, 0))
                            continue;
                        //sereved continuce
                        if (IsSupHuTrue(ik, j, 0, 5))
                            continue;


                        //self do
                        if (Order != AllDraw.OrderPlateDraw)
                        {
                            //when certification for continued of code satisfied
                            if (ReturnConsiderationOfPermitForValidationOfLearningInFullGameThinkingTree(ik, 5, true, j)
                            )
                            {
                                //when blitz game (limited game)
                                if (AllDraw.Blitz)
                                {
                                    //when do permite
                                    if (Index[4] != -1)
                                    {
                                        //object kind semaphore
                                        if (ik != Index[4])
                                        {
                                            //satisfied of created deeper one
                                            BlitzNotValidFullGameThinkingTreePartOne(ik, Order, 5);
                                            continue;
                                        }
                                        else
                                             if (j != jindex[4])
                                        {
                                            //satisfied of created deeper tow
                                            BlitzNotValidFullGameThinkingTreePartTow(ik, Order, 5);
                                            continue;
                                        }
                                    }
                                    else
                                    {
                                        //satisfied of created deeper three
                                        BlitzNotValidFullGameThinkingTreePartThree(ik, Order, 5);
                                        continue;
                                    }
                                }
                                else
                                    BlitzNotValidFullGameThinkingTreePartOne(ik, Order, 5);
                                Object O3 = new Object();
                                lock (O3)
                                {
                                    //initiate for satisfied full game primary conditions

                                }


                                //when deeper is valid
                                if (MinisterOnTable[ik].MinisterThinking[0].AStarGreedy.Count > 0)
                                {
                                    Object O = new Object();
                                    lock (O)
                                    {
                                        //do deeper
                                        OpOfFullGameThinkingTree(ik, j, Order, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ii, jj, a, 5, FOUND, LeafAStarGreedy);
                                        Do = true;
                                    }
                                }
                            }
                        }
                        else
                        {
                            //when certification for continued of code satisfied
                            if (ReturnConsiderationOfPermitForValidationOfLearningInFullGameThinkingTree(ik, 5, false, j)
                            )
                            {
                                //when blitz game (limited game)
                                if (AllDraw.Blitz)
                                {
                                    //when do permite
                                    if (Index[4] != -1)
                                    {
                                        //object kind semaphore
                                        if (ik != Index[4])
                                        {
                                            //satisfied of created deeper one
                                            BlitzNotValidFullGameThinkingTreePartOne(ik, Order, 5);
                                            continue;
                                        }
                                        else
                                             if (j != jindex[4])
                                        {
                                            //satisfied of created deeper tow
                                            BlitzNotValidFullGameThinkingTreePartTow(ik, Order, 5);
                                            continue;
                                        }
                                    }
                                    else
                                    {
                                        //satisfied of created deeper three
                                        BlitzNotValidFullGameThinkingTreePartThree(ik, Order, 5);
                                        continue;
                                    }
                                }
                                else
                                    BlitzNotValidFullGameThinkingTreePartOne(ik, Order, 5);
                                Object O3 = new Object();
                                lock (O3)
                                {
                                    //initiate for satisfied full game primary conditions

                                }


                                if (MinisterOnTable[ik].MinisterThinking[0].AStarGreedy.Count > 0)
                                {
                                    Object O = new Object();
                                    lock (O)
                                    {
                                        //do deeper
                                        OpOfFullGameThinkingTree(ik, j, Order, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ii, jj, a, 5, FOUND, LeafAStarGreedy);
                                        Do = true;
                                    }
                                }
                            }
                        }
                    }
                }

                Object O2 = new Object();
                lock (O2)
                {
                    TaskEnd++;
                }
            }

            return Do;
        }
        //collection objects calling full game specific game 
        bool FullGameThinkingTreeMinisterGray(Color a, int Order, int iAStarGreedy, int ii, int jj, int ik1, int j1, bool FOUND, int LeafAStarGreedy)
        {

            bool Do = false;
            Object O1 = new Object();
            lock (O1)
            {
                ThinkingAllowed[4] = true;
                //Minister.
                ParallelOptions po = new ParallelOptions(); po.MaxDegreeOfParallelism = System.Threading.PlatformHelper.ProcessorCount; Parallel.For(0, MinisterMidle, ik =>

 {
     if (MinisterOnTable != null && MinisterOnTable[ik] != null && MinisterOnTable[ik].MinisterThinking != null && MinisterOnTable[ik].MinisterThinking[0] != null
    )
     {
         Object O = new Object();
         lock (O)
         {
             var array = Task.Factory.StartNew(() => Do = FullGameThinkingTreeMinister(ik, a, Order, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ii, jj, ik1, j1, FOUND, LeafAStarGreedy));
             array.Wait(); array.Dispose();
            //TH.Add(array);
        }
     }
 });
            }

            return Do;
        }
        bool FullGameThinkingTreeKing(int ik, Color a, int Order, int iAStarGreedy, int ii, int jj, int ik1, int j1, bool FOUND, int LeafAStarGreedy)
        {

            bool Do = false;
            Object O1 = new Object();
            lock (O1)
            {
                if (ReturnFullGameThinkingTreeIligalSemaphore(ik, 6))
                    return false;
                //semaphore
                var array = Task.Factory.StartNew(() => ReturnFullGameThinkingTreeSemaphoreAs(Order, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ik, 6));
                array.Wait(); array.Dispose();

                Object OOOO = new Object();
                lock (OOOO)
                {

                    //when search finished stop and return
                    if (FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy))
                        return false;


                }
                if (KingOnTable[ik].KingThinking[0].TableListKing.Count == 0)
                    return Do;
                // //ParallelOptions po = new ParallelOptions();       po.MaxDegreeOfParallelism =PlatformHelper.ProcessorCount;                    Parallel.For(0, KingOnTable[ik].KingThinking[0].TableListKing.Count, j =>
                //operational computation secxistence
                for (var j = 0; j < KingOnTable[ik].KingThinking[0].TableListKing.Count; j++)
                {
                    Object OOOOO = new Object();
                    lock (OOOOO)
                    {
                        if (IsSupHuTrue(ik, j, 0, 6))
                            continue;

                        bool ac = false;
                        var ah3 = Task.Factory.StartNew(() => ac = Lose(6, ik, j, Order));
                        ah3.Wait();
                        ah3.Dispose();
                        if (ac)
                            continue;


                        //when search finished stop and return
                        if (FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy))
                            return false;
                    }
                    Object ooo = new Object();
                    lock (ooo)
                    {
                        //when node have kings dangoures ignore and continue.
                        if (CheckeHuristci(CloneATable(KingOnTable[ik].KingThinking[0].TableListKing[j]), Order, ik, j, 0))
                            continue;
                        //sereved continuce
                        if (IsSupHuTrue(ik, j, 0, 6))
                            continue;
                        //when is self
                        if (Order != AllDraw.OrderPlateDraw)
                        {
                            //when certification for continued of code satisfied
                            if (ReturnConsiderationOfPermitForValidationOfLearningInFullGameThinkingTree(ik, 6, true, j)
                            )
                            {
                                //when blitz game (limited game)
                                if (AllDraw.Blitz)
                                {
                                    //when do permite
                                    if (Index[5] != -1)
                                    {
                                        //object kind semaphore
                                        if (ik != Index[5])
                                        {
                                            //satisfied of created deeper one
                                            BlitzNotValidFullGameThinkingTreePartOne(ik, Order, 6);
                                            continue;
                                        }
                                        else
                                             if (j != jindex[5])
                                        {
                                            //satisfied of created deeper tow
                                            BlitzNotValidFullGameThinkingTreePartTow(ik, Order, 6);
                                            continue;
                                        }
                                    }
                                    else
                                    {
                                        //satisfied of created deeper three
                                        BlitzNotValidFullGameThinkingTreePartThree(ik, Order, 6);
                                        continue;
                                    }
                                }
                                else
                                    BlitzNotValidFullGameThinkingTreePartOne(ik, Order, 6);
                                Object O3 = new Object();
                                lock (O3)
                                {
                                    //initiate for satisfied full game primary conditions

                                }


                                //when deeper is valid
                                if (KingOnTable[ik].KingThinking[0].AStarGreedy.Count > 0)
                                {
                                    Object O = new Object();
                                    lock (O)
                                    {
                                        //do deeper
                                        OpOfFullGameThinkingTree(ik, j, Order, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ii, jj, a, 6, FOUND, LeafAStarGreedy);
                                        Do = true;
                                    }
                                }
                            }
                        }
                        else
                        {
                            //when certification for continued of code satisfied
                            if (ReturnConsiderationOfPermitForValidationOfLearningInFullGameThinkingTree(ik, 6, false, j)
                            )
                            {
                                //when blitz game (limited game)
                                if (AllDraw.Blitz)
                                {
                                    //when do permite
                                    if (Index[5] != -1)
                                    {
                                        //object kind semaphore
                                        if (ik != Index[5])
                                        {
                                            //satisfied of created deeper one
                                            BlitzNotValidFullGameThinkingTreePartOne(ik, Order, 6);
                                            continue;
                                        }
                                        else
                                             if (j != jindex[5])
                                        {
                                            //satisfied of created deeper tow
                                            BlitzNotValidFullGameThinkingTreePartTow(ik, Order, 6);
                                            continue;
                                        }
                                    }
                                    else
                                    {
                                        //satisfied of created deeper three
                                        BlitzNotValidFullGameThinkingTreePartThree(ik, Order, 6);
                                        continue;
                                    }
                                }
                                else
                                    BlitzNotValidFullGameThinkingTreePartOne(ik, Order, 6);
                                Object O3 = new Object();
                                lock (O3)
                                {
                                    //initiate for satisfied full game primary conditions

                                }


                                if (KingOnTable[ik].KingThinking[0].AStarGreedy.Count > 0)
                                {
                                    Object O = new Object();
                                    lock (O)
                                    {
                                        OpOfFullGameThinkingTree(ik, j, Order, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ii, jj, a, 6, FOUND, LeafAStarGreedy);
                                        Do = true;
                                    }
                                }
                            }
                        }
                    }
                }

                Object O2 = new Object();
                lock (O2)
                {
                    TaskEnd++;
                }
            }

            return Do;
        }
        bool FullGameThinkingTreeCastling(int kin, int ik, Color a, int Order, int iAStarGreedy, int ii, int jj, int ik1, int j1, bool FOUND, int LeafAStarGreedy)
        {

            bool Do = false;
            Object O1 = new Object();
            lock (O1)
            {
                if (ReturnFullGameThinkingTreeIligalSemaphore(ik, kin))
                    return false;
                //semaphore
                var array = Task.Factory.StartNew(() => ReturnFullGameThinkingTreeSemaphoreAs(Order, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ik, kin));
                array.Wait(); array.Dispose();

                Object OOOO = new Object();
                lock (OOOO)
                {

                    //when search finished stop and return
                    if (FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy))
                        return false;


                }
                if (CastlingOnTable[ik].CastlingThinking[0].TableListCastling.Count == 0)
                    return Do;
                // //ParallelOptions po = new ParallelOptions();       po.MaxDegreeOfParallelism =PlatformHelper.ProcessorCount;                    Parallel.For(0, CastlingOnTable[ik].CastlingThinking[0].TableListCastling.Count, j =>
                //operational computation secxistence
                for (var j = 0; j < CastlingOnTable[ik].CastlingThinking[0].TableListCastling.Count; j++)
                {
                    Object OOOOO = new Object();
                    lock (OOOOO)
                    {
                        if (IsSupHuTrue(ik, j, 0, kin))
                            continue;
                        //when search finished stop and return
                        if (FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy))
                            return false;
                    }
                    Object ooo = new Object();
                    lock (ooo)
                    {
                        //when node have kings dangoures ignore and continue.
                        if (CheckeHuristci(CloneATable(CastlingOnTable[ik].CastlingThinking[0].TableListCastling[j]), Order, ik, j, 0))
                            continue;
                        //sereved continuce
                        if (IsSupHuTrue(ik, j, 0, 7))
                            continue;

                        bool ac = false;
                        var ah3 = Task.Factory.StartNew(() => ac = Lose(7, ik, j, Order));
                        ah3.Wait();
                        ah3.Dispose();
                        if (ac)
                            continue;


                        //when is self
                        if (Order != AllDraw.OrderPlateDraw)
                        {
                            //when certification for continued of code satisfied
                            if (ReturnConsiderationOfPermitForValidationOfLearningInFullGameThinkingTree(ik, kin, true, j)
                            )
                            {
                                //when blitz game (limited game)
                                if (AllDraw.Blitz)
                                {
                                    //when do permite
                                    if (Index[6] != -1)
                                    {
                                        //object kind semaphore
                                        if (ik != Index[6])
                                        {
                                            //satisfied of created deeper one
                                            BlitzNotValidFullGameThinkingTreePartOne(ik, Order, kin);
                                            continue;
                                        }
                                        else
                                             if (j != jindex[6])
                                        {
                                            //satisfied of created deeper tow
                                            BlitzNotValidFullGameThinkingTreePartTow(ik, Order, kin);
                                            continue;
                                        }
                                    }
                                    else
                                    {
                                        //satisfied of created deeper three
                                        BlitzNotValidFullGameThinkingTreePartThree(ik, Order, kin);
                                        continue;
                                    }
                                }
                                else
                                    BlitzNotValidFullGameThinkingTreePartOne(ik, Order, kin);
                                Object O3 = new Object();
                                lock (O3)
                                {
                                    //initiate for satisfied full game primary conditions

                                }


                                //when deeper is valid
                                if (CastlingOnTable[ik].CastlingThinking[0].AStarGreedy.Count > 0)
                                {
                                    Object O = new Object();
                                    lock (O)
                                    {
                                        //do deeper
                                        OpOfFullGameThinkingTree(ik, j, Order, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ii, jj, a, kin, FOUND, LeafAStarGreedy);
                                        Do = true;
                                    }
                                }
                            }
                        }
                        else
                        {
                            //when certification for continued of code satisfied
                            if (ReturnConsiderationOfPermitForValidationOfLearningInFullGameThinkingTree(ik, kin, false, j)
                            )
                            {
                                //when blitz game (limited game)
                                if (AllDraw.Blitz)
                                {
                                    //when do permite
                                    if (Index[6] != -1)
                                    {
                                        //object kind semaphore
                                        if (ik != Index[6])
                                        {
                                            //satisfied of created deeper one
                                            BlitzNotValidFullGameThinkingTreePartOne(ik, Order, kin);
                                            continue;
                                        }
                                        else
                                             if (j != jindex[6])
                                        {
                                            //satisfied of created deeper tow
                                            BlitzNotValidFullGameThinkingTreePartTow(ik, Order, kin);
                                            continue;
                                        }
                                    }
                                    else
                                    {
                                        //satisfied of created deeper three
                                        BlitzNotValidFullGameThinkingTreePartThree(ik, Order, kin);
                                        continue;
                                    }
                                }
                                else
                                    BlitzNotValidFullGameThinkingTreePartOne(ik, Order, kin);
                                Object O3 = new Object();
                                lock (O3)
                                {
                                    //initiate for satisfied full game primary conditions

                                }


                                if (CastlingOnTable[ik].CastlingThinking[0].AStarGreedy.Count > 0)
                                {
                                    Object O = new Object();
                                    lock (O)
                                    {
                                        OpOfFullGameThinkingTree(ik, j, Order, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ii, jj, a, kin, FOUND, LeafAStarGreedy);
                                        Do = true;
                                    }
                                }
                            }
                        }
                    }
                }

                Object O2 = new Object();
                lock (O2)
                {
                    TaskEnd++;
                }
            }

            return Do;
        }
        //collection objects calling full game specific game 
        bool FullGameThinkingTreeKingGray(Color a, int Order, int iAStarGreedy, int ii, int jj, int ik1, int j1, bool FOUND, int LeafAStarGreedy)
        {

            bool Do = false;
            Object O1 = new Object();
            lock (O1)
            {

                //King.
                ThinkingAllowed[5] = true;
                ParallelOptions po = new ParallelOptions(); po.MaxDegreeOfParallelism = System.Threading.PlatformHelper.ProcessorCount; Parallel.For(0, KingMidle, ik =>

 {
     if (KingOnTable != null && KingOnTable[ik] != null && KingOnTable[ik].KingThinking != null && KingOnTable[ik].KingThinking[0] != null
    )
     {
         Object O = new Object();
         lock (O)
         {
             var array = Task.Factory.StartNew(() => Do = FullGameThinkingTreeKing(ik, a, Order, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ii, jj, ik1, j1, FOUND, LeafAStarGreedy));
             array.Wait(); array.Dispose();
            //TH.Add(array);

        }
     }
 });
            }

            return Do;
        }
        bool FullGameThinkingTreeCastlingGray(Color a, int Order, int iAStarGreedy, int ii, int jj, int ik1, int j1, bool FOUND, int LeafAStarGreedy)
        {

            bool Do = false;
            Object O1 = new Object();
            lock (O1)
            {

                //Castling.
                ThinkingAllowed[6] = true;
                ParallelOptions po = new ParallelOptions(); po.MaxDegreeOfParallelism = System.Threading.PlatformHelper.ProcessorCount; Parallel.For(0, 1, ik =>

                 {
                     if (CastlingOnTable != null && CastlingOnTable[ik] != null && CastlingOnTable[ik].CastlingThinking != null && CastlingOnTable[ik].CastlingThinking[0] != null
                         )
                     {
                         Object O = new Object();
                         lock (O)
                         {
                             var array = Task.Factory.StartNew(() => Do = FullGameThinkingTreeCastling(7, ik, a, Order, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ii, jj, ik1, j1, FOUND, LeafAStarGreedy));
                             array.Wait(); array.Dispose();
                            //TH.Add(array);

                        }
                     }
                 });
            }

            return Do;
        }
        //collection objects calling full game specific game 
        bool FullGameThinkingTreeSoldierBrown(Color a, int Order, int iAStarGreedy, int ii, int jj, int ik1, int j1, bool FOUND, int LeafAStarGreedy)
        {

            bool Do = false;
            Object O1 = new Object();
            lock (O1)
            {
                ThinkingAllowed[7] = true;
                ParallelOptions po = new ParallelOptions(); po.MaxDegreeOfParallelism = System.Threading.PlatformHelper.ProcessorCount; Parallel.For(SodierMidle, SodierHigh, ik =>

 {
     if (SolderesOnTable != null && SolderesOnTable[ik] != null && SolderesOnTable[ik].SoldierThinking != null && SolderesOnTable[ik].SoldierThinking[0] != null
    )
     {
        //Soldier.
        Object O = new Object();
         lock (O)
         {
             var array = Task.Factory.StartNew(() => Do = FullGameThinkingTreeSoldier(ik, a, Order, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ii, jj, ik1, j1, FOUND, LeafAStarGreedy));
             array.Wait(); array.Dispose();
            //TH.Add(array);
        }
     }
 });
            }

            return Do;
        }
        //collection objects calling full game specific game 
        bool FullGameThinkingTreeElephantBrown(Color a, int Order, int iAStarGreedy, int ii, int jj, int ik1, int j1, bool FOUND, int LeafAStarGreedy)
        {

            bool Do = false;
            Object O1 = new Object();
            lock (O1)
            {
                ThinkingAllowed[8] = true;
                //Elephant
                ParallelOptions po = new ParallelOptions(); po.MaxDegreeOfParallelism = System.Threading.PlatformHelper.ProcessorCount; Parallel.For(ElefantMidle, ElefantHigh, ik =>

 {
     if (ElephantOnTable != null && ElephantOnTable[ik] != null && ElephantOnTable[ik].ElefantThinking != null && ElephantOnTable[ik].ElefantThinking[0] != null
    )
     {
         Object O = new Object();
         lock (O)
         {
             var array = Task.Factory.StartNew(() => Do = FullGameThinkingTreeElephant(ik, a, Order, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ii, jj, ik1, j1, FOUND, LeafAStarGreedy));
             array.Wait(); array.Dispose();
            //TH.Add(array);
        }
     }
 });
            }

            return Do;
        }
        //collection objects calling full game specific game 
        bool FullGameThinkingTreeHourseBrown(Color a, int Order, int iAStarGreedy, int ii, int jj, int ik1, int j1, bool FOUND, int LeafAStarGreedy)
        {

            bool Do = false;
            Object O1 = new Object();
            lock (O1)
            {
                ThinkingAllowed[9] = true;
                //Hourse.
                ParallelOptions po = new ParallelOptions(); po.MaxDegreeOfParallelism = System.Threading.PlatformHelper.ProcessorCount; Parallel.For(HourseMidle, HourseHight, ik =>

 {
     if (HoursesOnTable != null && HoursesOnTable[ik] != null && HoursesOnTable[ik].HourseThinking != null && HoursesOnTable[ik].HourseThinking[0] != null
    )
     {
         Object O = new Object();
         lock (O)
         {
             var array = Task.Factory.StartNew(() => Do = FullGameThinkingTreeHourse(ik, a, Order, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ii, jj, ik1, j1, FOUND, LeafAStarGreedy));
             array.Wait(); array.Dispose();
            //TH.Add(array);
        }
     }
 });
            }

            return Do;
        }
        //collection objects calling full game specific game 
        bool FullGameThinkingTreeCastleBrown(Color a, int Order, int iAStarGreedy, int ii, int jj, int ik1, int j1, bool FOUND, int LeafAStarGreedy)
        {

            bool Do = false;
            Object O1 = new Object();
            lock (O1)
            {
                ThinkingAllowed[10] = true;
                //Castles.
                ParallelOptions po = new ParallelOptions(); po.MaxDegreeOfParallelism = System.Threading.PlatformHelper.ProcessorCount; Parallel.For(CastleMidle, CastleHigh, ik =>

 {
     if (CastlesOnTable != null && CastlesOnTable[ik] != null && CastlesOnTable[ik].CastleThinking != null && CastlesOnTable[ik].CastleThinking[0] != null
    )
     {
         Object O = new Object();
         lock (O)
         {
             var array = Task.Factory.StartNew(() => Do = FullGameThinkingTreeCastle(ik, a, Order, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ii, jj, ik1, j1, FOUND, LeafAStarGreedy));
             array.Wait(); array.Dispose();
            //TH.Add(array);
        }
     }
 });
            }

            return Do;
        }
        //collection objects calling full game specific game 
        bool FullGameThinkingTreeMinisterBrown(Color a, int Order, int iAStarGreedy, int ii, int jj, int ik1, int j1, bool FOUND, int LeafAStarGreedy)
        {

            bool Do = false;
            Object O1 = new Object();
            lock (O1)
            {
                ThinkingAllowed[11] = true;
                //Minister.
                ParallelOptions po = new ParallelOptions(); po.MaxDegreeOfParallelism = System.Threading.PlatformHelper.ProcessorCount; Parallel.For(MinisterMidle, MinisterHigh, ik =>

 {
     if (MinisterOnTable != null && MinisterOnTable[ik] != null && MinisterOnTable[ik].MinisterThinking != null && MinisterOnTable[ik].MinisterThinking[0] != null
    )
     {
         Object O = new Object();
         lock (O)
         {
             var array = Task.Factory.StartNew(() => Do = FullGameThinkingTreeMinister(ik, a, Order, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ii, jj, ik1, j1, FOUND, LeafAStarGreedy));
             array.Wait(); array.Dispose();
            //TH.Add(array);
        }
     }
 });
            }

            return Do;
        }
        //collection objects calling full game specific game 
        bool FullGameThinkingTreeKingBrown(Color a, int Order, int iAStarGreedy, int ii, int jj, int ik1, int j1, bool FOUND, int LeafAStarGreedy)
        {

            bool Do = false;
            Object O1 = new Object();
            lock (O1)
            {
                ThinkingAllowed[12] = true;
                //King.
                ParallelOptions po = new ParallelOptions(); po.MaxDegreeOfParallelism = System.Threading.PlatformHelper.ProcessorCount; Parallel.For(KingMidle, KingHigh, ik =>

                 {
                     if (KingOnTable != null && KingOnTable[ik] != null && KingOnTable[ik].KingThinking != null && KingOnTable[ik].KingThinking[0] != null
                         )
                     {
                         Object O = new Object();
                         lock (O)
                         {
                             var array = Task.Factory.StartNew(() => Do = FullGameThinkingTreeKing(ik, a, Order, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ii, jj, ik1, j1, FOUND, LeafAStarGreedy));
                             array.Wait(); array.Dispose();
                            //TH.Add(array);
                        }
                     }
                 });
            }

            return Do;
        }
        bool FullGameThinkingTreeCastlingBrown(Color a, int Order, int iAStarGreedy, int ii, int jj, int ik1, int j1, bool FOUND, int LeafAStarGreedy)
        {

            bool Do = false;
            Object O1 = new Object();
            lock (O1)
            {
                ThinkingAllowed[13] = true;
                //Castling.
                ParallelOptions po = new ParallelOptions(); po.MaxDegreeOfParallelism = System.Threading.PlatformHelper.ProcessorCount; Parallel.For(0, 1, ik =>

                 {
                     if (CastlingOnTable != null && CastlingOnTable[ik] != null && CastlingOnTable[ik].CastlingThinking != null && CastlingOnTable[ik].CastlingThinking[0] != null
                         )
                     {
                         Object O = new Object();
                         lock (O)
                         {
                             var array = Task.Factory.StartNew(() => Do = FullGameThinkingTreeCastling(-7, ik, a, Order, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ii, jj, ik1, j1, FOUND, LeafAStarGreedy));
                             array.Wait(); array.Dispose();
                            //TH.Add(array);
                        }
                     }
                 });
            }

            return Do;
        }
        public bool FullGameThinkingTreeGray(Color a, int Order, int iAStarGreedy, int ii, int jj, int ik1, int j1, bool FOUND, int LeafAStarGreedy)
        {
            Object OOOOO = new Object();
            lock (OOOOO)
            {
                bool Do = false;
                int DummyOrder = Order;
                int DummyCurrentOrder = ChessRules.CurrentOrder;
                var output = Task.Factory.StartNew(() =>
                {
                    //if (!feedCancellationTokenSource.IsCancellationRequested)
                    {
                        ParallelOptions po = new ParallelOptions(); po.MaxDegreeOfParallelism = System.Threading.PlatformHelper.ProcessorCount; Parallel.Invoke(() =>
 {
     Object O1 = new Object();
     lock (O1)
     {
         if (Order == 1)
             a = Color.Gray;
         else
             a = Color.Brown;
         int ii1 = ii, jj1 = jj, ik11 = ik1, j11 = j1;
         int Ord1 = OrderP;
         Color a1 = a;
         int iAStarGreedy1 = iAStarGreedy;

         var array1 = Task.Factory.StartNew(() => Do |= this.FullGameThinkingTreeSoldierGray(a1, Ord1, iAStarGreedy1, ii1, jj1, ik11, j11, FOUND, LeafAStarGreedy));
         array1.Wait(); array1.Dispose();


         Order = DummyOrder;
         ChessRules.CurrentOrder = DummyCurrentOrder;
     }
 }, () =>
 {
     Object O1 = new Object();
     lock (O1)
     {
         if (Order == 1)
             a = Color.Gray;
         else
             a = Color.Brown;


         int ii2 = ii, jj2 = jj, ik12 = ik1, j12 = j1;
         int Ord2 = Order;
         Color a2 = a;
         int iAStarGreedy2 = iAStarGreedy;

         var array2 = Task.Factory.StartNew(() => Do |= this.FullGameThinkingTreeElephantGray(a2, Ord2, iAStarGreedy2, ii2, jj2, ik12, j12, FOUND, LeafAStarGreedy));
         array2.Wait(); array2.Dispose();


        //Initiatye Variables.
        Order = DummyOrder;
         ChessRules.CurrentOrder = DummyCurrentOrder;
     }
 }, () =>
 {
     Object O1 = new Object();
     lock (O1)
     {
         if (Order == 1)
             a = Color.Gray;
         else
             a = Color.Brown;


         int ii3 = ii, jj3 = jj, ik13 = ik1, j13 = j1;
         int Ord3 = Order;
         Color a3 = a;
         int iAStarGreedy3 = iAStarGreedy;

         var array3 = Task.Factory.StartNew(() => Do |= this.FullGameThinkingTreeHourseGray(a3, Ord3, iAStarGreedy3, ii3, jj3, ik13, j13, FOUND, LeafAStarGreedy));
         array3.Wait(); array3.Dispose();


        //Initiatye Variables.
        Order = DummyOrder;
         ChessRules.CurrentOrder = DummyCurrentOrder;
     }
 }, () =>
 {
     Object O1 = new Object();
     lock (O1)
     {
         if (Order == 1)
             a = Color.Gray;
         else
             a = Color.Brown;


         int ii4 = ii, jj4 = jj, ik14 = ik1, j14 = j1;
         int Ord4 = Order;
         Color a4 = a;
         int iAStarGreedy4 = iAStarGreedy;

         var array4 = Task.Factory.StartNew(() => Do |= this.FullGameThinkingTreeCastleGray(a4, Ord4, iAStarGreedy4, ii4, jj4, ik14, j14, FOUND, LeafAStarGreedy));
         array4.Wait(); array4.Dispose();


        //Initiatye Variables.
        Order = DummyOrder;
         ChessRules.CurrentOrder = DummyCurrentOrder;
     }
 }, () =>
 {
     Object O1 = new Object();
     lock (O1)
     {
         if (Order == 1)
             a = Color.Gray;
         else
             a = Color.Brown;


         int ii5 = ii, jj5 = jj, ik15 = ik1, j15 = j1;
         int Ord5 = Order;
         Color a5 = a;
         int iAStarGreedy5 = iAStarGreedy;

         var array5 = Task.Factory.StartNew(() => Do |= this.FullGameThinkingTreeMinisterGray(a5, Ord5, iAStarGreedy5, ii5, jj5, ik15, j15, FOUND, LeafAStarGreedy));
         array5.Wait(); array5.Dispose();


        //Initiatye Variables.
        Order = DummyOrder;
         ChessRules.CurrentOrder = DummyCurrentOrder;
     }
 }, () =>
 {
     Object O1 = new Object();
     lock (O1)
     {
         if (Order == 1)
             a = Color.Gray;
         else
             a = Color.Brown;


         int ii6 = ii, jj6 = jj, ik16 = ik1, j16 = j1;
         int Ord6 = Order;
         Color a6 = a;
         int iAStarGreedy6 = iAStarGreedy;

         var array6 = Task.Factory.StartNew(() => Do |= this.FullGameThinkingTreeKingGray(a6, Ord6, iAStarGreedy6, ii6, jj6, ik16, j16, FOUND, LeafAStarGreedy));
         array6.Wait(); array6.Dispose();


         Order = DummyOrder;
         ChessRules.CurrentOrder = DummyCurrentOrder;
     }
 }, () =>
 {
     Object O1 = new Object();
     lock (O1)
     {
         if (Order == 1)
             a = Color.Gray;
         else
             a = Color.Brown;


         int ii6 = ii, jj6 = jj, ik16 = ik1, j16 = j1;
         int Ord6 = Order;
         Color a6 = a;
         int iAStarGreedy6 = iAStarGreedy;

         var array7 = Task.Factory.StartNew(() => Do |= this.FullGameThinkingTreeCastlingGray(a6, Ord6, iAStarGreedy6, ii6, jj6, ik16, j16, FOUND, LeafAStarGreedy));
         array7.Wait(); array7.Dispose();


         Order = DummyOrder;
         ChessRules.CurrentOrder = DummyCurrentOrder;
     }
 });
                    }
                });
                output.Wait(); output.Dispose();
                //TH.Add(output);

                //ParallelOptions po = new ParallelOptions();       po.MaxDegreeOfParallelism =PlatformHelper.ProcessorCount;                    Parallel.ForEach(TH, item => Task.WaitAll(item));


                TH.Clear();
                return Do;
            }
        }
        //full game main method for deeper decicion and making
        public bool FullGameThinkingTreeBrown(Color a, int Order, int iAStarGreedy, int ii, int jj, int ik1, int j1, bool FOUND, int LeafAStarGreedy)
        {
            Object OOOOO = new Object();
            lock (OOOOO)
            {
                bool Do = false;
                int DummyOrder = Order;
                int DummyCurrentOrder = ChessRules.CurrentOrder;
                var output = Task.Factory.StartNew(() =>
                {
                    //if (!feedCancellationTokenSource.IsCancellationRequested)
                    {
                        ParallelOptions po = new ParallelOptions(); po.MaxDegreeOfParallelism = System.Threading.PlatformHelper.ProcessorCount; Parallel.Invoke(() =>
 {
     Object O1 = new Object();
     lock (O1)
     {
         if (Order == 1)
             a = Color.Gray;
         else
             a = Color.Brown;
         int ii1 = ii, jj1 = jj, ik11 = ik1, j11 = j1;
         int Ord1 = OrderP;
         Color a1 = a;
         int iAStarGreedy1 = iAStarGreedy;

         var array1 = Task.Factory.StartNew(() => Do |= this.FullGameThinkingTreeSoldierBrown(a1, Ord1, iAStarGreedy1, ii1, jj1, ik11, j11, FOUND, LeafAStarGreedy));
         array1.Wait(); array1.Dispose();


         Order = DummyOrder;
         ChessRules.CurrentOrder = DummyCurrentOrder;
     }
 }, () =>
 {
     Object O1 = new Object();
     lock (O1)
     {
         if (Order == 1)
             a = Color.Gray;
         else
             a = Color.Brown;


         int ii2 = ii, jj2 = jj, ik12 = ik1, j12 = j1;
         int Ord2 = Order;
         Color a2 = a;
         int iAStarGreedy2 = iAStarGreedy;

         var array2 = Task.Factory.StartNew(() => Do |= this.FullGameThinkingTreeElephantBrown(a2, Ord2, iAStarGreedy2, ii2, jj2, ik12, j12, FOUND, LeafAStarGreedy));
         array2.Wait(); array2.Dispose();


        //Initiatye Variables.
        Order = DummyOrder;
         ChessRules.CurrentOrder = DummyCurrentOrder;
     }
 }, () =>
 {
     Object O1 = new Object();
     lock (O1)
     {
         if (Order == 1)
             a = Color.Gray;
         else
             a = Color.Brown;


         int ii3 = ii, jj3 = jj, ik13 = ik1, j13 = j1;
         int Ord3 = Order;
         Color a3 = a;
         int iAStarGreedy3 = iAStarGreedy;

         var array3 = Task.Factory.StartNew(() => Do |= this.FullGameThinkingTreeHourseBrown(a3, Ord3, iAStarGreedy3, ii3, jj3, ik13, j13, FOUND, LeafAStarGreedy));
         array3.Wait(); array3.Dispose();


        //Initiatye Variables.
        Order = DummyOrder;
         ChessRules.CurrentOrder = DummyCurrentOrder;
     }
 }, () =>
 {
     Object O1 = new Object();
     lock (O1)
     {
         if (Order == 1)
             a = Color.Gray;
         else
             a = Color.Brown;


         int ii4 = ii, jj4 = jj, ik14 = ik1, j14 = j1;
         int Ord4 = Order;
         Color a4 = a;
         int iAStarGreedy4 = iAStarGreedy;

         var array4 = Task.Factory.StartNew(() => Do |= this.FullGameThinkingTreeCastleBrown(a4, Ord4, iAStarGreedy4, ii4, jj4, ik14, j14, FOUND, LeafAStarGreedy));
         array4.Wait(); array4.Dispose();


        //Initiatye Variables.
        Order = DummyOrder;
         ChessRules.CurrentOrder = DummyCurrentOrder;
     }
 }, () =>
 {
     Object O1 = new Object();
     lock (O1)
     {
         if (Order == 1)
             a = Color.Gray;
         else
             a = Color.Brown;


         int ii5 = ii, jj5 = jj, ik15 = ik1, j15 = j1;
         int Ord5 = Order;
         Color a5 = a;
         int iAStarGreedy5 = iAStarGreedy;

         var array5 = Task.Factory.StartNew(() => Do |= this.FullGameThinkingTreeMinisterBrown(a5, Ord5, iAStarGreedy5, ii5, jj5, ik15, j15, FOUND, LeafAStarGreedy));
         array5.Wait(); array5.Dispose();


        //Initiatye Variables.
        Order = DummyOrder;
         ChessRules.CurrentOrder = DummyCurrentOrder;
     }
 }, () =>
 {
     Object O1 = new Object();
     lock (O1)
     {
         if (Order == 1)
             a = Color.Gray;
         else
             a = Color.Brown;


         int ii6 = ii, jj6 = jj, ik16 = ik1, j16 = j1;
         int Ord6 = Order;
         Color a6 = a;
         int iAStarGreedy6 = iAStarGreedy;

         var array6 = Task.Factory.StartNew(() => Do |= this.FullGameThinkingTreeKingBrown(a6, Ord6, iAStarGreedy6, ii6, jj6, ik16, j16, FOUND, LeafAStarGreedy));
         array6.Wait(); array6.Dispose();


         Order = DummyOrder;
         ChessRules.CurrentOrder = DummyCurrentOrder;
     }
 }, () =>
 {
     Object O1 = new Object();
     lock (O1)
     {
         if (Order == 1)
             a = Color.Gray;
         else
             a = Color.Brown;


         int ii6 = ii, jj6 = jj, ik16 = ik1, j16 = j1;
         int Ord6 = Order;
         Color a6 = a;
         int iAStarGreedy6 = iAStarGreedy;

         var array7 = Task.Factory.StartNew(() => Do |= this.FullGameThinkingTreeCastlingBrown(a6, Ord6, iAStarGreedy6, ii6, jj6, ik16, j16, FOUND, LeafAStarGreedy));
         array7.Wait(); array7.Dispose();


         Order = DummyOrder;
         ChessRules.CurrentOrder = DummyCurrentOrder;
     }
 });
                    }
                });
                output.Wait(); output.Dispose();
                //TH.Add(output);

                //ParallelOptions po = new ParallelOptions();       po.MaxDegreeOfParallelism =PlatformHelper.ProcessorCount;                    Parallel.ForEach(TH, item => Task.WaitAll(item));


                TH.Clear();
                return Do;
            }
        }

        //full game main method for deeper decicion and making
        public bool FullGameThinkingTree(int Order, int iAStarGreedy, int ii, int jj, int ik1, int j1, bool FOUND, int LeafAStarGreedy)
        {

            bool Do = false;
            //Initiatye Variables.
            int DummyOrder = Order;
            int DummyCurrentOrder = ChessRules.CurrentOrder;
            Color a;
            if (Order == 1)
                a = Color.Gray;
            else
                a = Color.Brown;
            Object OOOOO = new Object();
            lock (OOOOO)
            {
                //when search finished stop and return
                if (FullBoundryConditions(CurrentAStarGredyMax, Order, iAStarGreedy))
                    return false;
            }
            Object O = new Object();
            lock (O)
            {
                //when blitz game (limited game)
                if (AllDraw.Blitz)
                    FullGameMakimgBlitz(ref Index, ref jindex, Order, LeafAStarGreedy);
            }

            if (TH == null)
                TH = new List<Task>();
            if (Order == 1)
            {

                //Soldeir
                //Initiatye Variables.               
                var array = Task.Factory.StartNew(() => Do = FullGameThinkingTreeGray(a, Order, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ii, jj, ik1, j1, FOUND, LeafAStarGreedy));

                array.Wait(); array.Dispose();

            }
            //For Brown Order Blitz Game Calculate Maximum Table Inclusive AStarGreedy First Game Search.
            else
            {
                var array = Task.Factory.StartNew(() => Do = FullGameThinkingTreeBrown(a, Order, PlatformHelper.ProcessorCount + StoreInitMaxAStarGreedy - MaxAStarGreedy, ii, jj, ik1, j1, FOUND, LeafAStarGreedy));

                array.Wait(); array.Dispose();
            }

            return Do;
        }
        //full game decicion making second method
        bool FullGameThinkingTreeObject(int Order, int iAStarGreedy, int ii, int jj, int ik1, int j1, bool FOUND, int LeafAStarGreedy)
        {

            //
            bool Do = false;
            //Initiatye Variables.
            int DummyOrder = Order;
            int DummyCurrentOrder = ChessRules.CurrentOrder;
            Color a;
            if (Order == 1)
                a = Color.Gray;
            else
                a = Color.Brown;



            //Kind =
            Object O = new Object();
            lock (O)
            {
                //when blitz game (limited game)
                if (AllDraw.Blitz)
                    FullGameMakimgBlitz(ref Index, ref jindex, Order, LeafAStarGreedy);
            }
            if (Order == 1)
            {
                var output = Task.Factory.StartNew(() =>
                {
                    //if (!feedCancellationTokenSource.IsCancellationRequested)
                    {
                        ParallelOptions po = new ParallelOptions(); po.MaxDegreeOfParallelism = System.Threading.PlatformHelper.ProcessorCount; Parallel.For(0, MaxGrayMidle(), i =>
 {
     ParallelOptions poo = new ParallelOptions(); poo.MaxDegreeOfParallelism = System.Threading.PlatformHelper.ProcessorCount; Parallel.Invoke(() =>
     {
         Object ooo = new Object();
         lock (ooo)
         {
             if (i < SodierMidle)
             {
                 Object O1 = new Object();
                 lock (O1)
                 {
                     if (Order == 1)
                         a = Color.Gray;
                     else
                         a = Color.Brown;
                     int ii1 = ii, jj1 = jj, ik11 = ik1, j11 = j1;
                     int Ord1 = OrderP;
                     Color a1 = a;
                     int iAStarGreedy1 = iAStarGreedy;
                     int i1 = i;
                     Do |= FullGameThinkingTreeSoldier(i1, a1, Ord1, iAStarGreedy1, ii1, jj1, ik11, j11, FOUND, LeafAStarGreedy);



                     Order = DummyOrder;
                     ChessRules.CurrentOrder = DummyCurrentOrder;
                 }
             }
         }
     }, () =>
     {
         Object ooo = new Object();
         lock (ooo)
         {
             if (i < ElefantMidle)
             {
                 Object O1 = new Object();
                 lock (O1)
                 {
                     if (Order == 1)
                         a = Color.Gray;
                     else
                         a = Color.Brown;


                     int ii2 = ii, jj2 = jj, ik12 = ik1, j12 = j1;
                     int Ord2 = Order;
                     Color a2 = a;
                     int iAStarGreedy2 = iAStarGreedy;
                     int i2 = i;
                     Do |= this.FullGameThinkingTreeElephant(i2, a2, Ord2, iAStarGreedy2, ii2, jj2, ik12, j12, FOUND, LeafAStarGreedy);
                    //Initiatye Variables.
                    Order = DummyOrder;
                     ChessRules.CurrentOrder = DummyCurrentOrder;
                 }
             }
         }
     }, () =>
     {
         Object ooo = new Object();
         lock (ooo)
         {
             if (i < HourseMidle)
             {
                 Object O1 = new Object();
                 lock (O1)
                 {
                     if (Order == 1)
                         a = Color.Gray;
                     else
                         a = Color.Brown;


                     int ii3 = ii, jj3 = jj, ik13 = ik1, j13 = j1;
                     int Ord3 = Order;
                     Color a3 = a;
                     int iAStarGreedy3 = iAStarGreedy;
                     int i3 = i;
                     Do |= this.FullGameThinkingTreeHourse(i3, a3, Ord3, iAStarGreedy3, ii3, jj3, ik13, j13, FOUND, LeafAStarGreedy);
                    //Initiatye Variables.
                    Order = DummyOrder;
                     ChessRules.CurrentOrder = DummyCurrentOrder;
                 }
             }
         }
     }, () =>
     {
         Object ooo = new Object();
         lock (ooo)
         {
             if (i < CastleMidle)
             {
                 Object O1 = new Object();
                 lock (O1)
                 {
                     if (Order == 1)
                         a = Color.Gray;
                     else
                         a = Color.Brown;


                     int ii4 = ii, jj4 = jj, ik14 = ik1, j14 = j1;
                     int Ord4 = Order;
                     Color a4 = a;
                     int iAStarGreedy4 = iAStarGreedy;
                     int i4 = i;
                     Do |= this.FullGameThinkingTreeCastle(i4, a4, Ord4, iAStarGreedy4, ii4, jj4, ik14, j14, FOUND, LeafAStarGreedy);
                    //Initiatye Variables.
                    Order = DummyOrder;
                     ChessRules.CurrentOrder = DummyCurrentOrder;
                 }
             }
         }
     }, () =>
     {
         Object ooo = new Object();
         lock (ooo)
         {
             if (i < MinisterMidle)
             {
                 Object O1 = new Object();
                 lock (O1)
                 {
                     if (Order == 1)
                         a = Color.Gray;
                     else
                         a = Color.Brown;


                     int ii5 = ii, jj5 = jj, ik15 = ik1, j15 = j1;
                     int Ord5 = Order;
                     Color a5 = a;
                     int iAStarGreedy5 = iAStarGreedy;
                     int i5 = i;
                     Do |= this.FullGameThinkingTreeMinister(i5, a5, Ord5, iAStarGreedy5, ii5, jj5, ik15, j15, FOUND, LeafAStarGreedy);
                    //Initiatye Variables.
                    Order = DummyOrder;
                     ChessRules.CurrentOrder = DummyCurrentOrder;
                 }
             }
         }
     }, () =>
     {
         Object ooo = new Object();
         lock (ooo)
         {
             if (i < KingMidle)
             {
                 Object O1 = new Object();
                 lock (O1)
                 {
                     if (Order == 1)
                         a = Color.Gray;
                     else
                         a = Color.Brown;


                     int ii6 = ii, jj6 = jj, ik16 = ik1, j16 = j1;
                     int Ord6 = Order;
                     Color a6 = a;
                     int iAStarGreedy6 = iAStarGreedy;
                     int i6 = i;
                     Do |= this.FullGameThinkingTreeKing(i6, a6, Ord6, iAStarGreedy6, ii6, jj6, ik16, j16, FOUND, LeafAStarGreedy);
                     Order = DummyOrder;
                     ChessRules.CurrentOrder = DummyCurrentOrder;
                 }
             }
         }
     });
 });
                    }
                });
                output.Wait(); output.Dispose();
            }
            //For Brown Order Blitz Game Calculate Maximum Table Inclusive AStarGreedy First Game Search.
            else
            {
                var output = Task.Factory.StartNew(() =>
                {
                    //if (!feedCancellationTokenSource.IsCancellationRequested)
                    {
                        ParallelOptions po = new ParallelOptions(); po.MaxDegreeOfParallelism = System.Threading.PlatformHelper.ProcessorCount; Parallel.For(MinBrownMidle(), MaxGrayMidle(), i =>
 {
     ParallelOptions poo = new ParallelOptions(); poo.MaxDegreeOfParallelism = System.Threading.PlatformHelper.ProcessorCount; Parallel.Invoke(() =>
     {
         Object ooo = new Object();
         lock (ooo)
         {
             if (i >= SodierMidle && i < SodierHigh)
             {
                 Object O1 = new Object();
                 lock (O1)
                 {
                     if (Order == 1)
                         a = Color.Gray;
                     else
                         a = Color.Brown;
                     int ii1 = ii, jj1 = jj, ik11 = ik1, j11 = j1;
                     int Ord1 = OrderP;
                     Color a1 = a;
                     int iAStarGreedy1 = iAStarGreedy;
                     int i1 = i;
                     Do |= this.FullGameThinkingTreeSoldier(i1, a1, Ord1, iAStarGreedy1, ii1, jj1, ik11, j11, FOUND, LeafAStarGreedy);
                     Order = DummyOrder;
                     ChessRules.CurrentOrder = DummyCurrentOrder;
                 }
             }
         }
     }, () =>
     {
         if (i >= ElefantMidle && i < ElefantHigh)
         {
             Object ooo = new Object();
             lock (ooo)
             {
                 if (Order == 1)
                     a = Color.Gray;
                 else
                     a = Color.Brown;
                 int ii2 = ii, jj2 = jj, ik12 = ik1, j12 = j1;
                 int Ord2 = Order;
                 Color a2 = a;
                 int iAStarGreedy2 = iAStarGreedy;
                 int i2 = i;
                 Do |= this.FullGameThinkingTreeElephant(i2, a2, Ord2, iAStarGreedy2, ii2, jj2, ik12, j12, FOUND, LeafAStarGreedy);
                //Initiatye Variables.
                Order = DummyOrder;
                 ChessRules.CurrentOrder = DummyCurrentOrder;
             }
         }
     }, () =>
     {
         if (i >= HourseMidle && i < HourseHight)
         {
             Object O1 = new Object();
             lock (O1)
             {
                 if (Order == 1)
                     a = Color.Gray;
                 else
                     a = Color.Brown;
                 int ii3 = ii, jj3 = jj, ik13 = ik1, j13 = j1;
                 int Ord3 = Order;
                 Color a3 = a;
                 int iAStarGreedy3 = iAStarGreedy;
                 int i3 = i;
                 Do |= this.FullGameThinkingTreeHourse(i3, a3, Ord3, iAStarGreedy3, ii3, jj3, ik13, j13, FOUND, LeafAStarGreedy);
                //Initiatye Variables.
                Order = DummyOrder;
                 ChessRules.CurrentOrder = DummyCurrentOrder;
             }
         }
     }, () =>
     {
         if (i >= CastleMidle && i < CastleHigh)
         {
             Object ooo = new Object();
             lock (ooo)
             {
                 if (Order == 1)
                     a = Color.Gray;
                 else
                     a = Color.Brown;
                 int ii4 = ii, jj4 = jj, ik14 = ik1, j14 = j1;
                 int Ord4 = Order;
                 Color a4 = a;
                 int iAStarGreedy4 = iAStarGreedy;
                 int i4 = i;
                 Do |= this.FullGameThinkingTreeCastle(i4, a4, Ord4, iAStarGreedy4, ii4, jj4, ik14, j14, FOUND, LeafAStarGreedy);
                //Initiatye Variables.
                Order = DummyOrder;
                 ChessRules.CurrentOrder = DummyCurrentOrder;
             }
         }
     }, () =>
     {
         if (i >= MinisterMidle && i < MinisterHigh)
         {
             Object ooo = new Object();
             lock (ooo)
             {
                 if (Order == 1)
                     a = Color.Gray;
                 else
                     a = Color.Brown;
                 int ii5 = ii, jj5 = jj, ik15 = ik1, j15 = j1;
                 int Ord5 = Order;
                 Color a5 = a;
                 int iAStarGreedy5 = iAStarGreedy;
                 int i5 = i;
                 Do |= this.FullGameThinkingTreeMinister(i5, a5, Ord5, iAStarGreedy5, ii5, jj5, ik15, j15, FOUND, LeafAStarGreedy);
                //Initiatye Variables.
                Order = DummyOrder;
                 ChessRules.CurrentOrder = DummyCurrentOrder;
             }
         }
     }, () =>
     {
         if (i >= KingMidle && i < KingHigh)
         {
             Object ooo = new Object();
             lock (ooo)
             {
                 if (Order == 1)
                     a = Color.Gray;
                 else
                     a = Color.Brown;
                 if (Order == 1)
                     a = Color.Gray;
                 else
                     a = Color.Brown;
                 int ii6 = ii, jj6 = jj, ik16 = ik1, j16 = j1;
                 int Ord6 = Order;
                 Color a6 = a;
                 int iAStarGreedy6 = iAStarGreedy;
                 int i6 = i;
                 Do |= this.FullGameThinkingTreeKing(i6, a6, Ord6, iAStarGreedy6, ii6, jj6, ik16, j16, FOUND, LeafAStarGreedy);
                 Order = DummyOrder;
                 ChessRules.CurrentOrder = DummyCurrentOrder;
             }
         }
     });
 });
                    }
                });
                output.Wait(); output.Dispose();
            }

            return Do;
        }
        //clone a table
        public int[,] CloneATable(int[,] Tab)
        {

            int[,] Tabl = new int[8, 8];
            for (var i = 0; i < 8; i++)
                for (var j = 0; j < 8; j++)
                    Tabl[i, j] = Tab[i, j];

            return Tabl;
        }
        //return maximum of six type values 
        int MaxOfSixHeuristic(int _1, int _2, int _3, int _4, int _5, int _6, int _7)
        {

            int[] LessB = new int[6];
            LessB[0] = _1;
            LessB[1] = _2;
            LessB[2] = _3;
            LessB[3] = _4;
            LessB[4] = _5;
            LessB[5] = _6;
            LessB[6] = _7;
            int Value = -1;
            int Les = Int32.MinValue;
            for (var i = 0; i < 7; i++)
            {
                if (LessB[i] > Les)
                {
                    Les = LessB[i];
                    Value = i;
                }
            }

            return Value;
        }
        //return minimum pf six type values
        int MinOfSixHeuristic(int _1, int _2, int _3, int _4, int _5, int _6, int _7)
        {

            int[] LessB = new int[6];
            LessB[0] = _1;
            LessB[1] = _2;
            LessB[2] = _3;
            LessB[3] = _4;
            LessB[4] = _5;
            LessB[5] = _6;
            LessB[5] = _7;
            int Value = -1;
            int Les = Int32.MaxValue;
            for (var i = 0; i < 7; i++)
            {
                if (LessB[i] < Les)
                {
                    Les = LessB[i];
                    Value = i;
                }
            }

            return Value;
        }
        //best movement indexes founder method.
        List<List<int>> FoundOfBestMovments(int AStarGreedy, ref List<int> i, ref List<int> j, ref List<int> k, AllDraw Dummy, Color a, int Order)
        {

            //initiate local variables.
            List<List<int>> p = new List<List<int>>();
            for (var ii = 0; ii < 6; ii++)
            {
                List<int> pl = new List<int>();
                p.Add(pl);
                Less = Int32.MinValue;
            }
            List<AllDraw> DummyList = new List<AllDraw>();
            DummyList.Add(Dummy);
            MaxHeuristicAStarGreedytBackWard.Clear();
            //found best movment depend of max Heuristic.
            Dummy.HeuristicAStarGreedySearch(0, a, Order, false);
            //proccess from a stored global variable decicion making.
            if (MaxHeuristicAStarGreedytBackWard[0][1] != -1)//soldier.
            {
                i.Add(MaxHeuristicAStarGreedytBackWard[0][2]);
                j.Add(MaxHeuristicAStarGreedytBackWard[0][3]);
                k.Add(MaxHeuristicAStarGreedytBackWard[0][4]);
                p[0].Add(MaxHeuristicAStarGreedytBackWard[0][2]);
            }
            else if (MaxHeuristicAStarGreedytBackWard[0][5] != -1)//Elephant
            {
                i.Add(MaxHeuristicAStarGreedytBackWard[0][6]);
                j.Add(MaxHeuristicAStarGreedytBackWard[0][7]);
                k.Add(MaxHeuristicAStarGreedytBackWard[0][8]);
                p[1].Add(MaxHeuristicAStarGreedytBackWard[0][6]);
            }
            else if (MaxHeuristicAStarGreedytBackWard[0][9] != -1)//Hourse
            {
                i.Add(MaxHeuristicAStarGreedytBackWard[0][10]);
                j.Add(MaxHeuristicAStarGreedytBackWard[0][11]);
                k.Add(MaxHeuristicAStarGreedytBackWard[0][12]);
                p[2].Add(MaxHeuristicAStarGreedytBackWard[0][10]);
            }
            else if (MaxHeuristicAStarGreedytBackWard[0][13] != -1)//Castles.
            {
                i.Add(MaxHeuristicAStarGreedytBackWard[0][14]);
                j.Add(MaxHeuristicAStarGreedytBackWard[0][15]);
                k.Add(MaxHeuristicAStarGreedytBackWard[0][16]);
                p[3].Add(MaxHeuristicAStarGreedytBackWard[0][14]);
            }
            else if (MaxHeuristicAStarGreedytBackWard[0][17] != -1)//Minister
            {
                i.Add(MaxHeuristicAStarGreedytBackWard[0][18]);
                j.Add(MaxHeuristicAStarGreedytBackWard[0][19]);
                k.Add(MaxHeuristicAStarGreedytBackWard[0][20]);
                p[4].Add(MaxHeuristicAStarGreedytBackWard[0][18]);
            }
            else if (MaxHeuristicAStarGreedytBackWard[0][21] != -1)//King.
            {
                i.Add(MaxHeuristicAStarGreedytBackWard[0][22]);
                j.Add(MaxHeuristicAStarGreedytBackWard[0][23]);
                k.Add(MaxHeuristicAStarGreedytBackWard[0][24]);
                p[5].Add(MaxHeuristicAStarGreedytBackWard[0][22]);
            }

            //not found
            return p;
        }
        //Copying of Items of Enemy Non Move and Current Moved.
        public AllDraw CopyRemeiningItems(AllDraw ADummy, int Order)
        {

            //Initiate Local Variables.
            AllDraw Dummy = new AllDraw(OrderPlate, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged);
            Dummy.TableList.Add(CloneATable(TableList[0]));
            Dummy.SolderesOnTable = new DrawSoldier[SodierHigh];
            Dummy.ElephantOnTable = new DrawElefant[ElefantHigh];
            Dummy.HoursesOnTable = new DrawHourse[HourseHight];
            Dummy.CastlesOnTable = new DrawCastle[CastleHigh];
            Dummy.MinisterOnTable = new DrawMinister[MinisterHigh];
            Dummy.KingOnTable = new DrawKing[KingHigh];
            //For All Sodiers Movments.
            for (var i = 0; i < SodierHigh; i++)
            {
                //Construction of Current Solders. 
                Dummy.SolderesOnTable[i] = new DrawSoldier(CurrentAStarGredyMax, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged, SolderesOnTable[i].Row, SolderesOnTable[i].Column, SolderesOnTable[i].color, CloneATable(SolderesOnTable[i].Table), SolderesOnTable[i].Order, false, SolderesOnTable[i].Current);
            }
            //For All Elephant Objects.
            for (var i = 0; i < ElefantHigh; i++)
            {
                //Construction of Curren Elephant.
                Dummy.ElephantOnTable[i] = new DrawElefant(CurrentAStarGredyMax, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged, ElephantOnTable[i].Row, ElephantOnTable[i].Column, ElephantOnTable[i].color, CloneATable(ElephantOnTable[i].Table), ElephantOnTable[i].Order, false, ElephantOnTable[i].Current);
            }
            //for All Hourse Objects.
            for (var i = 0; i < HourseHight; i++)
            {
                //Construction of Hourse Objects.
                Dummy.HoursesOnTable[i] = new DrawHourse(CurrentAStarGredyMax, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged, HoursesOnTable[i].Row, HoursesOnTable[i].Column, HoursesOnTable[i].color, CloneATable(HoursesOnTable[i].Table), HoursesOnTable[i].Order, false, HoursesOnTable[i].Current);
            }
            //For All Castles Objects.
            for (var i = 0; i < CastleHigh; i++)
            {
                //Construction of Castles Objects.
                Dummy.CastlesOnTable[i] = new DrawCastle(CurrentAStarGredyMax, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged, CastlesOnTable[i].Row, CastlesOnTable[i].Column, CastlesOnTable[i].color, CloneATable(CastlesOnTable[i].Table), CastlesOnTable[i].Order, false, CastlesOnTable[i].Current);
            }
            //For All Minister Objects.
            for (var i = 0; i < MinisterHigh; i++)
            {
                //Construction of Current Minister.
                Dummy.MinisterOnTable[i] = new DrawMinister(CurrentAStarGredyMax, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged, MinisterOnTable[i].Row, MinisterOnTable[i].Column, MinisterOnTable[i].color, CloneATable(MinisterOnTable[i].Table), MinisterOnTable[i].Order, false, MinisterOnTable[i].Current);
            }
            //For All King Objects.
            for (var i = 0; i < KingHigh; i++)
            {
                //Construction of Kings Objects.
                Dummy.KingOnTable[i] = new DrawKing(CurrentAStarGredyMax, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged, KingOnTable[i].Row, KingOnTable[i].Column, KingOnTable[i].color, CloneATable(KingOnTable[i].Table), KingOnTable[i].Order, false, KingOnTable[i].Current);
            }
            //Gray Order.
            if (Order == 1)
            {
                //For Gray Soders Objects.
                for (var i = 0; i < SodierMidle; i++)
                {
                    //Clone a Movments.
                    ADummy.SolderesOnTable[i].Clone(ref Dummy.SolderesOnTable[i]);
                }
                //For Gray Elephant.
                for (var i = 0; i < ElefantMidle; i++)
                {
                    //Clone a  Movments.
                    ADummy.ElephantOnTable[i].Clone(ref Dummy.ElephantOnTable[i]);
                }
                //For Gray Hourses.
                for (var i = 0; i < HourseMidle; i++)
                {
                    //Clone a Movments.
                    ADummy.HoursesOnTable[i].Clone(ref Dummy.HoursesOnTable[i]);
                }
                //For Gray Castles.
                for (var i = 0; i < CastleMidle; i++)
                {
                    //Clone a Movments.
                    ADummy.CastlesOnTable[i].Clone(ref Dummy.CastlesOnTable[i]);
                }
                //For Gray Ministers.
                for (var i = 0; i < MinisterMidle; i++)
                {
                    //Clone a Movments.
                    ADummy.MinisterOnTable[i].Clone(ref Dummy.MinisterOnTable[i]);
                }
                //For Gray King.
                for (var i = 0; i < KingMidle; i++)
                {
                    //Clone a Movments.
                    ADummy.KingOnTable[i].Clone(ref Dummy.KingOnTable[i]);
                }
                //For All Solders.
            }
            else//For Order Brown.
            {
                {
                    //For Brown Solders.
                    for (var i = SodierMidle; i < SodierHigh; i++)
                    {
                        //Clone a Movments.
                        ADummy.SolderesOnTable[i].Clone(ref Dummy.SolderesOnTable[i]);
                    }
                    //For All Brown Elephants.
                    for (var i = ElefantMidle; i < ElefantHigh; i++)
                    {
                        //Clone a Enemy.
                        ADummy.ElephantOnTable[i].Clone(ref Dummy.ElephantOnTable[i]);
                    }
                    //For All Brown Hourses.
                    for (var i = HourseMidle; i < HourseHight; i++)
                    {
                        //Clone a Enemy.
                        ADummy.HoursesOnTable[i].Clone(ref Dummy.HoursesOnTable[i]);
                    }
                    //For Brown Castles. 
                    for (var i = CastleMidle; i < CastleHigh; i++)
                    {
                        //Clone a Movments.
                        ADummy.CastlesOnTable[i].Clone(ref Dummy.CastlesOnTable[i]);
                    }
                    //For Gray Minsters.
                    for (var i = MinisterMidle; i < MinisterHigh; i++)
                    {
                        //Clone a Enemy.
                        ADummy.MinisterOnTable[i].Clone(ref Dummy.MinisterOnTable[i]);
                    }
                    //For Brown Kings.
                    for (var i = KingMidle; i < KingHigh; i++)
                    {
                        //Clone a Enemy.
                        ADummy.KingOnTable[i].Clone(ref Dummy.KingOnTable[i]);
                    }
                }
            }

            //Return Constructed Tables.
            return Dummy;

        }
        //determiniation and detection of zeros
        public bool TableZero(int[,] Ta)
        {

            bool Zerro = true;
            for (var i = 0; i < 8; i++)
                for (var j = 0; j < 8; j++)
                    if (Ta[i, j] != 0)
                        Zerro = false;

            return Zerro;
        }
        //operantional for victom learning autamata penalty make performing pbetter Heuristic values of current specific object
        void CheckedMateConfiguratiionSoldier(int Order, int i, bool Regrad)
        {

            for (var j = 0; j < SolderesOnTable[i].SoldierThinking[0].PenaltyRegardListSolder.Count; j++)
            {
                if (SolderesOnTable[i].SoldierThinking[0].LearningVarsObject.Count == SolderesOnTable[i].SoldierThinking[0].PenaltyRegardListSolder.Count)
                    if (SolderesOnTable[i].SoldierThinking[0].LearningVarsObject[j][1] && (!SolderesOnTable[i].SoldierThinking[0].LearningVarsObject[j][4]))
                    {
                        SolderesOnTable[i].SoldierThinking[0].PenaltyRegardListSolder[j].Initiate();
                        //if(Regrad)

                        //else
                        if (!Regrad)
                            SolderesOnTable[i].SoldierThinking[0].PenaltyRegardListSolder[j].LearningAlgorithmPenalty();
                        SolderesOnTable[i].SoldierThinking[0].HeuristicPenaltyValuePerform(SolderesOnTable[i].SoldierThinking[0].PenaltyRegardListSolder[j], Order, ref SolderesOnTable[i].SoldierThinking[0].HeuristicListSolder[j][0], true);
                    }
            }

        }
        //operantional for victom learning autamata penalty make performing pbetter Heuristic values of current specific object
        void CheckedMateConfiguratiionElephant(int Order, int i, bool Regrad)
        {

            for (var j = 0; j < ElephantOnTable[i].ElefantThinking[0].PenaltyRegardListElefant.Count; j++)
            {
                if (ElephantOnTable[i].ElefantThinking[0].LearningVarsObject.Count == ElephantOnTable[i].ElefantThinking[0].PenaltyRegardListElefant.Count)
                    if (ElephantOnTable[i].ElefantThinking[0].LearningVarsObject[j][1] && (!ElephantOnTable[i].ElefantThinking[0].LearningVarsObject[j][4]))
                    {
                        ElephantOnTable[i].ElefantThinking[0].PenaltyRegardListElefant[j].Initiate();
                        //if(Regrad)

                        //else
                        if (!Regrad)
                            ElephantOnTable[i].ElefantThinking[0].PenaltyRegardListElefant[j].LearningAlgorithmPenalty();
                        ElephantOnTable[i].ElefantThinking[0].HeuristicPenaltyValuePerform(ElephantOnTable[i].ElefantThinking[0].PenaltyRegardListElefant[j], Order, ref ElephantOnTable[i].ElefantThinking[0].HeuristicListElefant[j][0], true);
                    }
            }

        }
        //operantional for victom learning autamata penalty make performing pbetter Heuristic values of current specific object
        void CheckedMateConfiguratiionHourse(int Order, int i, bool Regrad)
        {

            for (var j = 0; j < HoursesOnTable[i].HourseThinking[0].PenaltyRegardListHourse.Count; j++)
            {
                if (HoursesOnTable[i].HourseThinking[0].LearningVarsObject.Count == HoursesOnTable[i].HourseThinking[0].PenaltyRegardListHourse.Count)
                    if (HoursesOnTable[i].HourseThinking[0].LearningVarsObject[j][1] && (!HoursesOnTable[i].HourseThinking[0].LearningVarsObject[j][4]))
                    {
                        HoursesOnTable[i].HourseThinking[0].PenaltyRegardListHourse[j].Initiate();
                        //if(Regrad)

                        //else
                        if (!Regrad)
                            HoursesOnTable[i].HourseThinking[0].PenaltyRegardListHourse[j].LearningAlgorithmPenalty();
                        HoursesOnTable[i].HourseThinking[0].HeuristicPenaltyValuePerform(HoursesOnTable[i].HourseThinking[0].PenaltyRegardListHourse[j], Order, ref HoursesOnTable[i].HourseThinking[0].HeuristicListHourse[j][0], true);
                    }
            }

        }
        //operantional for victom learning autamata penalty make performing pbetter Heuristic values of current specific object
        void CheckedMateConfiguratiionCastle(int Order, int i, bool Regrad)
        {

            for (var j = 0; j < CastlesOnTable[i].CastleThinking[0].PenaltyRegardListCastle.Count; j++)
            {
                if (CastlesOnTable[i].CastleThinking[0].LearningVarsObject.Count == CastlesOnTable[i].CastleThinking[0].PenaltyRegardListCastle.Count)
                    if (CastlesOnTable[i].CastleThinking[0].LearningVarsObject[j][1] && (!CastlesOnTable[i].CastleThinking[0].LearningVarsObject[j][4]))
                    {
                        CastlesOnTable[i].CastleThinking[0].PenaltyRegardListCastle[j].Initiate();
                        //if(Regrad)

                        //else
                        if (!Regrad)
                            CastlesOnTable[i].CastleThinking[0].PenaltyRegardListCastle[j].LearningAlgorithmPenalty();
                        CastlesOnTable[i].CastleThinking[0].HeuristicPenaltyValuePerform(CastlesOnTable[i].CastleThinking[0].PenaltyRegardListCastle[j], Order, ref CastlesOnTable[i].CastleThinking[0].HeuristicListCastle[j][0], true);
                    }
            }

        }
        //operantional for victom learning autamata penalty make performing pbetter Heuristic values of current specific object
        void CheckedMateConfiguratiionMinister(int Order, int i, bool Regrad)
        {

            for (var j = 0; j < MinisterOnTable[i].MinisterThinking[0].PenaltyRegardListMinister.Count; j++)
            {
                if (MinisterOnTable[i].MinisterThinking[0].LearningVarsObject.Count == MinisterOnTable[i].MinisterThinking[0].PenaltyRegardListMinister.Count)
                    if (MinisterOnTable[i].MinisterThinking[0].LearningVarsObject[j][1] && (!MinisterOnTable[i].MinisterThinking[0].LearningVarsObject[j][4]))
                    {
                        MinisterOnTable[i].MinisterThinking[0].PenaltyRegardListMinister[j].Initiate();
                        //if(Regrad)

                        //else
                        if (!Regrad)
                            MinisterOnTable[i].MinisterThinking[0].PenaltyRegardListMinister[j].LearningAlgorithmPenalty();
                        MinisterOnTable[i].MinisterThinking[0].HeuristicPenaltyValuePerform(MinisterOnTable[i].MinisterThinking[0].PenaltyRegardListMinister[j], Order, ref MinisterOnTable[i].MinisterThinking[0].HeuristicListMinister[j][0], true);
                    }
            }

        }
        //operantional for victom learning autamata penalty make performing pbetter Heuristic values of current specific object
        void CheckedMateConfiguratiionking(int Order, int i, bool Regrad)
        {

            for (var j = 0; j < KingOnTable[i].KingThinking[0].PenaltyRegardListKing.Count; j++)
            {
                if (KingOnTable[i].KingThinking[0].LearningVarsObject.Count == KingOnTable[i].KingThinking[0].PenaltyRegardListKing.Count)
                    if (KingOnTable[i].KingThinking[0].LearningVarsObject[j][1] && (!KingOnTable[i].KingThinking[0].LearningVarsObject[j][4]))
                    {
                        KingOnTable[i].KingThinking[0].PenaltyRegardListKing[j].Initiate();
                        //if(Regrad)

                        //else
                        if (!Regrad)
                            KingOnTable[i].KingThinking[0].PenaltyRegardListKing[j].LearningAlgorithmPenalty();
                        KingOnTable[i].KingThinking[0].HeuristicPenaltyValuePerform(KingOnTable[i].KingThinking[0].PenaltyRegardListKing[j], Order, ref KingOnTable[i].KingThinking[0].HeuristicListKing[j][0], true);
                    }
            }

        }
        void CheckedMateConfiguratiioncastling(int Order, int i, bool Regrad)
        {

            for (var j = 0; j < CastlingOnTable[i].CastlingThinking[0].PenaltyRegardListCastling.Count; j++)
            {
                if (CastlingOnTable[i].CastlingThinking[0].LearningVarsObject.Count == CastlingOnTable[i].CastlingThinking[0].PenaltyRegardListCastling.Count)
                    if (CastlingOnTable[i].CastlingThinking[0].LearningVarsObject[j][1] && (!CastlingOnTable[i].CastlingThinking[0].LearningVarsObject[j][4]))
                    {
                        CastlingOnTable[i].CastlingThinking[0].PenaltyRegardListCastling[j].Initiate();
                        //if(Regrad)

                        //else
                        if (!Regrad)
                            CastlingOnTable[i].CastlingThinking[0].PenaltyRegardListCastling[j].LearningAlgorithmPenalty();
                        CastlingOnTable[i].CastlingThinking[0].HeuristicPenaltyValuePerform(CastlingOnTable[i].CastlingThinking[0].PenaltyRegardListCastling[j], Order, ref CastlingOnTable[i].CastlingThinking[0].HeuristicListCastling[j][0], true);
                    }
            }

        }
        //specific learning autamata network oparational
        void CheckedMateConfiguratiion(int Order)
        {

            Object O = new Object();
            lock (O)
            {
                if (ThinkingRefrigtzChessPortable.LearningVarsCheckedMateOccured && ThinkingRefrigtzChessPortable.LearningVarsCheckedMateOccuredOneCheckedMate)
                {
                    if (Order == 1)
                    {
                        for (var i = 0; i < SodierMidle; i++)
                            if (SolderesOnTable != null && SolderesOnTable[i] != null)
                                CheckedMateConfiguratiionSoldier(Order, i, true);

                        for (var i = 0; i < ElefantMidle; i++)
                            if (ElephantOnTable != null && ElephantOnTable[i] != null)
                                CheckedMateConfiguratiionElephant(Order, i, true);
                        for (var i = 0; i < HourseMidle; i++)
                            if (HoursesOnTable != null && HoursesOnTable[i] != null)
                                CheckedMateConfiguratiionHourse(Order, i, true);
                        for (var i = 0; i < CastleMidle; i++)
                            if (CastlesOnTable != null && CastlesOnTable[i] != null)
                                CheckedMateConfiguratiionCastle(Order, i, true);
                        for (var i = 0; i < MinisterMidle; i++)
                            if (MinisterOnTable != null && MinisterOnTable[i] != null)
                                CheckedMateConfiguratiionMinister(Order, i, true);
                        for (var i = 0; i < KingMidle; i++)
                            if (KingOnTable != null && KingOnTable[i] != null)
                                CheckedMateConfiguratiionking(Order, i, true);
                        for (var i = 0; i < 1; i++)
                            if (CastlingOnTable != null && CastlingOnTable[i] != null)
                                CheckedMateConfiguratiioncastling(Order, i, true);
                    }
                    else
                    {
                        for (var i = SodierMidle; i < SodierHigh; i++)
                            if (SolderesOnTable != null && SolderesOnTable[i] != null)
                                CheckedMateConfiguratiionSoldier(Order, i, true);
                        for (var i = ElefantMidle; i < ElefantHigh; i++)
                            if (ElephantOnTable != null && ElephantOnTable[i] != null)
                                CheckedMateConfiguratiionElephant(Order, i, true);
                        for (var i = HourseMidle; i < HourseHight; i++)
                            if (HoursesOnTable != null && HoursesOnTable[i] != null)
                                CheckedMateConfiguratiionHourse(Order, i, true);
                        for (var i = CastleMidle; i < CastleHigh; i++)
                            if (CastlesOnTable != null && CastlesOnTable[i] != null)
                                CheckedMateConfiguratiionCastle(Order, i, true);
                        for (var i = MinisterMidle; i < MinisterHigh; i++)
                            if (MinisterOnTable != null && MinisterOnTable[i] != null)
                                CheckedMateConfiguratiionMinister(Order, i, true);
                        for (var i = KingMidle; i < KingHigh; i++)
                            if (KingOnTable != null && KingOnTable[i] != null)
                                CheckedMateConfiguratiionking(Order, i, true);
                        for (var i = 0; i < 1; i++)
                            if (CastlingOnTable != null && CastlingOnTable[i] != null)
                                CheckedMateConfiguratiioncastling(Order, i, true);
                    }

                }
                else
                {
                    if (Order == 1)
                    {
                        for (var i = 0; i < SodierMidle; i++)
                            if (SolderesOnTable != null && SolderesOnTable[i] != null)
                                CheckedMateConfiguratiionSoldier(Order, i, false);
                        for (var i = 0; i < ElefantMidle; i++)
                            if (ElephantOnTable != null && ElephantOnTable[i] != null)
                                CheckedMateConfiguratiionElephant(Order, i, false);
                        for (var i = 0; i < HourseMidle; i++)
                            if (HoursesOnTable != null && HoursesOnTable[i] != null)
                                CheckedMateConfiguratiionHourse(Order, i, false);
                        for (var i = 0; i < CastleMidle; i++)
                            if (CastlesOnTable != null && CastlesOnTable[i] != null)
                                CheckedMateConfiguratiionCastle(Order, i, false);
                        for (var i = 0; i < MinisterMidle; i++)
                            if (MinisterOnTable != null && MinisterOnTable[i] != null)
                                CheckedMateConfiguratiionMinister(Order, i, false);
                        for (var i = 0; i < KingMidle; i++)
                            if (KingOnTable != null && KingOnTable[i] != null)
                                CheckedMateConfiguratiionking(Order, i, false);
                        for (var i = 0; i < 1; i++)
                            if (CastlingOnTable != null && CastlingOnTable[i] != null)
                                CheckedMateConfiguratiioncastling(Order, i, false);
                    }
                    else
                    {
                        for (var i = SodierMidle; i < SodierHigh; i++)
                            if (SolderesOnTable != null && SolderesOnTable[i] != null)
                                CheckedMateConfiguratiionSoldier(Order, i, false);
                        for (var i = ElefantMidle; i < ElefantHigh; i++)
                            if (ElephantOnTable != null && ElephantOnTable[i] != null)
                                CheckedMateConfiguratiionElephant(Order, i, false);
                        for (var i = HourseMidle; i < HourseHight; i++)
                            if (HoursesOnTable != null && HoursesOnTable[i] != null)
                                CheckedMateConfiguratiionHourse(Order, i, false);
                        for (var i = CastleMidle; i < CastleHigh; i++)
                            if (CastlesOnTable != null && CastlesOnTable[i] != null)
                                CheckedMateConfiguratiionCastle(Order, i, false);
                        for (var i = MinisterMidle; i < MinisterHigh; i++)
                            if (MinisterOnTable != null && MinisterOnTable[i] != null)
                                CheckedMateConfiguratiionMinister(Order, i, false);
                        for (var i = KingMidle; i < KingHigh; i++)
                            if (KingOnTable != null && KingOnTable[i] != null)
                                CheckedMateConfiguratiionking(Order, i, false);
                        for (var i = 0; i < 1; i++)
                            if (CastlingOnTable != null && CastlingOnTable[i] != null)
                                CheckedMateConfiguratiioncastling(Order, i, false);
                    }
                }
            }

        }
        //monitor
        void SemaphoreExxedTime(int time, int Kind)
        {

        }
        int UniqueCapableMoveIsTruSup(int Kind, int Order, int ii, int jj)
        {
            int No = 0;
            if (!AllowedSupTrue)
            {
                if (Order == 1)
                {
                    if (Kind == 1)
                    {
                        for (int i = 0; i < SodierMidle; i++)
                        {
                            for (int j = 0; j < SolderesOnTable[i].SoldierThinking[0].IsSupHu.Count; j++)
                            {
                                if (!SolderesOnTable[i].SoldierThinking[0].IsSupHu[j])
                                    No++;
                            }
                        }
                    }
                    else if (Kind == 2)
                    {
                        for (int i = 0; i < ElefantMidle; i++)
                        {
                            for (int j = 0; j < ElephantOnTable[i].ElefantThinking[0].IsSupHu.Count; j++)
                            {
                                if (!ElephantOnTable[i].ElefantThinking[0].IsSupHu[j])
                                    No++;
                            }
                        }
                    }
                    else if (Kind == 3)
                    {
                        for (int i = 0; i < HourseMidle; i++)
                        {
                            for (int j = 0; j < HoursesOnTable[i].HourseThinking[0].IsSupHu.Count; j++)
                            {
                                if (!HoursesOnTable[i].HourseThinking[0].IsSupHu[j])
                                    No++;
                            }
                        }
                    }
                    else if (Kind == 4)
                    {
                        for (int i = 0; i < CastleMidle; i++)
                        {
                            for (int j = 0; j < CastlesOnTable[i].CastleThinking[0].IsSupHu.Count; j++)
                            {
                                if (!CastlesOnTable[i].CastleThinking[0].IsSupHu[j])
                                    No++;
                            }
                        }
                    }
                    else if (Kind == 5)
                    {
                        for (int i = 0; i < MinisterMidle; i++)
                        {
                            for (int j = 0; j < MinisterOnTable[i].MinisterThinking[0].IsSupHu.Count; j++)
                            {
                                if (!MinisterOnTable[i].MinisterThinking[0].IsSupHu[j])
                                    No++;
                            }
                        }
                    }
                    else if (Kind == 6)
                    {
                        for (int i = 0; i < KingMidle; i++)
                        {
                            for (int j = 0; j < KingOnTable[i].KingThinking[0].IsSupHu.Count; j++)
                            {
                                if (!KingOnTable[i].KingThinking[0].IsSupHu[j])
                                    No++;
                            }
                        }
                    }
                    else if (Kind == 7 || Kind == -7)
                    {
                        for (int i = 0; i < 1; i++)
                        {
                            for (int j = 0; j < CastlingOnTable[i].CastlingThinking[0].IsSupHu.Count; j++)
                            {
                                if (!CastlingOnTable[i].CastlingThinking[0].IsSupHu[j])
                                    No++;
                            }
                        }
                    }
                }
                else
                {
                    if (Kind == 1)
                    {
                        for (int i = SodierMidle; i < SodierHigh; i++)
                        {
                            for (int j = 0; j < SolderesOnTable[i].SoldierThinking[0].IsSupHu.Count; j++)
                            {
                                if (!SolderesOnTable[i].SoldierThinking[0].IsSupHu[j])
                                    No++;
                            }
                        }
                    }
                    else if (Kind == 2)
                    {
                        for (int i = ElefantMidle; i < ElefantHigh; i++)
                        {
                            for (int j = 0; j < ElephantOnTable[i].ElefantThinking[0].IsSupHu.Count; j++)
                            {
                                if (!ElephantOnTable[i].ElefantThinking[0].IsSupHu[j])
                                    No++;
                            }
                        }
                    }
                    else if (Kind == 3)
                    {
                        for (int i = HourseMidle; i < HourseHight; i++)
                        {
                            for (int j = 0; j < HoursesOnTable[i].HourseThinking[0].IsSupHu.Count; j++)
                            {
                                if (!HoursesOnTable[i].HourseThinking[0].IsSupHu[j])
                                    No++;
                            }
                        }
                    }
                    else if (Kind == 4)
                    {
                        for (int i = CastleMidle; i < CastleHigh; i++)
                        {
                            for (int j = 0; j < CastlesOnTable[i].CastleThinking[0].IsSupHu.Count; j++)
                            {
                                if (!CastlesOnTable[i].CastleThinking[0].IsSupHu[j])
                                    No++;
                            }
                        }
                    }
                    else if (Kind == 5)
                    {
                        for (int i = MinisterMidle; i < MinisterHigh; i++)
                        {
                            for (int j = 0; j < MinisterOnTable[i].MinisterThinking[0].IsSupHu.Count; j++)
                            {
                                if (!MinisterOnTable[i].MinisterThinking[0].IsSupHu[j])
                                    No++;
                            }
                        }
                    }
                    else if (Kind == 6)
                    {
                        for (int i = KingMidle; i < KingHigh; i++)
                        {
                            for (int j = 0; j < KingOnTable[i].KingThinking[0].IsSupHu.Count; j++)
                            {
                                if (!KingOnTable[i].KingThinking[0].IsSupHu[j])
                                    No++;
                            }
                        }
                    }
                    else if (Kind == 7 || Kind == -7)
                    {
                        for (int i = 0; i < 1; i++)
                        {
                            for (int j = 0; j < CastlingOnTable[i].CastlingThinking[0].IsSupHu.Count; j++)
                            {
                                if (!CastlingOnTable[i].CastlingThinking[0].IsSupHu[j])
                                    No++;
                            }
                        }
                    }
                }
            }
            else
            {
                if (Order == 1)
                {
                    if (Kind == 1)
                    {
                        for (int i = 0; i < SodierMidle; i++)
                        {
                            for (int j = 0; j < SolderesOnTable[i].SoldierThinking[0].IsSup.Count; j++)
                            {
                                if (!SolderesOnTable[i].SoldierThinking[0].IsSup[j])
                                    No++;
                            }
                        }
                    }
                    else if (Kind == 2)
                    {
                        for (int i = 0; i < ElefantMidle; i++)
                        {
                            for (int j = 0; j < ElephantOnTable[i].ElefantThinking[0].IsSup.Count; j++)
                            {
                                if (!ElephantOnTable[i].ElefantThinking[0].IsSup[j])
                                    No++;
                            }
                        }
                    }
                    else if (Kind == 3)
                    {
                        for (int i = 0; i < HourseMidle; i++)
                        {
                            for (int j = 0; j < HoursesOnTable[i].HourseThinking[0].IsSup.Count; j++)
                            {
                                if (!HoursesOnTable[i].HourseThinking[0].IsSup[j])
                                    No++;
                            }
                        }
                    }
                    else if (Kind == 4)
                    {
                        for (int i = 0; i < CastleMidle; i++)
                        {
                            for (int j = 0; j < CastlesOnTable[i].CastleThinking[0].IsSup.Count; j++)
                            {
                                if (!CastlesOnTable[i].CastleThinking[0].IsSup[j])
                                    No++;
                            }
                        }
                    }
                    else if (Kind == 5)
                    {
                        for (int i = 0; i < MinisterMidle; i++)
                        {
                            for (int j = 0; j < MinisterOnTable[i].MinisterThinking[0].IsSup.Count; j++)
                            {
                                if (!MinisterOnTable[i].MinisterThinking[0].IsSup[j])
                                    No++;
                            }
                        }
                    }
                    else if (Kind == 6)
                    {
                        for (int i = 0; i < KingMidle; i++)
                        {
                            for (int j = 0; j < KingOnTable[i].KingThinking[0].IsSup.Count; j++)
                            {
                                if (!KingOnTable[i].KingThinking[0].IsSup[j])
                                    No++;
                            }
                        }
                    }
                    else if (Kind == 7 || Kind == -7)
                    {
                        for (int i = 0; i < 1; i++)
                        {
                            for (int j = 0; j < CastlingOnTable[i].CastlingThinking[0].IsSup.Count; j++)
                            {
                                if (!CastlingOnTable[i].CastlingThinking[0].IsSup[j])
                                    No++;
                            }
                        }
                    }
                }
                else
                {
                    if (Kind == 1)
                    {
                        for (int i = SodierMidle; i < SodierHigh; i++)
                        {
                            for (int j = 0; j < SolderesOnTable[i].SoldierThinking[0].IsSup.Count; j++)
                            {
                                if (!SolderesOnTable[i].SoldierThinking[0].IsSup[j])
                                    No++;
                            }
                        }
                    }
                    else if (Kind == 2)
                    {
                        for (int i = ElefantMidle; i < ElefantHigh; i++)
                        {
                            for (int j = 0; j < ElephantOnTable[i].ElefantThinking[0].IsSup.Count; j++)
                            {
                                if (!ElephantOnTable[i].ElefantThinking[0].IsSup[j])
                                    No++;
                            }
                        }
                    }
                    else if (Kind == 3)
                    {
                        for (int i = HourseMidle; i < HourseHight; i++)
                        {
                            for (int j = 0; j < HoursesOnTable[i].HourseThinking[0].IsSup.Count; j++)
                            {
                                if (!HoursesOnTable[i].HourseThinking[0].IsSup[j])
                                    No++;
                            }
                        }
                    }
                    else if (Kind == 4)
                    {
                        for (int i = CastleMidle; i < CastleHigh; i++)
                        {
                            for (int j = 0; j < CastlesOnTable[i].CastleThinking[0].IsSup.Count; j++)
                            {
                                if (!CastlesOnTable[i].CastleThinking[0].IsSup[j])
                                    No++;
                            }
                        }
                    }
                    else if (Kind == 5)
                    {
                        for (int i = MinisterMidle; i < MinisterHigh; i++)
                        {
                            for (int j = 0; j < MinisterOnTable[i].MinisterThinking[0].IsSup.Count; j++)
                            {
                                if (!MinisterOnTable[i].MinisterThinking[0].IsSup[j])
                                    No++;
                            }
                        }
                    }
                    else if (Kind == 6)
                    {
                        for (int i = KingMidle; i < KingHigh; i++)
                        {
                            for (int j = 0; j < KingOnTable[i].KingThinking[0].IsSup.Count; j++)
                            {
                                if (!KingOnTable[i].KingThinking[0].IsSup[j])
                                    No++;
                            }
                        }
                    }
                    else if (Kind == 7 || Kind == -7)
                    {
                        for (int i = 0; i < 1; i++)
                        {
                            for (int j = 0; j < CastlingOnTable[i].CastlingThinking[0].IsSup.Count; j++)
                            {
                                if (!CastlingOnTable[i].CastlingThinking[0].IsSup[j])
                                    No++;
                            }
                        }
                    }
                }
            }
            if (No == 0)
            {
                if (IgnoreOfLoseForKingReducedAttackDisturbingDouble(Kind, Order, ii, jj))
                    No = -1;
            }
            return No;
        }
        bool IgnoreOfLoseForKingReducedAttackDisturbingDouble(int Kind, int Order, int i, int j)
        {
            bool No = false;
            if (Kind == 1)
            {
                SolderesOnTable[i].SoldierThinking[0].TowDistrurbProperUsePreferNotToClose(ref SolderesOnTable[i].LoseOcuuredatChiled, CloneATable(SolderesOnTable[i].SoldierThinking[0].TableListSolder[j]));
                if ((SolderesOnTable[i].SoldierThinking[0].RemoveOfDisturbIndex == j) && (SolderesOnTable[i].SoldierThinking[0].LoseChiled[j] < 0 || SolderesOnTable[i].LoseOcuuredatChiled[0] < 0))
                    No = true;
            }
            else if (Kind == 2)
            {
                ElephantOnTable[i].ElefantThinking[0].TowDistrurbProperUsePreferNotToClose(ref ElephantOnTable[i].LoseOcuuredatChiled, CloneATable(ElephantOnTable[i].ElefantThinking[0].TableListElefant[j]));
                if ((ElephantOnTable[i].ElefantThinking[0].RemoveOfDisturbIndex == j) && (ElephantOnTable[i].ElefantThinking[0].LoseChiled[j] < 0 || ElephantOnTable[i].LoseOcuuredatChiled[0] < 0))
                    No = true;
            }
            else if (Kind == 3)
            {
                HoursesOnTable[i].HourseThinking[0].TowDistrurbProperUsePreferNotToClose(ref HoursesOnTable[i].LoseOcuuredatChiled, CloneATable(HoursesOnTable[i].HourseThinking[0].TableListHourse[j]));
                if ((HoursesOnTable[i].HourseThinking[0].RemoveOfDisturbIndex == j) && (HoursesOnTable[i].HourseThinking[0].LoseChiled[j] < 0 || HoursesOnTable[i].LoseOcuuredatChiled[0] < 0))
                    No = true;

            }
            else if (Kind == 4)
            {
                CastlesOnTable[i].CastleThinking[0].TowDistrurbProperUsePreferNotToClose(ref CastlesOnTable[i].LoseOcuuredatChiled, CloneATable(CastlesOnTable[i].CastleThinking[0].TableListCastle[j]));
                if ((CastlesOnTable[i].CastleThinking[0].RemoveOfDisturbIndex == j) && (CastlesOnTable[i].CastleThinking[0].LoseChiled[j] < 0 || CastlesOnTable[i].LoseOcuuredatChiled[0] < 0))
                    No = true;
            }
            else if (Kind == 5)
            {
                MinisterOnTable[i].MinisterThinking[0].TowDistrurbProperUsePreferNotToClose(ref MinisterOnTable[i].LoseOcuuredatChiled, CloneATable(MinisterOnTable[i].MinisterThinking[0].TableListMinister[j]));
                if ((MinisterOnTable[i].MinisterThinking[0].RemoveOfDisturbIndex == j) && (MinisterOnTable[i].MinisterThinking[0].LoseChiled[j] < 0 || MinisterOnTable[i].LoseOcuuredatChiled[0] < 0))
                    No = true;

            }
            else if (Kind == 6)
            {
                KingOnTable[i].KingThinking[0].TowDistrurbProperUsePreferNotToClose(ref KingOnTable[i].LoseOcuuredatChiled, CloneATable(KingOnTable[i].KingThinking[0].TableListKing[j]));
                if ((KingOnTable[i].KingThinking[0].RemoveOfDisturbIndex == j) && (KingOnTable[i].KingThinking[0].LoseChiled[j] < 0 || KingOnTable[i].LoseOcuuredatChiled[0] < 0))
                    No = true;
            }
            else if (Kind == 7 || Kind == -7)
            {
                CastlingOnTable[i].CastlingThinking[0].TowDistrurbProperUsePreferNotToClose(ref CastlingOnTable[i].LoseOcuuredatChiled, CloneATable(CastlingOnTable[i].CastlingThinking[0].TableListCastling[j]));
                if ((CastlingOnTable[i].CastlingThinking[0].RemoveOfDisturbIndex == j) && (CastlingOnTable[i].CastlingThinking[0].LoseChiled[j] < 0 || CastlingOnTable[i].LoseOcuuredatChiled[0] < 0))
                    No = true;
            }

            return No;
        }

        //Main Initiate Thinking Method.
        public int[,] Initiate(int ii, int jj, Color a, int[,] Table, int Order, bool TB, bool FOUND, int LeafAStarGreedy, bool SetDept = false)
        {

            Object o = new Object();
            lock (o)
            {
                object n = new object();
                lock (n)
                {
                    //due to resource leak of in leak depth
                    StoreInitMaxAStarGreedy = CurrentMaxLevel; MaxAStarGreedy = CurrentMaxLevel;
                    AllDraw.ChangedInTreeOccured = false;

                }
                RefrigtzChessPortable.AllDraw.TimeInitiation = (DateTime.Now.Hour * 60 * 60 * 1000 + DateTime.Now.Minute * 60 * 1000 + DateTime.Now.Second * 1000);

                LeafSemaphoreIndex = false;
                if (tH != null)
                    tH.Clear();
                else
                    tH = new List<Task>();
                if (TH != null)
                    TH.Clear();
                else
                    TH = new List<Task>();
                ThinkingRefrigtzChessPortable.Colleralation = int.MinValue;
                ThinkingRefrigtzChessPortable.DeColleralation = int.MaxValue;
                if (FOUND && (!FirstTraversalTree))
                    NumberOfLeafComputation = ThinkingRefrigtzChessPortable.NumbersOfAllNode;
                else
                    NumberOfLeafComputation = -1;
                ThinkingRefrigtzChessPortable.IsAtLeastOneKillerAtDraw = false;

                //var parallelOptions = new ParallelOptions();
                //parallelOptionsMaxDegreeOfParallelism =System.Threading.PlatformHelper.ProcessorCount; //PlatformHelper.ProcessorCount;
                SetDeptIgnore = SetDept;
                int[,] TableHeuristic = null;
                int Current = ChessRules.CurrentOrder;
                int DummyOrder = Order;
                Object O = new Object();
                lock (O)
                {
                    AllDraw.ActionStringReady = false;
                    ThinkingRefrigtzChessPortable.LearningVarsCheckedMateOccured = false;
                    ThinkingRefrigtzChessPortable.LearningVarsCheckedMateOccuredOneCheckedMate = false;
                    RegardOccurred = false;
                    Object OO21 = new Object();
                    lock (OO21)
                    {
                        TaskBegin = 0;
                        TaskEnd = 0;
                    }
                    Object OO1 = new Object();
                    lock (OO1)
                    {
                        lock (OO1)
                        {
                            if (AllDraw.THIScomboBoxMaxLevelText != "")
                                MaxDuringLevelThinkingCreation = System.Convert.ToInt32(AllDraw.THIScomboBoxMaxLevelText);
                        }
                    }
                    Object Om1 = new Object();
                    lock (Om1)
                    {
                        MinThinkingTreeDepth = 0;
                    }
                    ThinkingRefrigtzChessPortable.FoundFirstMating = 0;
                    ThinkingRefrigtzChessPortable.FoundFirstSelfMating = 0;
                    //Monitor Log File Appending First Line. 
                    Object On = new Object();
                    lock (On)
                    {


                    }
                    //Initiate Local and Global Variables.            
                    Object ol = new Object();
                    lock (ol)
                    {
                        CurrentHeuristic = Int32.MinValue;
                        MaxHeuristicxT = Int32.MinValue;
                        DrawCastle.MaxHeuristicxB = Int32.MinValue;
                        DrawElefant.MaxHeuristicxE = Int32.MinValue;
                        DrawHourse.MaxHeuristicxH = Int32.MinValue;
                        DrawKing.MaxHeuristicxK = Int32.MinValue;
                        DrawMinister.MaxHeuristicxM = Int32.MinValue;
                        DrawSoldier.MaxHeuristicxS = Int32.MinValue;
                        MovementsAStarGreedyHeuristicFoundT = false;
                        DrawTable = false;
                        ChessRules.CheckBrownObjectDangourFirstTimesOcured = false;
                        ChessRules.CheckGrayObjectDangourFirstTimesOcured = false;
                    }
                }
                MaxHeuristicAStarGreedytBackWard.Clear();
                int[,] Tab = null;
                if (!FOUND)
                {
                    Object O7 = new Object();
                    lock (O7)
                    {
                        ThinkingRefrigtzChessPortable.NotSolvedKingDanger = false;
                        LoopHeuristicIndex = 0;
                        Less = Int32.MinValue;
                    }
                }
                //THIS.Invoke((MethodInvoker)delegate()
                /*{
                    Object OOO = new Object();
                    lock (OOO)
                    {
                        if (!SetDept)
                            MaxAStarGreedy = System.Convert.ToInt32(AllDraw.MaxDuringLevelThinkingCreation);
                        AllDraw.AStarGreedyiLevelMax = MaxAStarGreedy;
                        AStarGreedyiLevelMax = System.Convert.ToInt32(AllDraw.MaxDuringLevelThinkingCreation);
                        AllDraw.MaxAStarGreedyHeuristicProgress = 6;
                        for (var i = 0; i <= MaxAStarGreedy; i++)
                            AllDraw.MaxAStarGreedyHeuristicProgress += AllDraw.MaxAStarGreedyHeuristicProgress * 6;
                        increasedProgress = (int)((int)999999999 / (int)(AllDraw.MaxAStarGreedyHeuristicProgress));
                        Object Omm1 = new Object();
                        lock (Omm1)
                        {
                            AStarGreedytMaxCount = (int)MaxAStarGreedy;
                        }
                    }
                }*/
                ChessRules.CurrentOrder = Current;
                Order = DummyOrder;
                int iiii = ii, jjjj = jj, Ord = Order;
                int MaxAStarGreedy1 = 0;
                Object OOOO = new Object();
                lock (OOOO)
                {
                    //if (MaxAStarGreedy == 0)
                    //MaxAStarGreedy = 0; // PlatformHelper.ProcessorCount;
                    MaxAStarGreedy1 = MaxAStarGreedy;
                    int[,] Tabl = CloneATable(Table);
                    Color aaa = a;
                    AllDraw THISA = AStarGreedyString;
                    var H = Task.Factory.StartNew(() => InitiateAStarGreedyt(PlatformHelper.ProcessorCount + AllDraw.StoreInitMaxAStarGreedy - AllDraw.MaxAStarGreedy, iiii, jjjj, aaa, CloneATable(Tabl), Ord, false, FOUND, LeafAStarGreedy));
                    H.Wait();
                    H.Dispose();
                    AStarGreedyString = THISA;
                }
                Object Om = new Object();
                lock (Om)
                {
                    MinThinkingTreeDepth = MaxAStarGreedy - MinThinkingTreeDepth;
                    //Initaite Local Varibales.
                    Tab = new int[8, 8];
                    Less = Int32.MinValue;
                }
                ChessRules.CurrentOrder = Current;
                Order = DummyOrder;
                Object OO = new Object();
                lock (OO)
                {

                }

                NumberOfLeafComputation = -1;

                TableHeuristic = HeuristicAStarGreedySearch(0, a, Order, false);
                if ((TableHeuristic == null || ((TableZero(TableHeuristic)))) && UsePenaltyRegardMechnisamT)
                {

                    Object OOoOO = new Object();
                    lock (OOoOO)
                    {


                        bool aa = UsePenaltyRegardMechnisamT;
                        if (UsePenaltyRegardMechnisamT)
                        {

                            UsePenaltyRegardMechnisamT = false;

                            RemovePenalltyFromFirstBranches(Order);
                            MaxAStarGreedy = 1;
                            AStarGreedyiLevelMax = 1;
                        }
                        Less = Int32.MinValue;


                        AllowedSupTrue = true;

                        TableHeuristic = HeuristicAStarGreedySearch(0, a, Order, false);

                        AllowedSupTrue = false;

                        UsePenaltyRegardMechnisamT = aa;
                    }

                }
                else
                if ((TableHeuristic == null || ((TableZero(TableHeuristic)))))

                    //If Table Found.
                    if (TableHeuristic != null)
                    {
                        Object OOoOO = new Object();
                        lock (OOoOO)
                        {
                            bool aa = UsePenaltyRegardMechnisamT;
                            if (UsePenaltyRegardMechnisamT)
                            {

                                UsePenaltyRegardMechnisamT = false;

                                RemovePenalltyFromFirstBranches(Order);
                                MaxAStarGreedy = 1;
                                AStarGreedyiLevelMax = 1;
                            }
                            Less = Int32.MinValue;


                            AllowedSupTrue = true;

                            TableHeuristic = HeuristicAStarGreedySearch(0, a, Order, false);

                            AllowedSupTrue = false;
                            UsePenaltyRegardMechnisamT = aa;
                        }
                    }
                    else
                    {
                        Object OOoOO = new Object();
                        lock (OOoOO)
                        {
                            //Clear AStarGreedy Varibales.
                            AllDraw.StoreADraw.Clear();
                            TableCurrent.Clear();
                            AStarGreedy = 0;
                        }
                        Order = DummyOrder;
                        ChessRules.CurrentOrder = Current;

                        Object Omm = new Object();
                        lock (Omm)
                        {
                            DrawTable = true;
                            FoundATable = true;
                        }
                    }
                //indexStep++;//no to axelirity speed

                return CloneATable(TableHeuristic);
            }
        }
        //Identification of Illegal AStarGreedy First and Common Hurist Movments.
        public bool IsEnemyThingsinStable(int[,] TableHeuristic, int[,] TableAction, int Order)
        {

            //Iniatiet Local Variables.
            int[,] Cromosom1 = TableHeuristic;
            int[,] Cromosom2 = TableAction;
            bool and = true;
            bool Find = false;

            int FindNumber = 0;
            int
                  CromosomRowFirst = -1, CromosomColumnFirst = -1,
                  CromosomRow = -1, CromosomColumn = -1;
            //Initiate Local Variables.
            //For All Table Home
            for (var i = 0; i < 8; i++)
            {
                for (var j = 0; j < 8; j++)
                {
                    //Gray Order.
                    if (Order == 1)
                    {
                        //Situation 11.
                        if (and)
                        {
                            //All The Brown Object Ignored.
                            if (Cromosom1[i, j] < 0 && Cromosom2[i, j] < 0)
                                continue;
                        }
                        else///Situation 2.
                        {
                            //All The Brown Ojects Ignored.
                            if (Cromosom1[i, j] < 0 || Cromosom2[i, j] < 0)
                                continue;
                        }
                    }
                    else//Brown Order.
                    {
                        //Situation 1.
                        if (and)
                        {
                            //All The Gray Objects Ignored.
                            if (Cromosom1[i, j] > 0 && Cromosom2[i, j] > 0)
                                continue;
                        }
                        else
                        {
                            //All The Gray Objects Ignored.
                            if (Cromosom1[i, j] > 0 || Cromosom2[i, j] > 0)
                                continue;
                        }
                    }
                    if (!(ArrangmentsChanged))
                    {
                        {
                            if (Order == 1 && j == 6 && i > 0 && i < 7)
                            {
                                if (((Cromosom2[i, j + 1] > 0) || (Cromosom2[i + 1, j + 1] > 0 && Cromosom1[i + 1, j + 1] < 0) || (Cromosom2[i - 1, j + 1] > 0 && Cromosom1[i - 1, j + 1] < 0) && Cromosom1[i, j] == 1))
                                {
                                    CromosomRowFirst = i;
                                    CromosomColumnFirst = j;
                                    if (Cromosom2[i, j + 1] > 0)
                                    {
                                        CromosomRow = i;
                                        CromosomColumn = j + 1;
                                    }
                                    else if (Cromosom2[i + 1, j + 1] > 0 && Cromosom1[i + 1, j + 1] < 0)
                                    {
                                        CromosomRow = i + 1;
                                        CromosomColumn = j + 1;
                                    }
                                    else if (Cromosom2[i - 1, j + 1] > 0 && Cromosom1[i - 1, j + 1] < 0)
                                    {
                                        CromosomRow = i - 1;
                                        CromosomColumn = j + 1;
                                    }
                                    Find = true;
                                    FindNumber++;
                                    AllDraw.SodierConversionOcuured = true;
                                }
                            }
                            else
                                if (Order == -1 && j == 1 && i > 0 && i < 7)
                            {
                                if (((Cromosom2[i, j - 1] < 0) || (Cromosom2[i + 1, j - 1] < 0 && Cromosom1[i + 1, j - 1] > 0) || (Cromosom2[i - 1, j - 1] < 0 && Cromosom1[i - 1, j - 1] < 0) && Cromosom1[i, j] == -1))
                                {
                                    CromosomRowFirst = i;
                                    CromosomColumnFirst = j;
                                    if (Cromosom2[i, j - 1] > 0)
                                    {
                                        CromosomRow = i;
                                        CromosomColumn = j - 1;
                                    }
                                    else if (Cromosom2[i + 1, j - 1] > 0 && Cromosom1[i + 1, j - 1] < 0)
                                    {
                                        CromosomRow = i + 1;
                                        CromosomColumn = j - 1;
                                    }
                                    else if (Cromosom2[i - 1, j - 1] > 0 && Cromosom1[i - 1, j - 1] < 0)
                                    {
                                        CromosomRow = i - 1;
                                        CromosomColumn = j - 1;
                                    }
                                    FindNumber++;
                                    AllDraw.SodierConversionOcuured = true;
                                }
                            }
                            //Castles King Validity Condition.
                            if (Order == 1 && j == 0)
                            {
                                //Small Gray Castles King.
                                if (i == 6 && Cromosom2[i, j] == 6 && Cromosom2[i - 1, j] == 4 && Cromosom1[i, j] != 6 && Cromosom1[i - 1, j] != 4)
                                {
                                    CromosomRowFirst = i - 3;
                                    CromosomColumnFirst = j;
                                    CromosomRow = i;
                                    CromosomColumn = j;
                                    Find = true;
                                    FindNumber++;
                                    ChessRules.SmallKingCastleGray = true;
                                    CastlesKing = true;
                                }
                                else //Big Briges King Gray.
                                    if (i == 2 && Cromosom2[i, j] == 6 && Cromosom2[i + 1, j] == 4 && Cromosom1[i, j] != 6 && Cromosom1[i + 1, j] != 4)
                                {
                                    CromosomRowFirst = i + 3;
                                    CromosomColumnFirst = j;
                                    CromosomRow = i;
                                    CromosomColumn = j;
                                    Find = true;
                                    FindNumber++;
                                    ChessRules.BigKingCastleGray = true;
                                    CastlesKing = true;
                                }
                            }
                            else if (j == 7)
                            {
                                //Small Castles King Brown.
                                if (i == 6 && Cromosom2[i, j] == -6 && Cromosom2[i - 1, j] == -4 && Cromosom1[i, j] != -6 && Cromosom1[i - 1, j] != -4)
                                {
                                    CromosomRowFirst = i - 3;
                                    CromosomColumnFirst = j;
                                    CromosomRow = i;
                                    CromosomColumn = j;
                                    Find = true;
                                    FindNumber++;
                                    ChessRules.SmallKingCastleBrown = true;
                                    CastlesKing = true;
                                }
                                else//Big Castles King Brown.
                                    if (i == 2 && Cromosom2[i, j] == -6 && Cromosom2[i + 1, j] == -4 && Cromosom1[i, j] != -6 && Cromosom1[i + 1, j] != -4)
                                {
                                    CromosomRowFirst = i + 3;
                                    CromosomColumnFirst = j;
                                    CromosomRow = i;
                                    CromosomColumn = j;
                                    Find = true;
                                    FindNumber++;
                                    ChessRules.BigKingCastleBrown = true;
                                    CastlesKing = true;
                                }
                            }
                        }
                    }
                    else
                    {
                        {
                            if (Order == 1 && j == 1 && i > 0 && i < 7)
                            {
                                if (((Cromosom2[i, j - 1] > 0) || (Cromosom2[i + 1, j - 1] > 0 && Cromosom1[i + 1, j - 1] < 0) || (Cromosom2[i - 1, j - 1] > 0 && Cromosom1[i - 1, j - 1] < 0) && Cromosom1[i, j] == 1))
                                {
                                    CromosomRowFirst = i;
                                    CromosomColumnFirst = j;
                                    if (Cromosom2[i, j - 1] > 0)
                                    {
                                        CromosomRow = i;
                                        CromosomColumn = j - 1;
                                    }
                                    else if (Cromosom2[i + 1, j - 1] > 0 && Cromosom1[i + 1, j - 1] < 0)
                                    {
                                        CromosomRow = i + 1;
                                        CromosomColumn = j - 1;
                                    }
                                    else if (Cromosom2[i - 1, j - 1] > 0 && Cromosom1[i - 1, j - 1] < 0)
                                    {
                                        CromosomRow = i - 1;
                                        CromosomColumn = j - 1;
                                    }
                                    FindNumber++;
                                    AllDraw.SodierConversionOcuured = true;
                                }
                            }
                            else
                                if (Order == -1 && j == 6 && i > 0 && i < 7)
                            {
                                if (((Cromosom2[i, j + 1] < 0) || (Cromosom2[i + 1, j + 1] < 0 && Cromosom1[i + 1, j + 1] > 0) || (Cromosom2[i - 1, j + 1] < 0 && Cromosom1[i - 1, j + 1] < 0) && Cromosom1[i, j] == -1))
                                {
                                    CromosomRowFirst = i;
                                    CromosomColumnFirst = j;
                                    if (Cromosom2[i, j + 1] > 0)
                                    {
                                        CromosomRow = i;
                                        CromosomColumn = j + 1;
                                    }
                                    else if (Cromosom2[i + 1, j + 1] > 0 && Cromosom1[i + 1, j + 1] < 0)
                                    {
                                        CromosomRow = i + 1;
                                        CromosomColumn = j + 1;
                                    }
                                    else if (Cromosom2[i - 1, j + 1] > 0 && Cromosom1[i - 1, j + 1] < 0)
                                    {
                                        CromosomRow = i - 1;
                                        CromosomColumn = j + 1;
                                    }
                                    Find = true;
                                    FindNumber++;
                                    AllDraw.SodierConversionOcuured = true;
                                }
                            }
                            //Castles King Validity Condition.
                            if (Order == 1 && j == 7)
                            {
                                //Small Gray Castles King.
                                if (i == 6 && Cromosom2[i, j] == 6 && Cromosom2[i - 1, j] == 4 && Cromosom1[i, j] != 6 && Cromosom1[i - 1, j] != 4)
                                {
                                    CromosomRowFirst = i - 3;
                                    CromosomColumnFirst = j;
                                    CromosomRow = i;
                                    CromosomColumn = j;
                                    Find = true;
                                    FindNumber++;
                                    ChessRules.SmallKingCastleGray = true;
                                    CastlesKing = true;
                                }
                                else //Big Briges King Gray.
                                    if (i == 2 && Cromosom2[i, j] == 6 && Cromosom2[i + 1, j] == 4 && Cromosom1[i, j] != 6 && Cromosom1[i + 1, j] != 4)
                                {
                                    CromosomRowFirst = i + 3;
                                    CromosomColumnFirst = j;
                                    CromosomRow = i;
                                    CromosomColumn = j;
                                    Find = true;
                                    FindNumber++;
                                    ChessRules.BigKingCastleGray = true;
                                    CastlesKing = true;
                                }
                            }
                            else if (j == 0)
                            {
                                //Small Castles King Brown.
                                if (i == 6 && Cromosom2[i, j] == -6 && Cromosom2[i - 1, j] == -4 && Cromosom1[i, j] != -6 && Cromosom1[i - 1, j] != -4)
                                {
                                    CromosomRowFirst = i - 3;
                                    CromosomColumnFirst = j;
                                    CromosomRow = i;
                                    CromosomColumn = j;
                                    Find = true;
                                    FindNumber++;
                                    ChessRules.SmallKingCastleBrown = true;
                                    CastlesKing = true;
                                }
                                else//Big Castles King Brown.
                                    if (i == 2 && Cromosom2[i, j] == -6 && Cromosom2[i + 1, j] == -4 && Cromosom1[i, j] != -6 && Cromosom1[i + 1, j] != -4)
                                {
                                    CromosomRowFirst = i + 3;
                                    CromosomColumnFirst = j;
                                    CromosomRow = i;
                                    CromosomColumn = j;
                                    Find = true;
                                    FindNumber++;
                                    ChessRules.BigKingCastleBrown = true;
                                    CastlesKing = true;
                                }
                            }
                        }
                    }
                    //When To Same Location Tbles are Different in Gen.
                    if (Cromosom1[i, j] != Cromosom2[i, j])
                    {
                        //When Cromosom 2 is Empty.
                        if (Cromosom2[i, j] == 0)
                        {
                            //Initiate Location of Table.
                            continue;
                        }
                        else
                        {
                            //Situation 1.0
                            if (and)
                            {
                                //When Cromosom1 Current Location is Empty.
                                if (Cromosom1[i, j] == 0)
                                {
                                    //Initiate Location of Gen.
                                    CromosomRow = i;
                                    CromosomColumn = j;
                                    Find = true;
                                    FindNumber++;
                                    continue;
                                }
                            }
                        }
                        //Store Location of Gen and Calculate Gen Numbers.
                        CromosomRow = i;
                        CromosomColumn = j;
                        Find = true;
                        FindNumber++;
                    }
                }
            }

            //If Gen Foundation is Valid. 
            if (((FindNumber == 1 || FindNumber == 2) && Find) || CastlesKing || AllDraw.SodierConversionOcuured)
                return Find;
            //Gen Not Found.
            return false;
        }
        //web translator monitor strings
        List<int[]> WhereNumbers(String Tag)
        {

            Object OOOO = new Object();
            lock (OOOO)
            {
                List<int[]> TagList = new List<int[]>();
                for (var i = 0; i < Tag.Length; i++)
                {
                    if (i + 1 < Tag.Length)
                    {
                        for (var j = i + 1; j < i + RefrigtzChessPortable.AllDraw.MaxAStarGreedy.ToString().Length + 1; j++)
                        {
                            int A = System.Convert.ToInt32(Tag.Substring(i, j - i));
                            if (A >= 0 && A <= AllDraw.MaxAStarGreedy)
                            {
                                int[] Loc = new int[2];
                                Loc[0] = i;
                                Loc[1] = j - i;
                                TagList.Add(Loc);
                            }


                        }
                    }
                }

                return TagList;
            }
        }
        String CreateHtmlTag(String Tag)
        {

            Object O = new Object();
            lock (O)
            {




                if (Tag.Contains("Thinking"))
                    Tag = Tag.Replace("Thinking", "<font Color=\"Green\">" + "Thinking" + "</font>");
                if (Tag.Contains("Perception"))
                    Tag = Tag.Replace("Perception", "<font Color=\"Green\">" + "Perception" + "</font>");
                if (Tag.Contains("Bob"))
                    Tag = Tag.Replace("Bob", "<font Color=\"Gray\">" + "Bob" + "</font>");
                if (Tag.Contains("Alice"))
                    Tag = Tag.Replace("Alice", "<font Color=\"Brown\">" + "Brown" + "</font>");
                if (Tag.Contains("AstarGreedy "))
                    Tag = Tag.Replace("AstarGreedy ", "<font Color=\"Yellow\">" + "AstarGreedy " + "</font>");
                if (Tag.Contains("Level"))
                    Tag = Tag.Replace("Level", "<font Color=\"Blue\">" + "Level" + "</Font>");

                String R = "<font Color=\"Red\">" + Tag + "</font>";

                return R;
            }
        }
        //recursive base 'pre-proccessing" writing
        public void RewriteAllDrawRec(BinaryFormatter Formatters, FileStream DummyFileStream, int Order)
        {
            Object o = new Object();
            lock (o)
            {

                AllDraw Node = this;

                if (DummyFileStream.Position >= DummyFileStream.Length)
                    return;


                Formatters.Serialize(DummyFileStream, Node.SodierMidle);
                Formatters.Serialize(DummyFileStream, Node.SodierHigh);
                for (int i = 0; i < Node.SodierHigh; i++)
                {
                    if (Node.SolderesOnTable == null)
                        continue;
                    if (Node.SolderesOnTable[i] == null)
                        continue;
                    if (Node.SolderesOnTable[i].SoldierThinking == null)
                        continue;
                    if (Node.SolderesOnTable[i].SoldierThinking[0] == null)
                        continue;
                    if (Node.SolderesOnTable[i].SoldierThinking[0].AStarGreedy.Count == 0)
                        continue;
                    Formatters.Serialize(DummyFileStream, Node.SolderesOnTable[i].SoldierThinking[0].AStarGreedy.Count);
                    for (int j = 0; j < Node.SolderesOnTable[i].SoldierThinking[0].AStarGreedy.Count; j++)
                    {
                        Formatters.Serialize(DummyFileStream, Node.SolderesOnTable[i].SoldierThinking[0].AStarGreedy[j]);
                        Node.SolderesOnTable[i].SoldierThinking[0].AStarGreedy[j].RewriteAllDrawRec(Formatters, DummyFileStream, Order * -1);
                    }
                }
                Formatters.Serialize(DummyFileStream, Node.ElefantMidle);
                Formatters.Serialize(DummyFileStream, Node.ElefantHigh);
                for (int i = 0; i < Node.ElefantHigh; i++)
                {
                    if (Node.ElephantOnTable == null)
                        continue;
                    if (Node.ElephantOnTable[i] == null)
                        continue;
                    if (Node.ElephantOnTable[i].ElefantThinking == null)
                        continue;
                    if (Node.ElephantOnTable[i].ElefantThinking[0] == null)
                        continue;
                    if (Node.ElephantOnTable[i].ElefantThinking[0].AStarGreedy.Count == 0)
                        continue;
                    Formatters.Serialize(DummyFileStream, Node.ElephantOnTable[i].ElefantThinking[0].AStarGreedy.Count);
                    for (int j = 0; j < Node.ElephantOnTable[i].ElefantThinking[0].AStarGreedy.Count; j++)
                    {
                        Formatters.Serialize(DummyFileStream, Node.ElephantOnTable[i].ElefantThinking[0].AStarGreedy[j]);
                        Node.ElephantOnTable[i].ElefantThinking[0].AStarGreedy[j].RewriteAllDrawRec(Formatters, DummyFileStream, Order * -1);
                    }
                }
                Formatters.Serialize(DummyFileStream, Node.HourseMidle);
                Formatters.Serialize(DummyFileStream, Node.HourseHight);
                for (int i = 0; i < Node.HourseHight; i++)
                {
                    if (Node.HoursesOnTable == null)
                        continue;
                    if (Node.HoursesOnTable[i] == null)
                        continue;
                    if (Node.HoursesOnTable[i].HourseThinking == null)
                        continue;
                    if (Node.HoursesOnTable[i].HourseThinking[0] == null)
                        continue;
                    if (Node.HoursesOnTable[i].HourseThinking[0].AStarGreedy.Count == 0)
                        continue;
                    Formatters.Serialize(DummyFileStream, Node.HoursesOnTable[i].HourseThinking[0].AStarGreedy.Count);
                    for (int j = 0; j < Node.HoursesOnTable[i].HourseThinking[0].AStarGreedy.Count; j++)
                    {
                        Formatters.Serialize(DummyFileStream, Node.HoursesOnTable[i].HourseThinking[0].AStarGreedy[j]);
                        Node.HoursesOnTable[i].HourseThinking[0].AStarGreedy[j].RewriteAllDrawRec(Formatters, DummyFileStream, Order * -1);
                    }
                }
                Formatters.Serialize(DummyFileStream, Node.CastleMidle);
                Formatters.Serialize(DummyFileStream, Node.CastleHigh);
                for (int i = 0; i < Node.CastleHigh; i++)
                {
                    if (Node.CastlesOnTable == null)
                        continue;
                    if (Node.CastlesOnTable[i] == null)
                        continue;
                    if (Node.CastlesOnTable[i].CastleThinking == null)
                        continue;
                    if (Node.CastlesOnTable[i].CastleThinking[0] == null)
                        continue;
                    if (Node.CastlesOnTable[i].CastleThinking[0].AStarGreedy.Count == 0)
                        continue;
                    Formatters.Serialize(DummyFileStream, Node.CastlesOnTable[i].CastleThinking[0].AStarGreedy.Count);
                    for (int j = 0; j < Node.CastlesOnTable[i].CastleThinking[0].AStarGreedy.Count; j++)
                    {
                        Formatters.Serialize(DummyFileStream, Node.CastlesOnTable[i].CastleThinking[0].AStarGreedy[j]);
                        Node.CastlesOnTable[i].CastleThinking[0].AStarGreedy[j].RewriteAllDrawRec(Formatters, DummyFileStream, Order * -1);
                    }
                }
                Formatters.Serialize(DummyFileStream, Node.MinisterMidle);
                Formatters.Serialize(DummyFileStream, Node.MinisterHigh);
                for (int i = 0; i < Node.MinisterHigh; i++)
                {
                    if (Node.MinisterOnTable == null)
                        continue;
                    if (Node.MinisterOnTable[i] == null)
                        continue;
                    if (Node.MinisterOnTable[i].MinisterThinking == null)
                        continue;
                    if (Node.MinisterOnTable[i].MinisterThinking[0] == null)
                        continue;
                    if (Node.MinisterOnTable[i].MinisterThinking[0].AStarGreedy.Count == 0)
                        continue;
                    Formatters.Serialize(DummyFileStream, Node.MinisterOnTable[i].MinisterThinking[0].AStarGreedy.Count);
                    for (int j = 0; j < Node.MinisterOnTable[i].MinisterThinking[0].AStarGreedy.Count; j++)
                    {
                        Formatters.Serialize(DummyFileStream, Node.MinisterOnTable[i].MinisterThinking[0].AStarGreedy[j]);
                        Node.MinisterOnTable[i].MinisterThinking[0].AStarGreedy[j].RewriteAllDrawRec(Formatters, DummyFileStream, Order * -1);
                    }
                }
                Formatters.Serialize(DummyFileStream, Node.KingMidle);
                Formatters.Serialize(DummyFileStream, Node.KingHigh);
                for (int i = 0; i < Node.KingHigh; i++)
                {
                    if (Node.KingOnTable == null)
                        continue;
                    if (Node.KingOnTable[i] == null)
                        continue;
                    if (Node.KingOnTable[i].KingThinking == null)
                        continue;
                    if (Node.KingOnTable[i].KingThinking[0] == null)
                        continue;
                    if (Node.KingOnTable[i].KingThinking[0] == null)
                        continue;
                    if (Node.KingOnTable[i].KingThinking[0].AStarGreedy.Count == 0)
                        continue;
                    Formatters.Serialize(DummyFileStream, Node.KingOnTable[i].KingThinking[0].AStarGreedy.Count);
                    for (int j = 0; j < Node.KingOnTable[i].KingThinking[0].AStarGreedy.Count; j++)
                    {
                        Formatters.Serialize(DummyFileStream, Node.KingOnTable[i].KingThinking[0].AStarGreedy[j]);
                        Node.KingOnTable[i].KingThinking[0].AStarGreedy[j].RewriteAllDrawRec(Formatters, DummyFileStream, Order * -1);
                    }
                }
                for (int i = 0; i < 1; i++)
                {
                    if (Node.CastlingOnTable == null)
                        continue;
                    if (Node.CastlingOnTable[i] == null)
                        continue;
                    if (Node.CastlingOnTable[i].CastlingThinking == null)
                        continue;
                    if (Node.CastlingOnTable[i].CastlingThinking[0] == null)
                        continue;
                    if (Node.CastlingOnTable[i].CastlingThinking[0] == null)
                        continue;
                    if (Node.CastlingOnTable[i].CastlingThinking[0].AStarGreedy.Count == 0)
                        continue;
                    Formatters.Serialize(DummyFileStream, Node.CastlingOnTable[i].CastlingThinking[0].AStarGreedy.Count);
                    for (int j = 0; j < Node.CastlingOnTable[i].CastlingThinking[0].AStarGreedy.Count; j++)
                    {
                        Formatters.Serialize(DummyFileStream, Node.CastlingOnTable[i].CastlingThinking[0].AStarGreedy[j]);
                        Node.CastlingOnTable[i].CastlingThinking[0].AStarGreedy[j].RewriteAllDrawRec(Formatters, DummyFileStream, Order * -1);
                    }
                }
            }
        }
        //loads recursive depend of orderic of writing "pre-proccessing" 
        public AllDraw LoaderEC(bool Quantum, int Order, FileStream DummyFileStream, BinaryFormatter Formatters)
        {
            Object o = new Object();
            lock (o)
            {

                AllDraw Node = this;
                if (DummyFileStream.Position >= DummyFileStream.Length)
                    return Node;


                Node.SodierMidle = (Int32)Formatters.Deserialize(DummyFileStream);
                Node.SodierHigh = (Int32)Formatters.Deserialize(DummyFileStream);
                for (int i = 0; i < Node.SodierHigh; i++)
                {
                    if (Node.SolderesOnTable == null)
                        continue;
                    if (Node.SolderesOnTable[i] == null)
                        continue;
                    if (Node.SolderesOnTable[i].SoldierThinking == null)
                        continue;
                    if (Node.SolderesOnTable[i].SoldierThinking[0] == null)
                        continue;
                    if (Node.SolderesOnTable[i].SoldierThinking[0].AStarGreedy.Count == 0)
                        continue;
                    int count = (Int32)Formatters.Deserialize(DummyFileStream);
                    Node.SolderesOnTable[i].SoldierThinking[0].AStarGreedy.Clear();
                    for (int j = 0; j < count; j++)
                    {
                        if (DummyFileStream.Position < DummyFileStream.Length)
                        {
                            Node.SolderesOnTable[i].SoldierThinking[0].AStarGreedy.Add((AllDraw)Formatters.Deserialize(DummyFileStream));
                            Node.SolderesOnTable[i].SoldierThinking[0].AStarGreedy[j].LoaderEC(Quantum, Order * -1, DummyFileStream, Formatters);
                            Node.SolderesOnTable[i].SoldierThinking[0].AStarGreedy[j].AStarGreedyString = Node;
                        }
                    }
                }
                Node.ElefantMidle = (Int32)Formatters.Deserialize(DummyFileStream);
                Node.ElefantHigh = (Int32)Formatters.Deserialize(DummyFileStream);
                for (int i = 0; i < Node.ElefantHigh; i++)
                {
                    if (Node.ElephantOnTable == null)
                        continue;
                    if (Node.ElephantOnTable[i] == null)
                        continue;
                    if (Node.ElephantOnTable[i].ElefantThinking == null)
                        continue;
                    if (Node.ElephantOnTable[i].ElefantThinking[0] == null)
                        continue;
                    if (Node.ElephantOnTable[i].ElefantThinking[0].AStarGreedy.Count == 0)
                        continue;
                    int count = (Int32)Formatters.Deserialize(DummyFileStream);
                    Node.ElephantOnTable[i].ElefantThinking[0].AStarGreedy.Clear();
                    for (int j = 0; j < count; j++)
                    {
                        if (DummyFileStream.Position < DummyFileStream.Length)
                        {
                            Node.ElephantOnTable[i].ElefantThinking[0].AStarGreedy.Add((AllDraw)Formatters.Deserialize(DummyFileStream));
                            Node.ElephantOnTable[i].ElefantThinking[0].AStarGreedy[j].LoaderEC(Quantum, Order * -1, DummyFileStream, Formatters);
                            Node.ElephantOnTable[i].ElefantThinking[0].AStarGreedy[j].AStarGreedyString = Node;
                        }
                    }
                }
                Node.HourseMidle = (Int32)Formatters.Deserialize(DummyFileStream);
                Node.HourseHight = (Int32)Formatters.Deserialize(DummyFileStream);
                for (int i = 0; i < Node.HourseHight; i++)
                {
                    if (Node.HoursesOnTable == null)
                        continue;
                    if (Node.HoursesOnTable[i] == null)
                        continue;
                    if (Node.HoursesOnTable[i].HourseThinking == null)
                        continue;
                    if (Node.HoursesOnTable[i].HourseThinking[0] == null)
                        continue;
                    if (Node.HoursesOnTable[i].HourseThinking[0].AStarGreedy.Count == 0)
                        continue;
                    int count = (Int32)Formatters.Deserialize(DummyFileStream);
                    Node.HoursesOnTable[i].HourseThinking[0].AStarGreedy.Clear();
                    for (int j = 0; j < count; j++)
                    {
                        if (DummyFileStream.Position < DummyFileStream.Length)
                        {
                            Node.HoursesOnTable[i].HourseThinking[0].AStarGreedy.Add((AllDraw)Formatters.Deserialize(DummyFileStream));
                            Node.HoursesOnTable[i].HourseThinking[0].AStarGreedy[j].LoaderEC(Quantum, Order * -1, DummyFileStream, Formatters);
                            Node.HoursesOnTable[i].HourseThinking[0].AStarGreedy[j].AStarGreedyString = Node;
                        }
                    }
                }
                Node.CastleMidle = (Int32)Formatters.Deserialize(DummyFileStream);
                Node.CastleHigh = (Int32)Formatters.Deserialize(DummyFileStream);
                for (int i = 0; i < Node.CastleHigh; i++)
                {
                    if (Node.CastlesOnTable == null)
                        continue;
                    if (Node.CastlesOnTable[i] == null)
                        continue;
                    if (Node.CastlesOnTable[i].CastleThinking == null)
                        continue;
                    if (Node.CastlesOnTable[i].CastleThinking[0] == null)
                        continue;
                    if (Node.CastlesOnTable[i].CastleThinking[0].AStarGreedy.Count == 0)
                        continue;
                    int count = (Int32)Formatters.Deserialize(DummyFileStream);
                    Node.CastlesOnTable[i].CastleThinking[0].AStarGreedy.Clear();
                    for (int j = 0; j < count; j++)
                    {
                        if (DummyFileStream.Position < DummyFileStream.Length)
                        {
                            Node.CastlesOnTable[i].CastleThinking[0].AStarGreedy.Add((AllDraw)Formatters.Deserialize(DummyFileStream));
                            Node.CastlesOnTable[i].CastleThinking[0].AStarGreedy[j].LoaderEC(Quantum, Order * -1, DummyFileStream, Formatters);
                            Node.CastlesOnTable[i].CastleThinking[0].AStarGreedy[j].AStarGreedyString = Node;
                        }
                    }
                }
                Node.MinisterMidle = (Int32)Formatters.Deserialize(DummyFileStream);
                Node.MinisterHigh = (Int32)Formatters.Deserialize(DummyFileStream);
                for (int i = 0; i < Node.MinisterHigh; i++)
                {
                    if (Node.MinisterOnTable == null)
                        continue;
                    if (Node.MinisterOnTable[i] == null)
                        continue;
                    if (Node.MinisterOnTable[i].MinisterThinking == null)
                        continue;
                    if (Node.MinisterOnTable[i].MinisterThinking[0] == null)
                        continue;
                    if (Node.MinisterOnTable[i].MinisterThinking[0].AStarGreedy.Count == 0)
                        continue;
                    int count = (Int32)Formatters.Deserialize(DummyFileStream);
                    Node.MinisterOnTable[i].MinisterThinking[0].AStarGreedy.Clear();
                    for (int j = 0; j < count; j++)
                    {
                        if (DummyFileStream.Position < DummyFileStream.Length)
                        {
                            Node.MinisterOnTable[i].MinisterThinking[0].AStarGreedy.Add((AllDraw)Formatters.Deserialize(DummyFileStream));
                            Node.MinisterOnTable[i].MinisterThinking[0].AStarGreedy[j].LoaderEC(Quantum, Order * -1, DummyFileStream, Formatters);
                            Node.MinisterOnTable[i].MinisterThinking[0].AStarGreedy[j].AStarGreedyString = Node;
                        }
                    }
                }
                Node.KingMidle = (Int32)Formatters.Deserialize(DummyFileStream);
                Node.KingHigh = (Int32)Formatters.Deserialize(DummyFileStream);
                for (int i = 0; i < Node.KingHigh; i++)
                {
                    if (Node.KingOnTable == null)
                        continue;
                    if (Node.KingOnTable[i] == null)
                        continue;
                    if (Node.KingOnTable[i].KingThinking == null)
                        continue;
                    if (Node.KingOnTable[i].KingThinking[0] == null)
                        continue;
                    if (Node.KingOnTable[i].KingThinking[0] == null)
                        continue;
                    if (Node.KingOnTable[i].KingThinking[0].AStarGreedy.Count == 0)
                        continue;
                    int count = (Int32)Formatters.Deserialize(DummyFileStream);
                    Node.KingOnTable[i].KingThinking[0].AStarGreedy.Clear();
                    for (int j = 0; j < count; j++)
                    {
                        if (DummyFileStream.Position < DummyFileStream.Length)
                        {
                            Node.KingOnTable[i].KingThinking[0].AStarGreedy.Add((AllDraw)Formatters.Deserialize(DummyFileStream));
                            Node.KingOnTable[i].KingThinking[0].AStarGreedy[j].LoaderEC(Quantum, Order * -1, DummyFileStream, Formatters);
                            Node.KingOnTable[i].KingThinking[0].AStarGreedy[j].AStarGreedyString = Node;
                        }
                    }
                }
                for (int i = 0; i < 1; i++)
                {
                    if (Node.CastlingOnTable == null)
                        continue;
                    if (Node.CastlingOnTable[i] == null)
                        continue;
                    if (Node.CastlingOnTable[i].CastlingThinking == null)
                        continue;
                    if (Node.CastlingOnTable[i].CastlingThinking[0] == null)
                        continue;
                    if (Node.CastlingOnTable[i].CastlingThinking[0] == null)
                        continue;
                    if (Node.CastlingOnTable[i].CastlingThinking[0].AStarGreedy.Count == 0)
                        continue;
                    int count = (Int32)Formatters.Deserialize(DummyFileStream);
                    Node.CastlingOnTable[i].CastlingThinking[0].AStarGreedy.Clear();
                    for (int j = 0; j < count; j++)
                    {
                        if (DummyFileStream.Position < DummyFileStream.Length)
                        {
                            Node.CastlingOnTable[i].CastlingThinking[0].AStarGreedy.Add((AllDraw)Formatters.Deserialize(DummyFileStream));
                            Node.CastlingOnTable[i].CastlingThinking[0].AStarGreedy[j].LoaderEC(Quantum, Order * -1, DummyFileStream, Formatters);
                            Node.CastlingOnTable[i].CastlingThinking[0].AStarGreedy[j].AStarGreedyString = Node;
                        }
                    }
                }
                //  if (!Act)




                return Node;

            }
        }
        bool UpdateLoseAndWinDepenOfKindBoundryCondition(int kind, int i, int j)
        {

            if (kind == 1)
            {
                if (SolderesOnTable == null)
                    return false;
                if (SolderesOnTable[i] == null)
                    return false;
                if (SolderesOnTable[i].SoldierThinking[0] == null)
                    return false;
                if (SolderesOnTable[i].SoldierThinking[0].TableListSolder == null)
                    return false;
            }
            else
            if (kind == 2)
            {
                if (ElephantOnTable == null)
                    return false;
                if (ElephantOnTable[i] == null)
                    return false;
                if (ElephantOnTable[i].ElefantThinking[0] == null)
                    return false;
                if (ElephantOnTable[i].ElefantThinking[0].TableListElefant == null)
                    return false;
            }
            else
            if (kind == 3)
            {
                if (HoursesOnTable == null)
                    return false;
                if (HoursesOnTable[i] == null)
                    return false;
                if (HoursesOnTable[i].HourseThinking[0] == null)
                    return false;
                if (HoursesOnTable[i].HourseThinking[0].TableListHourse == null)
                    return false;
            }
            else
            if (kind == 4)
            {
                if (CastlesOnTable == null)
                    return false;
                if (CastlesOnTable[i] == null)
                    return false;
                if (CastlesOnTable[i].CastleThinking[0] == null)
                    return false;
                if (CastlesOnTable[i].CastleThinking[0].TableListCastle == null)
                    return false;
            }
            else
            if (kind == 5)
            {
                if (MinisterOnTable == null)
                    return false;
                if (MinisterOnTable[i] == null)
                    return false;
                if (MinisterOnTable[i].MinisterThinking[0] == null)
                    return false;
                if (MinisterOnTable[i].MinisterThinking[0].TableListMinister == null)
                    return false;
            }
            else
            if (kind == 6)
            {
                if (KingOnTable == null)
                    return false;
                if (KingOnTable[i] == null)
                    return false;
                if (KingOnTable[i].KingThinking[0] == null)
                    return false;
                if (KingOnTable[i].KingThinking[0].TableListKing == null)
                    return false;
            }
            else
            if (kind == 7 || kind == -7)
            {
                if (CastlingOnTable == null)
                    return false;
                if (CastlingOnTable[i] == null)
                    return false;
                if (CastlingOnTable[i].CastlingThinking[0] == null)
                    return false;
                if (CastlingOnTable[i].CastlingThinking[0].TableListCastling == null)
                    return false;
            }
            return true;
        }
        public void UpdateLoseAndWinDepenOfKindSoldier(int i, int Order)
        {
            Object a = new Object();
            lock (a)
            {
                //when found return recursive
                for (var j = 0; UpdateLoseAndWinDepenOfKindBoundryCondition(1, i, j) && j < SolderesOnTable[i].SoldierThinking[0].TableListSolder.Count; j++)
                {
                    if (IsSupHuTrue(i, j, 0, 1))
                        continue;

                    //deeper
                    for (var ii = 0; ii < SolderesOnTable[i].SoldierThinking[0].AStarGreedy.Count; ii++)
                        SolderesOnTable[i].SoldierThinking[0].AStarGreedy[ii].UpdateLoseAndWinDepenOfKind(Order * -1);
                    if (SolderesOnTable[i].WinOcuuredatChiled == 0)
                    {    //non learning autamata victory leafs
                        for (int h = 0; h < SolderesOnTable[i].SoldierThinking[0].AStarGreedy.Count && SolderesOnTable[i].SoldierThinking[0].AStarGreedy != null; h++)
                            SolderesOnTable[i].WinOcuuredatChiled += SumOfObjects(SolderesOnTable[i].SoldierThinking[0].AStarGreedy[h], Order * -1);
                    }
                    if (SolderesOnTable[i].LoseOcuuredatChiled[0] == 0)
                    {   //non learning autamata victom leafs
                        for (int h = 0; h < SolderesOnTable[i].SoldierThinking[0].AStarGreedy.Count && SolderesOnTable[i].SoldierThinking[0].AStarGreedy != null; h++)
                            SolderesOnTable[i].LoseOcuuredatChiled[0] += SumMinusOfObjects(SolderesOnTable[i].SoldierThinking[0].AStarGreedy[h], Order * -1);
                    }
                }
            }
        }
        public void UpdateLoseAndWinDepenOfKindElephant(int i, int Order)
        {
            Object a = new Object();
            lock (a)
            {
                //when found return recursive
                for (var j = 0; UpdateLoseAndWinDepenOfKindBoundryCondition(2, i, j) && j < ElephantOnTable[i].ElefantThinking[0].TableListElefant.Count; j++)
                {
                    if (IsSupHuTrue(i, j, 0, 2))
                        continue;
                    //deeper
                    for (var ii = 0; ii < ElephantOnTable[i].ElefantThinking[0].AStarGreedy.Count; ii++)
                        ElephantOnTable[i].ElefantThinking[0].AStarGreedy[ii].UpdateLoseAndWinDepenOfKind(Order * -1);
                    if (ElephantOnTable[i].WinOcuuredatChiled == 0)
                    {    //non learning autamata victory leafs
                        for (int h = 0; h < ElephantOnTable[i].ElefantThinking[0].AStarGreedy.Count && ElephantOnTable[i].ElefantThinking[0].AStarGreedy != null; h++)
                            ElephantOnTable[i].WinOcuuredatChiled += SumOfObjects(ElephantOnTable[i].ElefantThinking[0].AStarGreedy[h], Order * -1);
                    }
                    if (ElephantOnTable[i].LoseOcuuredatChiled[0] == 0)
                    {   //non learning autamata victom leafs
                        for (int h = 0; h < ElephantOnTable[i].ElefantThinking[0].AStarGreedy.Count && ElephantOnTable[i].ElefantThinking[0].AStarGreedy != null; h++)
                            ElephantOnTable[i].LoseOcuuredatChiled[0] += SumMinusOfObjects(ElephantOnTable[i].ElefantThinking[0].AStarGreedy[h], Order * -1);
                    }
                }
            }
        }
        public void UpdateLoseAndWinDepenOfKindHourse(int i, int Order)
        {
            Object a = new Object();
            lock (a)
            {
                //when found return recursive
                for (var j = 0; UpdateLoseAndWinDepenOfKindBoundryCondition(3, i, j) && j < HoursesOnTable[i].HourseThinking[0].TableListHourse.Count; j++)
                {
                    if (IsSupHuTrue(i, j, 0, 3))
                        continue;
                    //deeper
                    for (var ii = 0; ii < HoursesOnTable[i].HourseThinking[0].AStarGreedy.Count; ii++)
                        HoursesOnTable[i].HourseThinking[0].AStarGreedy[ii].UpdateLoseAndWinDepenOfKind(Order * -1);
                    if (HoursesOnTable[i].WinOcuuredatChiled == 0)
                    {   //non learning autamata victory leafs
                        for (int h = 0; h < HoursesOnTable[i].HourseThinking[0].AStarGreedy.Count && HoursesOnTable[i].HourseThinking[0].AStarGreedy != null; h++)
                            HoursesOnTable[i].WinOcuuredatChiled += SumOfObjects(HoursesOnTable[i].HourseThinking[0].AStarGreedy[h], Order * -1);
                    }
                    if (HoursesOnTable[i].LoseOcuuredatChiled[0] == 0)
                    {   //non learning autamata victom leafs
                        for (int h = 0; h < HoursesOnTable[i].HourseThinking[0].AStarGreedy.Count && HoursesOnTable[i].HourseThinking[0].AStarGreedy != null; h++)
                            HoursesOnTable[i].LoseOcuuredatChiled[0] += SumMinusOfObjects(HoursesOnTable[i].HourseThinking[0].AStarGreedy[h], Order * -1);
                    }
                }

            }
        }
        public void UpdateLoseAndWinDepenOfKindCastle(int i, int Order)
        {
            Object a = new Object();
            lock (a)
            {
                //when found return recursive
                for (var j = 0; UpdateLoseAndWinDepenOfKindBoundryCondition(4, i, j) && j < CastlesOnTable[i].CastleThinking[0].TableListCastle.Count; j++)
                {
                    if (IsSupHuTrue(i, j, 0, 4))
                        continue;

                    //deeper
                    for (var ii = 0; ii < CastlesOnTable[i].CastleThinking[0].AStarGreedy.Count; ii++)
                        CastlesOnTable[i].CastleThinking[0].AStarGreedy[ii].UpdateLoseAndWinDepenOfKind(Order * -1);
                    if (CastlesOnTable[i].WinOcuuredatChiled == 0)
                    { //non learning autamata victory leafs
                        for (int h = 0; h < CastlesOnTable[i].CastleThinking[0].AStarGreedy.Count && CastlesOnTable[i].CastleThinking[0].AStarGreedy != null; h++)
                            CastlesOnTable[i].WinOcuuredatChiled += SumOfObjects(CastlesOnTable[i].CastleThinking[0].AStarGreedy[h], Order * -1);
                    }
                    if (CastlesOnTable[i].LoseOcuuredatChiled[0] == 0)
                    {
                        for (int h = 0; h < CastlesOnTable[i].CastleThinking[0].AStarGreedy.Count && CastlesOnTable[i].CastleThinking[0].AStarGreedy != null; h++)
                            CastlesOnTable[i].LoseOcuuredatChiled[0] += SumMinusOfObjects(CastlesOnTable[i].CastleThinking[0].AStarGreedy[h], Order * -1);
                    }
                }
            }
        }
        public void UpdateLoseAndWinDepenOfKindMinister(int i, int Order)
        {
            Object a = new Object();
            lock (a)
            {
                //when found return recursive
                for (var j = 0; UpdateLoseAndWinDepenOfKindBoundryCondition(5, i, j) && j < MinisterOnTable[i].MinisterThinking[0].TableListMinister.Count; j++)
                {
                    if (IsSupHuTrue(i, j, 0, 5))
                        continue;
                    //deeper
                    for (var ii = 0; ii < MinisterOnTable[i].MinisterThinking[0].AStarGreedy.Count; ii++)
                        MinisterOnTable[i].MinisterThinking[0].AStarGreedy[ii].UpdateLoseAndWinDepenOfKind(Order * -1);
                    if (MinisterOnTable[i].WinOcuuredatChiled == 0)
                    {  //non learning autamata victory leafs
                        for (int h = 0; h < MinisterOnTable[i].MinisterThinking[0].AStarGreedy.Count && MinisterOnTable[i].MinisterThinking[0].AStarGreedy != null; h++)
                            MinisterOnTable[i].WinOcuuredatChiled += SumOfObjects(MinisterOnTable[i].MinisterThinking[0].AStarGreedy[h], Order * -1);
                    }
                    if (MinisterOnTable[i].LoseOcuuredatChiled[0] == 0)
                    {   //non learning autamata victom leafs
                        for (int h = 0; h < MinisterOnTable[i].MinisterThinking[0].AStarGreedy.Count && MinisterOnTable[i].MinisterThinking[0].AStarGreedy != null; h++)
                            MinisterOnTable[i].LoseOcuuredatChiled[0] += SumMinusOfObjects(MinisterOnTable[i].MinisterThinking[0].AStarGreedy[h], Order * -1);
                    }
                }
            }
        }
        public void UpdateLoseAndWinDepenOfKindKing(int i, int Order)
        {
            Object a = new Object();
            lock (a)
            {
                //when found return recursive
                for (var j = 0; UpdateLoseAndWinDepenOfKindBoundryCondition(6, i, j) && j < KingOnTable[i].KingThinking[0].TableListKing.Count; j++)
                {
                    if (IsSupHuTrue(i, j, 0, 6))
                        continue;
                    //deeper
                    for (var ii = 0; ii < KingOnTable[i].KingThinking[0].AStarGreedy.Count; ii++)
                        KingOnTable[i].KingThinking[0].AStarGreedy[ii].UpdateLoseAndWinDepenOfKind(Order * -1);
                    if (KingOnTable[i].WinOcuuredatChiled == 0)
                    {
                        //non learning autamata victory leafs
                        for (int h = 0; h < KingOnTable[i].KingThinking[0].AStarGreedy.Count && KingOnTable[i].KingThinking[0].AStarGreedy != null; h++)
                            KingOnTable[i].WinOcuuredatChiled += SumOfObjects(KingOnTable[i].KingThinking[0].AStarGreedy[h], Order * -1);
                    }
                    if (KingOnTable[i].LoseOcuuredatChiled[0] == 0)
                    {   //non learning autamata victom leafs
                        for (int h = 0; h < KingOnTable[i].KingThinking[0].AStarGreedy.Count && KingOnTable[i].KingThinking[0].AStarGreedy != null; h++)
                            KingOnTable[i].LoseOcuuredatChiled[0] += SumMinusOfObjects(KingOnTable[i].KingThinking[0].AStarGreedy[h], Order * -1);
                    }
                }
            }
        }
        public void UpdateLoseAndWinDepenOfKindCastling(int i, int Order)
        {
            Object a = new Object();
            lock (a)
            {
                //when found return recursive
                for (var j = 0; UpdateLoseAndWinDepenOfKindBoundryCondition(7, i, j) && j < CastlingOnTable[i].CastlingThinking[0].TableListCastling.Count; j++)
                {
                    if (IsSupHuTrue(i, j, 0, 7))
                        continue;
                    //deeper
                    for (var ii = 0; ii < CastlingOnTable[i].CastlingThinking[0].AStarGreedy.Count; ii++)
                        CastlingOnTable[i].CastlingThinking[0].AStarGreedy[ii].UpdateLoseAndWinDepenOfKind(Order * -1);
                    if (CastlingOnTable[i].WinOcuuredatChiled == 0)
                    {
                        //non learning autamata victory leafs
                        for (int h = 0; h < CastlingOnTable[i].CastlingThinking[0].AStarGreedy.Count && CastlingOnTable[i].CastlingThinking[0].AStarGreedy != null; h++)
                            CastlingOnTable[i].WinOcuuredatChiled += SumOfObjects(CastlingOnTable[i].CastlingThinking[0].AStarGreedy[h], Order * -1);
                    }
                    if (CastlingOnTable[i].LoseOcuuredatChiled[0] == 0)
                    {   //non learning autamata victom leafs
                        for (int h = 0; h < CastlingOnTable[i].CastlingThinking[0].AStarGreedy.Count && CastlingOnTable[i].CastlingThinking[0].AStarGreedy != null; h++)
                            CastlingOnTable[i].LoseOcuuredatChiled[0] += SumMinusOfObjects(CastlingOnTable[i].CastlingThinking[0].AStarGreedy[h], Order * -1);
                    }
                }
            }
        }
        //found of leadfs of created tree depend of orderic 
        public void UpdateLoseAndWinDepenOfKind(int Order)
        {
            Object a = new Object();
            lock (a)
            {
                //when found return recursive
                //Gray
                if (Order == 1)
                {
                    for (var i = 0; i < SodierMidle; i++)
                    {
                        UpdateLoseAndWinDepenOfKindSoldier(i, Order);
                    }
                    for (var i = 0; i < ElefantMidle; i++)
                    {
                        UpdateLoseAndWinDepenOfKindElephant(i, Order);
                    }
                    for (var i = 0; i < HourseMidle; i++)
                    {
                        UpdateLoseAndWinDepenOfKindHourse(i, Order);
                    }
                    for (var i = 0; i < CastleMidle; i++)
                    {
                        UpdateLoseAndWinDepenOfKindCastle(i, Order);
                    }
                    for (var i = 0; i < MinisterMidle; i++)
                    {
                        UpdateLoseAndWinDepenOfKindMinister(i, Order);
                    }
                    for (var i = 0; i < KingMidle; i++)
                    {
                        UpdateLoseAndWinDepenOfKindKing(i, Order);
                    }
                    for (var i = 0; i < 1; i++)
                    {
                        UpdateLoseAndWinDepenOfKindCastling(i, Order);
                    }
                }
                else
                {
                    for (var i = SodierMidle; i < SodierHigh; i++)
                    {
                        UpdateLoseAndWinDepenOfKindSoldier(i, Order);
                    }
                    for (var i = ElefantMidle; i < ElefantHigh; i++)
                    {
                        UpdateLoseAndWinDepenOfKindElephant(i, Order);
                    }
                    for (var i = HourseMidle; i < HourseHight; i++)
                    {
                        UpdateLoseAndWinDepenOfKindHourse(i, Order);
                    }
                    for (var i = CastleMidle; i < CastleHigh; i++)
                    {
                        UpdateLoseAndWinDepenOfKindCastle(i, Order);
                    }
                    for (var i = MinisterMidle; i < MinisterHigh; i++)
                    {
                        UpdateLoseAndWinDepenOfKindMinister(i, Order);
                    }
                    for (var i = KingMidle; i < KingHigh; i++)
                    {
                        UpdateLoseAndWinDepenOfKindKing(i, Order);
                    }
                    for (var i = 0; i < 1; i++)
                    {
                        UpdateLoseAndWinDepenOfKindCastling(i, Order);
                    }
                }
            }
        }
        bool IsMovableLoseOcuuredatChiled(int[,] Tab, int Kind, int Order, int i)
        {
            bool Is = false;
            if (Kind == 1)
            {
                if (ServeBoundryConditionsSoldier(i, Kind, Order))
                    return false;
                if (SolderesOnTable[i].LoseOcuuredatChiled[0] == 5)
                {
                    Order = 1;
                    if (Tab[SolderesOnTable[i].LoseOcuuredatChiled[1], SolderesOnTable[i].LoseOcuuredatChiled[2]] < 0)
                        Order = -1;

                    for (int Row = 0; Row < 8; Row++)
                        for (int Col = 0; Col < 8; Col++)
                        {
                            if (Movable(CloneATable(Tab), SolderesOnTable[i].LoseOcuuredatChiled[1], SolderesOnTable[i].LoseOcuuredatChiled[2], Row, Col, OrderColor(Order), Order))
                                return true;
                        }
                }
            }
            else
            if (Kind == 2)
            {
                if (ServeBoundryConditionsElephant(i, Kind, Order))
                    return false;
                if (ElephantOnTable[i].LoseOcuuredatChiled[0] == 5)
                {
                    Order = 1;
                    if (Tab[ElephantOnTable[i].LoseOcuuredatChiled[1], ElephantOnTable[i].LoseOcuuredatChiled[2]] < 0)
                        Order = -1;

                    for (int Row = 0; Row < 8; Row++)
                        for (int Col = 0; Col < 8; Col++)
                        {
                            if (Movable(CloneATable(Tab), ElephantOnTable[i].LoseOcuuredatChiled[1], ElephantOnTable[i].LoseOcuuredatChiled[2], Row, Col, OrderColor(Order), Order))
                                return true;
                        }
                }
            }
            else
            if (Kind == 3)
            {
                if (ServeBoundryConditionsHourse(i, Kind, Order))
                    return false;
                if (HoursesOnTable[i].LoseOcuuredatChiled[0] == 5)
                {
                    Order = 1;
                    if (Tab[HoursesOnTable[i].LoseOcuuredatChiled[1], HoursesOnTable[i].LoseOcuuredatChiled[2]] < 0)
                        Order = -1;

                    for (int Row = 0; Row < 8; Row++)
                        for (int Col = 0; Col < 8; Col++)
                        {
                            if (Movable(CloneATable(Tab), HoursesOnTable[i].LoseOcuuredatChiled[1], HoursesOnTable[i].LoseOcuuredatChiled[2], Row, Col, OrderColor(Order), Order))
                                return true;
                        }
                }
            }
            else
            if (Kind == 4)
            {
                if (ServeBoundryConditionsCastle(i, Kind, Order))
                    return false;
                if (CastlesOnTable[i].LoseOcuuredatChiled[0] == 5)
                {
                    Order = 1;
                    if (Tab[CastlesOnTable[i].LoseOcuuredatChiled[1], CastlesOnTable[i].LoseOcuuredatChiled[2]] < 0)
                        Order = -1;

                    for (int Row = 0; Row < 8; Row++)
                        for (int Col = 0; Col < 8; Col++)
                        {
                            if (Movable(CloneATable(Tab), CastlesOnTable[i].LoseOcuuredatChiled[1], CastlesOnTable[i].LoseOcuuredatChiled[2], Row, Col, OrderColor(Order), Order))
                                return true;
                        }
                }
            }
            else
            if (Kind == 5)
            {
                if (ServeBoundryConditionsMinister(i, Kind, Order))
                    return false;
                if (MinisterOnTable[i].LoseOcuuredatChiled[0] == 5)
                {
                    Order = 1;
                    if (Tab[MinisterOnTable[i].LoseOcuuredatChiled[1], MinisterOnTable[i].LoseOcuuredatChiled[2]] < 0)
                        Order = -1;

                    for (int Row = 0; Row < 8; Row++)
                        for (int Col = 0; Col < 8; Col++)
                        {
                            if (Movable(CloneATable(Tab), MinisterOnTable[i].LoseOcuuredatChiled[1], MinisterOnTable[i].LoseOcuuredatChiled[2], Row, Col, OrderColor(Order), Order))
                                return true;
                        }
                }
            }
            else
            if (Kind == 6)
            {
                if (ServeBoundryConditionsKing(i, Kind, Order))
                    return false;
                if (KingOnTable[i].LoseOcuuredatChiled[0] == 5)
                {
                    Order = 1;
                    if (Tab[KingOnTable[i].LoseOcuuredatChiled[1], KingOnTable[i].LoseOcuuredatChiled[2]] < 0)
                        Order = -1;

                    for (int Row = 0; Row < 8; Row++)
                        for (int Col = 0; Col < 8; Col++)
                        {
                            if (Movable(CloneATable(Tab), KingOnTable[i].LoseOcuuredatChiled[1], KingOnTable[i].LoseOcuuredatChiled[2], Row, Col, OrderColor(Order), Order))
                                return true;
                        }
                }
            }
            else
            if (Kind == 7 || Kind == -7)
            {
                if (ServeBoundryConditionsCasttling(i, Kind, Order))
                    return false;
                if (CastlingOnTable[i].LoseOcuuredatChiled[0] == 5)
                {
                    Order = 1;
                    if (Tab[CastlingOnTable[i].LoseOcuuredatChiled[1], CastlingOnTable[i].LoseOcuuredatChiled[2]] < 0)
                        Order = -1;

                    for (int Row = 0; Row < 8; Row++)
                        for (int Col = 0; Col < 8; Col++)
                        {
                            if (Movable(CloneATable(Tab), CastlingOnTable[i].LoseOcuuredatChiled[1], CastlingOnTable[i].LoseOcuuredatChiled[2], Row, Col, OrderColor(Order), Order))
                                return true;
                        }
                }
            }
            return Is;
        }
        //return color depend of order
        Color OrderColor(int Ord)
        {
            Object O = new Object();
            lock (O)
            {
                Color a = Color.Gray;
                if (Ord == -1)
                    a = Color.Brown;
                return a;
            }
        }
        ///Move Determination.
        public bool Movable(int[,] Tab, int i, int j, int ii, int jj, Color a, int Order)
        {
            Object O = new Object();
            lock (O)
            {
                if (Tab[i, j] == 0)
                    return false;
                if (Order == 1 && Tab[i, j] < 0)
                    return false;
                if (Order == -1 && Tab[i, j] > 0)
                    return false;
                int[,] Table = new int[8, 8];
                for (int p = 0; p < 8; p++)
                    for (int k = 0; k < 8; k++)
                        Table[p, k] = Tab[p, k];
                //Initiate Local Variables.
                int Store = Table[ii, jj];
                ChessRules A = new ChessRules(CurrentAStarGredyMax, MovementsAStarGreedyHeuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHeuristicT, OnlySelfT, AStarGreedyHeuristicT, ArrangmentsChanged, Table[i, j], CloneATable(Table), Order, i, j);
                //Menen Parameter is Moveble to Second Parameters Location returm Movable.
                if (Order == 1 && Table[ii, jj] < 0)
                {
                    if (A.Rules(i, j, ii, jj, a, Order))
                    {
                        return true;
                    }
                }
                else
                 if (Order == -1 && Table[ii, jj] > 0)
                {
                    if (A.Rules(i, j, ii, jj, a, Order))
                    {
                        return true;
                    }
                }
                if (Order == 1 && Table[ii, jj] == 0)
                {
                    if (A.Rules(i, j, ii, jj, a, Order))
                    {
                        return true;
                    }
                }
                else
                if (Order == -1 && Table[ii, jj] == 0)
                {
                    if (A.Rules(i, j, ii, jj, a, Order))
                    {
                        return true;
                    }
                }

                return false;
            }
        }
    }
}
//End of Documentation.
