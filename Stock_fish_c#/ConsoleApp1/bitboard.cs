using System;
using System.Collections.Generic;
using System.Diagnostics;

public static class GlobalMembersBitboard
{
    /*
	  Stockfish, a UCI chess playing engine derived from Glaurung 2.1
	  Copyright (C) 2004-2008 Tord Romstad (Glaurung author)
	  Copyright (C) 2008-2015 Marco Costalba, Joona Kiiski, Tord Romstad
	  Copyright (C) 2015-2016 Marco Costalba, Joona Kiiski, Gary Linscott, Tord Romstad
	
	  Stockfish is free software: you can redistribute it and/or modify
	  it under the terms of the GNU General Public License as published by
	  the Free Software Foundation, either version 3 of the License, or
	  (at your option) any later version.
	
	  Stockfish is distributed in the hope that it will be useful,
	  but WITHOUT ANY WARRANTY; without even the implied warranty of
	  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	  GNU General Public License for more details.
	
	  You should have received a copy of the GNU General Public License
	  along with this program.  If not, see <http://www.gnu.org/licenses/>.
	*/


    /*
	  Stockfish, a UCI chess playing engine derived from Glaurung 2.1
	  Copyright (C) 2004-2008 Tord Romstad (Glaurung author)
	  Copyright (C) 2008-2015 Marco Costalba, Joona Kiiski, Tord Romstad
	  Copyright (C) 2015-2016 Marco Costalba, Joona Kiiski, Gary Linscott, Tord Romstad
	
	  Stockfish is free software: you can redistribute it and/or modify
	  it under the terms of the GNU General Public License as published by
	  the Free Software Foundation, either version 3 of the License, or
	  (at your option) any later version.
	
	  Stockfish is distributed in the hope that it will be useful,
	  but WITHOUT ANY WARRANTY; without even the implied warranty of
	  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	  GNU General Public License for more details.
	
	  You should have received a copy of the GNU General Public License
	  along with this program.  If not, see <http://www.gnu.org/licenses/>.
	*/



    /*
	  Stockfish, a UCI chess playing engine derived from Glaurung 2.1
	  Copyright (C) 2004-2008 Tord Romstad (Glaurung author)
	  Copyright (C) 2008-2015 Marco Costalba, Joona Kiiski, Tord Romstad
	  Copyright (C) 2015-2016 Marco Costalba, Joona Kiiski, Gary Linscott, Tord Romstad
	
	  Stockfish is free software: you can redistribute it and/or modify
	  it under the terms of the GNU General Public License as published by
	  the Free Software Foundation, either version 3 of the License, or
	  (at your option) any later version.
	
	  Stockfish is distributed in the hope that it will be useful,
	  but WITHOUT ANY WARRANTY; without even the implied warranty of
	  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	  GNU General Public License for more details.
	
	  You should have received a copy of the GNU General Public License
	  along with this program.  If not, see <http://www.gnu.org/licenses/>.
	*/


    /// When compiling with provided Makefile (e.g. for Linux and OSX), configuration
    /// is done automatically. To get started type 'make help'.
    ///
    /// When Makefile is not used (e.g. with Microsoft Visual Studio) some switches
    /// need to be set manually:
    ///
    /// -DNDEBUG      | Disable debugging mode. Always use this for release.
    ///
    /// -DNO_PREFETCH | Disable use of prefetch asm-instruction. You may need this to
    ///               | run on some very old machines.
    ///
    /// -DUSE_POPCNT  | Add runtime support for use of popcnt asm-instruction. Works
    ///               | only in 64-bit mode and requires hardware with popcnt support.
    ///
    /// -DUSE_PEXT    | Add runtime support for use of pext asm-instruction. Works
    ///               | only in 64-bit mode and requires hardware with pext support.


#if _MSC_VER
	// Disable some silly and noisy warning from MSVC compiler
	//C++ TO C# CONVERTER TODO TASK: There is no equivalent to most C++ 'pragma' directives in C#:
	//#pragma warning(disable: 4127) // Conditional expression is constant
	//C++ TO C# CONVERTER TODO TASK: There is no equivalent to most C++ 'pragma' directives in C#:
	//#pragma warning(disable: 4146) // Unary minus operator applied to unsigned type
	//C++ TO C# CONVERTER TODO TASK: There is no equivalent to most C++ 'pragma' directives in C#:
	//#pragma warning(disable: 4800) // Forcing value to bool 'true' or 'false'
#endif

    /// Predefined macros hell:
    ///
    /// __GNUC__           Compiler is gcc, Clang or Intel on Linux
    /// __INTEL_COMPILER   Compiler is Intel
    /// _MSC_VER           Compiler is MSVC or Intel on Windows
    /// _WIN32             Building on Windows (any)
    /// _WIN64             Building on Windows 64 bit

#if _WIN64 && _MSC_VER
#define IS_64BIT
#endif

#if USE_POPCNT && (__INTEL_COMPILER || _MSC_VER)
#endif

#if !NO_PREFETCH && (__INTEL_COMPILER || _MSC_VER)
#endif

#if USE_PEXT
	//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
	//ORIGINAL LINE: #define pext(b, m) _pext_u64(b, m)
#define pext
#else
    //C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
    //ORIGINAL LINE: #define pext(b, m) (0)
#define pext
#endif

#if USE_POPCNT
	public const bool HasPopCnt = true;
#else
    public const bool HasPopCnt = false;
#endif

#if USE_PEXT
	public const bool HasPext = true;
#else
    public const bool HasPext = false;
#endif

#if IS_64BIT
	public const bool Is64Bit = true;
#else
    public const bool Is64Bit = false;
#endif


    public const int MAX_MOVES = 256;
    public const int MAX_PLY = 128;

    public static readonly Piece[] Pieces = { Piece.W_PAWN, Piece.W_KNIGHT, Piece.W_BISHOP, Piece.W_ROOK, Piece.W_QUEEN, Piece.W_KING, Piece.B_PAWN, Piece.B_KNIGHT, Piece.B_BISHOP, Piece.B_ROOK, Piece.B_QUEEN, Piece.B_KING };
    //C++ TO C# CONVERTER NOTE: 'extern' variable declarations are not required in C#:
    //extern Value PieceValue[PHASE_NB][PIECE_NB];

    public static Score make_score(int mg, int eg)
    {
        return GlobalMembersSearch.Score((int)((uint)eg << 16) + mg);
    }

    /// Extracting the signed lower and upper 16 bits is not so trivial because
    /// according to the standard a simple cast to short is implementation defined
    /// and so is a right shift of a signed integer.
    public static Value eg_value(Score s)
    {

        //C++ TO C# CONVERTER TODO TASK: Unions within methods are not supported in C#:
        //  union
        //  {
        //	  ushort u;
        //	  short s;
        //  }
        eg = { (ushort)((uint)(s + 0x8000) >> 16)};
        return Value(eg.s);
    }

    public static Value mg_value(Score s)
    {

        //C++ TO C# CONVERTER TODO TASK: Unions within methods are not supported in C#:
        //  union
        //  {
        //	  ushort u;
        //	  short s;
        //  }
        mg = { (ushort)((uint)s)};
        return Value(mg.s);
    }

    //C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
    //ORIGINAL LINE: #define ENABLE_BASE_OPERATORS_ON(T) inline T operator+(T d1, T d2) { return T(int(d1) + int(d2)); } inline T operator-(T d1, T d2) { return T(int(d1) - int(d2)); } inline T operator*(int i, T d) { return T(i * int(d)); } inline T operator*(T d, int i) { return T(int(d) * i); } inline T operator-(T d) { return T(-int(d)); } inline T& operator+=(T& d1, T d2) { return d1 = d1 + d2; } inline T& operator-=(T& d1, T d2) { return d1 = d1 - d2; } inline T& operator*=(T& d, int i) { return d = T(int(d) * i); }
#define ENABLE_BASE_OPERATORS_ON

    //C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
    //ORIGINAL LINE: #define ENABLE_FULL_OPERATORS_ON(T) ENABLE_BASE_OPERATORS_ON(T) inline T& operator++(T& d) { return d = T(int(d) + 1); } inline T& operator--(T& d) { return d = T(int(d) - 1); } inline T operator/(T d, int i) { return T(int(d) / i); } inline int operator/(T d1, T d2) { return int(d1) / int(d2); } inline T& operator/=(T& d, int i) { return d = T(int(d) / i); }
#define ENABLE_FULL_OPERATORS_ON

    public static Value operator +(Value d1, Value d2)
    {
        return Value((int)d1 + (int)d2);
    }
    public static Value operator -(Value d1, Value d2)
    {
        return Value((int)d1 - (int)d2);
    }
    public static Value operator *(int i, Value d)
    {
        return Value(i * (int)d);
    }
    public static Value operator *(Value d, int i)
    {
        return Value((int)d * i);
    }
    public static Value operator -(Value d)
    {
        return Value(-(int)d);
    }
    //C++ TO C# CONVERTER TODO TASK: The += operator cannot be overloaded in C#:
    public static Value operator += (Value d1, Value d2)
    {
        return d1 = d1 + d2;
    }
    //C++ TO C# CONVERTER TODO TASK: The -= operator cannot be overloaded in C#:
    public static Value operator -= (Value d1, Value d2)
    {
        return d1 = d1 - d2;
    }
    //C++ TO C# CONVERTER TODO TASK: The *= operator cannot be overloaded in C#:
    public static Value operator *= (Value d, int i)
    {
        return d = Value((int)d * i);
    }
    public static Value operator ++(Value d)
    {
        return d = Value((int)d + 1);
    }
    public static Value operator --(Value d)
    {
        return d = Value((int)d - 1);
    }
    public static Value operator /(Value d, int i)
    {
        return Value((int)d / i);
    }
    public static int operator /(Value d1, Value d2)
    {
        return (int)d1 / (int)d2;
    }
    //C++ TO C# CONVERTER TODO TASK: The /= operator cannot be overloaded in C#:
    public static Value operator /= (Value d, int i)
    {
        return d = Value((int)d / i);
    }
    public static PieceType operator +(PieceType d1, PieceType d2)
    {
        return PieceType((int)d1 + (int)d2);
    }
    public static PieceType operator -(PieceType d1, PieceType d2)
    {
        return PieceType((int)d1 - (int)d2);
    }
    public static PieceType operator *(int i, PieceType d)
    {
        return PieceType(i * (int)d);
    }
    public static PieceType operator *(PieceType d, int i)
    {
        return PieceType((int)d * i);
    }
    public static PieceType operator -(PieceType d)
    {
        return PieceType(-(int)d);
    }
    //C++ TO C# CONVERTER TODO TASK: The += operator cannot be overloaded in C#:
    public static PieceType operator += (PieceType d1, PieceType d2)
    {
        return d1 = d1 + d2;
    }
    //C++ TO C# CONVERTER TODO TASK: The -= operator cannot be overloaded in C#:
    public static PieceType operator -= (PieceType d1, PieceType d2)
    {
        return d1 = d1 - d2;
    }
    //C++ TO C# CONVERTER TODO TASK: The *= operator cannot be overloaded in C#:
    public static PieceType operator *= (PieceType d, int i)
    {
        return d = PieceType((int)d * i);
    }
    public static PieceType operator ++(PieceType d)
    {
        return d = PieceType((int)d + 1);
    }
    public static PieceType operator --(PieceType d)
    {
        return d = PieceType((int)d - 1);
    }
    public static PieceType operator /(PieceType d, int i)
    {
        return PieceType((int)d / i);
    }
    public static int operator /(PieceType d1, PieceType d2)
    {
        return (int)d1 / (int)d2;
    }
    //C++ TO C# CONVERTER TODO TASK: The /= operator cannot be overloaded in C#:
    public static PieceType operator /= (PieceType d, int i)
    {
        return d = PieceType((int)d / i);
    }
    public static Piece operator +(Piece d1, Piece d2)
    {
        return Piece((int)d1 + (int)d2);
    }
    public static Piece operator -(Piece d1, Piece d2)
    {
        return Piece((int)d1 - (int)d2);
    }
    public static Piece operator *(int i, Piece d)
    {
        return Piece(i * (int)d);
    }
    public static Piece operator *(Piece d, int i)
    {
        return Piece((int)d * i);
    }
    public static Piece operator -(Piece d)
    {
        return Piece(-(int)d);
    }
    //C++ TO C# CONVERTER TODO TASK: The += operator cannot be overloaded in C#:
    public static Piece operator += (Piece d1, Piece d2)
    {
        return d1 = d1 + d2;
    }
    //C++ TO C# CONVERTER TODO TASK: The -= operator cannot be overloaded in C#:
    public static Piece operator -= (Piece d1, Piece d2)
    {
        return d1 = d1 - d2;
    }
    //C++ TO C# CONVERTER TODO TASK: The *= operator cannot be overloaded in C#:
    public static Piece operator *= (Piece d, int i)
    {
        return d = Piece((int)d * i);
    }
    public static Piece operator ++(Piece d)
    {
        return d = Piece((int)d + 1);
    }
    public static Piece operator --(Piece d)
    {
        return d = Piece((int)d - 1);
    }
    public static Piece operator /(Piece d, int i)
    {
        return Piece((int)d / i);
    }
    public static int operator /(Piece d1, Piece d2)
    {
        return (int)d1 / (int)d2;
    }
    //C++ TO C# CONVERTER TODO TASK: The /= operator cannot be overloaded in C#:
    public static Piece operator /= (Piece d, int i)
    {
        return d = Piece((int)d / i);
    }
    public static Color operator +(Color d1, Color d2)
    {
        return Color((int)d1 + (int)d2);
    }
    public static Color operator -(Color d1, Color d2)
    {
        return Color((int)d1 - (int)d2);
    }
    public static Color operator *(int i, Color d)
    {
        return Color(i * (int)d);
    }
    public static Color operator *(Color d, int i)
    {
        return Color((int)d * i);
    }
    public static Color operator -(Color d)
    {
        return Color(-(int)d);
    }
    //C++ TO C# CONVERTER TODO TASK: The += operator cannot be overloaded in C#:
    public static Color operator += (Color d1, Color d2)
    {
        return d1 = d1 + d2;
    }
    //C++ TO C# CONVERTER TODO TASK: The -= operator cannot be overloaded in C#:
    public static Color operator -= (Color d1, Color d2)
    {
        return d1 = d1 - d2;
    }
    //C++ TO C# CONVERTER TODO TASK: The *= operator cannot be overloaded in C#:
    public static Color operator *= (Color d, int i)
    {
        return d = Color((int)d * i);
    }
    public static Color operator ++(Color d)
    {
        return d = Color((int)d + 1);
    }
    public static Color operator --(Color d)
    {
        return d = Color((int)d - 1);
    }
    public static Color operator /(Color d, int i)
    {
        return Color((int)d / i);
    }
    public static int operator /(Color d1, Color d2)
    {
        return (int)d1 / (int)d2;
    }
    //C++ TO C# CONVERTER TODO TASK: The /= operator cannot be overloaded in C#:
    public static Color operator /= (Color d, int i)
    {
        return d = Color((int)d / i);
    }
    public static Depth operator +(Depth d1, Depth d2)
    {
        return Depth((int)d1 + (int)d2);
    }
    public static Depth operator -(Depth d1, Depth d2)
    {
        return Depth((int)d1 - (int)d2);
    }
    public static Depth operator *(int i, Depth d)
    {
        return Depth(i * (int)d);
    }
    public static Depth operator *(Depth d, int i)
    {
        return Depth((int)d * i);
    }
    public static Depth operator -(Depth d)
    {
        return Depth(-(int)d);
    }
    //C++ TO C# CONVERTER TODO TASK: The += operator cannot be overloaded in C#:
    public static Depth operator += (Depth d1, Depth d2)
    {
        return d1 = d1 + d2;
    }
    //C++ TO C# CONVERTER TODO TASK: The -= operator cannot be overloaded in C#:
    public static Depth operator -= (Depth d1, Depth d2)
    {
        return d1 = d1 - d2;
    }
    //C++ TO C# CONVERTER TODO TASK: The *= operator cannot be overloaded in C#:
    public static Depth operator *= (Depth d, int i)
    {
        return d = Depth((int)d * i);
    }
    public static Depth operator ++(Depth d)
    {
        return d = Depth((int)d + 1);
    }
    public static Depth operator --(Depth d)
    {
        return d = Depth((int)d - 1);
    }
    public static Depth operator /(Depth d, int i)
    {
        return Depth((int)d / i);
    }
    public static int operator /(Depth d1, Depth d2)
    {
        return (int)d1 / (int)d2;
    }
    //C++ TO C# CONVERTER TODO TASK: The /= operator cannot be overloaded in C#:
    public static Depth operator /= (Depth d, int i)
    {
        return d = Depth((int)d / i);
    }
    public static Square operator +(Square d1, Square d2)
    {
        return Square((int)d1 + (int)d2);
    }
    public static Square operator -(Square d1, Square d2)
    {
        return Square((int)d1 - (int)d2);
    }
    public static Square operator *(int i, Square d)
    {
        return Square(i * (int)d);
    }
    public static Square operator *(Square d, int i)
    {
        return Square((int)d * i);
    }
    public static Square operator -(Square d)
    {
        return Square(-(int)d);
    }
    //C++ TO C# CONVERTER TODO TASK: The += operator cannot be overloaded in C#:
    public static Square operator += (Square d1, Square d2)
    {
        return d1 = d1 + d2;
    }
    //C++ TO C# CONVERTER TODO TASK: The -= operator cannot be overloaded in C#:
    public static Square operator -= (Square d1, Square d2)
    {
        return d1 = d1 - d2;
    }
    //C++ TO C# CONVERTER TODO TASK: The *= operator cannot be overloaded in C#:
    public static Square operator *= (Square d, int i)
    {
        return d = Square((int)d * i);
    }
    public static Square operator ++(Square d)
    {
        return d = Square((int)d + 1);
    }
    public static Square operator --(Square d)
    {
        return d = Square((int)d - 1);
    }
    public static Square operator /(Square d, int i)
    {
        return Square((int)d / i);
    }
    public static int operator /(Square d1, Square d2)
    {
        return (int)d1 / (int)d2;
    }
    //C++ TO C# CONVERTER TODO TASK: The /= operator cannot be overloaded in C#:
    public static Square operator /= (Square d, int i)
    {
        return d = Square((int)d / i);
    }
    public static File operator +(File d1, File d2)
    {
        return File((int)d1 + (int)d2);
    }
    public static File operator -(File d1, File d2)
    {
        return File((int)d1 - (int)d2);
    }
    public static File operator *(int i, File d)
    {
        return File(i * (int)d);
    }
    public static File operator *(File d, int i)
    {
        return File((int)d * i);
    }
    public static File operator -(File d)
    {
        return File(-(int)d);
    }
    //C++ TO C# CONVERTER TODO TASK: The += operator cannot be overloaded in C#:
    public static File operator += (File d1, File d2)
    {
        return d1 = d1 + d2;
    }
    //C++ TO C# CONVERTER TODO TASK: The -= operator cannot be overloaded in C#:
    public static File operator -= (File d1, File d2)
    {
        return d1 = d1 - d2;
    }
    //C++ TO C# CONVERTER TODO TASK: The *= operator cannot be overloaded in C#:
    public static File operator *= (File d, int i)
    {
        return d = File((int)d * i);
    }
    public static File operator ++(File d)
    {
        return d = File((int)d + 1);
    }
    public static File operator --(File d)
    {
        return d = File((int)d - 1);
    }
    public static File operator /(File d, int i)
    {
        return File((int)d / i);
    }
    public static int operator /(File d1, File d2)
    {
        return (int)d1 / (int)d2;
    }
    //C++ TO C# CONVERTER TODO TASK: The /= operator cannot be overloaded in C#:
    public static File operator /= (File d, int i)
    {
        return d = File((int)d / i);
    }
    public static Rank operator +(Rank d1, Rank d2)
    {
        return Rank((int)d1 + (int)d2);
    }
    public static Rank operator -(Rank d1, Rank d2)
    {
        return Rank((int)d1 - (int)d2);
    }
    public static Rank operator *(int i, Rank d)
    {
        return Rank(i * (int)d);
    }
    public static Rank operator *(Rank d, int i)
    {
        return Rank((int)d * i);
    }
    public static Rank operator -(Rank d)
    {
        return Rank(-(int)d);
    }
    //C++ TO C# CONVERTER TODO TASK: The += operator cannot be overloaded in C#:
    public static Rank operator += (Rank d1, Rank d2)
    {
        return d1 = d1 + d2;
    }
    //C++ TO C# CONVERTER TODO TASK: The -= operator cannot be overloaded in C#:
    public static Rank operator -= (Rank d1, Rank d2)
    {
        return d1 = d1 - d2;
    }
    //C++ TO C# CONVERTER TODO TASK: The *= operator cannot be overloaded in C#:
    public static Rank operator *= (Rank d, int i)
    {
        return d = Rank((int)d * i);
    }
    public static Rank operator ++(Rank d)
    {
        return d = Rank((int)d + 1);
    }
    public static Rank operator --(Rank d)
    {
        return d = Rank((int)d - 1);
    }
    public static Rank operator /(Rank d, int i)
    {
        return Rank((int)d / i);
    }
    public static int operator /(Rank d1, Rank d2)
    {
        return (int)d1 / (int)d2;
    }
    //C++ TO C# CONVERTER TODO TASK: The /= operator cannot be overloaded in C#:
    public static Rank operator /= (Rank d, int i)
    {
        return d = Rank((int)d / i);
    }

    public static Score operator +(Score d1, Score d2)
    {
        return GlobalMembersSearch.Score((int)d1 + (int)d2);
    }
    public static Score operator -(Score d1, Score d2)
    {
        return GlobalMembersSearch.Score((int)d1 - (int)d2);
    }
    public static Score operator *(int i, Score d)
    {
        return GlobalMembersSearch.Score(i * (int)d);
    }
    public static Score operator *(Score d, int i)
    {
        return GlobalMembersSearch.Score((int)d * i);
    }
    public static Score operator -(Score d)
    {
        return GlobalMembersSearch.Score(-(int)d);
    }
    //C++ TO C# CONVERTER TODO TASK: The += operator cannot be overloaded in C#:
    public static Score operator += (Score d1, Score d2)
    {
        return d1 = d1 + d2;
    }
    //C++ TO C# CONVERTER TODO TASK: The -= operator cannot be overloaded in C#:
    public static Score operator -= (Score d1, Score d2)
    {
        return d1 = d1 - d2;
    }
    //C++ TO C# CONVERTER TODO TASK: The *= operator cannot be overloaded in C#:
    public static Score operator *= (Score d, int i)
    {
        return d = GlobalMembersSearch.Score((int)d * i);
    }

#undef ENABLE_FULL_OPERATORS_ON
#undef ENABLE_BASE_OPERATORS_ON

    /// Additional operators to add integers to a Value
    public static Value operator +(Value v, int i)
    {
        return Value((int)v + i);
    }
    public static Value operator -(Value v, int i)
    {
        return Value((int)v - i);
    }
    //C++ TO C# CONVERTER TODO TASK: The += operator cannot be overloaded in C#:
    public static Value operator += (Value v, int i)
    {
        return v = v + i;
    }
    //C++ TO C# CONVERTER TODO TASK: The -= operator cannot be overloaded in C#:
    public static Value operator -= (Value v, int i)
    {
        return v = v - i;
    }

    /// Only declared but not defined. We don't want to multiply two scores due to
    /// a very high risk of overflow. So user should explicitly convert to integer.
    //C++ TO C# CONVERTER TODO TASK: The implementation of the following method could not be found:
    //Score operator *(Score s1, Score s2);

    /// Division of a Score must be handled separately for each term
    public static Score operator /(Score s, int i)
    {
        return GlobalMembersBenchmark.make_score(GlobalMembersBenchmark.mg_value(s) / i, GlobalMembersBenchmark.eg_value(s) / i);
    }

    public static Color operator ~(Color c)
    {
        return Color(c ^ Color.BLACK); // Toggle color
    }

    public static Square operator ~(Square s)
    {
        return Square(s ^ Square.SQ_A8); // Vertical flip SQ_A1 -> SQ_A8
    }

    public static Piece operator ~(Piece pc)
    {
        return Piece(pc ^ 8); // Swap color of piece B_KNIGHT -> W_KNIGHT
    }

    public static CastlingRight operator |(Color c, CastlingSide s)
    {
        return CastlingRight(CastlingRight.WHITE_OO << ((s == CastlingSide.QUEEN_SIDE) + 2 * c));
    }

    public static Value mate_in(int ply)
    {
        return Value.VALUE_MATE - ply;
    }

    public static Value mated_in(int ply)
    {
        return -Value.VALUE_MATE + ply;
    }

    public static Square make_square(File f, Rank r)
    {
        return Square((r << 3) + f);
    }

    public static Piece make_piece(Color c, PieceType pt)
    {
        return Piece((c << 3) + pt);
    }

    public static PieceType type_of(Piece pc)
    {
        return PieceType((int)pc & 7);
    }

    public static Color color_of(Piece pc)
    {
        Debug.Assert(pc != Piece.NO_PIECE);
        return Color(pc >> 3);
    }

    public static bool is_ok(Square s)
    {
        return s >= Square.SQ_A1 && s <= Square.SQ_H8;
    }

    public static File file_of(Square s)
    {
        return File((int)s & 7);
    }

    public static Rank rank_of(Square s)
    {
        return Rank(s >> 3);
    }

    public static Square relative_square(Color c, Square s)
    {
        return Square(s ^ (c * 56));
    }

    public static Rank relative_rank(Color c, Rank r)
    {
        return Rank(r ^ (c * 7));
    }

    public static Rank relative_rank(Color c, Square s)
    {
        return GlobalMembersBenchmark.relative_rank(c, GlobalMembersBenchmark.rank_of(s));
    }

    public static bool opposite_colors(Square s1, Square s2)
    {
        int s = (int)s1 ^ (int)s2;
        return ((s >> 3) ^ s) & 1;
    }

    public static Square pawn_push(Color c)
    {
        return c == ((int)Color.WHITE) != 0 ? Square.NORTH : Square.SOUTH;
    }

    public static Square from_sq(Move m)
    {
        return Square((m >> 6) & 0x3F);
    }

    public static Square to_sq(Move m)
    {
        return Square((int)m & 0x3F);
    }

    public static MoveType type_of(Move m)
    {
        return MoveType((int)m & (3 << 14));
    }

    public static PieceType promotion_type(Move m)
    {
        return PieceType(((m >> 12) & 3) + PieceType.KNIGHT);
    }

    public static Move make_move(Square from, Square to)
    {
        return Move((from << 6) + to);
    }

    //C++ TO C# CONVERTER TODO TASK: C++ template specifiers with non-type parameters cannot be converted to C#:
    //ORIGINAL LINE: template<MoveType T>
    public static Move make<MoveType T>(Square from, Square to)
    {
        return make(from, to, PieceType.KNIGHT);
    }
    //C++ TO C# CONVERTER NOTE: Overloaded method(s) are created above to convert the following method having default parameters:
    //ORIGINAL LINE: inline Move make(Square from, Square to, PieceType pt = KNIGHT)
    public static Move make<MoveType T>(Square from, Square to, PieceType pt)

    {
        return Move(T + ((pt - PieceType.KNIGHT) << 12) + (from << 6) + to);
    }

    public static bool is_ok(Move m)
    {
        return GlobalMembersBenchmark.from_sq(m) != GlobalMembersBenchmark.to_sq(m); // Catch MOVE_NULL and MOVE_NONE
    }

    //C++ TO C# CONVERTER TODO TASK: The implementation of the following method could not be found:
    //void init();
    //C++ TO C# CONVERTER TODO TASK: The implementation of the following method could not be found:
    //bool probe(Square wksq, Square wpsq, Square bksq, Color us);

    /// Bitboards::init() initializes various bitboard tables. It is called at
    /// startup and relies on global objects to be already zero-initialized.


    public static void init()
    {

        for (uint i = 0; i < (1 << 16); ++i)
        {
            PopCnt16[i] = (byte)GlobalMembersBitboard.popcount16(i);
        }

        for (Square s = Square.SQ_A1; s <= Square.SQ_H8; ++s)
        {
            SquareBB[(int)s] = 1UL << s;
            BSFTable[GlobalMembersBitboard.bsf_index(SquareBB[(int)s])] = s;
        }

        for (ulong b = 2; b < 256; ++b)
        {
            MSBTable[b] = MSBTable[b - 1] + !GlobalMembersBenchmark.more_than_one(b);
        }

        for (File f = File.FILE_A; f <= File.FILE_H; ++f)
        {
            FileBB[(int)f] = f > ((int)File.FILE_A) != 0 ? FileBB[(int)f - 1] << 1 : FileABB;
        }

        for (Rank r = Rank.RANK_1; r <= Rank.RANK_8; ++r)
        {
            RankBB[(int)r] = r > ((int)Rank.RANK_1) != 0 ? RankBB[(int)r - 1] << 8 : Rank1BB;
        }

        for (File f = File.FILE_A; f <= File.FILE_H; ++f)
        {
            AdjacentFilesBB[(int)f] = (f > ((int)File.FILE_A) != 0 ? FileBB[(int)f - 1] : 0) | (f < ((int)File.FILE_H) != 0 ? FileBB[(int)f + 1] : 0);
        }

        for (Rank r = Rank.RANK_1; r < Rank.RANK_8; ++r)
        {
            InFrontBB[(int)Color.WHITE, (int)r] = ~(InFrontBB[(int)Color.BLACK, r + 1] = InFrontBB[(int)Color.BLACK, (int)r] | RankBB[(int)r]);
        }

        for (Color c = Color.WHITE; c <= Color.BLACK; ++c)
        {
            for (Square s = Square.SQ_A1; s <= Square.SQ_H8; ++s)
            {
                ForwardBB[(int)c, (int)s] = InFrontBB[(int)c, (int)GlobalMembersBenchmark.rank_of(s)] & FileBB[(int)GlobalMembersBenchmark.file_of(s)];
                PawnAttackSpan[(int)c, (int)s] = InFrontBB[(int)c, (int)GlobalMembersBenchmark.rank_of(s)] & AdjacentFilesBB[(int)GlobalMembersBenchmark.file_of(s)];
                PassedPawnMask[(int)c, (int)s] = ForwardBB[(int)c, (int)s] | PawnAttackSpan[(int)c, (int)s];
            }
        }

        for (Square s1 = Square.SQ_A1; s1 <= Square.SQ_H8; ++s1)
        {
            for (Square s2 = Square.SQ_A1; s2 <= Square.SQ_H8; ++s2)
            {
                if (s1 != s2)
                {
                    SquareDistance[(int)s1, (int)s2] = Math.Max(distance<File>(s1, s2), distance<Rank>(s1, s2));
                    DistanceRingBB[(int)s1, SquareDistance[(int)s1, (int)s2] - 1] |= s2;
                }
            }
        }

        int[,] steps =
        {
          {, 0, 0, 0, 0, 0, 0, 0, 0},
          {7, 9, 0, 0, 0, 0, 0, 0, 0},
          {17, 15, 10, 6, -6, -10, -15, -17, 0},
          {, 0, 0, 0, 0, 0, 0, 0, 0},
          {, 0, 0, 0, 0, 0, 0, 0, 0},
          {, 0, 0, 0, 0, 0, 0, 0, 0},
          {9, 7, -7, -9, 8, 1, -1, -8, 0}
      };

        for (Color c = Color.WHITE; c <= Color.BLACK; ++c)
        {
            for (PieceType pt = PieceType.PAWN; pt <= PieceType.KING; ++pt)
            {
                for (Square s = Square.SQ_A1; s <= Square.SQ_H8; ++s)
                {
                    for (int i = 0; steps[(int)pt, i] != 0; ++i)
                    {
                        Square to = s + Square(c == ((int)Color.WHITE) != 0 ? steps[(int)pt, i] : -steps[(int)pt, i]);

                        if (GlobalMembersBenchmark.is_ok(to) && GlobalMembersBenchmark.distance(s, to) < 3)
                        {
                            StepAttacksBB[(int)GlobalMembersBenchmark.make_piece(c, pt), (int)s] |= to;
                        }
                    }
                }
            }
        }

        Square[] RookDeltas = { Square.NORTH, Square.EAST, Square.SOUTH, Square.WEST };
        Square[] BishopDeltas = { Square.NORTH_EAST, Square.SOUTH_EAST, Square.SOUTH_WEST, Square.NORTH_WEST };

        GlobalMembersBitboard.init_magics(RookTable, RookAttacks, RookMagics, RookMasks, RookShifts, RookDeltas, magic_index<PieceType.ROOK>);
        GlobalMembersBitboard.init_magics(BishopTable, BishopAttacks, BishopMagics, BishopMasks, BishopShifts, BishopDeltas, magic_index<PieceType.BISHOP>);

        for (Square s1 = Square.SQ_A1; s1 <= Square.SQ_H8; ++s1)
        {
            PseudoAttacks[(int)PieceType.QUEEN, (int)s1] = PseudoAttacks[(int)PieceType.BISHOP, (int)s1] = attacks_bb<PieceType.BISHOP>(s1, 0);
            PseudoAttacks[(int)PieceType.QUEEN, (int)s1] |= PseudoAttacks[(int)PieceType.ROOK, (int)s1] = attacks_bb<PieceType.ROOK>(s1, 0);

            for (Piece pc = Piece.W_BISHOP; pc <= Piece.W_ROOK; ++pc)
            {
                for (Square s2 = Square.SQ_A1; s2 <= Square.SQ_H8; ++s2)
                {
                    if (((PseudoAttacks[(int)pc, (int)s1] & (int)s2) == 0)
  
                      continue;

                    LineBB[(int)s1, (int)s2] = (GlobalMembersBenchmark.attacks_bb(pc, s1, 0) & GlobalMembersBenchmark.attacks_bb(pc, s2, 0)) | (int)s1 | (int)s2;
                    BetweenBB[(int)s1, (int)s2] = GlobalMembersBenchmark.attacks_bb(pc, s1, SquareBB[(int)s2]) & GlobalMembersBenchmark.attacks_bb(pc, s2, SquareBB[(int)s1]);
                }
            }
        }
    }

    /// Bitboards::pretty() returns an ASCII representation of a bitboard suitable
    /// to be printed to standard output. Useful for debugging.

    public static string pretty(ulong b)
    {

        string s = "+---+---+---+---+---+---+---+---+\n";

        for (Rank r = Rank.RANK_8; r >= Rank.RANK_1; --r)
        {
            for (File f = File.FILE_A; f <= File.FILE_H; ++f)
            {
                s += (b & (int)GlobalMembersBenchmark.make_square(f, r)) != 0 ? "| X " : "|   ";
            }

            s += "|\n+---+---+---+---+---+---+---+---+\n";
        }

        return s;
    }

    public const ulong DarkSquares = 0xAA55AA55AA55AA55UL;

    public const ulong FileABB = 0x0101010101010101UL;
    public static ulong FileBBB = FileABB << 1;
    public static ulong FileCBB = FileABB << 2;
    public static ulong FileDBB = FileABB << 3;
    public static ulong FileEBB = FileABB << 4;
    public static ulong FileFBB = FileABB << 5;
    public static ulong FileGBB = FileABB << 6;
    public static ulong FileHBB = FileABB << 7;

    public const ulong Rank1BB = 0xFF;
    public static ulong Rank2BB = Rank1BB << (8 * 1);
    public static ulong Rank3BB = Rank1BB << (8 * 2);
    public static ulong Rank4BB = Rank1BB << (8 * 3);
    public static ulong Rank5BB = Rank1BB << (8 * 4);
    public static ulong Rank6BB = Rank1BB << (8 * 5);
    public static ulong Rank7BB = Rank1BB << (8 * 6);
    public static ulong Rank8BB = Rank1BB << (8 * 7);

    //C++ TO C# CONVERTER NOTE: 'extern' variable declarations are not required in C#:
    //extern int SquareDistance[SQUARE_NB][SQUARE_NB];

    //C++ TO C# CONVERTER NOTE: 'extern' variable declarations are not required in C#:
    //extern ulong SquareBB[SQUARE_NB];
    //C++ TO C# CONVERTER NOTE: 'extern' variable declarations are not required in C#:
    //extern ulong FileBB[FILE_NB];
    //C++ TO C# CONVERTER NOTE: 'extern' variable declarations are not required in C#:
    //extern ulong RankBB[RANK_NB];
    //C++ TO C# CONVERTER NOTE: 'extern' variable declarations are not required in C#:
    //extern ulong AdjacentFilesBB[FILE_NB];
    //C++ TO C# CONVERTER NOTE: 'extern' variable declarations are not required in C#:
    //extern ulong InFrontBB[COLOR_NB][RANK_NB];
    //C++ TO C# CONVERTER NOTE: 'extern' variable declarations are not required in C#:
    //extern ulong StepAttacksBB[PIECE_NB][SQUARE_NB];
    //C++ TO C# CONVERTER NOTE: 'extern' variable declarations are not required in C#:
    //extern ulong BetweenBB[SQUARE_NB][SQUARE_NB];
    //C++ TO C# CONVERTER NOTE: 'extern' variable declarations are not required in C#:
    //extern ulong LineBB[SQUARE_NB][SQUARE_NB];
    //C++ TO C# CONVERTER NOTE: 'extern' variable declarations are not required in C#:
    //extern ulong DistanceRingBB[SQUARE_NB][8];
    //C++ TO C# CONVERTER NOTE: 'extern' variable declarations are not required in C#:
    //extern ulong ForwardBB[COLOR_NB][SQUARE_NB];
    //C++ TO C# CONVERTER NOTE: 'extern' variable declarations are not required in C#:
    //extern ulong PassedPawnMask[COLOR_NB][SQUARE_NB];
    //C++ TO C# CONVERTER NOTE: 'extern' variable declarations are not required in C#:
    //extern ulong PawnAttackSpan[COLOR_NB][SQUARE_NB];
    //C++ TO C# CONVERTER NOTE: 'extern' variable declarations are not required in C#:
    //extern ulong PseudoAttacks[PIECE_TYPE_NB][SQUARE_NB];


    /// Overloads of bitwise operators between a Bitboard and a Square for testing
    /// whether a given bit is set in a bitboard, and for setting and clearing bits.

    public static ulong operator &(ulong b, Square s)
    {
        return b & SquareBB[(int)s];
    }

    public static ulong operator |(ulong b, Square s)
    {
        return b | SquareBB[(int)s];
    }

    public static ulong operator ^(ulong b, Square s)
    {
        return b ^ SquareBB[(int)s];
    }

    //C++ TO C# CONVERTER TODO TASK: The |= operator cannot be overloaded in C#:
    public static ulong operator |= (ref ulong b, Square s)
    {
        return b |= SquareBB[(int)s];
    }

    //C++ TO C# CONVERTER TODO TASK: The ^= operator cannot be overloaded in C#:
    public static ulong operator ^= (ref ulong b, Square s)
    {
        return b ^= SquareBB[(int)s];
    }

    public static bool more_than_one(ulong b)
    {
        return b & (b - 1);
    }


    /// rank_bb() and file_bb() return a bitboard representing all the squares on
    /// the given file or rank.

    public static ulong rank_bb(Rank r)
    {
        return RankBB[(int)r];
    }

    public static ulong rank_bb(Square s)
    {
        return RankBB[(int)GlobalMembersBenchmark.rank_of(s)];
    }

    public static ulong file_bb(File f)
    {
        return FileBB[(int)f];
    }

    public static ulong file_bb(Square s)
    {
        return FileBB[(int)GlobalMembersBenchmark.file_of(s)];
    }


    /// shift() moves a bitboard one step along direction D. Mainly for pawns

    //C++ TO C# CONVERTER TODO TASK: C++ template specifiers with non-type parameters cannot be converted to C#:
    //ORIGINAL LINE: template<Square D>
    public static ulong shift<Square D>(ulong b)

    {
        return D == ((int)Square.NORTH) != 0 ? b << 8 : D == ((int)Square.SOUTH) != 0 ? b >> 8 : D == ((int)Square.NORTH_EAST) != 0 ? (b & ~FileHBB) << 9 : D == ((int)Square.SOUTH_EAST) != 0 ? (b & ~FileHBB) >> 7 : D == ((int)Square.NORTH_WEST) != 0 ? (b & ~FileABB) << 7 : D == ((int)Square.SOUTH_WEST) != 0 ? (b & ~FileABB) >> 9 : 0;
    }


    /// adjacent_files_bb() returns a bitboard representing all the squares on the
    /// adjacent files of the given one.

    public static ulong adjacent_files_bb(File f)
    {
        return AdjacentFilesBB[(int)f];
    }


    /// between_bb() returns a bitboard representing all the squares between the two
    /// given ones. For instance, between_bb(SQ_C4, SQ_F7) returns a bitboard with
    /// the bits for square d5 and e6 set. If s1 and s2 are not on the same rank, file
    /// or diagonal, 0 is returned.

    public static ulong between_bb(Square s1, Square s2)
    {
        return BetweenBB[(int)s1, (int)s2];
    }


    /// in_front_bb() returns a bitboard representing all the squares on all the ranks
    /// in front of the given one, from the point of view of the given color. For
    /// instance, in_front_bb(BLACK, RANK_3) will return the squares on ranks 1 and 2.

    public static ulong in_front_bb(Color c, Rank r)
    {
        return InFrontBB[(int)c, (int)r];
    }


    /// forward_bb() returns a bitboard representing all the squares along the line
    /// in front of the given one, from the point of view of the given color:
    ///        ForwardBB[c][s] = in_front_bb(c, s) & file_bb(s)

    public static ulong forward_bb(Color c, Square s)
    {
        return ForwardBB[(int)c, (int)s];
    }


    /// pawn_attack_span() returns a bitboard representing all the squares that can be
    /// attacked by a pawn of the given color when it moves along its file, starting
    /// from the given square:
    ///       PawnAttackSpan[c][s] = in_front_bb(c, s) & adjacent_files_bb(s);

    public static ulong pawn_attack_span(Color c, Square s)
    {
        return PawnAttackSpan[(int)c, (int)s];
    }


    /// passed_pawn_mask() returns a bitboard mask which can be used to test if a
    /// pawn of the given color and on the given square is a passed pawn:
    ///       PassedPawnMask[c][s] = pawn_attack_span(c, s) | forward_bb(c, s)

    public static ulong passed_pawn_mask(Color c, Square s)
    {
        return PassedPawnMask[(int)c, (int)s];
    }


    /// aligned() returns true if the squares s1, s2 and s3 are aligned either on a
    /// straight or on a diagonal line.

    public static bool aligned(Square s1, Square s2, Square s3)
    {
        return LineBB[(int)s1, (int)s2] & (int)s3;
    }


    /// distance() functions return the distance between x and y, defined as the
    /// number of steps for a king in x to reach y. Works with squares, ranks, files.

    //C++ TO C# CONVERTER TODO TASK: The original C++ template specifier was replaced with a C# generic specifier, which may not produce the same behavior:
    //ORIGINAL LINE: template<typename T>
    public static int distance<T>(T x, T y)
    {
        return x < y != null ? y - x : x - y;
    }
    public static int distance(Square x, Square y)
    {
        return SquareDistance[(int)x, (int)y];
    }

    //C++ TO C# CONVERTER TODO TASK: The original C++ template specifier was replaced with a C# generic specifier, which may not produce the same behavior:
    //ORIGINAL LINE: template<typename T1, typename T2>
    //C++ TO C# CONVERTER TODO TASK: The implementation of the following method could not be found:
    //int distance<T1, T2>(T2 x, T2 y);
    public static int distance<T1, T2>(Square x, Square y)
    {
        return GlobalMembersBenchmark.distance(GlobalMembersBenchmark.file_of(x), GlobalMembersBenchmark.file_of(y));
    }
    public static int distance(Square x, Square y)
    {
        return GlobalMembersBenchmark.distance(GlobalMembersBenchmark.rank_of(x), GlobalMembersBenchmark.rank_of(y));
    }


    /// attacks_bb() returns a bitboard representing all the squares attacked by a
    /// piece of type Pt (bishop or rook) placed on 's'. The helper magic_index()
    /// looks up the index using the 'magic bitboards' approach.
    //C++ TO C# CONVERTER TODO TASK: C++ template specifiers with non-type parameters cannot be converted to C#:
    //ORIGINAL LINE: template<PieceType Pt>
    public static uint magic_index<PieceType Pt>(Square s, ulong occupied)

    {

        //C++ TO C# CONVERTER NOTE: 'extern' variable declarations are not required in C#:
        //  extern ulong RookMasks[SQUARE_NB];
        //C++ TO C# CONVERTER NOTE: 'extern' variable declarations are not required in C#:
        //  extern ulong RookMagics[SQUARE_NB];
        //C++ TO C# CONVERTER NOTE: 'extern' variable declarations are not required in C#:
        //  extern uint RookShifts[SQUARE_NB];
        //C++ TO C# CONVERTER NOTE: 'extern' variable declarations are not required in C#:
        //  extern ulong BishopMasks[SQUARE_NB];
        //C++ TO C# CONVERTER NOTE: 'extern' variable declarations are not required in C#:
        //  extern ulong BishopMagics[SQUARE_NB];
        //C++ TO C# CONVERTER NOTE: 'extern' variable declarations are not required in C#:
        //  extern uint BishopShifts[SQUARE_NB];

        ulong[] Masks = Pt == ((int)PieceType.ROOK) != 0 ? RookMasks : BishopMasks;
        ulong[] Magics = Pt == ((int)PieceType.ROOK) != 0 ? RookMagics : BishopMagics;
        uint[] Shifts = Pt == ((int)PieceType.ROOK) != 0 ? RookShifts : BishopShifts;

        if (HasPext)
        {
            return (uint)((b, m)(0)(occupied, Masks[(int)s]));
        }

        if (Is64Bit)
        {
            return (uint)(((occupied & Masks[(int)s]) * Magics[(int)s]) >> (int)Shifts[(int)s]);
        }

        uint lo = (uint)occupied & (uint)Masks[(int)s];
        uint hi = (uint)(occupied >> 32) & (uint)(Masks[(int)s] >> 32);
        return (lo * (uint)Magics[(int)s] ^ hi * (uint)(Magics[(int)s] >> 32)) >> (int)Shifts[(int)s];
    }

    //C++ TO C# CONVERTER TODO TASK: C++ template specifiers with non-type parameters cannot be converted to C#:
    //ORIGINAL LINE: template<PieceType Pt>
    public static ulong attacks_bb<PieceType Pt>(Square s, ulong occupied)

    {

        //C++ TO C# CONVERTER NOTE: 'extern' variable declarations are not required in C#:
        //  extern ulong* RookAttacks[SQUARE_NB];
        //C++ TO C# CONVERTER NOTE: 'extern' variable declarations are not required in C#:
        //  extern ulong* BishopAttacks[SQUARE_NB];

        return (Pt == ((int)PieceType.ROOK) != 0 ? RookAttacks : BishopAttacks)[(int)s][magic_index<Pt>(s, occupied)];
    }

    public static ulong attacks_bb(Piece pc, Square s, ulong occupied)
    {

        switch (GlobalMembersBenchmark.type_of(pc))
        {
            case PieceType.BISHOP:
                return attacks_bb<PieceType.BISHOP>(s, occupied);
            case PieceType.ROOK:
                return attacks_bb<PieceType.ROOK>(s, occupied);
            case PieceType.QUEEN:
                return attacks_bb<PieceType.BISHOP>(s, occupied) | attacks_bb<PieceType.ROOK>(s, occupied);
            default:
                return StepAttacksBB[(int)pc, (int)s];
        }
    }


    /// popcount() counts the number of non-zero bits in a bitboard

    public static int popcount(ulong b)
    {

#if !USE_POPCNT

        //C++ TO C# CONVERTER NOTE: 'extern' variable declarations are not required in C#:
        //  extern byte PopCnt16[1 << 16];
        //C++ TO C# CONVERTER TODO TASK: Unions within methods are not supported in C#:
        //  union
        //  {
        //	  ulong bb;
        //	  ushort u[4];
        //  }
        v = { b};
        return PopCnt16[v.u[0]] + PopCnt16[v.u[1]] + PopCnt16[v.u[2]] + PopCnt16[v.u[3]];

#elif _MSC_VER || __INTEL_COMPILER

	  return (int)_mm_popcnt_u64(b);

#else

	  return __builtin_popcountll(b);

#endif
    }


    /// lsb() and msb() return the least/most significant bit in a non-zero bitboard

#if __GNUC__

	public static Square lsb(ulong b)
	{
	  Debug.Assert(b);
	  return Square(__builtin_ctzll(b));
	}

	public static Square msb(ulong b)
	{
	  Debug.Assert(b);
	  return Square(63 - __builtin_clzll(b));
	}

#elif _WIN64 && _MSC_VER

	public static Square lsb(ulong b)
	{
	  Debug.Assert(b);
	  uint idx;
	  _BitScanForward64(idx, b);
	  return (Square) idx;
	}

	public static Square msb(ulong b)
	{
	  Debug.Assert(b);
	  uint idx;
	  _BitScanReverse64(idx, b);
	  return (Square) idx;
	}

/// Software fall-back of lsb() and msb() for CPU lacking hardware support


#else

#define NO_BSF

#if NO_BSF
    public static Square lsb(ulong b)
    {
        Debug.Assert(b);
        return BSFTable[GlobalMembersBitboard.bsf_index(b)];
    }
    public static Square msb(ulong b)
    {

        Debug.Assert(b);
        uint b32;
        int result = 0;

        if (b > 0xFFFFFFFF)
        {
            b >>= 32;
            result = 32;
        }

        b32 = (uint)b;

        if (b32 > 0xFFFF)
        {
            b32 >>= 16;
            result += 16;
        }

        if (b32 > 0xFF)
        {
            b32 >>= 8;
            result += 8;
        }

        return Square(result + MSBTable[b32]);
    }

#endif


    /// pop_lsb() finds and clears the least significant bit in a non-zero bitboard

    public static Square pop_lsb(ref ulong b)
    {
        Square s = GlobalMembersBenchmark.lsb(b);
        b &= b - 1;
        return s;
    }


    /// frontmost_sq() and backmost_sq() return the square corresponding to the
    /// most/least advanced bit relative to the given color.

    public static Square frontmost_sq(Color c, ulong b)
    {
        return c == ((int)Color.WHITE) != 0 ? GlobalMembersBenchmark.msb(b) : GlobalMembersBenchmark.lsb(b);
    }
    public static Square backmost_sq(Color c, ulong b)
    {
        return c == ((int)Color.WHITE) != 0 ? GlobalMembersBenchmark.lsb(b) : GlobalMembersBenchmark.msb(b);
    }


    /*
	  Stockfish, a UCI chess playing engine derived from Glaurung 2.1
	  Copyright (C) 2004-2008 Tord Romstad (Glaurung author)
	  Copyright (C) 2008-2015 Marco Costalba, Joona Kiiski, Tord Romstad
	  Copyright (C) 2015-2016 Marco Costalba, Joona Kiiski, Gary Linscott, Tord Romstad
	
	  Stockfish is free software: you can redistribute it and/or modify
	  it under the terms of the GNU General Public License as published by
	  the Free Software Foundation, either version 3 of the License, or
	  (at your option) any later version.
	
	  Stockfish is distributed in the hope that it will be useful,
	  but WITHOUT ANY WARRANTY; without even the implied warranty of
	  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	  GNU General Public License for more details.
	
	  You should have received a copy of the GNU General Public License
	  along with this program.  If not, see <http://www.gnu.org/licenses/>.
	*/




    //C++ TO C# CONVERTER TODO TASK: The implementation of the following method could not be found:
    //string engine_info(bool to_uci);
    //C++ TO C# CONVERTER TODO TASK: The implementation of the following method could not be found:
    //void prefetch(object addr);
    //C++ TO C# CONVERTER TODO TASK: The implementation of the following method could not be found:
    //void start_logger(string fname);

    //C++ TO C# CONVERTER TODO TASK: The implementation of the following method could not be found:
    //void dbg_hit_on(bool b);
    //C++ TO C# CONVERTER TODO TASK: The implementation of the following method could not be found:
    //void dbg_hit_on(bool c, bool b);
    //C++ TO C# CONVERTER TODO TASK: The implementation of the following method could not be found:
    //void dbg_mean_of(int v);
    //C++ TO C# CONVERTER TODO TASK: The implementation of the following method could not be found:
    //void dbg_print();


    public static std.chrono.milliseconds.rep now()
    {
        return std.chrono.duration_cast<std.chrono.milliseconds>(std.chrono.steady_clock.now().time_since_epoch()).count();
    }

    //C++ TO C# CONVERTER TODO TASK: The original C++ template specifier was replaced with a C# generic specifier, which may not produce the same behavior:
    //ORIGINAL LINE: template<class Entry, int Size>
    //C++ TO C# CONVERTER TODO TASK: The implementation of the following method could not be found:
    //std::ostream operator <<(std::ostream NamelessParameter1, SyncCout NamelessParameter2);



    public static byte[] PopCnt16 = new byte[1 << 16];
    public static int[,] SquareDistance = new int[(int)Square.SQUARE_NB, (int)Square.SQUARE_NB];

    public static ulong[] RookMasks = new ulong[(int)Square.SQUARE_NB];
    public static ulong[] RookMagics = new ulong[(int)Square.SQUARE_NB];
    //C++ TO C# CONVERTER TODO TASK: C# does not have an equivalent for pointers to value types:
    //ORIGINAL LINE: ulong* RookAttacks[SQUARE_NB];
    public static ulong[] RookAttacks = new ulong[(int)Square.SQUARE_NB];
    public static uint[] RookShifts = new uint[(int)Square.SQUARE_NB];

    public static ulong[] BishopMasks = new ulong[(int)Square.SQUARE_NB];
    public static ulong[] BishopMagics = new ulong[(int)Square.SQUARE_NB];
    //C++ TO C# CONVERTER TODO TASK: C# does not have an equivalent for pointers to value types:
    //ORIGINAL LINE: ulong* BishopAttacks[SQUARE_NB];
    public static ulong[] BishopAttacks = new ulong[(int)Square.SQUARE_NB];
    public static uint[] BishopShifts = new uint[(int)Square.SQUARE_NB];

    public static ulong[] SquareBB = new ulong[(int)Square.SQUARE_NB];
    public static ulong[] FileBB = new ulong[(int)File.FILE_NB];
    public static ulong[] RankBB = new ulong[(int)Rank.RANK_NB];
    public static ulong[] AdjacentFilesBB = new ulong[(int)File.FILE_NB];
    public static ulong[,] InFrontBB = new ulong[(int)Color.COLOR_NB, (int)Rank.RANK_NB];
    public static ulong[,] StepAttacksBB = new ulong[(int)Piece.PIECE_NB, (int)Square.SQUARE_NB];
    public static ulong[,] BetweenBB = new ulong[(int)Square.SQUARE_NB, (int)Square.SQUARE_NB];
    public static ulong[,] LineBB = new ulong[(int)Square.SQUARE_NB, (int)Square.SQUARE_NB];
    public static ulong[,] DistanceRingBB = new ulong[(int)Square.SQUARE_NB, 8];
    public static ulong[,] ForwardBB = new ulong[(int)Color.COLOR_NB, (int)Square.SQUARE_NB];
    public static ulong[,] PassedPawnMask = new ulong[(int)Color.COLOR_NB, (int)Square.SQUARE_NB];
    public static ulong[,] PawnAttackSpan = new ulong[(int)Color.COLOR_NB, (int)Square.SQUARE_NB];
    public static ulong[,] PseudoAttacks = new ulong[(int)PieceType.PIECE_TYPE_NB, (int)Square.SQUARE_NB];

    // De Bruijn sequences. See chessprogramming.wikispaces.com/BitScan
    public const ulong DeBruijn64 = 0x3F79D71B4CB0A89UL;
    public const uint DeBruijn32 = 0x783A9B23;

    public static int[] MSBTable = new int[256]; // To implement software msb()
    public static Square[] BSFTable = new Square[(int)Square.SQUARE_NB]; // To implement software bitscan
    public static ulong[] RookTable = new ulong[0x19000]; // To store rook attacks
    public static ulong[] BishopTable = new ulong[0x1480]; // To store bishop attacks

    typedef uint (Fn) (Square, ulong);

  // init_magics() computes all rook and bishop attacks at startup. Magic
  // bitboards are used to look up attacks of sliding pieces. As a reference see
  // chessprogramming.wikispaces.com/Magic+Bitboards. In particular, here we
  // use the so called "fancy" approach.


	  public static void init_magics(ulong[] table, ulong[] attacks, ulong[] magics, ulong[] masks, uint[] shifts, Square[] deltas, Fn index)
    {

        int[,] seeds =
        {
            {8977, 44560, 54343, 38998, 5731, 95205, 104912, 17020},
            {728, 10316, 55013, 32803, 12281, 15100, 16645, 255}
        };

        ulong[] occupancy = new ulong[4096];
        ulong[] reference = new ulong[4096];
        ulong edges;
        ulong b;
        int[] age = new int[4096];
        int current = 0;
        int i;
        int size;

        // attacks[s] is a pointer to the beginning of the attacks table for square 's'
        attacks[(int)Square.SQ_A1] = table;

        for (Square s = Square.SQ_A1; s <= Square.SQ_H8; ++s)
        {
            // Board edges are not considered in the relevant occupancies
            edges = ((Rank1BB | Rank8BB) & ~GlobalMembersBenchmark.rank_bb(s)) | ((FileABB | FileHBB) & ~GlobalMembersBenchmark.file_bb(s));

            // Given a square 's', the mask is the bitboard of sliding attacks from
            // 's' computed on an empty board. The index must be big enough to contain
            // all the attacks for each possible subset of the mask and so is 2 power
            // the number of 1s of the mask. Hence we deduce the size of the shift to
            // apply to the 64 or 32 bits word to get the index.
            masks[(int)s] = GlobalMembersBitboard.sliding_attack(deltas, s, 0) & ~edges;
            shifts[(int)s] = (Is64Bit ? 64 : 32) - GlobalMembersBenchmark.popcount(masks[(int)s]);

            // Use Carry-Rippler trick to enumerate all subsets of masks[s] and
            // store the corresponding sliding attack bitboard in reference[].
            b = size = 0;
            do
            {
                occupancy[size] = b;
                reference[size] = GlobalMembersBitboard.sliding_attack(deltas, s, b);

                if (HasPext)
                {
                    attacks[(int)s][(b, m)(0)(b, masks[(int)s])] = reference[size];
                }

                size++;
                b = (b - masks[(int)s]) & masks[(int)s];
            } while (b);

            // Set the offset for the table of the next square. We have individual
            // table sizes for each square with "Fancy Magic Bitboards".
            if (s < Square.SQ_H8)
            {
                attacks[(int)s + 1] = attacks[(int)s] + size;
            }

            if (HasPext)
                continue;

            PRNG rng = new PRNG(seeds[Is64Bit, (int)GlobalMembersBenchmark.rank_of(s)]);

            // Find a magic for square 's' picking up an (almost) random number
            // until we find the one that passes the verification test.
            do
            {
                do
                {
                    magics[(int)s] = rng.sparse_rand<ulong>();
                } while (GlobalMembersBenchmark.popcount((magics[(int)s] * masks[(int)s]) >> 56) < 6);

                // A good magic must map every possible occupancy to an index that
                // looks up the correct sliding attack in the attacks[s] database.
                // Note that we build up the database for square 's' as a side
                // effect of verifying the magic.
                for (++current, i = 0; i < size; ++i)
                {
                    uint idx = index(s, occupancy[i]);

                    if (age[idx] < current)
                    {
                        age[idx] = current;
                        attacks[(int)s][idx] = reference[i];
                    }
                    else if (attacks[(int)s][idx] != reference[i])
                        break;
                }
            } while (i < size);
        }
    }

    // bsf_index() returns the index into BSFTable[] to look up the bitscan. Uses
    // Matt Taylor's folding for 32 bit case, extended to 64 bit by Kim Walisch.

    public static uint bsf_index(ulong b)
    {
        b ^= b - 1;
        return Is64Bit ? (b * DeBruijn64) >> 58 : (((uint)b ^ (uint)(b >> 32)) * DeBruijn32) >> 26;
    }


    // popcount16() counts the non-zero bits using SWAR-Popcount algorithm

    public static uint popcount16(uint u)
    {
        u -= (u >> 1) & 0x5555U;
        u = ((u >> 2) & 0x3333U) + (u & 0x3333U);
        u = ((u >> 4) + u) & 0x0F0FU;
        return (u * 0x0101U) >> 8;
    }
#endif

    public static ulong sliding_attack(Square[] deltas, Square sq, ulong occupied)
    {

        ulong attack = 0;

        for (int i = 0; i < 4; ++i)
        {
            for (Square s = sq + deltas[i]; GlobalMembersBenchmark.is_ok(s) && GlobalMembersBenchmark.distance(s, s - deltas[i]) == 1; s += deltas[i])
            {
                attack |= s;

                if ((occupied & (int)s) != 0)
                    break;
            }
        }

        return attack;
    }
}

/// A move needs 16 bits to be stored
///
/// bit  0- 5: destination square (from 0 to 63)
/// bit  6-11: origin square (from 0 to 63)
/// bit 12-13: promotion piece type - 2 (from KNIGHT-2 to QUEEN-2)
/// bit 14-15: special move flag: promotion (1), en passant (2), castling (3)
/// NOTE: EN-PASSANT bit is set only when a pawn can be captured
///
/// Special cases are MOVE_NONE and MOVE_NULL. We can sneak these in because in
/// any normal move destination square is always different from origin square
/// while MOVE_NONE and MOVE_NULL have the same origin and destination square.

public enum Move : int
{
    MOVE_NONE,
    MOVE_NULL = 65
}

public enum MoveType
{
    NORMAL,
    PROMOTION = 1 << 14,
    ENPASSANT = 2 << 14,
    CASTLING = 3 << 14
}

public enum Color
{
    WHITE,
    BLACK,
    NO_COLOR,
    COLOR_NB = 2
}

public enum CastlingSide
{
    KING_SIDE,
    QUEEN_SIDE,
    CASTLING_SIDE_NB = 2
}

public enum CastlingRight
{
    NO_CASTLING,
    WHITE_OO,
    WHITE_OOO = WHITE_OO << 1,
    BLACK_OO = WHITE_OO << 2,
    BLACK_OOO = WHITE_OO << 3,
    ANY_CASTLING = WHITE_OO | WHITE_OOO | BLACK_OO | BLACK_OOO,
    CASTLING_RIGHT_NB = 16
}

//C++ TO C# CONVERTER TODO TASK: C++ template specifiers with non-type parameters cannot be converted to C#:
//ORIGINAL LINE: template<Color C, CastlingSide S>
public class MakeCastling<Color C, CastlingSide S>
{
    //C++ TO C# CONVERTER TODO TASK: C# does not allow bit fields:
    public static const CastlingRight right = C == ((int)Color.WHITE) != 0 ? S == ((int)CastlingSide.QUEEN_SIDE) != 0 ? CastlingRight.WHITE_OOO : CastlingRight.WHITE_OO : S == ((int)CastlingSide.QUEEN_SIDE) != 0 ? CastlingRight.BLACK_OOO : CastlingRight.BLACK_OO;
}

public enum Phase
{
    PHASE_ENDGAME,
    PHASE_MIDGAME = 128,
    MG = 0,
    EG = 1,
    PHASE_NB = 2
}

public enum ScaleFactor
{
    SCALE_FACTOR_DRAW = 0,
    SCALE_FACTOR_ONEPAWN = 48,
    SCALE_FACTOR_NORMAL = 64,
    SCALE_FACTOR_MAX = 128,
    SCALE_FACTOR_NONE = 255
}

public enum Bound
{
    BOUND_NONE,
    BOUND_UPPER,
    BOUND_LOWER,
    BOUND_EXACT = BOUND_UPPER | BOUND_LOWER
}

public enum Value : int
{
    VALUE_ZERO = 0,
    VALUE_DRAW = 0,
    VALUE_KNOWN_WIN = 10000,
    VALUE_MATE = 32000,
    VALUE_INFINITE = 32001,
    VALUE_NONE = 32002,

    VALUE_MATE_IN_MAX_PLY = VALUE_MATE - 2 * MAX_PLY,
    VALUE_MATED_IN_MAX_PLY = -VALUE_MATE + 2 * MAX_PLY,

    PawnValueMg = 188,
    PawnValueEg = 248,
    KnightValueMg = 753,
    KnightValueEg = 832,
    BishopValueMg = 826,
    BishopValueEg = 897,
    RookValueMg = 1285,
    RookValueEg = 1371,
    QueenValueMg = 2513,
    QueenValueEg = 2650,

    MidgameLimit = 15258,
    EndgameLimit = 3915
}

public enum PieceType
{
    NO_PIECE_TYPE,
    PAWN,
    KNIGHT,
    BISHOP,
    ROOK,
    QUEEN,
    KING,
    ALL_PIECES = 0,
    PIECE_TYPE_NB = 8
}

public enum Piece
{
    NO_PIECE,
    W_PAWN = 1,
    W_KNIGHT,
    W_BISHOP,
    W_ROOK,
    W_QUEEN,
    W_KING,
    B_PAWN = 9,
    B_KNIGHT,
    B_BISHOP,
    B_ROOK,
    B_QUEEN,
    B_KING,
    PIECE_NB = 16
}

public enum Depth
{

    ONE_PLY = 1,

    DEPTH_ZERO = 0 * ONE_PLY,
    DEPTH_QS_CHECKS = 0 * ONE_PLY,
    DEPTH_QS_NO_CHECKS = -1 * ONE_PLY,
    DEPTH_QS_RECAPTURES = -5 * ONE_PLY,

    DEPTH_NONE = -6 * ONE_PLY,
    DEPTH_MAX = MAX_PLY * ONE_PLY
}

//C++ TO C# CONVERTER TODO TASK: There is no equivalent in C# to 'static_assert':
//static_assert(!(ONE_PLY & (ONE_PLY - 1)), "ONE_PLY is not a power of 2");

public enum Square
{
    SQ_A1,
    SQ_B1,
    SQ_C1,
    SQ_D1,
    SQ_E1,
    SQ_F1,
    SQ_G1,
    SQ_H1,
    SQ_A2,
    SQ_B2,
    SQ_C2,
    SQ_D2,
    SQ_E2,
    SQ_F2,
    SQ_G2,
    SQ_H2,
    SQ_A3,
    SQ_B3,
    SQ_C3,
    SQ_D3,
    SQ_E3,
    SQ_F3,
    SQ_G3,
    SQ_H3,
    SQ_A4,
    SQ_B4,
    SQ_C4,
    SQ_D4,
    SQ_E4,
    SQ_F4,
    SQ_G4,
    SQ_H4,
    SQ_A5,
    SQ_B5,
    SQ_C5,
    SQ_D5,
    SQ_E5,
    SQ_F5,
    SQ_G5,
    SQ_H5,
    SQ_A6,
    SQ_B6,
    SQ_C6,
    SQ_D6,
    SQ_E6,
    SQ_F6,
    SQ_G6,
    SQ_H6,
    SQ_A7,
    SQ_B7,
    SQ_C7,
    SQ_D7,
    SQ_E7,
    SQ_F7,
    SQ_G7,
    SQ_H7,
    SQ_A8,
    SQ_B8,
    SQ_C8,
    SQ_D8,
    SQ_E8,
    SQ_F8,
    SQ_G8,
    SQ_H8,
    SQ_NONE,

    SQUARE_NB = 64,

    NORTH = 8,
    EAST = 1,
    SOUTH = -8,
    WEST = -1,

    NORTH_EAST = NORTH + EAST,
    SOUTH_EAST = SOUTH + EAST,
    SOUTH_WEST = SOUTH + WEST,
    NORTH_WEST = NORTH + WEST
}

public enum File : int
{
    FILE_A,
    FILE_B,
    FILE_C,
    FILE_D,
    FILE_E,
    FILE_F,
    FILE_G,
    FILE_H,
    FILE_NB
}

public enum Rank : int
{
    RANK_1,
    RANK_2,
    RANK_3,
    RANK_4,
    RANK_5,
    RANK_6,
    RANK_7,
    RANK_8,
    RANK_NB
}


/// Score enum stores a middlegame and an endgame value in a single integer
/// (enum). The least significant 16 bits are used to store the endgame value
/// and the upper 16 bits are used to store the middlegame value. Take some
/// care to avoid left-shifting a signed int to avoid undefined behavior.
public enum Score : int
{
    SCORE_ZERO
}




public class HashTable<Entry, int Size>
{
    public Entry this[ulong key]
    {
        get
        {
            return table[(uint)key & (Size - 1)];
        }
    }

    private List<Entry> table = new List<Entry>(Size);
}


public enum SyncCout
{
    IO_LOCK,
    IO_UNLOCK
}

//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
//ORIGINAL LINE: #define sync_cout std::cout << IO_LOCK
#define sync_cout
//C++ TO C# CONVERTER NOTE: The following #define macro was replaced in-line:
//ORIGINAL LINE: #define sync_endl std::endl << IO_UNLOCK
#define sync_endl


/// xorshift64star Pseudo-Random Number Generator
/// This class is based on original code written and dedicated
/// to the public domain by Sebastiano Vigna (2014).
/// It has the following characteristics:
///
///  -  Outputs 64-bit numbers
///  -  Passes Dieharder and SmallCrush test batteries
///  -  Does not require warm-up, no zeroland to escape
///  -  Internal state is a single 64-bit integer
///  -  Period is 2^64 - 1
///  -  Speed: 1.60 ns/call (Core i7 @3.40GHz)
///
/// For further analysis see
///   <http://vigna.di.unimi.it/ftp/papers/xorshift.pdf>

public class PRNG
{

    private ulong s;

    private ulong rand64()
    {

        s ^= s >> 12, s ^= s << 25, s = s >> 27;
        return s * 2685821657736338717L;
    }

    public PRNG(ulong seed)
    {
        this.s = seed;
        Debug.Assert(seed);
    }

    //C++ TO C# CONVERTER TODO TASK: The original C++ template specifier was replaced with a C# generic specifier, which may not produce the same behavior:
    //ORIGINAL LINE: template<typename T>
    public T rand<T>()
    {
        return T(rand64());
    }

    /// Special generator used to fast init magic numbers.
    /// Output values only have 1/8th of their bits set on average.
    //C++ TO C# CONVERTER TODO TASK: The original C++ template specifier was replaced with a C# generic specifier, which may not produce the same behavior:
    //ORIGINAL LINE: template<typename T>
    public T sparse_rand<T>()
    {
        return T(rand64() & rand64() & rand64());
    }
}

//C++ TO C# CONVERTER NOTE: C# does not allow anonymous namespaces:
//namespace




//C++ TO C# CONVERTER NOTE: C# does not allow anonymous namespaces:
//namespace
