/*******************************************************************************************
 * Initiate and Decision making class.******************************************************
 * Ramin Edjlal*****************************************************************************
 * Call Of Constructor From Constructor***************************************************0.12**4**Managements and Cuation Programing**********************(+)
 * The Storing AllDraw Object in Self Constructor Caused Stack Overflow*******************0.12**4**Managements and Cuation Programing**********************(+)
 * Link List Of Storing String Caused A Stack Over Flow***********************************0.12**4**Managements and Cuation Programing**********************(+)
 * Wait For Finished Current AStarGreedy Caused To Long Time*************************************0.12**4**Managements and Cuation Programing**********************(+)
 * Need To Heuristic (Arvin) Function(s) to Manage Cell in Form1**************************0.12**4**Managements and Cuation Programing**********************(+)
 * First Scanning Movements of Things Anomaly*********************************************0.12**4**Managements and Cuation Programing**********************(+)
 * In Current Version of Heuristic Table Doesn’t Reached(Zero)****************************0.12**4**Managements and Cuation Programing**********************(+)
 * In Current Version InitiateForEveryThisngsHome Dosn't Work*****************************0.12**4**Managements and Cuation Programing**********************(+)
 * In This Version Thinking Taking A LotofTime(AStarGreedyt Array Tree)**********************0.12**4**Managements and Cuation Programing**********************(+)
 * Heuristic Work In AStarGreedys. But Scanning Dosen’t Works************************************0.12**4**Managements and Cuation Programing**********************(+)
 * Adding Clone Caused To Stack Overflow**************************************************0.12**4**Managements and Cuation Programing**********************(+)
 * Clone Caused To StackOverFlow**********************************************************0.12**4**Managements and Cuation Programing**********************(+)
 * Row And Column Become Zero in Virtualization*******************************************0.12**4**Managements and Cuation Programing**********************(+)
 * Initiate Error*************************************************************************0.12**4**Managements and Cuation Programing**********************(+)
 * Seems To Be Logical Drawing ***********************************************************0.12**4**Managements and Cuation Programing**********************(+)
 * Color Suddenly Changing****************************************************************0.12**4**Managements and Cuation Programing**********************(+)
 * AllDraw Object Sub Objects List When Return from local Scope Become Zero.**************0.12**4**Managements and Cuation Programing**********************(+)
 * Huristic Dosn't Work*******************************************************************0.12**4**Managements and Cuation Programing**********************(+)
 * Color Order Of Visualization Changed Suddenly******************************************0.12**4**Managements and Cuation Programing**********************(+)
 * Color Changes with no movement*********************************************************0.12**4**Managements and Cuation Programing**********************(+)
 * Table Not Gate (Inversion of Table List) Doesn’t help to do Normally*******************0.12**4**Managements and Cuation Programing**********************(+)
 * Literally Errors Correction************************************************************0.12**4**Managements and Cuation Programing**********************(+)
 * From Arrangements of Things Reaches Suddenly Things Location OccuRS********************0.12**4**Managements and Cuation Programing**********************(+)
 * The Arrangements is Logical************************************************************0.12**4**Managements and Cuation Programing**********************(+)
 * The Color changes and the arrangements changes are not clearly obvious*****************0.12**4**Managements and Cuation Programing**********************(+)
 * Color Changes Solved. no movements*****************************************************0.12**4**Managements and Cuation Programing**********************(+)(-+)
 * Things movements Anomally**************************************************************0.12**4**Managements and Cuation Programing**********************(+)
 * Chess Rules Anomally*******************************************************************0.12**4**Managements and Cuation Programing**********************(+)
 * Heuristic Function Not Work************************************************************0.12**4**Managements and Cuation Programing**********************(+)
 * Heuristic Work But the Table is Empty**************************************************0.12**4**Managements and Cuation Programing**********************(+)
 * Table is Not Empty But the Movement is Not Logical*************************************0.12**4**Managements and Cuation Programing**********************(+)
 * Clear Dirty Part.**********************************************************************0.88**1**Risk Control********************************************(*)QC-OK.
 * Need to Restricted Approval. Taking a lot of time Thinking Computation*****************0.12**4**Managements and Cuation Programing**********************(+)
 * No movements In Virtualization*********************************************************0.12**4**Managements and Cuation Programing**********************(+)
 * Chess Rules Abnormal thinking movements. No movement greater than 2********************0.12**4**Managements and Cuation Programing**********************(+)
 * Problem For Drawing of Thinking Things*************************************************0.12**4**Managements and Cuation Programing**********************(+)
 * Heuristic Constant Result**************************************************************0.12**4**Managements and Cuation Programing**********************(+)
 * One movements Right .Heuristic Remaining Constant Results******************************0.12**4**Managements and Cuation Programing**********************(+)
 * Constant Heuristic Result**************************************************************0.12**4**Managements and Cuation Programing**********************(+)
 * Need To Add A Heuristic Useful Another*************************************************0.12**4**Managements and Cuation Programing**********************(+)
 * Heuristic Function Does’ Work Allis suddenly Become Zero that Previously Working*******0.12**4**Managements and Cuation Programing**********************(+)
 * No Movement Greater than one order in Computer 'Alice'*********************************0.12**4**Managements and Cuation Programing**********************(+)
 * Tow movements in Computer 'Alice' Of two Different Order Color*************************0.12**4**Managements and Cuation Programing**********************(+)
 * Heuristic Not Work Greater than 3 Length Count of A************************************0.12**4**Managements and Cuation Programing**********************(+)
 * 'They Don't Really Take care about us'. Misleading in Heuristic King Supported*********0.12**4**Managements and Cuation Programing**********************(+)
 * Non Order Movments*********************************************************************0.12**4**Managements and Cuation Programing**********************(+)
 * Misleading at Stage three. no illegal movement greater than three**********************0.12**4**Managements and Cuation Programing**********************(+)
 * Thinking Order Misleading**************************************************************0.12**4**Managements and Cuation Programing**********************(+)
 * Hit Mechanism Malfunctional************************************************************0.12**4**Managements and Cuation Programing**********************(+)
 * Tow movements At One 'Alice' Order time************************************************0.12**4**Managements and Cuation Programing**********************(+)
 * Heuristic Computer By Computer 'Alice' by 'Bob' Caused to Loop Heuristic.**************0.12**4**Managements and Cuation Programing**********************(+)
 * Learning Automata of Quantum also leads to re loop heuristic***************************0.88**1**Risk Control********************************************(*)QC-OK.
 * Heuristic Learning Automata 'Alice' By 'Bob' Leads to Re loop**************************0.12**4**Managements and Cuation Programing**********************(+)
 * Heuristic Things Loop 'Alice' By 'Bob'*************************************************0.12**4**Managements and Cuation Programing**********************(+)
 * Self 'Check' Detection Failure By 'Alice'***********************************************0.12**4**Managements and Cuation Programing**********************(+)
 * 'Penalty' Value Of All Become zero althouth the one should be non Penalty**************0.88**1**Risk Control********************************************(*)
 * Clone Dosn't Copy All Content of AllDraw Dummy*****************************************0.12**4**Managements and Cuation Programing**********************(+)
 * CheckRemovable By Self King Solved.Penalty Action Misleading****************************0.88**1**Risk Control********************************************(-*)QC-OK.
 * 'Check' Detection Failure***************************************************************0.12**4**Managements and Cuation Programing**********************(+)
 * Mechanisam Of Order in Predict Failed.*************************************************0.12**4**Managements and Cuation Programing**********************(+)
 * 'Alice' King Virtualization or Table Content of King Misleading************************0.12**4**Managements and Cuation Programing**********************(+)
 * With The All Things Huristic Signing Mechnisam Some Movments become null Table.********0.12**4**Managements and Cuation Programing**********************(+)
 * AStarGreedy First Search Not Working. Misleading MalFunction Virtualization.******************0.12**4**Managements and Cuation Programing**********************(+)
 * AStarGreedy First Table is Null at Bob Order.*************************************************0.12**4**Managements and Cuation Programing**********************(+)
 * AStarGreedy First SetVirtualization and Table Misleading By Alice.****************************0.12**4**Managements and Cuation Programing**********************(+)
 * No Reason Logically For MalFunction  Refrigtz.Timer AStarGreedy First Dynamic Refrigtz.Timer.*******************0.12**4**Managements and Cuation Programing**********************(+)
 * AStarGreedyt Thinking Taking a lot of time.***********************************************0.12**4**Managements and Cuation Programing**********************([+]
 * AStarGreedy First Not Work.*******************************************************************0.12**4**Managements and Cuation Programing**********************[+]
 * AStarGreedy First Not Work.Refrigtz.Timer Stop At Greater than 2,3,4,5,6,7 Movments.*******************0.12**4**Managements and Cuation Programing**********************[+]
 * No Reason For MalFunction of AStarGreedytNotFoundHuristicAStarGreedyt.***********************0.12**4**Managements and Cuation Programing**********************[+]
 * Problem Solved.No Reason to NullExeption of AStarGreedytHuristic Algorithm.***************0.88**1**Risk Control********************************************[-*]QC-OK.
 * Function Evaluation Disabled .At Initiate AStarGreedytGenetic Found Sysntax.**************0.88**1**Risk Control********************************************[*]
 * Index Was Out Of Range Exeption Was Not Handled.Colud Not Be Handle.*******************0.12**4**Managements and Cuation Programing**********************{+}
 * No Logical Mechanism To Reconstructe Current AllDraw Objects.**************************0.12**4**Managements and Cuation Programing**********************{+}
 * AStarGreedy First Sysntax is legal and The table is constant table.***************************0.12**4**Managements and Cuation Programing**********************{+}
 * Table Content Empty. No Syntax Exist.**************************************************0.12**4**Managements and Cuation Programing**********************{+}
 * Game Begin From First When the Soldiers Move Ordinary Complete in AStarGreedy First***********0.88**1**Risk Control********************************************{*}QC-OK.
 * New Instatnt Of Program Cuase to Begin Fron First.*************************************0.12**4**Managements and Cuation Programing**********************<+>
 * No Logically Reason For New Game Of Program. New Instatnt Not Detected.****************0.12**4**Managements and Cuation Programing**********************<+>
 * Internal New Instatnt Of FormeRefregitz is MalFunction.********************************0.12**4**Managements and Cuation Programing**********************<+>
 * AStarGreedy First CC Changes to CC Normal Game.***********************************************0.12**4**Managements and Cuation Programing**********************<+>
 * Game CC UnContoroled.******************************************************************0.12**4**Managements and Cuation Programing**********************<+>
 * MalFunction of Syntax and Movments.By Alice and Bob.***********************************0.12**4**Managements and Cuation Programing**********************<+>
 * Threading Solved! The OutOfRangeIndex Not Work.****************************************0.12**4**Managements and Cuation Programing**********************[-+]
 * Vituallization error!No Best Matches between Truth of table content and irtualization**0.12**4**Managements and Cuation Programing**********************[+]
 * Dynamic Programming for Stroring ADraw THISDummy Adraw Value MalFunction.**************0.12**4**Managements and Cuation Programing**********************(+)
 * Order is Constant in Dynamic Programming.**********************************************0.12**4**Managements and Cuation Programing**********************(+)
 * Table MalFunction at Dynamic Programming.At Step 3.************************************0.12**4**Managements and Cuation Programing**********************(+)
 * Some Movments are MalFuncational at Dynamic Programming.*******************************0.12**4**Managements and Cuation Programing**********************(+)
 * Huristic Overlay Tow Part of ADraw and StoreADraw Sections at Different levels Tab Cal.0.12**4**Managements and Cuation Programing**********************(+)
 * Not to be needing again calculation. MalFunction is depend of tow part.****************0.12**4**Managements and Cuation Programing**********************(+)
 * BackWard Loos of Things AllDraw Mechnisam.*********************************************0.88**1**Risk Control********************************************(*)QC-OK.
 * Some Dynamic Programming MalFunction Movments.*****************************************0.88**1**Risk Control********************************************(*)QC-OK.
 * Syntax and Forward and Backward Movments Syntax is MalFunction.************************0.12**4**Managements and Cuation Programing**********************<+>
 * Database and Virtualization Forward and Backward MalFunction***************************0.12**4**Managements and Cuation Programing**********************<+>
 * Reproduction of Thinfs Missleading.****************************************************0.88**1**Risk Control********************************************<*>QC-OK.
 * Reproduction of Some Things are MalFunction Movments.**********************************0.12**4**Managements and Cuation Programing**********************{+}
 * AStarGreedy Count of Dynamic Programming Misleadig.AStarGreedy Operation Count Mal Function.*********0.88**1**Risk Control********************************************(*)QC-OK.
 * Huristic By Alice is MalFunction.******************************************************0.12**4**Managements and Cuation Programing**********************(+)
 * ObjectDanger Identification By Alice is MalFunction.*****************************************0.12**4**Managements and Cuation Programing**********************(+)
 * Check Identification By Alice is MalFunction.*******************************************0.12**4**Managements and Cuation Programing**********************(+)
 * Check Recognized But CheckMate Not Recognized!***********************************************0.12**4**Managements and Cuation Programing**********************(_+)
 * Penalty Regard Mechanism Misleading.***************************************************0.12**4**Managements and Cuation Programing**********************{+}
 * Inhereted LearningAtamata Caused to Shared Parent Allocated Variable.******************0.12**4**Managements and Cuation Programing**********************{+}
 * 'Check' By 'Alice' Not Removed Unreasonably.********************************************0.88**1**Risk Control********************************************{*}QC-OK.
 * AStarGreedyt Huristic Found MalFunction at Check Alice.************************************0.12**4**Managements and Cuation Programing**********************{+}
 * Sortments of ADRAW and Construction is MalFunction at AStarGreedy Dynamic Programming.********0.12**4**Managements and Cuation Programing**********************{+}
 * Huristic AStarGreedy First were Worked Out Unreasonably such Situation(Golden Sword Magic).***0.88**1**Risk Control********************************************{*}QC-OK.
 * Converted 'King' of 'Alice' to 'Elephant' UnReasonably.********************************0.12**4**Managements and Cuation Programing**********************(+)
 * 'Long Game' ; But MalFunction of Game.*************************************************0.12**4**Managements and Cuation Programing**********************(+)
 * 'Always' in Current game is 'Bob'.*****************************************************0.12**4**Managements and Cuation Programing**********************(+)
 * Current Table of ADRAW is Correct Table But the Game is MalFunction.*******************0.12**4**Managements and Cuation Programing**********************(+)
 * Move of Current Table AStarGreedy First Huristic found ;found an ovelay in 'Bob' and 'Alice'**0.12**4**Managements and Cuation Programing**********************(+)
 * Current Table in High Level Become Null and prevent of 'LongGame' Strategy.************0.12**4**Managements and Cuation Programing**********************(+)
 * 'LongGame' Become short Undetectably Unreasonably;Clear Store Non Detectably.**********0.88**1**Risk Control********************************************(*)QC-OK.
 * All Draw AStarGreedy First section some movments have not been accurred considerably.*********0.88**1**Risk Control********************************************(*)QC-OK.
 * 'Long Game' Breaks Suddendly without Monitor Caused.***********************************0.12**4**Managements and Cuation Programing**********************{+}
 * Overlay Some Movments of 'Long Game' Breaked.Caused Probability to break.**************0.12**4**Managements and Cuation Programing**********************{+}
 * SomeTimes All Situation of Current Games Become Cleared and No Table Founded.**********0.12**4**Managements and Cuation Programing**********************{+}
 * Gray Soldeir is Only Movmnets and Converts in Huristic and No Move are detectable.*****0.12**4**Managements and Cuation Programing**********************{+}
 * DEEPLY Recursive Tree of Second Version Become in Some Null At Hurristic Finsished.****0.12**4**Managements and Cuation Programing**********************{+}
 * AStarGreedy Huristic Content is Zero. No Calculation of AStarGreedy Huristic Calculation.************0.12**4**Managements and Cuation Programing**********************{+}
 * MalFunction of Dep Huristic Person and MalFunction Movments of CC AStarGreedy Huristic********0.88**1**Risk Control********************************************{*}QC-OK.
 * Mal Function of Reconstruction of AStarGreedy Objects In Initiate AStarGreedy First.*****************0.12**4**Managements and Cuation Programing**********************<+>
 * Hurisic Operantional Have Mal Function Behaviour.**************************************0.12**4**Managements and Cuation Programing**********************<+>
 * Table Zero of AStarGreedy First Huristic Mal Function.****************************************0.12**4**Managements and Cuation Programing**********************<+>
 * AStarGreedy First Initiate Method Result Object Content Mal Function.*************************0.12**4**Managements and Cuation Programing**********************<+>
 * Table Nopt Found Of AStarGreedy First Huristic.Mal Function of Initiate and Huristic.*********0.12**4**Managements and Cuation Programing**********************<+>
 * Table Foundation Successfule. Traversaling of All Tree Not Successfule.****************0.12**4**Managements and Cuation Programing**********************<+>
 * Table Some Movments Intiaiazation Mal Function.****************************************0.12**4**Managements and Cuation Programing**********************{+}
 * BackWard Max Check CheckMate Mechanism For Best Huristic is Unknown**************************0.12**4**Managements and Cuation Programing**********************{+}
 * Minister After Calculation AStarGreedyHuristic At AStarGreedyHuristic becomes Null.******************0.88**1**Risk Control********************************************(*)QC-OK
 * All Objects Possible Movments Not calculating During AStarGreedytSerach Method.***********0.88**1**Risk Control********************************************{*}QC_OK
 * Mechanisam olf AStarGreedytHuristic and Hurisistic is QC-Ok. But Table foundation Illegal.0.88**1**Risk Control********************************************<*>QC-OK
 * Full Game Indexing Parameters Misleading UnLogically.*************************************0.88**1**Risk Control********************************************(*)QC_OK
 * Index out of Range Unlogically at Full Game Soldier Order Brown.**************************0.88**1**Risk Control********************************************<*>QC_OK
 * Execution make zero table but trace make valid table.*************************************0.88**1**Risk Control********************************************{*}Qc-OK.
 * Virtualization need to more hardware capabilities gone to malfunction virtualization.******0.88**1**Risk Control*******************************************{*}QC-BAD.
 * ********************************************************************************************************************************************************(+:Sum(63)) 
 * 1394/12/19**********************************************************************************************************************************************(*:Sum(4))
 * ********************************************************************************************************************************************************(-:sum(2)) (_:Sum(0)):2:(+:Sum(3)) (-:Sum(1)) (*:Sum(2)) 3: (+:Sum(4)) (*:Sum(1)) 4:(+:Sum(6))  5:(+:Sum(2)) (-:Sum(1)) 6:(+:Sum(6)) (*:Sum(2)) 7.(+:Sum(2)) (*:Sum(1)) 8.(+:Sum(1)) 9.(+:Sum(4)) (*:Sum(1)) (-:Sum(1)) 10.(+:Sum(4)) (*:Sum(2)) 11.(+:Sum(4)) 12.(+:Sum(2)) (*:Sum(2)) 13.(+:Sum(4)) 14.(+:Sum(2)) (*:Sum(1)) 15.(+:Sum(6)) 16.(+:Sum(2)) 17.(QC-OK.:Sum(13))
 */
using System;
using System.Collections.Generic;
using System.Text;
using System.Drawing;
using System.Threading;
using System.Threading.Tasks;
using System.IO;
using System.Diagnostics;
namespace RefrigtzW
{



    public class AllDraw
    {
        //Initiate Variables.
        public double MaxHuristicxT = Double.MinValue;
        public bool MovementsAStarGreedyHuristicFoundT = false;
        public bool IgnoreSelfObjectsT = false;
        public bool UsePenaltyRegardMechnisamT = true;
        public bool BestMovmentsT = false;
        public bool PredictHuristicT = true;
        public bool OnlySelfT = false;
        public bool AStarGreedyHuristicT = false;

        public FormRefrigtz THISDummy = null;
        bool ArrangmentsChanged = false;
        bool WaitSome = true;
        bool ThinkingFinished = false;
        public static double AStarGreedytMaxCount = 0;
        public static bool FoundATable = false;
        bool ToFindMovments = false;
        public static double Less = Double.MinValue;
        public bool BridgesKing = false;
        List<int[,]> MaxHuristicAStarGreedytBackWardTable = new List<int[,]>();
        public static int increasedProgress = 0;
        public static double CurrentHuristic = Double.MinValue;
        public static int SignAttack = 100000000;
        public static int SignObjectDangour = 1;
        public static int SignReducedAttacked = 1;
        public static int SignSupport = 1;
        public static int SignHitting = 1;
        public static int SignMovments = 1;
        int Hureturn = 0;
        public static bool DrawTable = false;
        public static int[,] TableVeryfy = new int[8, 8];
        public static int MaxAStarGreedy = 1;
        public static int[,] TableVeryfyConst = new int[8, 8];
        //public static int[,] TableHuristic = new int[8, 8];
        public static List<int[,]> TableCurrent = new List<int[,]>();
        public static bool NoTableFound = false;
        public static bool DynamicAStarGreedytPrograming = false;
        public static List<AllDraw> StoreADraw = new List<AllDraw>();
        public static List<int> StoreADrawAStarGreedy = new List<int>();
        static int LevelAStarGreedyFirsDynamic = 1;
        public static bool UseDoubleTime = false;
        public static int AStarGreedyiLevelMax = 2;
        public static bool AStarGreadyFirstSearch = true;
        public static String ImageRoot = FormRefrigtz.Root + "\\Images";
        public static String ImagesSubRoot = AllDraw.ImageRoot + "\\Fit\\Small\\";
        public static bool RedrawTable = true;
        public static String SyntaxToWrite = "";
        public static bool SodierConversionOcuured = false;
        public static int SodierMovments = 1;
        public static int ElefantMovments = 1;
        public static int HourseMovments = 1;
        public static int BridgeMovments = 1;
        public static int MinisterMovments = 1;
        public static int KingMovments = 1;
        public int SodierMidle = 8;
        public int SodierHigh = 16;
        public int ElefantMidle = 2;
        public int ElefantHigh = 4;
        public int HourseMidle = 2;
        public int HourseHight = 4;
        public int BridgeMidle = 2;
        public int BridgeHigh = 4;
        public int MinisterMidle = 1;
        public int MinisterHigh = 2;
        public int KingMidle = 1;
        public int KingHigh = 2;
        ChessPerdict APredict = null;
        int RW = 0;
        int CL = 0;
        int Ki = 0;
        int RW1 = 0;
        int CL1 = 0;
        int Ki1 = 0;
        double MaxLess1 = 0;
        int RW2 = 0;
        int CL2 = 0;
        int Ki2 = 0;
        double MaxLess2 = 0;
        int RW3 = 0;
        int CL3 = 0;
        int Ki3 = 0;
        double MaxLess3 = 0;
        int RW4 = 0;
        int CL4 = 0;
        int Ki4 = 0;
        double MaxLess4 = 0;
        int RW5 = 0;
        int CL5 = 0;
        int Ki5 = 0;
        double MaxLess5 = 0;
        int RW6 = 0;
        int CL6 = 0;
        int Ki6 = 0;
        double MaxLess6 = 0;
        public static int LoopHuristicIndex = 0;
        static List<int> RWList = new List<int>();
        static List<int> ClList = new List<int>();
        static List<int> KiList = new List<int>();
        static public List<int[,]> TableListAction = new List<int[,]>();
        public int Move = 0;
        static public int MouseClick = 0;
        int[] AStarGreedyIndex = new int[20];
        int AStarGreedyIndexVlue = 0;
        public int[,] CurrentTable = new int[8, 8];
        public List<AllDraw> ADraw = null;
        public List<int[,]> TableList = new List<int[,]>();
        public int AStarGreedy = 0;
        public DrawSoldier[] SolderesOnTable = null;
        public DrawElefant[] ElephantOnTable = null;
        public DrawHourse[] HoursesOnTable = null;
        public DrawBridge[] BridgesOnTable = null;
        public DrawMinister[] MinisterOnTable = null;
        public DrawKing[] KingOnTable = null;
        List<double[]> MaxHuristicAStarGreedytBackWard = new List<double[]>();
        const int MaxSoldeirFounded = 2;
        const int MaxElephntFounded = 6;
        const int MaxHourseFounded = 10;
        const int MaxBridgesFounded = 14;
        const int MaxMinisterFounded = 18;
        const int MaxKingFounded = 22;
        public FormRefrigtz THIS;
        //Error Handling
        static void Log(Exception ex)
        {
            try
            {
                string stackTrace = ex.ToString();
                File.AppendAllText(FormRefrigtz.Root + "\\ErrorProgramRun.txt", stackTrace + ": On" + DateTime.Now.ToString()); // path of file where stack trace will be stored.
            }
            catch (Exception t) { }
        }
        public void SetObjectNumbers(int[,] TabS)
        {
            SodierMidle = 0;
            SodierHigh = 0;
            ElefantMidle = 0;
            ElefantHigh = 0;
            HourseMidle = 0;
            HourseHight = 0;
            BridgeMidle = 0;
            BridgeHigh = 0;
            MinisterMidle = 0;
            MinisterHigh = 0;
            KingMidle = 0;
            KingHigh = 0;
            for (int h = 0; h < 8; h++)
                for (int s = 0; s < 8; s++)
                {
                    if (TabS[h, s] == 1)
                    {
                        SodierMidle++;
                        SodierHigh++;
                    }
                    else if (TabS[h, s] == 2)
                    {
                        ElefantMidle++;
                        ElefantHigh++;
                    }
                    else if (TabS[h, s] == 3)
                    {
                        HourseMidle++;
                        HourseHight++;
                    }
                    else if (TabS[h, s] == 4)
                    {
                        BridgeMidle++;
                        BridgeHigh++;
                    }
                    else if (TabS[h, s] == 5)
                    {
                        MinisterMidle++;
                        MinisterHigh++;
                    }
                    else if (TabS[h, s] == 6)
                    {
                        KingMidle++;
                        KingHigh++;
                    }
                    else
                        if (TabS[h, s] == -1)
                        {
                            SodierHigh++;
                        }
                        else if (TabS[h, s] == -2)
                        {
                            ElefantHigh++;
                        }
                        else if (TabS[h, s] == -3)
                        {
                            HourseHight++;
                        }
                        else if (TabS[h, s] == -4)
                        {
                            BridgeHigh++;
                        }
                        else if (TabS[h, s] == -5)
                        {

                            MinisterHigh++;
                        }
                        else if (TabS[h, s] == -6)
                        {
                            KingHigh++;
                        }
                }
        }
        //Constructor
        public AllDraw(bool MovementsAStarGreedyHuristicTFou, bool IgnoreSelfObject, bool UsePenaltyRegardMechnisa, bool BestMovment, bool PredictHurist, bool OnlySel, bool AStarGreedyHuris, bool Arrangments, ref FormRefrigtz th)
        {
            MaxHuristicxT = Double.MinValue;
            MovementsAStarGreedyHuristicFoundT = MovementsAStarGreedyHuristicTFou;
            IgnoreSelfObjectsT = IgnoreSelfObject;
            UsePenaltyRegardMechnisamT = UsePenaltyRegardMechnisa;
            BestMovmentsT = BestMovment;
            PredictHuristicT = PredictHurist;
            OnlySelfT = OnlySel;
            AStarGreedyHuristicT = AStarGreedyHuris;
            ArrangmentsChanged = Arrangments;
            //Initiayte Locally Variables.
            THIS = th;
            TableList = new List<int[,]>();
            APredict = new ChessPerdict(MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, ref th);
            ADraw = new List<AllDraw>();
            SolderesOnTable = new DrawSoldier[SodierHigh];
            for (int i = 0; i < SodierHigh; i++)
                SolderesOnTable[i] = new DrawSoldier(MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged);
            ElephantOnTable = new DrawElefant[ElefantHigh];
            for (int i = 0; i < ElefantHigh; i++)
                ElephantOnTable[i] = new DrawElefant(MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged);
            HoursesOnTable = new DrawHourse[HourseHight];
            for (int i = 0; i < HourseHight; i++)
                HoursesOnTable[i] = new DrawHourse(MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged);
            BridgesOnTable = new DrawBridge[BridgeHigh];
            for (int i = 0; i < BridgeHigh; i++)
                BridgesOnTable[i] = new DrawBridge(MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged);
            MinisterOnTable = new DrawMinister[MinisterHigh];
            for (int i = 0; i < MinisterHigh; i++)
                MinisterOnTable[i] = new DrawMinister(MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged);
            KingOnTable = new DrawKing[KingHigh];
            for (int i = 0; i < KingHigh; i++)
                KingOnTable[i] = new DrawKing(MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged);


        }
        //Clone Copy Method
        public void Clone(AllDraw AA)
        {
            if (this.TableList.Count == 1)
                this.SetObjectNumbers(this.TableList[0]);
            //Initiate a new class object and clone a copy.
            AA.SolderesOnTable = new DrawSoldier[SodierHigh];
            AA.ArrangmentsChanged = ArrangmentsChanged;
            for (int i = 0; i < SodierHigh; i++)
            {
                try
                {
                    this.SolderesOnTable[i].Clone(ref AA.SolderesOnTable[i]);
                }
                catch (Exception t) { }
            }
            AA.ElephantOnTable = new DrawElefant[ElefantHigh];
            for (int i = 0; i < ElefantHigh; i++)
            {
                try
                {
                    this.ElephantOnTable[i].Clone(ref AA.ElephantOnTable[i]);

                }
                catch (Exception t) { }
            }
            AA.HoursesOnTable = new DrawHourse[HourseHight];
            for (int i = 0; i < HourseHight; i++)
            {
                try
                {
                    this.HoursesOnTable[i].Clone(ref AA.HoursesOnTable[i]);

                }
                catch (Exception t) { }
            }
            AA.BridgesOnTable = new DrawBridge[BridgeHigh];
            for (int i = 0; i < BridgeHigh; i++)
            {
                try
                {
                    this.BridgesOnTable[i].Clone(ref AA.BridgesOnTable[i]);

                }
                catch (Exception t) { }
            }
            AA.MinisterOnTable = new DrawMinister[MinisterHigh];
            for (int i = 0; i < MinisterHigh; i++)
            {
                try
                {
                    this.MinisterOnTable[i].Clone(ref AA.MinisterOnTable[i]);

                }
                catch (Exception t) { }
            }
            AA.KingOnTable = new DrawKing[KingHigh];
            for (int i = 0; i < KingHigh; i++)
            {
                try
                {
                    this.KingOnTable[i].Clone(ref AA.KingOnTable[i]);

                }
                catch (Exception t) { }
            }
            AA.ADraw = new List<AllDraw>();
            AA.AStarGreedy = this.AStarGreedy;
            for (int i = 0; i < this.ADraw.Count; i++)
            {

                AA.ADraw.Add(this.ADraw[i]);
            }
            if (AA.TableList.Count > 0)
                AA.TableList.Clear();
            for (int i = 0; i < this.TableList.Count; i++)
                AA.TableList.Add(this.TableList[i]);
            if (AA.TableList.Count > 0)
                AA.SetObjectNumbers(AA.TableList[0]);
            AA.AStarGreedy = AStarGreedy;

        }
        //aBlanck Constructor
        public AllDraw(bool MovementsAStarGreedyHuristicTFou, bool IgnoreSelfObject, bool UsePenaltyRegardMechnisa, bool BestMovment, bool PredictHurist, bool OnlySel, bool AStarGreedyHuris, bool Arrangments, AllDraw THi)
        {
            MaxHuristicxT = Double.MinValue;
            MovementsAStarGreedyHuristicFoundT = MovementsAStarGreedyHuristicTFou;
            IgnoreSelfObjectsT = IgnoreSelfObject;
            UsePenaltyRegardMechnisamT = UsePenaltyRegardMechnisa;
            BestMovmentsT = BestMovment;
            PredictHuristicT = PredictHurist;
            OnlySelfT = OnlySel;
            AStarGreedyHuristicT = AStarGreedyHuris;
            ArrangmentsChanged = Arrangments;
            ArrangmentsChanged = Arrangments;
        }
        //Check For Thinking Of Current Item Movments Finished.
        public bool AllCurrentAStarGreedyThinkingFinished(AllDraw Dum, int i, int j, int Kind)
        {
            //For All kind of Current Thinking depend of current type consider finshing state thinking.
            bool Finished = false;
            {
                //For Soldier
                if (Kind == 1)
                {

                    if (Dum.SolderesOnTable[i].SoldierThinking[0].ThinkingFinished)
                        return true;
                }
                //For Elephant
                else if (Kind == 2)
                {
                    if (Dum.ElephantOnTable[i].ElefantThinking[0].ThinkingFinished)
                        return true;
                }
                //For Hourse.
                else if (Kind == 3)
                {
                    if (Dum.HoursesOnTable[i].HourseThinking[0].ThinkingFinished)
                        return true;
                }
                //For Bridges.
                else if (Kind == 4)
                {
                    if (Dum.BridgesOnTable[i].BridgeThinking[0].ThinkingFinished)
                        return true;
                }
                //For Minsters.
                else if (Kind == 5)
                {
                    if (Dum.MinisterOnTable[i].MinisterThinking[0].ThinkingFinished)
                        return true;
                }
                //For Kings.
                else if (Kind == 6)
                {
                    if (Dum.KingOnTable[i].KingThinking[0].ThinkingFinished)
                        return true;
                }
            }
            return Finished;

        }
        //Wait For Thinking Of Current Item Finished.
        void Wait(AllDraw Dum, int i, int j, int k, int Kind, bool AStarGreedy)
        {
            //While Thinking not finished do while.
            do
            {
                //Theading.Sleep(1);
            } while (!AllCurrentAStarGreedyThinkingFinished(Dum, i, j, Kind));


        }
        //(Non AStarGreedy First ) Huristic Non Coplement Search Method.
        public void InitiateForEveryKindThingHome(AllDraw DummyHA, int ii, int jj, Color a, int[,] Table, int Order, bool TB, int IN)
        {
            //Initiate Local Variables.
            int i = 0, j = 0;
            AllDraw Dummy = new AllDraw(MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, ref THIS);
            //When Order is Gray.
            if (Order == 1)
            {
                //For All Gray Soldeirs.
                for (i = 0; i < SodierMidle; i++)
                {
                    try
                    {

                        //If there is not Soldeir continue Traversal.
                        if (SolderesOnTable[i] == null)
                            continue;
                        //Store Objective Current Variables in Local Variable.
                        ii = (int)SolderesOnTable[i].Row;
                        jj = (int)SolderesOnTable[i].Column;
                        Table = SolderesOnTable[i].Table;
                        //Construction of New Thinking Dummy Variables depend of Local Variables.
                        Dummy.SolderesOnTable[i] = new DrawSoldier(MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, ii, jj, a, Table, Order, false, i);
                        {
                            //For All Gray Soldeir Movable Situation.
                            for (j = 0; j < AllDraw.SodierMovments; j++)
                            {
                                //Operation of Thinking Iniatation.
                                Dummy.SolderesOnTable[i].SoldierThinking[0].ThinkingBegin = true;
                                Dummy.SolderesOnTable[i].SoldierThinking[0].ThinkingFinished = false;
                                Dummy.SolderesOnTable[i].SoldierThinking[0].t = new Task(new Action(Dummy.SolderesOnTable[i].SoldierThinking[0].Thinking));
                                Dummy.SolderesOnTable[i].SoldierThinking[0].t.Start();
                                //Wait for finishing.
                                //Wait(Dummy, i, j, 0, 1, false);
                                //Dummy.SolderesOnTable[i].SoldierThinking[0].t.Abort();
                                Dummy.SolderesOnTable[i].SoldierThinking[0].t.Wait();

                            }
                        }
                    }
                    catch (Exception t)
                    {
                        Dummy.SolderesOnTable[i] = null;

                    }
                }
                //For all Elefant Gray 
                for (i = 0; i < ElefantMidle; i++)
                {
                    try
                    {
                        //If The Elephant is not exist continue traversal.
                        if (ElephantOnTable[i] == null)
                            continue;
                        //Initiate Objective Elefphant Variables by Local One.
                        ii = (int)ElephantOnTable[i].Row;
                        jj = (int)ElephantOnTable[i].Column;
                        Table = ElephantOnTable[i].Table;
                        //Construction of Elephant Thinking Object by Local Variables.
                        Dummy.ElephantOnTable[i] = new DrawElefant(MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, ii, jj, a, Table, Order, false, i);
                        {
                            //For All Gray Elephant Movable.
                            for (j = 0; j < AllDraw.ElefantMovments; j++)
                            {
                                //Operation of Elephant of Current Gray Thinking.
                                Dummy.ElephantOnTable[i].ElefantThinking[0].ThinkingBegin = true;
                                Dummy.ElephantOnTable[i].ElefantThinking[0].ThinkingFinished = false;
                                Dummy.ElephantOnTable[i].ElefantThinking[0].t = new Task(new Action(Dummy.ElephantOnTable[i].ElefantThinking[0].Thinking));
                                Dummy.ElephantOnTable[i].ElefantThinking[0].t.Start();
                                //Wait for Finishing.
                                //Wait(Dummy, i, j, 0, 2, false);
                                //Dummy.ElephantOnTable[i].ElefantThinking[0].t.Abort();
                                Dummy.ElephantOnTable[i].ElefantThinking[0].t.Wait();
                            }
                        }
                    }

                    catch (Exception t)
                    {
                        Dummy.ElephantOnTable[i] = null;

                    }
                }


                //For All Gray Hourse
                for (i = 0; i < HourseMidle; i++)
                {
                    try
                    {
                        //Igone of Non Exist HourseGray.
                        if (HoursesOnTable[i] == null)
                            continue;
                        //Initae Of Local Variables By Objective Variables.
                        ii = (int)HoursesOnTable[i].Row;
                        jj = (int)HoursesOnTable[i].Column;
                        Table = HoursesOnTable[i].Table;
                        //Construction of Hourse Gray By Local Variables.
                        Dummy.HoursesOnTable[i] = new DrawHourse(MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, ii, jj, a, Table, Order, false, i);


                        {
                            //For All Possible Movments.
                            for (j = 0; j < AllDraw.HourseMovments; j++)
                            {
                                //Thinking of Hourse Current Operation.
                                Dummy.HoursesOnTable[i].HourseThinking[0].ThinkingBegin = true;
                                Dummy.HoursesOnTable[i].HourseThinking[0].ThinkingFinished = false;
                                Dummy.HoursesOnTable[i].HourseThinking[0].t = new Task(new Action(Dummy.HoursesOnTable[i].HourseThinking[0].Thinking));
                                Dummy.HoursesOnTable[i].HourseThinking[0].t.Start();
                                //Wait for Thinking Finsished.
                                //Wait(Dummy, i, j, 0, 3, false);
                                //Dummy.HoursesOnTable[i].HourseThinking[0].t.Abort();
                                Dummy.HoursesOnTable[i].HourseThinking[0].t.Wait();
                            }

                        }
                    }
                    catch (Exception t)
                    {
                        Dummy.HoursesOnTable[i] = null;

                    }
                }



                //For All Possible Gray Bridges
                for (i = 0; i < BridgeMidle; i++)
                {
                    try
                    {
                        //If Bridges NonExist Continue Traversal
                        if (BridgesOnTable[i] == null)
                            continue;
                        //Initiate Local Variables for Objective Parameters.
                        ii = (int)BridgesOnTable[i].Row;
                        jj = (int)BridgesOnTable[i].Column;
                        Table = BridgesOnTable[i].Table;
                        //Construction of Thinking Variables Objective By Local Variables.
                        Dummy.BridgesOnTable[i] = new DrawBridge(MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, ii, jj, a, Table, Order, false, i);

                        {
                            //For All Possible Bridge Movments.
                            for (j = 0; j < AllDraw.BridgeMovments; j++)
                            {
                                //Thinking Of Gray Briges of Current.
                                Dummy.BridgesOnTable[i].BridgeThinking[0].ThinkingBegin = true;
                                Dummy.BridgesOnTable[i].BridgeThinking[0].ThinkingFinished = false;
                                Dummy.BridgesOnTable[i].BridgeThinking[0].t = new Task(new Action(Dummy.BridgesOnTable[i].BridgeThinking[0].Thinking));
                                Dummy.BridgesOnTable[i].BridgeThinking[0].t.Start();
                                //Wait for Thinking Finshing.
                                //Wait(Dummy, i, j, 0, 4, false);
                                //Dummy.BridgesOnTable[i].BridgeThinking[0].t.Abort();
                                Dummy.BridgesOnTable[i].BridgeThinking[0].t.Wait();
                            }

                        }
                    }
                    catch (Exception t)
                    {
                        Dummy.BridgesOnTable[i] = null;

                    }
                }
                //For All Minister Gray Objectes.
                for (i = 0; i < MinisterMidle; i++)
                {
                    try
                    {
                        //For Non Exist Gray Minster Ignore and Continue.
                        if (MinisterOnTable[i] == null)
                            continue;
                        //Initiate Local Variables By Objective Current State.
                        ii = (int)MinisterOnTable[i].Row;
                        jj = (int)MinisterOnTable[i].Column;
                        Table = MinisterOnTable[i].Table;
                        //Construction of Gray Minister Thinking Objectives.
                        Dummy.MinisterOnTable[i] = new DrawMinister(MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, ii, jj, a, Table, Order, false, i);


                        {
                            //For All Possible Movments that is ignored.
                            for (j = 0; j < AllDraw.MinisterMovments; j++)
                            {
                                //Thinking of Current Minister Gray 
                                Dummy.MinisterOnTable[i].MinisterThinking[0].ThinkingBegin = true;
                                Dummy.MinisterOnTable[i].MinisterThinking[0].ThinkingFinished = false;
                                Dummy.MinisterOnTable[i].MinisterThinking[0].t = new Task(new Action(Dummy.MinisterOnTable[i].MinisterThinking[0].Thinking));
                                Dummy.MinisterOnTable[i].MinisterThinking[0].t.Start();
                                //Wait Until Thinking Finished.
                                //Wait(Dummy, i, j, 0, 5, false);
                                //Dummy.MinisterOnTable[i].MinisterThinking[0].t.Abort();
                                Dummy.MinisterOnTable[i].MinisterThinking[0].t.Wait();
                            }

                        }

                    }
                    catch (Exception t)
                    {
                        Dummy.MinisterOnTable[i] = null;

                    }
                }

                //For All Possible Gray Kings Objective.
                for (i = 0; i < KingMidle; i++)
                {
                    try
                    {
                        //Ignore of Non Exists Gray King.
                        if (KingOnTable[i] == null)
                            continue;
                        //Initiate of Local Variables by Objective Current Gray King Variables.
                        ii = (int)KingOnTable[i].Row;
                        jj = (int)KingOnTable[i].Column;
                        Table = KingOnTable[i].Table;
                        //Construction of Gray King Thinking Objects.
                        Dummy.KingOnTable[i] = new DrawKing(MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, ii, jj, a, Table, Order, false, i);


                        {
                            //For All Possible Gray Kings Movments of Current Objects.
                            for (j = 0; j < AllDraw.KingMovments; j++)
                            {
                                //Gray King Thinking Operations.
                                Dummy.KingOnTable[i].KingThinking[0].ThinkingBegin = true;
                                Dummy.KingOnTable[i].KingThinking[0].ThinkingFinished = false;
                                Dummy.KingOnTable[i].KingThinking[0].t = new Task(new Action(Dummy.KingOnTable[i].KingThinking[0].Thinking));
                                Dummy.KingOnTable[i].KingThinking[0].t.Start();
                                //Wait Untile Thinking Finished.
                                //Wait(Dummy, i, j, 0, 6, false);
                                //Dummy.KingOnTable[i].KingThinking[0].t.Abort();
                                Dummy.KingOnTable[i].KingThinking[0].t.Wait();
                            }


                        }
                    }
                    catch (Exception t)
                    {

                        Dummy.KingOnTable[i] = null;
                    }
                }
            }
            //for All brown thinking Operation.
            else
            {
                //For All Brown soldeir Objects.
                for (i = SodierMidle; i < SodierHigh; i++)
                {
                    try
                    {

                        //For Non Exist Brown soldeir continue and Traverse Back.
                        if (SolderesOnTable[i] == null)
                            continue;
                        //Initiate Local Variables By Global Objective Varibales of current Soldier On Consideration.
                        ii = (int)SolderesOnTable[i].Row;
                        jj = (int)SolderesOnTable[i].Column;
                        Table = SolderesOnTable[i].Table;
                        //Construction ofBraown soldeir On Thinking Objects.
                        Dummy.SolderesOnTable[i] = new DrawSoldier(MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, ii, jj, a, Table, Order, false, i);

                        {
                            //For Al Possible Ignored Movments.
                            for (j = 0; j < AllDraw.SodierMovments; j++)
                            {
                                //Thinking of Brown Solder Operations.
                                Dummy.SolderesOnTable[i].SoldierThinking[0].ThinkingBegin = true;
                                Dummy.SolderesOnTable[i].SoldierThinking[0].ThinkingFinished = false;
                                Dummy.SolderesOnTable[i].SoldierThinking[0].t = new Task(new Action(Dummy.SolderesOnTable[i].SoldierThinking[0].Thinking));
                                Dummy.SolderesOnTable[i].SoldierThinking[0].t.Start();
                                //Wait For Thinkings Finishing.
                                //Wait(Dummy, i, j, 0, 1, false);

                                //Dummy.SolderesOnTable[i].SoldierThinking[0].t.Abort();
                                Dummy.SolderesOnTable[i].SoldierThinking[0].t.Wait();

                            }
                        }
                    }
                    catch (Exception t)
                    {
                        Dummy.SolderesOnTable[i] = null;

                    }
                }
                //For All Brown Elephant Objects.
                for (i = ElefantMidle; i < ElefantHigh; i++)
                {
                    try
                    {
                        //When there is not A Objects and is Zero Continue Traveral
                        if (ElephantOnTable[i] == null)
                            continue;
                        //Initiate Local Varibale By Global Object Vriables.
                        ii = (int)ElephantOnTable[i].Row;
                        jj = (int)ElephantOnTable[i].Column;
                        Table = ElephantOnTable[i].Table;
                        //Construction of Current Brown Elephant Thinking Object.
                        Dummy.ElephantOnTable[i] = new DrawElefant(MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, ii, jj, a, Table, Order, false, i);

                        {
                            //For All  Possible Brown Elephant Movments.
                            for (j = 0; j < AllDraw.ElefantMovments; j++)
                            {
                                //Elephant Brown Current Object Thinking Operations.
                                Dummy.ElephantOnTable[i].ElefantThinking[0].ThinkingBegin = true;
                                Dummy.ElephantOnTable[i].ElefantThinking[0].ThinkingFinished = false;
                                Dummy.ElephantOnTable[i].ElefantThinking[0].t = new Task(new Action(Dummy.ElephantOnTable[i].ElefantThinking[0].Thinking));
                                Dummy.ElephantOnTable[i].ElefantThinking[0].t.Start();
                                //Wait For Thinking Finished.
                                //Wait(Dummy, i, j, 0, 2, false);
                                //Dummy.ElephantOnTable[i].ElefantThinking[0].t.Abort();
                                Dummy.ElephantOnTable[i].ElefantThinking[0].t.Wait();
                            }
                        }
                    }

                    catch (Exception t)
                    {
                        Dummy.ElephantOnTable[i] = null;

                    }
                }

                //For All Possible Hourse Objects.
                for (i = HourseMidle; i < HourseHight; i++)
                {
                    try
                    {
                        //If Current Brown Hourse Not Exist Continue.
                        if (HoursesOnTable[i] == null)
                            continue;
                        //Initiate Local Varables By Gobal Objective Global Variables..
                        ii = (int)HoursesOnTable[i].Row;
                        jj = (int)HoursesOnTable[i].Column;
                        Table = HoursesOnTable[i].Table;
                        //Construction of Thinking Objects By Local Variables.
                        Dummy.HoursesOnTable[i] = new DrawHourse(MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, ii, jj, a, Table, Order, false, i);

                        {
                            //For All Possible Current Object Movment.
                            for (j = 0; j < AllDraw.HourseMovments; j++)
                            {
                                //Operation of Brown Current Hourse Thinking.
                                Dummy.HoursesOnTable[i].HourseThinking[0].ThinkingBegin = true;
                                Dummy.HoursesOnTable[i].HourseThinking[0].ThinkingFinished = false;
                                Dummy.HoursesOnTable[i].HourseThinking[0].t = new Task(new Action(Dummy.HoursesOnTable[i].HourseThinking[0].Thinking));
                                Dummy.HoursesOnTable[i].HourseThinking[0].t.Start();
                                //Wait Until Current Hourse Thinking Finished.
                                //Wait(Dummy, i, j, 0, 3, false);
                                //Dummy.HoursesOnTable[i].HourseThinking[0].t.Abort();
                                Dummy.HoursesOnTable[i].HourseThinking[0].t.Wait();
                            }

                        }
                    }
                    catch (Exception t)
                    {
                        Dummy.HoursesOnTable[i] = null;

                    }
                }
                //For All Brown Bridges Objects.
                for (i = BridgeMidle; i < BridgeHigh; i++)
                {
                    try
                    {
                        //Ignore for Current Non Exist Objects and Continue.
                        if (BridgesOnTable[i] == null)
                            continue;
                        //Initiate Local Variable with Global Objects Variables.
                        ii = (int)BridgesOnTable[i].Row;
                        jj = (int)BridgesOnTable[i].Column;
                        Table = BridgesOnTable[i].Table;
                        //Construction of Brown Bridge thinking Object Thinking. 
                        Dummy.BridgesOnTable[i] = new DrawBridge(MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, ii, jj, a, Table, Order, false, i);

                        {
                            for (j = 0; j < AllDraw.BridgeMovments; j++)
                            {
                                //Operational Thinking of Current Brown Bridge.
                                Dummy.BridgesOnTable[i].BridgeThinking[0].ThinkingBegin = true;
                                Dummy.BridgesOnTable[i].BridgeThinking[0].ThinkingFinished = false;
                                Dummy.BridgesOnTable[i].BridgeThinking[0].t = new Task(new Action(Dummy.BridgesOnTable[i].BridgeThinking[0].Thinking));
                                Dummy.BridgesOnTable[i].BridgeThinking[0].t.Start();
                                //Wiat for Finishing of Current Brown Bridge. 
                                //Wait(Dummy, i, j, 0, 4, false);
                                //Dummy.BridgesOnTable[i].BridgeThinking[0].t.Abort();
                                Dummy.BridgesOnTable[i].BridgeThinking[0].t.Wait();
                            }

                        }
                    }
                    catch (Exception t)
                    {
                        Dummy.BridgesOnTable[i] = null;

                    }
                }

                //For All Brown Minister Objects.
                for (i = MinisterMidle; i < MinisterHigh; i++)
                {
                    try
                    {
                        //Ignore of Current Brown Minsiter Object.
                        if (MinisterOnTable[i] == null)
                            continue;
                        //Initiate for Local Variables by Global Current Brown Object.
                        ii = (int)MinisterOnTable[i].Row;
                        jj = (int)MinisterOnTable[i].Column;
                        Table = MinisterOnTable[i].Table;
                        //construction of Brown Minster Thinking Object.
                        Dummy.MinisterOnTable[i] = new DrawMinister(MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, ii, jj, a, Table, Order, false, i);


                        {
                            //for All Possible Brown Minister Movments.
                            for (j = 0; j < AllDraw.MinisterMovments; j++)
                            {
                                //Operational Thinking of Brown Minister 
                                Dummy.MinisterOnTable[i].MinisterThinking[0].ThinkingBegin = true;
                                Dummy.MinisterOnTable[i].MinisterThinking[0].ThinkingFinished = false;
                                Dummy.MinisterOnTable[i].MinisterThinking[0].t = new Task(new Action(Dummy.MinisterOnTable[i].MinisterThinking[0].Thinking));
                                Dummy.MinisterOnTable[i].MinisterThinking[0].t.Start();
                                //Wait Until Thinking Finished.
                                //Wait(Dummy, i, j, 0, 5, false);
                                //Dummy.MinisterOnTable[i].MinisterThinking[0].t.Abort();
                                Dummy.MinisterOnTable[i].MinisterThinking[0].t.Wait();
                            }

                        }

                    }
                    catch (Exception t)
                    {
                        Dummy.MinisterOnTable[i] = null;

                    }
                }
                //For All Possible Brown King Objects.
                for (i = KingMidle; i < KingHigh; i++)
                {
                    try
                    {
                        //Ignore of Current Non Exist Brown King Object and Continue.
                        if (KingOnTable[i] == null)
                            continue;
                        //Initiate of Local varibale By Global Objective Brown King Varibales.
                        ii = (int)KingOnTable[i].Row;
                        jj = (int)KingOnTable[i].Column;
                        Table = KingOnTable[i].Table;
                        //Construction of Brown King Thinking Objects.
                        Dummy.KingOnTable[i] = new DrawKing(MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, ii, jj, a, Table, Order, false, i);

                        {
                            //For All Possible Non Exist and Ignored King Movments.
                            for (j = 0; j < AllDraw.KingMovments; j++)
                            {
                                //Operational Brown King Thinking.
                                Dummy.KingOnTable[i].KingThinking[0].ThinkingBegin = true;
                                Dummy.KingOnTable[i].KingThinking[0].ThinkingFinished = false;
                                Dummy.KingOnTable[i].KingThinking[0].t = new Task(new Action(Dummy.KingOnTable[i].KingThinking[0].Thinking));
                                Dummy.KingOnTable[i].KingThinking[0].t.Start();
                                //Wait Untile Brown King Operation finished.
                                //Wait(Dummy, i, j, 0, 6, false);
                                //Dummy.KingOnTable[i].KingThinking[0].t.Abort();
                                Dummy.KingOnTable[i].KingThinking[0].t.Wait();
                            }

                        }
                    }
                    catch (Exception t)
                    {

                        Dummy.KingOnTable[i] = null;
                    }
                }

            }
            //when AStarGreedy First Thinking finished.
            if (AllDraw.AStarGreadyFirstSearch)
            {
                //Construction of New All Draw Enemy And Self Movments Objects.
                AllDraw AdumnmyConstructed = Dummy.CopyRemeiningItems(this, Order * -1);
                if (ADraw != null)
                    this.ADraw.Clear();
                else
                    this.ADraw = new List<AllDraw>();
                this.ADraw.Add(Dummy);
            }
            else
            {
                if (ADraw != null)
                    this.ADraw = new List<AllDraw>();
                else
                    this.ADraw.Clear();
                this.ADraw.Add(Dummy);
            }

        }
        //Rearrange AllDraw Object Content.
        public void SetRowColumn(int index)
        {
            try
            {
                SetObjectNumbers(TableList[0]);
                Move = 0;
                //Intiate Dummy Variables.
                int So1 = 0;
                int So2 = SodierMidle;
                int El1 = 0;
                int El2 = ElefantMidle;
                int Ho1 = 0;
                int Ho2 = HourseMidle;
                int Br1 = 0;
                int Br2 = BridgeMidle;
                int Mi1 = 0;
                int Mi2 = MinisterMidle;
                int Ki1 = 0;
                int Ki2 = KingMidle;
                //When Conversion Occured.
                //A = new List<AllDraw>();
                SolderesOnTable = new DrawSoldier[SodierHigh];
                for (int i = 0; i < SodierHigh; i++)
                    SolderesOnTable[i] = new DrawSoldier(MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged);
                ElephantOnTable = new DrawElefant[ElefantHigh];
                for (int i = 0; i < ElefantHigh; i++)
                    ElephantOnTable[i] = new DrawElefant(MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged);
                HoursesOnTable = new DrawHourse[HourseHight];
                for (int i = 0; i < HourseHight; i++)
                    HoursesOnTable[i] = new DrawHourse(MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged);
                BridgesOnTable = new DrawBridge[BridgeHigh];
                for (int i = 0; i < BridgeHigh; i++)
                    BridgesOnTable[i] = new DrawBridge(MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged);
                MinisterOnTable = new DrawMinister[MinisterHigh];
                for (int i = 0; i < MinisterHigh; i++)
                    MinisterOnTable[i] = new DrawMinister(MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged);
                KingOnTable = new DrawKing[KingHigh];
                for (int i = 0; i < KingHigh; i++)
                    KingOnTable[i] = new DrawKing(MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged);
                AllDraw.SodierConversionOcuured = false;

                //When Table Exist.
                if (TableList.Count > 0)
                {
                    //For Every Table Things.
                    for (int Column = 0; Column < 8; Column++)
                        for (int Row = 0; Row < 8; Row++)
                        {
                            //When Things are Soldiers.
                            if (System.Math.Abs(this.TableList[index][Row, Column]) == 1)
                            {
                                //Determine Color
                                Color a;

                                if (this.TableList[index][Row, Column] > 0)
                                    a = Color.Gray;
                                else
                                    a = Color.Brown;
                                //When Color is Gray. 
                                if (a == Color.Gray)
                                {
                                    try
                                    {
                                        //When Solders ate current location differs add move.
                                        try
                                        {
                                            if (SolderesOnTable[So1].Row != Row || SolderesOnTable[So1].Column != Column)
                                                Move++;
                                        }
                                        catch (Exception t) { }
                                        //Construct Soder Gray.
                                        SolderesOnTable[So1] = new DrawSoldier(MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, Row, Column, a, this.TableList[index], 1, false, So1);
                                        //Increase So1.
                                        So1++;
                                        if (So1 > SodierMidle)
                                        {
                                            SodierMidle++;
                                            SodierHigh++;
                                        }

                                    }
                                    catch (Exception t)
                                    {

                                    }
                                }
                                //When Color is Brown
                                else
                                {
                                    try
                                    {
                                        //When Solders ate current location differs add move.
                                        try
                                        {
                                            if (SolderesOnTable[So2].Row != Row ||
                                            SolderesOnTable[So2].Column != Column)
                                                Move++;
                                        }
                                        catch (Exception t) { }
                                        //Construct Soldeir Brown.
                                        SolderesOnTable[So2] = new DrawSoldier(MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, Row, Column, a, this.TableList[index], -1, false, So2);
                                        //Increase So2.
                                        So2++;
                                        if (So2 > SodierHigh)
                                            SodierHigh++;
                                    }
                                    catch (Exception t)
                                    {

                                    }
                                }
                            }
                            else //For Elephant Objects.
                                if (System.Math.Abs(this.TableList[index][Row, Column]) == 2)
                                {
                                    //Initiate Local Variables.
                                    Color a;
                                    if (this.TableList[index][Row, Column] > 0)
                                        a = Color.Gray;
                                    else
                                        a = Color.Brown;
                                    //If Gray Elepahnt
                                    if (a == Color.Gray)
                                    {
                                        try
                                        {
                                            try
                                            {
                                                //Calculation of Movment Number.
                                                if (ElephantOnTable[El1].Row != Row ||
                                                    ElephantOnTable[El1].Column != Column)
                                                    Move++;
                                            }
                                            catch (Exception t) { }
                                            //Construction of Draw Object.
                                            ElephantOnTable[El1] = new DrawElefant(MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, Row, Column, a, this.TableList[index], 1, false, El1);
                                            //Increament of Gray Index.
                                            El1++;
                                            //If New Object Increament Gray Objects.
                                            if (El1 > ElefantMidle)
                                            {
                                                ElefantMidle++;
                                                ElefantHigh++;
                                            }
                                        }
                                        catch (Exception t)
                                        {

                                        }
                                    }
                                    else//For Brown Elephant .Objects
                                    {
                                        try
                                        {
                                            try
                                            {
                                                //Calculation of Movments Numbers.
                                                if (ElephantOnTable[El2].Row != Row ||
                                                    ElephantOnTable[El2].Column != Column)
                                                    Move++;
                                            }
                                            catch (Exception t) { }
                                            //Construction of Draw Brown Elephant Object. 
                                            ElephantOnTable[El2] = new DrawElefant(MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, Row, Column, a, this.TableList[index], -1, false, El2);
                                            //Increament of Index.
                                            El2++;
                                            //When New Brown Elephant Object Increament of Index.
                                            if (El2 > ElefantHigh)
                                                ElefantHigh++;

                                        }
                                        catch (Exception t)
                                        {

                                        }

                                    }
                                }
                                else//For Hourse Objects.
                                    if (System.Math.Abs(this.TableList[index][Row, Column]) == 3)
                                    {
                                        //Initiate Local Varibale and Color.
                                        Color a;
                                        if (this.TableList[index][Row, Column] > 0)
                                            a = Color.Gray;
                                        else
                                            a = Color.Brown;
                                        //If Gray Hourse.
                                        if (a == Color.Gray)
                                        {

                                            try
                                            {
                                                try
                                                {
                                                    //Calculation of Movments Number.
                                                    if (HoursesOnTable[Ho1].Row != Row ||
                                                        HoursesOnTable[Ho1].Column != Column)
                                                        Move++;
                                                }
                                                catch (Exception t) { }
                                                //Construction of Draw Brown Hourse.
                                                HoursesOnTable[Ho1] = new DrawHourse(MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, Row, Column, a, this.TableList[index], 1, false, Ho1);
                                                //Increament of Index.
                                                Ho1++;
                                                //when There is New Gray Hourse Increase.
                                                if (Ho1 > HourseMidle)
                                                {
                                                    HourseMidle++;
                                                    HourseHight++;
                                                }
                                            }
                                            catch (Exception t)
                                            {

                                            }
                                        }//For Brown Hourses.
                                        else
                                        {
                                            try
                                            {
                                                try
                                                {
                                                    //Calculation of Movments Number.
                                                    if (HoursesOnTable[Ho2].Row != Row |
                                                        HoursesOnTable[Ho2].Column != Column)
                                                        Move++;
                                                }
                                                catch (Exception t) { }
                                                //Construction of Draw Brown Hourse.
                                                HoursesOnTable[Ho2] = new DrawHourse(MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, Row, Column, a, this.TableList[index], -1, false, Ho2);
                                                //Increament of Index.
                                                Ho2++;
                                                //When New Brown Hourse Exist Exist Index.
                                                if (Ho2 > HourseHight)
                                                    HourseHight++;
                                            }
                                            catch (Exception t)
                                            {

                                            }
                                        }
                                    }
                                    else//For Bridges Objects.
                                        if (System.Math.Abs(this.TableList[index][Row, Column]) == 4)
                                        {
                                            //Initiate of Local Variables.
                                            Color a;
                                            if (this.TableList[index][Row, Column] > 0)
                                                a = Color.Gray;
                                            else
                                                a = Color.Brown;
                                            //For Gray Color.
                                            if (a == Color.Gray)
                                            {

                                                try
                                                {
                                                    try
                                                    {
                                                        //Calculation of Movments Number.
                                                        if (BridgesOnTable[Br1].Row != Row ||
                                                            BridgesOnTable[Br1].Column != Column)
                                                            Move++;
                                                    }
                                                    catch (Exception t) { }
                                                    //Construction of New Draw Gray Bridges.
                                                    BridgesOnTable[Br1] = new DrawBridge(MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, Row, Column, a, this.TableList[index], 1, false, Br1);
                                                    //Increamnt of Index.
                                                    Br1++;
                                                    //When New Gray Briges Increamnt Max Index.
                                                    if (Br1 > BridgeMidle)
                                                    {
                                                        BridgeMidle++;
                                                        BridgeHigh++;
                                                    }

                                                }
                                                catch (Exception t)
                                                {

                                                }
                                            }//For Brown Bridges.
                                            else
                                            {
                                                try
                                                {
                                                    try
                                                    {
                                                        //Calculation of Movments Number.
                                                        if (BridgesOnTable[Br2].Row != Row ||
                                                            BridgesOnTable[Br2].Column != Column)
                                                            Move++;
                                                    }
                                                    catch (Exception t) { }
                                                    //Construction Draw of New Brown Bridges.
                                                    BridgesOnTable[Br2] = new DrawBridge(MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, Row, Column, a, this.TableList[index], -1, false, Br2);
                                                    //Increament of Index.
                                                    Br2++;
                                                    //wehn Brown New Bridges Detected Increament Max Index.
                                                    if (Br2 > BridgeHigh)
                                                        BridgeHigh++;

                                                }
                                                catch (Exception t)
                                                {

                                                }
                                            }
                                        }
                                        else//For Minister Objects.
                                            if (System.Math.Abs(this.TableList[index][Row, Column]) == 5)
                                            {
                                                //Initiate Local Color Varibales.
                                                Color a;
                                                if (this.TableList[index][Row, Column] > 0)
                                                    a = Color.Gray;
                                                else
                                                    a = Color.Brown;
                                                //For Gray Colors.
                                                if (a == Color.Gray)
                                                {

                                                    try
                                                    {
                                                        try
                                                        {
                                                            //Clculationb of Movments Number.
                                                            if (MinisterOnTable[Mi1].Row != Row ||
                                                                MinisterOnTable[Mi1].Column != Column)
                                                                Move++;
                                                        }
                                                        catch (Exception t) { }
                                                        //construction of new draw Gray Minster.
                                                        MinisterOnTable[Mi1] = new DrawMinister(MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, Row, Column, a, this.TableList[index], 1, false, Mi1);
                                                        //Increament of Index.
                                                        Mi1++;
                                                        //Wehn New Gray Minster Detected Increament Max Indexes.
                                                        if (Mi1 > MinisterMidle)
                                                        {
                                                            MinisterMidle++;
                                                            MinisterHigh++;
                                                        }
                                                    }
                                                    catch (Exception t)
                                                    {

                                                    }

                                                }//For Brown  Colors.
                                                else
                                                {
                                                    try
                                                    {
                                                        try
                                                        {
                                                            //Calculation of Movments Number.
                                                            if (MinisterOnTable[Mi2].Row != Row ||
                                                                MinisterOnTable[Mi2].Column != Column)
                                                                Move++;
                                                        }
                                                        catch (Exception t) { }
                                                        //Construction of New Draw Brown Minster.
                                                        MinisterOnTable[Mi2] = new DrawMinister(MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, Row, Column, a, this.TableList[index], -1, false, Mi2);
                                                        //Increament Index.
                                                        Mi2++;
                                                        //When New Brown Minister Detected Increament Max Index.
                                                        if (Mi2 > MinisterHigh)
                                                            MinisterHigh++;

                                                    }
                                                    catch (Exception t)
                                                    {

                                                    }
                                                }
                                            }
                                            else//for King Objects.
                                                if (System.Math.Abs(this.TableList[index][Row, Column]) == 6)
                                                {
                                                    //Initiate Of Color.
                                                    Color a;
                                                    if (this.TableList[index][Row, Column] > 0)
                                                        a = Color.Gray;
                                                    else
                                                        a = Color.Brown;
                                                    //Color consideration.
                                                    if (a == Color.Gray)
                                                    {

                                                        try
                                                        {
                                                            try
                                                            {
                                                                //Calculation of Movments Number.
                                                                if (KingOnTable[Ki1].Row != Row ||
                                                                    KingOnTable[Ki1].Column != Column)
                                                                    Move++;

                                                            }
                                                            catch (Exception t) { }
                                                            //Construction of New Draw Gray King.
                                                            KingOnTable[Ki1] = new DrawKing(MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, Row, Column, a, this.TableList[index], 1, false, Ki1);
                                                            //Increament of Index.
                                                            Ki1++;
                                                            //when New Draw  Object Detected Increament Max Index.
                                                            if (Ki1 > KingMidle)
                                                            {
                                                                KingMidle++;
                                                                KingHigh++;

                                                            }

                                                        }
                                                        catch (Exception t)
                                                        {

                                                        }
                                                    }//For Brown King Color
                                                    else
                                                    {
                                                        try
                                                        {
                                                            try
                                                            {
                                                                //Calculation of Movment Number.
                                                                if (KingOnTable[Ki2].Row != Row ||
                                                                    KingOnTable[Ki2].Column != Column)
                                                                    Move++;
                                                            }
                                                            catch (Exception t) { }
                                                            //Construction of New Draw King Brown Object.
                                                            KingOnTable[Ki2] = new DrawKing(MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, Row, Column, a, this.TableList[index], -1, false, Ki2);
                                                            //Increament of Index.
                                                            Ki2++;
                                                            //When New Object Detected Increament Of Brown King Max Index.
                                                            if (Ki2 > KingHigh)
                                                                KingHigh++;
                                                        }
                                                        catch (Exception t)
                                                        {

                                                        }
                                                    }

                                                }
                        }
                    SetObjectNumbers(TableList[0]);
                    //Make Empty Remaining.
                    for (int i = So1; i < SodierMidle; i++)
                        SolderesOnTable[i] = null;

                    for (int i = So2; i < SodierHigh; i++)
                        SolderesOnTable[i] = null;

                    for (int i = El1; i < ElefantMidle; i++)
                        ElephantOnTable[i] = null;

                    for (int i = El2; i < ElefantHigh; i++)
                        ElephantOnTable[i] = null;

                    for (int i = Ho1; i < HourseMidle; i++)
                        HoursesOnTable[i] = null;

                    for (int i = Ho2; i < HourseHight; i++)
                        HoursesOnTable[i] = null;

                    for (int i = Br1; i < BridgeMidle; i++)
                        BridgesOnTable[i] = null;

                    for (int i = Br2; i < BridgeHigh; i++)
                        BridgesOnTable[i] = null;

                    for (int i = Mi1; i < MinisterMidle; i++)
                        MinisterOnTable[i] = null;

                    for (int i = Mi2; i < MinisterHigh; i++)
                        MinisterOnTable[i] = null;

                    for (int i = Ki1; i < KingMidle; i++)
                        KingOnTable[i] = null;

                    for (int i = Ki2; i < KingHigh; i++)
                        KingOnTable[i] = null;

                }


            }
            catch (Exception t)
            {

            }
        }
        //Max Index List Of Huristic AStarGreedy First Method.
        public void BeginIndexFoundingMaxLessofMaxList(int ListIndex, List<double> Founded, ref double Less)
        {
            //When There is Maximum Huristsic AStar Gredy Back Ward in Blitz Games.
            if (MaxHuristicAStarGreedytBackWard.Count > 0)
            {
                //When List Index is less than Founded.
                if (ListIndex < MaxHuristicAStarGreedytBackWard.Count)
                    return;
                //Initiate Variable.
                bool Added = false;
                //Recursive Method.
                BeginIndexFoundingMaxLessofMaxList(ListIndex++, Founded, ref Less);
                //When Greater Less of First index Object Found.
                if (Less < MaxHuristicAStarGreedytBackWard[ListIndex][1])
                {
                    Less = MaxHuristicAStarGreedytBackWard[ListIndex][1];
                    Added = true;

                    Founded.Add(2);
                }
                //When Greater Less of Second index Object Found.
                if (Less < MaxHuristicAStarGreedytBackWard[ListIndex][5])
                {
                    Less = MaxHuristicAStarGreedytBackWard[ListIndex][5];
                    if (Added)
                        Founded.RemoveAt(Founded.Count - 1);
                    Added = true;
                    Founded.Add(6);
                }
                //When Greater Less of Third index Object Found.
                if (Less < MaxHuristicAStarGreedytBackWard[ListIndex][9])
                {
                    Less = MaxHuristicAStarGreedytBackWard[ListIndex][9];
                    if (Added)
                        Founded.RemoveAt(Founded.Count - 1);
                    Added = true;
                    Founded.Add(10);
                }
                //When Greater Less of Foutrh index Object Found.
                if (Less < MaxHuristicAStarGreedytBackWard[ListIndex][13])
                {
                    Less = MaxHuristicAStarGreedytBackWard[ListIndex][13];
                    if (Added)
                        Founded.RemoveAt(Founded.Count - 1);
                    Added = true;
                    Founded.Add(14);
                }
                //When Greater Less of Fifth index Object Found.
                if (Less < MaxHuristicAStarGreedytBackWard[ListIndex][18])
                {
                    Less = MaxHuristicAStarGreedytBackWard[ListIndex][18];
                    if (Added)
                        Founded.RemoveAt(Founded.Count - 1);
                    Added = true;
                    Founded.Add(19);
                }
                //When Greater Less of Sith index Object Found.
                if (Less < MaxHuristicAStarGreedytBackWard[ListIndex][22])
                {
                    Less = MaxHuristicAStarGreedytBackWard[ListIndex][22];
                    if (Added)
                        Founded.RemoveAt(Founded.Count - 1);
                    Added = true;
                    Founded.Add(23);
                }
            }
        }
        //Method for Check of Existence of Checkmate less than for checked mate.
        bool IsToCheckMateHasLessDeeperThanForCheckMate(AllDraw A, int Order, ref int ToCheckMate, ref int ForCheckMate, int AStarGreedy)
        {
            //Initiate variables.
            bool AA = false;
            int CDummy = Order;
            //For Gray One.
            if (Order == 1)
            {

                //For Solderis.
                for (int i = 0; i < SodierMidle; i++)
                    for (int j = 0; A.SolderesOnTable[i] != null && A.SolderesOnTable[i].SoldierThinking[0] != null && j < A.SolderesOnTable[i].SoldierThinking[0].TableListSolder.Count; j++)
                    {
                        try
                        {

                            //When there is Brown checked mate.
                            if (A.SolderesOnTable[i].SoldierThinking[0].CheckMateAStarGreedy == -1)
                            {
                                //Set.
                                ForCheckMate = AStarGreedy;
                                if (ToCheckMate >= 0)
                                    if (ToCheckMate < ForCheckMate && ToCheckMate >= 0)
                                        AA = true;
                            }
                            else
                            {
                                //When there is Gray Checked mate.
                                if (A.SolderesOnTable[i].SoldierThinking[0].CheckMateAStarGreedy == 1)
                                {
                                    ToCheckMate = AStarGreedy;
                                    if (ForCheckMate >= 0)
                                        if (ToCheckMate < ForCheckMate && ToCheckMate >= 0)
                                            AA = true;


                                }
                            }
                        }
                        catch (Exception t)
                        {
                        }
                        Order *= -1;
                        for (int ii = 0; A.SolderesOnTable[i] != null && A.SolderesOnTable[i].SoldierThinking[0] != null && ii < A.SolderesOnTable[i].SoldierThinking[0].AStarGreedy.Count; ii++)
                            return AA || IsToCheckMateHasLessDeeperThanForCheckMate(A.SolderesOnTable[i].SoldierThinking[0].AStarGreedy[ii], Order, ref ToCheckMate, ref ForCheckMate, AStarGreedy++);
                        Order = CDummy;
                    }
                for (int i = 0; i < ElefantMidle; i++)
                    for (int j = 0; A.ElephantOnTable[i] != null && A.ElephantOnTable[i].ElefantThinking[0] != null && j < A.ElephantOnTable[i].ElefantThinking[0].TableListElefant.Count; j++)
                    {

                        try
                        {
                            //When there is Brown checked mate.
                            if (A.ElephantOnTable[i].ElefantThinking[0].CheckMateAStarGreedy == -1)
                            {
                                ForCheckMate = AStarGreedy;
                                if (ToCheckMate >= 0)
                                    if (ToCheckMate < ForCheckMate && ToCheckMate >= 0)
                                        AA = true;



                            }
                            else
                            {
                                //When there is Gray Checked mate.
                                if (A.ElephantOnTable[i].ElefantThinking[0].CheckMateAStarGreedy == 1)
                                {
                                    ToCheckMate = AStarGreedy;
                                    if (ForCheckMate >= 0)
                                        if (ToCheckMate < ForCheckMate && ToCheckMate >= 0)
                                            AA = true;


                                }
                            }
                        }
                        catch (Exception t)
                        {
                        }
                        Order *= -1;
                        for (int ii = 0; A.ElephantOnTable[i] != null && A.ElephantOnTable[i].ElefantThinking[0] != null && ii < A.ElephantOnTable[i].ElefantThinking[0].AStarGreedy.Count; ii++)
                            return AA || IsToCheckMateHasLessDeeperThanForCheckMate(A.ElephantOnTable[i].ElefantThinking[0].AStarGreedy[ii], Order, ref ToCheckMate, ref ForCheckMate, AStarGreedy++);
                        Order = CDummy;
                    }
                for (int i = 0; i < HourseMidle; i++)
                    for (int j = 0; A.HoursesOnTable[i] != null && A.HoursesOnTable[i].HourseThinking[0] != null && j < A.HoursesOnTable[i].HourseThinking[0].TableListHourse.Count; j++)
                    {

                        try
                        {
                            //When there is Brown checked mate.
                            if (A.HoursesOnTable[i].HourseThinking[0].CheckMateAStarGreedy == -1)
                            {
                                ForCheckMate = AStarGreedy;
                                if (ToCheckMate >= 0)
                                    if (ToCheckMate < ForCheckMate && ToCheckMate >= 0)
                                        AA = true;


                            }
                            else
                            {
                                //When there is Gray Checked mate.
                                if (A.HoursesOnTable[i].HourseThinking[0].CheckMateAStarGreedy == 1)
                                {
                                    ToCheckMate = AStarGreedy;
                                    if (ForCheckMate >= 0)
                                        if (ToCheckMate < ForCheckMate && ToCheckMate >= 0)
                                            AA = true;


                                }
                            }
                        }
                        catch (Exception t)
                        {
                        }
                        Order *= -1;
                        for (int ii = 0; A.HoursesOnTable[i] != null && A.HoursesOnTable[i].HourseThinking[0] != null && ii < A.HoursesOnTable[i].HourseThinking[0].AStarGreedy.Count; ii++)
                            return AA || IsToCheckMateHasLessDeeperThanForCheckMate(A.HoursesOnTable[i].HourseThinking[0].AStarGreedy[ii], Order, ref ToCheckMate, ref ForCheckMate, AStarGreedy++);
                        Order = CDummy;
                    }
                for (int i = 0; i < BridgeMidle; i++)
                    for (int j = 0; A.BridgesOnTable[i] != null && A.BridgesOnTable[i].BridgeThinking[0] != null && j < A.BridgesOnTable[i].BridgeThinking[0].TableListBridge.Count; j++)
                    {

                        try
                        {
                            //When there is Brown checked mate.
                            if (A.BridgesOnTable[i].BridgeThinking[0].CheckMateAStarGreedy == -1)
                            {
                                ForCheckMate = AStarGreedy;
                                if (ToCheckMate >= 0)
                                    if (ToCheckMate < ForCheckMate && ToCheckMate >= 0)
                                        AA = true;


                            }
                            else
                            {
                                //When there is Gray Checked mate.
                                if (A.BridgesOnTable[i].BridgeThinking[0].CheckMateAStarGreedy == 1)
                                {
                                    ToCheckMate = AStarGreedy;
                                    if (ForCheckMate >= 0)
                                        if (ToCheckMate < ForCheckMate && ToCheckMate >= 0)
                                            AA = true;


                                }
                            }
                        }
                        catch (Exception t)
                        {
                        }
                        Order *= -1;
                        for (int ii = 0; A.BridgesOnTable[i] != null && A.BridgesOnTable[i].BridgeThinking[0] != null && ii < A.BridgesOnTable[i].BridgeThinking[0].AStarGreedy.Count; ii++)
                            return AA || IsToCheckMateHasLessDeeperThanForCheckMate(A.BridgesOnTable[i].BridgeThinking[0].AStarGreedy[ii], Order, ref ToCheckMate, ref ForCheckMate, AStarGreedy++);
                        Order = CDummy;
                    }
                for (int i = 0; i < MinisterMidle; i++)
                    for (int j = 0; A.MinisterOnTable[i] != null && A.MinisterOnTable[i].MinisterThinking[0] != null && j < A.MinisterOnTable[i].MinisterThinking[0].TableListMinister.Count; j++)
                    {

                        try
                        {
                            //When there is Brown checked mate.
                            if (A.MinisterOnTable[i].MinisterThinking[0].CheckMateAStarGreedy == -1)
                            {
                                ForCheckMate = AStarGreedy;
                                if (ToCheckMate >= 0)
                                    if (ToCheckMate < ForCheckMate && ToCheckMate >= 0)
                                        AA = true;


                            }
                            else
                            {
                                //When there is Gray Checked mate.
                                if (A.MinisterOnTable[i].MinisterThinking[0].CheckMateAStarGreedy == 1)
                                {
                                    ToCheckMate = AStarGreedy;
                                    if (ForCheckMate >= 0)
                                        if (ToCheckMate < ForCheckMate && ToCheckMate >= 0)
                                            AA = true;


                                }
                            }
                        }
                        catch (Exception t)
                        {
                        }
                        Order *= -1;
                        for (int ii = 0; A.MinisterOnTable[i] != null && A.MinisterOnTable[i].MinisterThinking[0] != null && ii < A.MinisterOnTable[i].MinisterThinking[0].AStarGreedy.Count; ii++)
                            return AA || IsToCheckMateHasLessDeeperThanForCheckMate(A.MinisterOnTable[i].MinisterThinking[0].AStarGreedy[ii], Order, ref ToCheckMate, ref ForCheckMate, AStarGreedy++);
                        Order = CDummy;
                    }
                for (int i = 0; i < KingMidle; i++)
                    for (int j = 0; A.KingOnTable[i] != null && A.KingOnTable[i].KingThinking[0] != null && j < A.KingOnTable[i].KingThinking[0].TableListKing.Count; j++)
                    {

                        try
                        {
                            //When there is Brown checked mate.
                            if (A.KingOnTable[i].KingThinking[0].CheckMateAStarGreedy == -1)
                            {
                                ForCheckMate = AStarGreedy;
                                if (ToCheckMate >= 0)
                                    if (ToCheckMate < ForCheckMate && ToCheckMate >= 0)
                                        AA = true;

                            }
                            else
                            {
                                //When there is Gray Checked mate.
                                if (A.KingOnTable[i].KingThinking[0].CheckMateAStarGreedy == 1)
                                {
                                    ToCheckMate = AStarGreedy;
                                    if (ForCheckMate >= 0)
                                        if (ToCheckMate < ForCheckMate && ToCheckMate >= 0)
                                            AA = true;


                                }
                            }
                        }
                        catch (Exception t)
                        {
                        }
                        Order *= -1;
                        for (int ii = 0; A.KingOnTable[i] != null && A.KingOnTable[i].KingThinking[0] != null && ii < A.KingOnTable[i].KingThinking[0].AStarGreedy.Count; ii++)
                            return AA || IsToCheckMateHasLessDeeperThanForCheckMate(A.KingOnTable[i].KingThinking[0].AStarGreedy[ii], Order, ref ToCheckMate, ref ForCheckMate, AStarGreedy++);
                        Order = CDummy;
                    }
            }
            else
            {
                //ChessRules.CurrentOrder = -1;
                for (int i = SodierMidle; i < SodierHigh; i++)
                    for (int j = 0; A.SolderesOnTable[i] != null && A.SolderesOnTable[i].SoldierThinking[0] != null && j < A.SolderesOnTable[i].SoldierThinking[0].TableListSolder.Count; j++)
                    {

                        try
                        {
                            //When there is Brown checked mate.
                            if (A.SolderesOnTable[i].SoldierThinking[0].CheckMateAStarGreedy == -1)
                            {
                                ForCheckMate = AStarGreedy;
                                if (ToCheckMate >= 0)
                                    if (ToCheckMate < ForCheckMate && ToCheckMate >= 0)
                                        AA = true;


                            }
                            else
                            {
                                //When there is Gray Checked mate.
                                if (A.SolderesOnTable[i].SoldierThinking[0].CheckMateAStarGreedy == 1)
                                {
                                    ToCheckMate = AStarGreedy;
                                    if (ForCheckMate >= 0)
                                        if (ToCheckMate < ForCheckMate && ToCheckMate >= 0)
                                            AA = true;


                                }
                            }
                        }
                        catch (Exception t)
                        {
                        }
                        Order *= -1;
                        for (int ii = 0; A.SolderesOnTable[i] != null && A.SolderesOnTable[i].SoldierThinking[0] != null && ii < A.SolderesOnTable[i].SoldierThinking[0].AStarGreedy.Count; ii++)
                            return AA || IsToCheckMateHasLessDeeperThanForCheckMate(A.SolderesOnTable[i].SoldierThinking[0].AStarGreedy[ii], Order, ref ToCheckMate, ref ForCheckMate, AStarGreedy++);
                        Order = CDummy;
                    }
                for (int i = ElefantMidle; i < ElefantHigh; i++)
                    for (int j = 0; A.ElephantOnTable[i] != null && A.ElephantOnTable[i].ElefantThinking[0] != null && j < A.ElephantOnTable[i].ElefantThinking[0].TableListElefant.Count; j++)
                    {

                        try
                        {
                            //When there is Brown checked mate.
                            if (A.ElephantOnTable[i].ElefantThinking[0].CheckMateAStarGreedy == -1)
                            {
                                ForCheckMate = AStarGreedy;
                                if (ToCheckMate >= 0)
                                    if (ToCheckMate < ForCheckMate && ToCheckMate >= 0)
                                        AA = true;

                            }
                            else
                            {
                                //When there is Gray Checked mate.
                                if (A.ElephantOnTable[i].ElefantThinking[0].CheckMateAStarGreedy == 1)
                                {
                                    ToCheckMate = AStarGreedy;
                                    if (ForCheckMate >= 0)
                                        if (ToCheckMate < ForCheckMate && ToCheckMate >= 0)
                                            AA = true;


                                }
                            }
                        }
                        catch (Exception t)
                        {
                        }
                        Order *= -1;
                        for (int ii = 0; A.ElephantOnTable[i] != null && A.ElephantOnTable[i].ElefantThinking[0] != null && ii < A.ElephantOnTable[i].ElefantThinking[0].AStarGreedy.Count; ii++)
                            return AA || IsToCheckMateHasLessDeeperThanForCheckMate(A.ElephantOnTable[i].ElefantThinking[0].AStarGreedy[ii], Order, ref ToCheckMate, ref ForCheckMate, AStarGreedy++);
                        Order = CDummy;
                    }
                for (int i = HourseMidle; i < HourseHight; i++)
                    for (int j = 0; A.HoursesOnTable[i] != null && A.HoursesOnTable[i].HourseThinking[0] != null && j < A.HoursesOnTable[i].HourseThinking[0].TableListHourse.Count; j++)
                    {

                        try
                        {
                            //When there is Brown checked mate.
                            if (A.HoursesOnTable[i].HourseThinking[0].CheckMateAStarGreedy == -1)
                            {
                                ForCheckMate = AStarGreedy;
                                if (ToCheckMate >= 0)
                                    if (ToCheckMate < ForCheckMate && ToCheckMate >= 0)
                                        AA = true;


                            }
                            else
                            {
                                //When there is Gray Checked mate.
                                if (A.HoursesOnTable[i].HourseThinking[0].CheckMateAStarGreedy == 1)
                                {
                                    ToCheckMate = AStarGreedy;
                                    if (ForCheckMate >= 0)
                                        if (ToCheckMate < ForCheckMate && ToCheckMate >= 0)
                                            AA = true;


                                }
                            }
                        }
                        catch (Exception t)
                        {
                        }
                        Order *= -1;
                        for (int ii = 0; A.HoursesOnTable[i] != null && A.HoursesOnTable[i].HourseThinking[0] != null && ii < A.HoursesOnTable[i].HourseThinking[0].AStarGreedy.Count; ii++)
                            return AA || IsToCheckMateHasLessDeeperThanForCheckMate(A.HoursesOnTable[i].HourseThinking[0].AStarGreedy[ii], Order, ref ToCheckMate, ref ForCheckMate, AStarGreedy++);
                        Order = CDummy;
                    }
                for (int i = BridgeMidle; i < BridgeHigh; i++)
                    for (int j = 0; A.BridgesOnTable[i] != null && A.BridgesOnTable[i].BridgeThinking[0] != null && j < A.BridgesOnTable[i].BridgeThinking[0].TableListBridge.Count; j++)
                    {

                        try
                        {
                            //When there is Brown checked mate.
                            if (A.BridgesOnTable[i].BridgeThinking[0].CheckMateAStarGreedy == -1)
                            {
                                ForCheckMate = AStarGreedy;
                                if (ToCheckMate >= 0)
                                    if (ToCheckMate < ForCheckMate && ToCheckMate >= 0)
                                        AA = true;


                            }
                            else
                            {
                                //When there is Gray Checked mate.
                                if (A.BridgesOnTable[i].BridgeThinking[0].CheckMateAStarGreedy == 1)
                                {
                                    ToCheckMate = AStarGreedy;
                                    if (ForCheckMate >= 0)
                                        if (ToCheckMate < ForCheckMate && ToCheckMate >= 0)
                                            AA = true;


                                }
                            }
                        }
                        catch (Exception t)
                        {
                        }
                        Order *= -1;
                        for (int ii = 0; A.BridgesOnTable[i] != null && A.BridgesOnTable[i].BridgeThinking[0] != null && ii < A.BridgesOnTable[i].BridgeThinking[0].AStarGreedy.Count; ii++)
                            return AA || IsToCheckMateHasLessDeeperThanForCheckMate(A.BridgesOnTable[i].BridgeThinking[0].AStarGreedy[ii], Order, ref ToCheckMate, ref ForCheckMate, AStarGreedy++);
                        Order = CDummy;
                    }
                for (int i = MinisterMidle; i < MinisterHigh; i++)
                    for (int j = 0; A.MinisterOnTable[i] != null && A.MinisterOnTable[i].MinisterThinking[0] != null && j < A.MinisterOnTable[i].MinisterThinking[0].TableListMinister.Count; j++)
                    {

                        try
                        {
                            //When there is Brown checked mate.
                            if (A.MinisterOnTable[i].MinisterThinking[0].CheckMateAStarGreedy == -1)
                            {
                                ForCheckMate = AStarGreedy;
                                if (ToCheckMate >= 0)
                                    if (ToCheckMate < ForCheckMate && ToCheckMate >= 0)
                                        AA = true;


                            }
                            else
                            {
                                //When there is Gray Checked mate.
                                if (A.MinisterOnTable[i].MinisterThinking[0].CheckMateAStarGreedy == 1)
                                {
                                    ToCheckMate = AStarGreedy;
                                    if (ForCheckMate >= 0)
                                        if (ToCheckMate < ForCheckMate && ToCheckMate >= 0)
                                            AA = true;


                                }
                            }
                        }
                        catch (Exception t)
                        {
                        }

                        Order *= -1;
                        for (int ii = 0; A.MinisterOnTable[i] != null && A.MinisterOnTable[i].MinisterThinking[0] != null && ii < A.MinisterOnTable[i].MinisterThinking[0].AStarGreedy.Count; ii++)
                            return AA || IsToCheckMateHasLessDeeperThanForCheckMate(A.MinisterOnTable[i].MinisterThinking[0].AStarGreedy[ii], Order, ref ToCheckMate, ref ForCheckMate, AStarGreedy++);
                        Order = CDummy;
                    }
                for (int i = KingMidle; i < KingHigh; i++)
                    for (int j = 0; A.KingOnTable[i] != null && A.KingOnTable[i].KingThinking[0] != null && j < A.KingOnTable[i].KingThinking[0].TableListKing.Count; j++)
                    {

                        try
                        {
                            //When there is Brown checked mate.
                            if (A.KingOnTable[i].KingThinking[0].CheckMateAStarGreedy == -1)
                            {
                                ForCheckMate = AStarGreedy;
                                if (ToCheckMate >= 0)
                                    if (ToCheckMate < ForCheckMate && ToCheckMate >= 0)
                                        AA = true;


                            }
                            else
                            {
                                //When there is Gray Checked mate.
                                if (A.KingOnTable[i].KingThinking[0].CheckMateAStarGreedy == 1)
                                {
                                    ToCheckMate = AStarGreedy;
                                    if (ForCheckMate >= 0)
                                        if (ToCheckMate < ForCheckMate && ToCheckMate >= 0)
                                            AA = true;


                                }
                            }

                        }
                        catch (Exception t)
                        {
                        }
                        Order *= -1;
                        for (int ii = 0; A.KingOnTable[i] != null && A.KingOnTable[i].KingThinking[0] != null && ii < A.KingOnTable[i].KingThinking[0].AStarGreedy.Count; ii++)
                            return AA || IsToCheckMateHasLessDeeperThanForCheckMate(A.KingOnTable[i].KingThinking[0].AStarGreedy[ii], Order, ref ToCheckMate, ref ForCheckMate, AStarGreedy++);
                        Order = CDummy;
                    }

            }
            ChessRules.CurrentOrder = CDummy;
            return AA;
        }
        //When Penalty Regard Branches expanded to sub branches.
        void IsPenaltyRegardCheckMateAtBranch(
            //AllDraw A, 
            int Order, ref int Do
            , AllDraw Base
            )
        {
            int CDummy = ChessRules.CurrentOrder;
            int COrder = Order;
            //For Gray Order.
            if (Order == 1)
            {
                ChessRules AA = null;

                //ChessRules.CurrentOrder = 1;
                //For  Soldeirs.
                for (int i = 0; i < SodierMidle; i++)
                    for (int j = 0; SolderesOnTable[i] != null && SolderesOnTable[i].SoldierThinking[0] != null && j < SolderesOnTable[i].SoldierThinking[0].TableListSolder.Count; j++)
                    {
                        try
                        {

                            //Create Rules Objects For Soldiers.
                            AA = new ChessRules(MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, SolderesOnTable[i].SoldierThinking[0].TableListSolder[j][SolderesOnTable[i].SoldierThinking[0].RowColumnSoldier[j][0], SolderesOnTable[i].SoldierThinking[0].RowColumnSoldier[j][1]]
                                , SolderesOnTable[i].SoldierThinking[0].TableListSolder[j]
                                , Order
                                , SolderesOnTable[i].SoldierThinking[0].RowColumnSoldier[j][0]
                                , SolderesOnTable[i].SoldierThinking[0].RowColumnSoldier[j][1]);
                            //When CheckMate Occured for Current Sodiers
                            if (AA.CheckMate(SolderesOnTable[i].SoldierThinking[0].TableListSolder[j], Order))
                                //When Self CheckMate
                                if (FormRefrigtz.OrderPlate == 1 && AA.CheckMateGray)
                                {
                                    //Return Ignore
                                    Do = -1;
                                    //Set Superposition.
                                    SolderesOnTable[i].SoldierThinking[0].CheckMateAStarGreedy = -1;
                                    //Penalty Subbranchs.
                                    MakePenaltyAllCheckMateBranches(Base, FormRefrigtz.OrderPlate);
                                }
                                else
                                {
                                    //When Enemy CheckMate
                                    if (FormRefrigtz.OrderPlate == -1 && AA.CheckMateBrown)
                                    {
                                        //Set Regard and Set Movements.
                                        Do = 1;
                                        //Regard Subbranchs.
                                        MakeRegardAllCheckMateBranches(Base, FormRefrigtz.OrderPlate);
                                        //Set Superpostion.
                                        SolderesOnTable[i].SoldierThinking[0].CheckMateAStarGreedy = 1;
                                    }
                                }
                        }
                        catch (Exception t)
                        {
                        }
                        if (Do != -1)
                        {
                            Order *= -1;
                            ChessRules.CurrentOrder *= -1;
                            //For Subbranchs.
                            for (int ii = 0; SolderesOnTable[i] != null && SolderesOnTable[i].SoldierThinking[0] != null && ii < SolderesOnTable[i].SoldierThinking[0].AStarGreedy.Count; ii++)
                                SolderesOnTable[ii].SoldierThinking[0].AStarGreedy[i].IsPenaltyRegardCheckMateAtBranch(Order, ref Do, Base);
                            Order = COrder;
                            ChessRules.CurrentOrder = CDummy;
                        }

                    }
                //For Elephant.
                for (int i = 0; i < ElefantMidle; i++)
                    for (int j = 0; ElephantOnTable[i] != null && ElephantOnTable[i].ElefantThinking[0] != null && j < ElephantOnTable[i].ElefantThinking[0].TableListElefant.Count; j++)
                    {

                        try
                        {
                            //Create Elephant Rules.
                            AA = new ChessRules(MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, ElephantOnTable[i].ElefantThinking[0].TableListElefant[j][ElephantOnTable[i].ElefantThinking[0].RowColumnElefant[j][0], ElephantOnTable[i].ElefantThinking[0].RowColumnElefant[j][1]]
                            , ElephantOnTable[i].ElefantThinking[0].TableListElefant[j]
                            , Order
                            , ElephantOnTable[i].ElefantThinking[0].RowColumnElefant[j][0]
                            , ElephantOnTable[i].ElefantThinking[0].RowColumnElefant[j][1]);
                            //When CheckMate Occured for Current Elephant.
                            if (AA.CheckMate(ElephantOnTable[i].ElefantThinking[0].TableListElefant[j], Order))
                                //For Self Order CheckMate.
                                if (FormRefrigtz.OrderPlate == 1 && AA.CheckMateGray)
                                {
                                    //Set Penalty Ignore.
                                    Do = -1;
                                    //Set Superposition.
                                    ElephantOnTable[i].ElefantThinking[0].CheckMateAStarGreedy = -1;
                                    //Penalty Subbranchs.
                                    MakePenaltyAllCheckMateBranches(Base, FormRefrigtz.OrderPlate);
                                }
                                else
                                {
                                    //For Enemy Order CheckMate.
                                    if (FormRefrigtz.OrderPlate == -1 && AA.CheckMateBrown)
                                    {
                                        //Set Regard Continue.
                                        Do = 1;
                                        //Regard Subolders.
                                        MakeRegardAllCheckMateBranches(Base, FormRefrigtz.OrderPlate);
                                        //Set Superposition.
                                        ElephantOnTable[i].ElefantThinking[0].CheckMateAStarGreedy = 1;
                                    }
                                }
                        }
                        catch (Exception t)
                        {
                        }
                        if (Do != -1)
                        {
                            Order *= -1;
                            ChessRules.CurrentOrder *= -1;
                            //For Subbranchs.
                            for (int ii = 0; ElephantOnTable[i] != null && ElephantOnTable[i].ElefantThinking[0] != null && ii < ElephantOnTable[i].ElefantThinking[0].AStarGreedy.Count; ii++)
                                ElephantOnTable[ii].ElefantThinking[0].AStarGreedy[i].IsPenaltyRegardCheckMateAtBranch(Order, ref Do, Base);
                            Order = COrder;
                            ChessRules.CurrentOrder = CDummy;
                        }
                    }
                //For Hourse.
                for (int i = 0; i < HourseMidle; i++)
                    for (int j = 0; HoursesOnTable[i] != null && HoursesOnTable[i].HourseThinking[0] != null && j < HoursesOnTable[i].HourseThinking[0].TableListHourse.Count; j++)
                    {

                        try
                        {
                            //Set Hourse Rules Objects.
                            AA = new ChessRules(MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, HoursesOnTable[i].HourseThinking[0].TableListHourse[j][HoursesOnTable[i].HourseThinking[0].RowColumnHourse[j][0], HoursesOnTable[i].HourseThinking[0].RowColumnHourse[j][1]]
                            , HoursesOnTable[i].HourseThinking[0].TableListHourse[j]
                            , Order
                            , HoursesOnTable[i].HourseThinking[0].RowColumnHourse[j][0]
                            , HoursesOnTable[i].HourseThinking[0].RowColumnHourse[j][1]);
                            //When CheckMate Occured.
                            if (AA.CheckMate(HoursesOnTable[i].HourseThinking[0].TableListSolder[j], Order))
                                //For Self CheckMate.
                                if (FormRefrigtz.OrderPlate == 1 && AA.CheckMateGray)
                                {
                                    //Set Ignore.
                                    Do = -1;
                                    //Set Superposition.
                                    HoursesOnTable[i].HourseThinking[0].CheckMateAStarGreedy = -1;
                                    //Penalty Subbranchs.
                                    MakePenaltyAllCheckMateBranches(Base, FormRefrigtz.OrderPlate);
                                }
                                else
                                {
                                    //For Enemy CheckMate.
                                    if (FormRefrigtz.OrderPlate == -1 && AA.CheckMateBrown)
                                    {
                                        //Set Regard.
                                        Do = 1;
                                        //Superposition.
                                        HoursesOnTable[i].HourseThinking[0].CheckMateAStarGreedy = 1;
                                        //Set Regard For Sub Branches.
                                        MakeRegardAllCheckMateBranches(Base, FormRefrigtz.OrderPlate);
                                    }
                                }
                        }
                        catch (Exception t)
                        {
                        }
                        if (Do != -1)
                        {
                            Order *= -1;
                            ChessRules.CurrentOrder *= -1;
                            //Sub branchs For Hourse.
                            for (int ii = 0; HoursesOnTable[i] != null && HoursesOnTable[i].HourseThinking[0] != null && ii < HoursesOnTable[i].HourseThinking[0].AStarGreedy.Count; ii++)
                                HoursesOnTable[i].HourseThinking[0].AStarGreedy[ii].IsPenaltyRegardCheckMateAtBranch(Order, ref Do, Base);
                            Order = COrder;
                            ChessRules.CurrentOrder = CDummy;
                        }
                    }
                //For Gray Briges.
                for (int i = 0; i < BridgeMidle; i++)
                    for (int j = 0; BridgesOnTable[i] != null && BridgesOnTable[i].BridgeThinking[0] != null && j < BridgesOnTable[i].BridgeThinking[0].TableListBridge.Count; j++)
                    {

                        try
                        {
                            //Bridges Gray Rules.
                            AA = new ChessRules(MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, BridgesOnTable[i].BridgeThinking[0].TableListBridge[j][BridgesOnTable[i].BridgeThinking[0].RowColumnBridge[j][0], BridgesOnTable[i].BridgeThinking[0].RowColumnBridge[j][1]]
                            , BridgesOnTable[i].BridgeThinking[0].TableListBridge[j]
                            , Order
                            , BridgesOnTable[i].BridgeThinking[0].RowColumnBridge[j][0]
                            , BridgesOnTable[i].BridgeThinking[0].RowColumnBridge[j][1]);
                            //When Current Gray Bridges CheckMate.
                            if (AA.CheckMate(BridgesOnTable[i].BridgeThinking[0].TableListBridge[j], Order))
                                //For Self CheckMate
                                if (FormRefrigtz.OrderPlate == 1 && AA.CheckMateGray)
                                {
                                    //Set Penalty Ignore.
                                    Do = -1;
                                    //Set Superposition.
                                    BridgesOnTable[i].BridgeThinking[0].CheckMateAStarGreedy = -1;
                                    //Penalty Sub branchs.
                                    MakePenaltyAllCheckMateBranches(Base, FormRefrigtz.OrderPlate);
                                }
                                else
                                {
                                    //For Enemy CheckMate.
                                    if (FormRefrigtz.OrderPlate == -1 && AA.CheckMateBrown)
                                    {
                                        //Set Regard.
                                        Do = 1;
                                        //Superpoistion.
                                        BridgesOnTable[i].BridgeThinking[0].CheckMateAStarGreedy = 1;
                                        //Set Regard Subbranchs.
                                        MakeRegardAllCheckMateBranches(Base, FormRefrigtz.OrderPlate);
                                    }
                                }
                        }
                        catch (Exception t)
                        {
                        }
                        if (Do != -1)
                        {
                            Order *= -1;
                            ChessRules.CurrentOrder *= -1;
                            //For Bridges Gray Subbranchs.
                            try
                            {
                                for (int ii = 0; BridgesOnTable[i] != null && BridgesOnTable[i].BridgeThinking[0] != null && ii < BridgesOnTable[i].BridgeThinking[0].AStarGreedy.Count; ii++)
                                    BridgesOnTable[i].BridgeThinking[0].AStarGreedy[ii].IsPenaltyRegardCheckMateAtBranch(Order, ref Do, Base);
                            }
                            catch (Exception t)
                            {
                            }
                            Order = COrder;
                            ChessRules.CurrentOrder = CDummy;
                        }
                    }
                //For Ministers Gray.
                for (int i = 0; i < MinisterMidle; i++)
                    for (int j = 0; MinisterOnTable[i] != null && MinisterOnTable[i].MinisterThinking[0] != null && j < MinisterOnTable[i].MinisterThinking[0].TableListMinister.Count; j++)
                    {

                        try
                        {
                            //Minister Gray Rules.
                            AA = new ChessRules(MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, MinisterOnTable[i].MinisterThinking[0].TableListMinister[j][MinisterOnTable[i].MinisterThinking[0].RowColumnMinister[j][0], MinisterOnTable[i].MinisterThinking[0].RowColumnMinister[j][1]]
                            , MinisterOnTable[i].MinisterThinking[0].TableListMinister[j]
                            , Order
                            , MinisterOnTable[i].MinisterThinking[0].RowColumnMinister[j][0]
                            , MinisterOnTable[i].MinisterThinking[0].RowColumnMinister[j][1]);
                            //When M ate Occured in Minister Gray.
                            if (AA.CheckMate(MinisterOnTable[i].MinisterThinking[0].TableListMinister[j], Order))
                                //Self CheckMate.
                                if (FormRefrigtz.OrderPlate == 1 && AA.CheckMateGray)
                                {
                                    //Penalty Ignore.
                                    Do = -1;
                                    //Superpostion.
                                    MinisterOnTable[i].MinisterThinking[0].CheckMateAStarGreedy = -1;
                                    //Penalty Subbranchs.
                                    MakePenaltyAllCheckMateBranches(Base, FormRefrigtz.OrderPlate);
                                }
                                else
                                {
                                    //For Enemy CheckMate.
                                    if (FormRefrigtz.OrderPlate == -1 && AA.CheckMateBrown)
                                    {
                                        //Regard Setting.
                                        Do = 1;
                                        //Superpoistion.
                                        MinisterOnTable[i].MinisterThinking[0].CheckMateAStarGreedy = 1;
                                        //Set Subbranchs Regard.
                                        MakeRegardAllCheckMateBranches(Base, FormRefrigtz.OrderPlate);
                                    }
                                }
                        }
                        catch (Exception t)
                        {
                        }
                        if (Do != -1)
                        {
                            Order *= -1;
                            ChessRules.CurrentOrder *= -1;
                            //For Gray Ministers Subbranchs.
                            try
                            {
                                for (int ii = 0; MinisterOnTable[i] != null && MinisterOnTable[i].MinisterThinking[0] != null && ii < MinisterOnTable[i].MinisterThinking[0].AStarGreedy.Count; ii++)
                                    MinisterOnTable[i].MinisterThinking[0].AStarGreedy[ii].IsPenaltyRegardCheckMateAtBranch(Order, ref Do, Base);
                            }
                            catch (Exception t)
                            {
                            }
                            Order = COrder;
                            ChessRules.CurrentOrder = CDummy;
                        }
                    }
                //For Gray King.
                for (int i = 0; i < KingMidle; i++)
                    for (int j = 0; KingOnTable[i] != null && KingOnTable[i].KingThinking[0] != null && j < KingOnTable[i].KingThinking[0].TableListKing.Count; j++)
                    {

                        try
                        {
                            //Gray King Rules.
                            AA = new ChessRules(MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, KingOnTable[i].KingThinking[0].TableListKing[j][KingOnTable[i].KingThinking[0].RowColumnKing[j][0], KingOnTable[i].KingThinking[0].RowColumnKing[j][1]]
                            , KingOnTable[i].KingThinking[0].TableListKing[j]
                            , Order
                            , KingOnTable[i].KingThinking[0].RowColumnKing[j][0]
                            , KingOnTable[i].KingThinking[0].RowColumnKing[j][1]);
                            //When CheckMate Occured in King Gray.
                            if (AA.CheckMate(KingOnTable[i].KingThinking[0].TableListKing[j], Order))
                                //Self CheckMate.
                                if (FormRefrigtz.OrderPlate == 1 && AA.CheckMateGray)
                                {
                                    //Penalty Ignore.
                                    Do = -1;
                                    //Superposition.
                                    KingOnTable[i].KingThinking[0].CheckMateAStarGreedy = -1;
                                    //Penalty Subbranchs.
                                    MakePenaltyAllCheckMateBranches(Base, FormRefrigtz.OrderPlate);
                                }
                                else
                                {
                                    //Self CheckMate.
                                    if (FormRefrigtz.OrderPlate == -1 && AA.CheckMateBrown)
                                    {
                                        //Regard Setting.
                                        Do = 1;
                                        //Superpoistion.
                                        KingOnTable[i].KingThinking[0].CheckMateAStarGreedy = 1;
                                        //Regard Subbranchs.
                                        MakeRegardAllCheckMateBranches(Base, FormRefrigtz.OrderPlate);
                                    }
                                }
                        }
                        catch (Exception t)
                        {
                        }
                        if (Do != -1)
                        {
                            Order *= -1;
                            ChessRules.CurrentOrder *= -1;
                            //For King Gray Subbranchs.
                            try
                            {
                                for (int ii = 0; KingOnTable[i] != null && KingOnTable[i].KingThinking[0] != null && ii < KingOnTable[i].KingThinking[0].AStarGreedy.Count; ii++)
                                    KingOnTable[i].KingThinking[0].AStarGreedy[ii].IsPenaltyRegardCheckMateAtBranch(Order, ref Do, Base);
                            }
                            catch (Exception t)
                            {
                            }
                            Order = COrder;
                            ChessRules.CurrentOrder = CDummy;
                        }
                    }
            }
            //For Brown Order.
            else
            {
                ChessRules AA = null;
                //ChessRules.CurrentOrder = -1;
                //For Solders Brown.
                for (int i = SodierMidle; i < SodierHigh; i++)
                    for (int j = 0; SolderesOnTable[i] != null && SolderesOnTable[i].SoldierThinking[0] != null && j < SolderesOnTable[i].SoldierThinking[0].TableListSolder.Count; j++)
                    {

                        try
                        {
                            //Solders Brown Rules.
                            AA = new ChessRules(MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, SolderesOnTable[i].SoldierThinking[0].TableListSolder[j][SolderesOnTable[i].SoldierThinking[0].RowColumnSoldier[j][0], SolderesOnTable[i].SoldierThinking[0].RowColumnSoldier[j][1]]
                            , SolderesOnTable[i].SoldierThinking[0].TableListSolder[j]
                            , Order
                            , SolderesOnTable[i].SoldierThinking[0].RowColumnSoldier[j][0]
                            , SolderesOnTable[i].SoldierThinking[0].RowColumnSoldier[j][1]);
                            //When Solders Brown CheckMate Occured.
                            if (AA.CheckMate(SolderesOnTable[i].SoldierThinking[0].TableListSolder[j], Order))
                                //Self CheckMate.
                                if (FormRefrigtz.OrderPlate == -1 && AA.CheckMateBrown)
                                {
                                    //Ignore Penalty.
                                    Do = -1;
                                    //Supperpoistion.
                                    SolderesOnTable[i].SoldierThinking[0].CheckMateAStarGreedy = -1;
                                    //Penalty Subbranchs Soders Brown.
                                    MakePenaltyAllCheckMateBranches(Base, FormRefrigtz.OrderPlate);
                                }
                                else
                                {
                                    //Self CheckMate.
                                    if (FormRefrigtz.OrderPlate == 1 && AA.CheckMateGray)
                                    {
                                        //Set Regard.
                                        Do = 1;
                                        //Superpoition.
                                        SolderesOnTable[i].SoldierThinking[0].CheckMateAStarGreedy = 1;
                                        //Penalty Subbranchs.
                                        MakeRegardAllCheckMateBranches(Base, FormRefrigtz.OrderPlate);
                                    }
                                }
                        }
                        catch (Exception t)
                        {
                        }
                        if (Do != -1)
                        {
                            Order *= -1;
                            ChessRules.CurrentOrder *= -1;
                            //Solders Brown Subbranchs Calling.
                            try
                            {
                                for (int ii = 0; SolderesOnTable[i] != null && SolderesOnTable[i].SoldierThinking[0] != null && ii < SolderesOnTable[i].SoldierThinking[0].AStarGreedy.Count; ii++)
                                    SolderesOnTable[i].SoldierThinking[0].AStarGreedy[ii].IsPenaltyRegardCheckMateAtBranch(Order, ref Do, Base);
                            }
                            catch (Exception t)
                            {
                            }
                            Order = COrder;
                            ChessRules.CurrentOrder = CDummy;
                        }
                    }
                //Elephant Brown 
                for (int i = ElefantMidle; i < ElefantHigh; i++)
                    for (int j = 0; ElephantOnTable[i] != null && ElephantOnTable[i].ElefantThinking[0] != null && j < ElephantOnTable[i].ElefantThinking[0].TableListElefant.Count; j++)
                    {

                        try
                        {
                            //Elephant Brown Rules.
                            AA = new ChessRules(MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, ElephantOnTable[i].ElefantThinking[0].TableListElefant[j][ElephantOnTable[i].ElefantThinking[0].RowColumnElefant[j][0], ElephantOnTable[i].ElefantThinking[0].RowColumnElefant[j][1]]
                            , ElephantOnTable[i].ElefantThinking[0].TableListElefant[j]
                            , Order
                            , ElephantOnTable[i].ElefantThinking[0].RowColumnElefant[j][0]
                            , ElephantOnTable[i].ElefantThinking[0].RowColumnElefant[j][1]);
                            //CheckMate Occured in Elephenat Brown.
                            if (AA.CheckMate(ElephantOnTable[i].ElefantThinking[0].TableListElefant[j], Order))
                                //Self CheckMate.
                                if (FormRefrigtz.OrderPlate == -1 && AA.CheckMateBrown)
                                {
                                    //Ignore Penalty.
                                    Do = -1;
                                    //Superpoistion.
                                    ElephantOnTable[i].ElefantThinking[0].CheckMateAStarGreedy = -1;
                                    //Penalty Subbranchs.
                                    MakePenaltyAllCheckMateBranches(Base, FormRefrigtz.OrderPlate);
                                }
                                else
                                {
                                    //CheckMate Enemy.
                                    if (FormRefrigtz.OrderPlate == 1 && AA.CheckMateGray)
                                    {
                                        //Set Regrading.
                                        Do = 1;
                                        //Superposition.
                                        ElephantOnTable[i].ElefantThinking[0].CheckMateAStarGreedy = 1;
                                        //Regrad Subbranchs.
                                        MakeRegardAllCheckMateBranches(Base, FormRefrigtz.OrderPlate);
                                    }
                                }
                        }
                        catch (Exception t)
                        {
                        }
                        if (Do != -1)
                        {
                            Order *= -1;
                            ChessRules.CurrentOrder *= -1;
                            //Subbranchs Elephenat Brown Calling.
                            try
                            {
                                for (int ii = 0; ElephantOnTable[i] != null && ElephantOnTable[i].ElefantThinking[0] != null && ii < ElephantOnTable[i].ElefantThinking[0].AStarGreedy.Count; ii++)
                                    ElephantOnTable[i].ElefantThinking[0].AStarGreedy[ii].IsPenaltyRegardCheckMateAtBranch(Order, ref Do, Base);
                            }
                            catch (Exception t)
                            {
                            }
                            Order = COrder;
                            ChessRules.CurrentOrder = CDummy;
                        }
                    }
                //Hourse Brown 
                for (int i = HourseMidle; i < HourseHight; i++)
                    for (int j = 0; HoursesOnTable[i] != null && HoursesOnTable[i].HourseThinking[0] != null && j < HoursesOnTable[i].HourseThinking[0].TableListHourse.Count; j++)
                    {

                        try
                        {
                            //Hourse Brown Rules.
                            AA = new ChessRules(MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, HoursesOnTable[i].HourseThinking[0].TableListHourse[j][HoursesOnTable[i].HourseThinking[0].RowColumnHourse[j][0], HoursesOnTable[i].HourseThinking[0].RowColumnHourse[j][1]]
                            , HoursesOnTable[i].HourseThinking[0].TableListHourse[j]
                            , Order
                            , HoursesOnTable[i].HourseThinking[0].RowColumnHourse[j][0]
                            , HoursesOnTable[i].HourseThinking[0].RowColumnHourse[j][1]);
                            //When Hourse Broin CheckMate Ocuucred.
                            if (AA.CheckMate(HoursesOnTable[i].HourseThinking[0].TableListSolder[j], Order))
                                //Self CheckMate.
                                if (FormRefrigtz.OrderPlate == -1 && AA.CheckMateBrown)
                                {
                                    //Ignore Penalty.
                                    Do = -1;
                                    //Superposition.
                                    HoursesOnTable[i].HourseThinking[0].CheckMateAStarGreedy = -1;
                                    //Penalty Subbranchs.
                                    MakePenaltyAllCheckMateBranches(Base, FormRefrigtz.OrderPlate);
                                }
                                else
                                {
                                    //CheckMate Enemy.
                                    if (FormRefrigtz.OrderPlate == 1 && AA.CheckMateGray)
                                    {
                                        //Set Regrad.
                                        Do = 1;
                                        //Superposition.
                                        HoursesOnTable[i].HourseThinking[0].CheckMateAStarGreedy = 1;
                                        //Regrad Subbranchs.
                                        MakeRegardAllCheckMateBranches(Base, FormRefrigtz.OrderPlate);
                                    }
                                }
                        }
                        catch (Exception t)
                        {
                        }
                        if (Do != -1)
                        {
                            Order *= -1;
                            ChessRules.CurrentOrder *= -1;
                            //Hourse Brown Calling Subbranchs.
                            try
                            {
                                for (int ii = 0; HoursesOnTable[i] != null && HoursesOnTable[i].HourseThinking[0] != null && ii < HoursesOnTable[i].HourseThinking[0].AStarGreedy.Count; ii++)
                                    HoursesOnTable[i].HourseThinking[0].AStarGreedy[ii].IsPenaltyRegardCheckMateAtBranch(Order, ref Do, Base);
                            }
                            catch (Exception t)
                            {
                            }
                            Order = COrder;
                            ChessRules.CurrentOrder = CDummy;
                        }
                    }
                //Bridges Brown 
                for (int i = BridgeMidle; i < BridgeHigh; i++)
                    for (int j = 0; BridgesOnTable[i] != null && BridgesOnTable[i].BridgeThinking[0] != null && j < BridgesOnTable[i].BridgeThinking[0].TableListBridge.Count; j++)
                    {

                        try
                        {
                            //Bridges Brown Rules.
                            AA = new ChessRules(MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, BridgesOnTable[i].BridgeThinking[0].TableListBridge[j][BridgesOnTable[i].BridgeThinking[0].RowColumnBridge[j][0], BridgesOnTable[i].BridgeThinking[0].RowColumnBridge[j][1]]
                            , BridgesOnTable[i].BridgeThinking[0].TableListBridge[j]
                            , Order
                            , BridgesOnTable[i].BridgeThinking[0].RowColumnBridge[j][0]
                            , BridgesOnTable[i].BridgeThinking[0].RowColumnBridge[j][1]);
                            //When Brown Bridges CheckMate Occured.
                            if (AA.CheckMate(BridgesOnTable[i].BridgeThinking[0].TableListBridge[j], Order))
                                //Self CheckMate.
                                if (FormRefrigtz.OrderPlate == -1 && AA.CheckMateBrown)
                                {
                                    //Ignore CheckMate.
                                    Do = -1;
                                    //Superpoistion.
                                    BridgesOnTable[i].BridgeThinking[0].CheckMateAStarGreedy = -1;
                                    //Subbranchs Penalty.
                                    MakePenaltyAllCheckMateBranches(Base, FormRefrigtz.OrderPlate);
                                }
                                else
                                {
                                    //CheckMate Enemy.
                                    if (FormRefrigtz.OrderPlate == 1 && AA.CheckMateGray)
                                    {
                                        //Set Regard.
                                        Do = 1;
                                        //Superpoistion.
                                        BridgesOnTable[i].BridgeThinking[0].CheckMateAStarGreedy = 1;
                                        //Regard Subbranchs.
                                        MakeRegardAllCheckMateBranches(Base, FormRefrigtz.OrderPlate);
                                    }
                                }
                        }
                        catch (Exception t)
                        {
                        }
                        if (Do != -1)
                        {
                            Order *= -1;
                            ChessRules.CurrentOrder *= -1;
                            //Brown Bridges Calling Subbranches.
                            try
                            {
                                for (int ii = 0; BridgesOnTable[i] != null && BridgesOnTable[i].BridgeThinking[0] != null && ii < BridgesOnTable[i].BridgeThinking[0].AStarGreedy.Count; ii++)
                                    BridgesOnTable[i].BridgeThinking[0].AStarGreedy[ii].IsPenaltyRegardCheckMateAtBranch(Order, ref Do, Base);
                            }
                            catch (Exception t)
                            {
                            }
                            Order = COrder;
                            ChessRules.CurrentOrder = CDummy;
                        }
                    }
                //Minister Brown 
                for (int i = MinisterMidle; i < MinisterHigh; i++)
                    for (int j = 0; MinisterOnTable[i] != null && MinisterOnTable[i].MinisterThinking[0] != null && j < MinisterOnTable[i].MinisterThinking[0].TableListMinister.Count; j++)
                    {

                        try
                        {
                            //Minister Brown Rules.
                            AA = new ChessRules(MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, MinisterOnTable[i].MinisterThinking[0].TableListMinister[j][MinisterOnTable[i].MinisterThinking[0].RowColumnMinister[j][0], MinisterOnTable[i].MinisterThinking[0].RowColumnMinister[j][1]]
                            , MinisterOnTable[i].MinisterThinking[0].TableListMinister[j]
                            , Order
                            , MinisterOnTable[i].MinisterThinking[0].RowColumnMinister[j][0]
                            , MinisterOnTable[i].MinisterThinking[0].RowColumnMinister[j][1]);
                            //When Minister Borwn CheckMate Occcured.
                            if (AA.CheckMate(MinisterOnTable[i].MinisterThinking[0].TableListMinister[j], Order))
                                //Self CheckMate.
                                if (FormRefrigtz.OrderPlate == -1 && AA.CheckMateBrown)
                                {
                                    //Set Ignore.
                                    Do = -1;
                                    //Superpoistion.
                                    MinisterOnTable[i].MinisterThinking[0].CheckMateAStarGreedy = -1;
                                    //Penalty Subbranches.
                                    MakePenaltyAllCheckMateBranches(Base, FormRefrigtz.OrderPlate);
                                }
                                else
                                {
                                    //CheckMate Enemy.
                                    if (FormRefrigtz.OrderPlate == 1 && AA.CheckMateGray)
                                    {
                                        //Set Regard.
                                        Do = 1;
                                        //Superposition.
                                        MinisterOnTable[i].MinisterThinking[0].CheckMateAStarGreedy = 1;
                                        //Regard SubBranches.
                                        MakeRegardAllCheckMateBranches(Base, FormRefrigtz.OrderPlate);
                                    }
                                }
                        }
                        catch (Exception t)
                        {
                        }

                        if (Do != -1)
                        {
                            Order *= -1;
                            ChessRules.CurrentOrder *= -1;
                            //Minister Brown SubBranches Calling.
                            try
                            {
                                for (int ii = 0; MinisterOnTable[i] != null && MinisterOnTable[i].MinisterThinking[0] != null && ii < MinisterOnTable[i].MinisterThinking[0].AStarGreedy.Count; ii++)
                                    MinisterOnTable[i].MinisterThinking[0].AStarGreedy[ii].IsPenaltyRegardCheckMateAtBranch(Order, ref Do, Base);
                            }
                            catch (Exception t)
                            {
                            }
                            Order = COrder;
                            ChessRules.CurrentOrder = CDummy;
                        }
                    }
                //King Brown
                for (int i = KingMidle; i < KingHigh; i++)
                    for (int j = 0; KingOnTable[i] != null && KingOnTable[i].KingThinking[0] != null && j < KingOnTable[i].KingThinking[0].TableListKing.Count; j++)
                    {

                        try
                        {
                            //King Brown Rules.
                            AA = new ChessRules(MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, KingOnTable[i].KingThinking[0].TableListKing[j][KingOnTable[i].KingThinking[0].RowColumnKing[j][0], KingOnTable[i].KingThinking[0].RowColumnKing[j][1]]
                            , KingOnTable[i].KingThinking[0].TableListKing[j]
                            , Order
                            , KingOnTable[i].KingThinking[0].RowColumnKing[j][0]
                            , KingOnTable[i].KingThinking[0].RowColumnKing[j][1]);
                            //When King Brown Rules CheckMate Occcured.
                            if (AA.CheckMate(KingOnTable[i].KingThinking[0].TableListKing[j], Order))
                                //Self CheckMate.
                                if (FormRefrigtz.OrderPlate == -1 && AA.CheckMateBrown)
                                {
                                    //Set Ignore.
                                    Do = -1;
                                    //Superposition.
                                    KingOnTable[i].KingThinking[0].CheckMateAStarGreedy = -1;
                                    //Penalty SubBranches.
                                    MakePenaltyAllCheckMateBranches(Base, FormRefrigtz.OrderPlate);
                                }
                                else
                                {
                                    //CheckMate Enemy.
                                    if (FormRefrigtz.OrderPlate == 1 && AA.CheckMateGray)
                                    {
                                        //Set Regard.
                                        Do = 1;
                                        //Superposition.
                                        KingOnTable[i].KingThinking[0].CheckMateAStarGreedy = 1;
                                        //Regard Subbranches.
                                        MakeRegardAllCheckMateBranches(Base, FormRefrigtz.OrderPlate);
                                    }
                                }

                        }
                        catch (Exception t)
                        {
                        }
                        if (Do != -1)
                        {
                            Order *= -1;
                            ChessRules.CurrentOrder *= -1;
                            //King Brown Subbranches Calling.
                            try
                            {
                                for (int ii = 0; KingOnTable[i] != null && KingOnTable[i].KingThinking[0] != null && ii < KingOnTable[i].KingThinking[0].AStarGreedy.Count; ii++)
                                    KingOnTable[i].KingThinking[0].AStarGreedy[ii].IsPenaltyRegardCheckMateAtBranch(Order, ref Do, Base);
                            }
                            catch (Exception t)
                            {
                            }
                            Order = COrder;
                            ChessRules.CurrentOrder = CDummy;
                        }
                    }

            }
            ChessRules.CurrentOrder = CDummy;
        }
        public void MakePenaltyAllCheckMateBranches(AllDraw A, int Order)
        {
            int COrder = Order;
            int CDummy = ChessRules.CurrentOrder;
            if (Order == 1)
            {

                for (int i = 0; i < SodierMidle; i++)
                    for (int j = 0; A.SolderesOnTable[i] != null && A.SolderesOnTable[i].SoldierThinking[0] != null && j < A.SolderesOnTable[i].SoldierThinking[0].TableListSolder.Count; j++)
                    {
                        try
                        {
                            A.SolderesOnTable[i].SoldierThinking[0].PenaltyRegardListSolder[i].LearningAlgorithmPenalty();
                        }
                        catch (Exception t)
                        {
                        }
                        Order *= -1; ChessRules.CurrentOrder *= -1;
                        for (int ii = 0; A.SolderesOnTable[i] != null && A.SolderesOnTable[i].SoldierThinking[0] != null && ii < A.SolderesOnTable[i].SoldierThinking[0].AStarGreedy.Count; ii++)
                            MakePenaltyAllCheckMateBranches(A.SolderesOnTable[i].SoldierThinking[0].AStarGreedy[ii], Order);
                        Order = COrder; ChessRules.CurrentOrder = CDummy;
                    }
                for (int i = 0; i < ElefantMidle; i++)
                    for (int j = 0; A.ElephantOnTable[i] != null && A.ElephantOnTable[i].ElefantThinking[0] != null && j < A.ElephantOnTable[i].ElefantThinking[0].TableListElefant.Count; j++)
                    {

                        try
                        {
                            A.ElephantOnTable[i].ElefantThinking[0].PenaltyRegardListElefant[j].LearningAlgorithmPenalty();
                        }
                        catch (Exception t)
                        {
                        }

                        Order *= -1; ChessRules.CurrentOrder *= -1;
                        try
                        {
                            for (int ii = 0; A.ElephantOnTable[i] != null && A.ElephantOnTable[i].ElefantThinking[0] != null && ii < A.ElephantOnTable[i].ElefantThinking[0].AStarGreedy.Count; ii++)
                                MakePenaltyAllCheckMateBranches(A.ElephantOnTable[i].ElefantThinking[0].AStarGreedy[ii], Order);
                        }
                        catch (Exception t)
                        {
                        }
                        Order = COrder; ChessRules.CurrentOrder = CDummy;
                    }
                for (int i = 0; i < HourseMidle; i++)
                    for (int j = 0; A.HoursesOnTable[i] != null && A.HoursesOnTable[i].HourseThinking[0] != null && j < A.HoursesOnTable[i].HourseThinking[0].TableListHourse.Count; j++)
                    {
                        try
                        {
                            A.HoursesOnTable[i].HourseThinking[0].PenaltyRegardListHourse[j].LearningAlgorithmPenalty();

                        }
                        catch (Exception t)
                        {
                        }

                        Order *= -1; ChessRules.CurrentOrder *= -1;
                        try
                        {
                            for (int ii = 0; A.HoursesOnTable[i] != null && A.HoursesOnTable[i].HourseThinking[0] != null && ii < A.HoursesOnTable[i].HourseThinking[0].AStarGreedy.Count; ii++)
                                MakePenaltyAllCheckMateBranches(A.HoursesOnTable[i].HourseThinking[0].AStarGreedy[ii], Order);
                        }
                        catch (Exception t)
                        {
                        }
                        Order = COrder; ChessRules.CurrentOrder = CDummy;
                    }
                for (int i = 0; i < BridgeMidle; i++)
                    for (int j = 0; A.BridgesOnTable[i] != null && A.BridgesOnTable[i].BridgeThinking[0] != null && j < A.BridgesOnTable[i].BridgeThinking[0].TableListBridge.Count; j++)
                    {
                        try
                        {
                            A.BridgesOnTable[i].BridgeThinking[0].PenaltyRegardListBridge[j].LearningAlgorithmPenalty();
                        }
                        catch (Exception t)
                        {
                        }

                        Order *= -1; ChessRules.CurrentOrder *= -1;
                        try
                        {
                            for (int ii = 0; A.BridgesOnTable[i] != null && A.BridgesOnTable[i].BridgeThinking[0] != null && ii < A.BridgesOnTable[i].BridgeThinking[0].AStarGreedy.Count; ii++)
                                MakePenaltyAllCheckMateBranches(A.BridgesOnTable[i].BridgeThinking[0].AStarGreedy[ii], Order);
                        }
                        catch (Exception t)
                        {
                        }
                        Order = COrder; ChessRules.CurrentOrder = CDummy;
                    }
                for (int i = 0; i < MinisterMidle; i++)
                    for (int j = 0; A.MinisterOnTable[i] != null && A.MinisterOnTable[i].MinisterThinking[0] != null && j < A.MinisterOnTable[i].MinisterThinking[0].TableListMinister.Count; j++)
                    {
                        try
                        {
                            A.MinisterOnTable[i].MinisterThinking[0].PenaltyRegardListMinister[j].LearningAlgorithmPenalty();
                        }
                        catch (Exception t)
                        {
                        }

                        Order *= -1; ChessRules.CurrentOrder *= -1;
                        try
                        {
                            for (int ii = 0; A.MinisterOnTable[i] != null && A.MinisterOnTable[i].MinisterThinking[0] != null && ii < A.MinisterOnTable[i].MinisterThinking[0].AStarGreedy.Count; ii++)
                                MakePenaltyAllCheckMateBranches(A.MinisterOnTable[i].MinisterThinking[0].AStarGreedy[ii], Order);
                        }
                        catch (Exception t)
                        {
                        }
                        Order = COrder; ChessRules.CurrentOrder = CDummy;
                    }
                for (int i = 0; i < KingMidle; i++)
                    for (int j = 0; A.KingOnTable[i] != null && A.KingOnTable[i].KingThinking[0] != null && j < A.KingOnTable[i].KingThinking[0].TableListKing.Count; j++)
                    {
                        try
                        {
                            A.KingOnTable[i].KingThinking[0].PenaltyRegardListKing[j].LearningAlgorithmPenalty();
                        }
                        catch (Exception t)
                        {
                        }

                        Order *= -1; ChessRules.CurrentOrder *= -1;
                        try
                        {
                            for (int ii = 0; A.KingOnTable[i] != null && A.KingOnTable[i].KingThinking[0] != null && ii < A.KingOnTable[i].KingThinking[0].AStarGreedy.Count; ii++)
                                MakePenaltyAllCheckMateBranches(A.KingOnTable[i].KingThinking[0].AStarGreedy[ii], Order);
                        }
                        catch (Exception t)
                        {
                        }
                        Order = COrder; ChessRules.CurrentOrder = CDummy;
                    }
            }
            else
            {
                for (int i = SodierMidle; i < SodierHigh; i++)
                    for (int j = 0; A.SolderesOnTable[i] != null && A.SolderesOnTable[i].SoldierThinking[0] != null && j < A.SolderesOnTable[i].SoldierThinking[0].TableListSolder.Count; j++)
                    {
                        try
                        {
                            A.SolderesOnTable[i].SoldierThinking[0].PenaltyRegardListSolder[i].LearningAlgorithmPenalty();
                        }
                        catch (Exception t)
                        {
                        }
                        Order *= -1; ChessRules.CurrentOrder *= -1;
                        try
                        {
                            for (int ii = 0; A.SolderesOnTable[i] != null && A.SolderesOnTable[i].SoldierThinking[0] != null && ii < A.SolderesOnTable[i].SoldierThinking[0].AStarGreedy.Count; ii++)
                                MakePenaltyAllCheckMateBranches(A.SolderesOnTable[i].SoldierThinking[0].AStarGreedy[ii], Order);
                        }
                        catch (Exception t)
                        {
                        }
                        Order = COrder; ChessRules.CurrentOrder = CDummy;
                    }
                for (int i = ElefantMidle; i < ElefantHigh; i++)
                    for (int j = 0; A.ElephantOnTable[i] != null && A.ElephantOnTable[i].ElefantThinking[0] != null && j < A.ElephantOnTable[i].ElefantThinking[0].TableListElefant.Count; j++)
                    {
                        try
                        {
                            A.ElephantOnTable[i].ElefantThinking[0].PenaltyRegardListElefant[j].LearningAlgorithmPenalty();
                        }
                        catch (Exception t)
                        {
                        }

                        Order *= -1; ChessRules.CurrentOrder *= -1;
                        try
                        {
                            for (int ii = 0; A.ElephantOnTable[i] != null && A.ElephantOnTable[i].ElefantThinking[0] != null && ii < A.ElephantOnTable[i].ElefantThinking[0].AStarGreedy.Count; ii++)
                                MakePenaltyAllCheckMateBranches(A.ElephantOnTable[i].ElefantThinking[0].AStarGreedy[ii], Order);
                        }
                        catch (Exception t)
                        {
                        }
                        Order = COrder; ChessRules.CurrentOrder = CDummy;
                    }
                for (int i = HourseMidle; i < HourseHight; i++)
                    for (int j = 0; A.HoursesOnTable[i] != null && A.HoursesOnTable[i].HourseThinking[0] != null && j < A.HoursesOnTable[i].HourseThinking[0].TableListHourse.Count; j++)
                    {
                        try
                        {
                            A.HoursesOnTable[i].HourseThinking[0].PenaltyRegardListHourse[j].LearningAlgorithmPenalty();

                        }
                        catch (Exception t)
                        {
                        }

                        Order *= -1; ChessRules.CurrentOrder *= -1;
                        try
                        {
                            for (int ii = 0; A.HoursesOnTable[i] != null && A.HoursesOnTable[i].HourseThinking[0] != null && ii < A.HoursesOnTable[i].HourseThinking[0].AStarGreedy.Count; ii++)
                                MakePenaltyAllCheckMateBranches(A.HoursesOnTable[i].HourseThinking[0].AStarGreedy[ii], Order);
                        }
                        catch (Exception t)
                        {
                        }
                        Order = COrder; ChessRules.CurrentOrder = CDummy;
                    }
                for (int i = BridgeMidle; i < BridgeHigh; i++)
                    for (int j = 0; A.BridgesOnTable[i] != null && A.BridgesOnTable[i].BridgeThinking[0] != null && j < A.BridgesOnTable[i].BridgeThinking[0].TableListBridge.Count; j++)
                    {
                        try
                        {
                            A.BridgesOnTable[i].BridgeThinking[0].PenaltyRegardListBridge[j].LearningAlgorithmPenalty();
                        }
                        catch (Exception t)
                        {
                        }

                        Order *= -1; ChessRules.CurrentOrder *= -1;
                        try
                        {
                            for (int ii = 0; A.BridgesOnTable[i] != null && A.BridgesOnTable[i].BridgeThinking[0] != null && ii < A.BridgesOnTable[i].BridgeThinking[0].AStarGreedy.Count; ii++)
                                MakePenaltyAllCheckMateBranches(A.BridgesOnTable[i].BridgeThinking[0].AStarGreedy[ii], Order);
                        }
                        catch (Exception t)
                        {
                        }
                        Order = COrder; ChessRules.CurrentOrder = CDummy;
                    }
                for (int i = MinisterMidle; i < MinisterHigh; i++)
                    for (int j = 0; A.MinisterOnTable[i] != null && A.MinisterOnTable[i].MinisterThinking[0] != null && j < A.MinisterOnTable[i].MinisterThinking[0].TableListMinister.Count; j++)
                    {
                        try
                        {
                            A.MinisterOnTable[i].MinisterThinking[0].PenaltyRegardListMinister[j].LearningAlgorithmPenalty();
                        }
                        catch (Exception t)
                        {
                        }

                        Order *= -1; ChessRules.CurrentOrder *= -1;
                        try
                        {
                            for (int ii = 0; A.MinisterOnTable[i] != null && A.MinisterOnTable[i].MinisterThinking[0] != null && ii < A.MinisterOnTable[i].MinisterThinking[0].AStarGreedy.Count; ii++)
                                MakePenaltyAllCheckMateBranches(A.MinisterOnTable[i].MinisterThinking[0].AStarGreedy[ii], Order);
                        }
                        catch (Exception t)
                        {
                        }
                        Order = COrder; ChessRules.CurrentOrder = CDummy;
                    }
                for (int i = KingMidle; i < MinisterHigh; i++)
                    for (int j = 0; A.KingOnTable[i] != null && A.KingOnTable[i].KingThinking[0] != null && j < A.KingOnTable[i].KingThinking[0].TableListKing.Count; j++)
                    {
                        try
                        {
                            A.KingOnTable[i].KingThinking[0].PenaltyRegardListKing[j].LearningAlgorithmPenalty();
                        }
                        catch (Exception t)
                        {
                        }

                        Order *= -1; ChessRules.CurrentOrder *= -1;
                        try
                        {
                            for (int ii = 0; A.KingOnTable[i] != null && A.KingOnTable[i].KingThinking[0] != null && ii < A.KingOnTable[i].KingThinking[0].AStarGreedy.Count; ii++)
                                MakePenaltyAllCheckMateBranches(A.KingOnTable[i].KingThinking[0].AStarGreedy[ii], Order);
                        }
                        catch (Exception t)
                        {
                        }
                        Order = COrder; ChessRules.CurrentOrder = CDummy;
                    }
            }
        }
        public AllDraw RemovePenalltyFromFirstBranches()
        {
            if (FormRefrigtz.OrderPlate == 1)
            {

                for (int i = 0; i < SodierMidle; i++)
                    for (int j = 0; SolderesOnTable[i] != null && SolderesOnTable[i].SoldierThinking[0] != null && j < SolderesOnTable[i].SoldierThinking[0].TableListSolder.Count; j++)
                    {

                        try
                        {
                            SolderesOnTable[i].SoldierThinking[0].PenaltyRegardListSolder[j].Initiate();
                        }
                        catch (Exception t)
                        {
                        }
                    }
                for (int i = 0; i < ElefantMidle; i++)
                    for (int j = 0; ElephantOnTable[i] != null && ElephantOnTable[i].ElefantThinking[0] != null && j < ElephantOnTable[i].ElefantThinking[0].TableListElefant.Count; j++)
                    {
                        try
                        {

                            ElephantOnTable[i].ElefantThinking[0].PenaltyRegardListElefant[j].Initiate();

                        }
                        catch (Exception t)
                        {
                        }
                    }
                for (int i = 0; i < HourseMidle; i++)
                    for (int j = 0; HoursesOnTable[i] != null && HoursesOnTable[i].HourseThinking[0] != null && j < HoursesOnTable[i].HourseThinking[0].TableListHourse.Count; j++)
                    {
                        try
                        {
                            HoursesOnTable[i].HourseThinking[0].PenaltyRegardListHourse[j].Initiate();
                        }
                        catch (Exception t)
                        {
                        }


                    }
                for (int i = 0; i < BridgeMidle; i++)
                    for (int j = 0; BridgesOnTable[i] != null && BridgesOnTable[i].BridgeThinking[0] != null && j < BridgesOnTable[i].BridgeThinking[0].TableListBridge.Count; j++)
                    {
                        try
                        {

                            BridgesOnTable[i].BridgeThinking[0].PenaltyRegardListBridge[j].Initiate();
                        }
                        catch (Exception t)
                        {
                        }

                    }
                for (int i = 0; i < MinisterMidle; i++)
                    for (int j = 0; MinisterOnTable[i] != null && MinisterOnTable[i].MinisterThinking[0] != null && j < MinisterOnTable[i].MinisterThinking[0].TableListMinister.Count; j++)
                    {
                        try
                        {

                            MinisterOnTable[i].MinisterThinking[0].PenaltyRegardListMinister[j].Initiate();
                        }
                        catch (Exception t)
                        {
                        }

                    }
                for (int i = 0; i < KingMidle; i++)
                    for (int j = 0; KingOnTable[i] != null && KingOnTable[i].KingThinking[0] != null && j < KingOnTable[i].KingThinking[0].TableListKing.Count; j++)
                    {
                        try
                        {

                            KingOnTable[i].KingThinking[0].PenaltyRegardListKing[j].Initiate();
                        }
                        catch (Exception t)
                        {
                        }

                    }
            }
            else
            {
                for (int i = SodierMidle; i < SodierHigh; i++)
                    for (int j = 0; SolderesOnTable[i] != null && SolderesOnTable[i].SoldierThinking != null && j < SolderesOnTable[i].SoldierThinking[0].TableListSolder.Count; j++)
                    {
                        try
                        {

                            SolderesOnTable[i].SoldierThinking[0].PenaltyRegardListSolder[j].Initiate();
                        }
                        catch (Exception t)
                        {
                        }
                    }
                for (int i = ElefantMidle; i < ElefantHigh; i++)
                    for (int j = 0; ElephantOnTable[i] != null && ElephantOnTable[i].ElefantThinking[0] != null && j < ElephantOnTable[i].ElefantThinking[0].TableListElefant.Count; j++)
                    {
                        try
                        {

                            ElephantOnTable[i].ElefantThinking[0].PenaltyRegardListElefant[j].Initiate();

                        }
                        catch (Exception t)
                        {
                        }
                    }
                for (int i = HourseMidle; i < HourseHight; i++)
                    for (int j = 0; HoursesOnTable[i] != null && HoursesOnTable[i].HourseThinking[0] != null && j < HoursesOnTable[i].HourseThinking[0].TableListHourse.Count; j++)
                    {
                        try
                        {

                            HoursesOnTable[i].HourseThinking[0].PenaltyRegardListHourse[j].Initiate();


                        }
                        catch (Exception t)
                        {
                        }
                    }
                for (int i = BridgeMidle; i < BridgeHigh; i++)
                    for (int j = 0; BridgesOnTable[i] != null && BridgesOnTable[i].BridgeThinking[0] != null && j < BridgesOnTable[i].BridgeThinking[0].TableListBridge.Count; j++)
                    {
                        try
                        {

                            BridgesOnTable[i].BridgeThinking[0].PenaltyRegardListBridge[j].Initiate();

                        }
                        catch (Exception t)
                        {
                        }
                    }
                for (int i = MinisterMidle; i < MinisterHigh; i++)
                    for (int j = 0; MinisterOnTable[i] != null && MinisterOnTable[i].MinisterThinking[0] != null && j < MinisterOnTable[i].MinisterThinking[0].TableListMinister.Count; j++)
                    {
                        try
                        {

                            MinisterOnTable[i].MinisterThinking[0].PenaltyRegardListMinister[j].Initiate();

                        }
                        catch (Exception t)
                        {
                        }
                    }
                for (int i = KingMidle; i < KingHigh; i++)
                    for (int j = 0; KingOnTable[i] != null && KingOnTable[i].KingThinking[0] != null && j < KingOnTable[i].KingThinking[0].TableListKing.Count; j++)
                    {
                        try
                        {
                            KingOnTable[i].KingThinking[0].PenaltyRegardListKing[j].Initiate();

                        }
                        catch (Exception t)
                        {
                        }
                    }
            }
            return this;
        }
        public AllDraw FoundOfCurrentTableNode(int[,] Tab, int Order, ref AllDraw THIS, ref bool Found)
        {
            if (Found)
                return THIS;
            if (Order == 1)
            {

                for (int i = 0; i < SodierMidle; i++)
                    for (int j = 0; SolderesOnTable[i] != null && SolderesOnTable[i].SoldierThinking[0] != null && j < SolderesOnTable[i].SoldierThinking[0].TableListSolder.Count; j++)
                    {

                        try
                        {
                            if (ThinkingChess.TableEqual(SolderesOnTable[i].SoldierThinking[0].TableListSolder[j], Tab))
                            {
                                THIS = this.SolderesOnTable[i].SoldierThinking[0].AStarGreedy[j];
                                Found = true;
                                return THIS;
                            }
                            else
                                for (int ii = 0; ii < SolderesOnTable[i].SoldierThinking[0].AStarGreedy.Count - 1; ii++)
                                    SolderesOnTable[i].SoldierThinking[0].AStarGreedy[ii].FoundOfCurrentTableNode(Tab, Order * -1, ref THIS, ref Found);

                        }

                        catch (Exception t)
                        {
                        }
                    }
                for (int i = 0; i < ElefantMidle; i++)
                    for (int j = 0; ElephantOnTable[i] != null && ElephantOnTable[i].ElefantThinking[0] != null && j < ElephantOnTable[i].ElefantThinking[0].TableListElefant.Count; j++)
                    {
                        try
                        {

                            if (ThinkingChess.TableEqual(ElephantOnTable[i].ElefantThinking[0].TableListElefant[j], Tab))
                            {
                                THIS = this.ElephantOnTable[i].ElefantThinking[0].AStarGreedy[j];
                                Found = true;
                                return THIS;
                            }
                            else
                                for (int ii = 0; ii < ElephantOnTable[i].ElefantThinking[0].AStarGreedy.Count - 1; ii++)
                                    ElephantOnTable[i].ElefantThinking[0].AStarGreedy[ii].FoundOfCurrentTableNode(Tab, Order * -1, ref THIS, ref Found);


                        }
                        catch (Exception t)
                        {
                        }
                    }
                for (int i = 0; i < HourseMidle; i++)
                    for (int j = 0; HoursesOnTable[i] != null && HoursesOnTable[i].HourseThinking[0] != null && j < HoursesOnTable[i].HourseThinking[0].TableListHourse.Count; j++)
                    {
                        try
                        {
                            if (ThinkingChess.TableEqual(HoursesOnTable[i].HourseThinking[0].TableListHourse[j], Tab))
                            {
                                THIS = this.HoursesOnTable[i].HourseThinking[0].AStarGreedy[j];
                                Found = true;
                                return THIS;
                            }
                            else
                                for (int ii = 0; ii < HoursesOnTable[i].HourseThinking[0].AStarGreedy.Count - 1; ii++)
                                    HoursesOnTable[i].HourseThinking[0].AStarGreedy[ii].FoundOfCurrentTableNode(Tab, Order * -1, ref THIS, ref Found);

                        }
                        catch (Exception t)
                        {
                        }


                    }
                for (int i = 0; i < BridgeMidle; i++)
                    for (int j = 0; BridgesOnTable[i] != null && BridgesOnTable[i].BridgeThinking[0] != null && j < BridgesOnTable[i].BridgeThinking[0].TableListBridge.Count; j++)
                    {
                        try
                        {
                            if (ThinkingChess.TableEqual(BridgesOnTable[i].BridgeThinking[0].TableListBridge[j], Tab))
                            {
                                THIS = this.BridgesOnTable[i].BridgeThinking[0].AStarGreedy[j];
                                Found = true;
                                return THIS;
                            }
                            else
                                for (int ii = 0; ii < BridgesOnTable[i].BridgeThinking[0].AStarGreedy.Count - 1; ii++)
                                    BridgesOnTable[i].BridgeThinking[0].AStarGreedy[ii].FoundOfCurrentTableNode(Tab, Order * -1, ref THIS, ref Found);
                        }
                        catch (Exception t)
                        {
                        }

                    }
                for (int i = 0; i < MinisterMidle; i++)
                    for (int j = 0; MinisterOnTable[i] != null && MinisterOnTable[i].MinisterThinking[0] != null && j < MinisterOnTable[i].MinisterThinking[0].TableListMinister.Count; j++)
                    {
                        try
                        {
                            if (ThinkingChess.TableEqual(MinisterOnTable[i].MinisterThinking[0].TableListMinister[j], Tab))
                            {
                                THIS = this.MinisterOnTable[i].MinisterThinking[0].AStarGreedy[j];
                                Found = true;
                                return THIS;
                            }
                            else
                                for (int ii = 0; ii < MinisterOnTable[i].MinisterThinking[0].AStarGreedy.Count - 1; ii++)
                                    MinisterOnTable[i].MinisterThinking[0].AStarGreedy[ii].FoundOfCurrentTableNode(Tab, Order * -1, ref THIS, ref Found);

                        }
                        catch (Exception t)
                        {
                        }

                    }
                for (int i = 0; i < KingMidle; i++)
                    for (int j = 0; KingOnTable[i] != null && KingOnTable[i].KingThinking[0] != null && j < KingOnTable[i].KingThinking[0].TableListKing.Count; j++)
                    {
                        try
                        {
                            if (ThinkingChess.TableEqual(KingOnTable[i].KingThinking[0].TableListKing[j], Tab))
                            {
                                THIS = this.KingOnTable[i].KingThinking[0].AStarGreedy[j];
                                Found = true;
                                return THIS;
                            }
                            else
                                for (int ii = 0; ii < KingOnTable[i].KingThinking[0].AStarGreedy.Count - 1; ii++)
                                    KingOnTable[i].KingThinking[0].AStarGreedy[ii].FoundOfCurrentTableNode(Tab, Order * -1, ref THIS, ref Found);

                        }
                        catch (Exception t)
                        {
                        }

                    }
            }
            else
            {
                for (int i = SodierMidle; i < SodierHigh; i++)
                    for (int j = 0; SolderesOnTable[i] != null && SolderesOnTable[i].SoldierThinking != null && j < SolderesOnTable[i].SoldierThinking[0].TableListSolder.Count; j++)
                    {
                        try
                        {

                            if (ThinkingChess.TableEqual(SolderesOnTable[i].SoldierThinking[0].TableListSolder[j], Tab))
                            {
                                THIS = this.SolderesOnTable[i].SoldierThinking[0].AStarGreedy[j];
                                Found = true;
                                return THIS;
                            }
                            else
                                for (int ii = 0; ii < SolderesOnTable[i].SoldierThinking[0].AStarGreedy.Count - 1; ii++)
                                    SolderesOnTable[i].SoldierThinking[0].AStarGreedy[ii].FoundOfCurrentTableNode(Tab, Order * -1, ref THIS, ref Found);

                        }
                        catch (Exception t)
                        {
                        }
                    }
                for (int i = ElefantMidle; i < ElefantHigh; i++)
                    for (int j = 0; ElephantOnTable[i] != null && ElephantOnTable[i].ElefantThinking[0] != null && j < ElephantOnTable[i].ElefantThinking[0].TableListElefant.Count; j++)
                    {
                        try
                        {

                            if (ThinkingChess.TableEqual(ElephantOnTable[i].ElefantThinking[0].TableListElefant[j], Tab))
                            {
                                THIS = this.ElephantOnTable[i].ElefantThinking[0].AStarGreedy[j];
                                Found = true;
                                return THIS;
                            }
                            else
                                for (int ii = 0; ii < ElephantOnTable[i].ElefantThinking[0].AStarGreedy.Count - 1; ii++)
                                    ElephantOnTable[i].ElefantThinking[0].AStarGreedy[ii].FoundOfCurrentTableNode(Tab, Order * -1, ref THIS, ref Found);

                        }
                        catch (Exception t)
                        {
                        }
                    }
                for (int i = HourseMidle; i < HourseHight; i++)
                    for (int j = 0; HoursesOnTable[i] != null && HoursesOnTable[i].HourseThinking[0] != null && j < HoursesOnTable[i].HourseThinking[0].TableListHourse.Count; j++)
                    {
                        try
                        {

                            if (ThinkingChess.TableEqual(HoursesOnTable[i].HourseThinking[0].TableListHourse[j], Tab))
                            {
                                THIS = this.HoursesOnTable[i].HourseThinking[0].AStarGreedy[j];
                                Found = true;
                                return THIS;
                            }
                            else
                                for (int ii = 0; ii < HoursesOnTable[i].HourseThinking[0].AStarGreedy.Count - 1; ii++)
                                    HoursesOnTable[i].HourseThinking[0].AStarGreedy[ii].FoundOfCurrentTableNode(Tab, Order * -1, ref THIS, ref Found);


                        }
                        catch (Exception t)
                        {
                        }
                    }
                for (int i = BridgeMidle; i < BridgeHigh; i++)
                    for (int j = 0; BridgesOnTable[i] != null && BridgesOnTable[i].BridgeThinking[0] != null && j < BridgesOnTable[i].BridgeThinking[0].TableListBridge.Count; j++)
                    {
                        try
                        {

                            if (ThinkingChess.TableEqual(BridgesOnTable[i].BridgeThinking[0].TableListBridge[j], Tab))
                            {
                                THIS = this.BridgesOnTable[i].BridgeThinking[0].AStarGreedy[j];
                                Found = true;
                                return THIS;
                            }
                            else
                                for (int ii = 0; ii < BridgesOnTable[i].BridgeThinking[0].AStarGreedy.Count - 1; ii++)
                                    BridgesOnTable[i].BridgeThinking[0].AStarGreedy[ii].FoundOfCurrentTableNode(Tab, Order * -1, ref THIS, ref Found);

                        }
                        catch (Exception t)
                        {
                        }
                    }
                for (int i = MinisterMidle; i < MinisterHigh; i++)
                    for (int j = 0; MinisterOnTable[i] != null && MinisterOnTable[i].MinisterThinking[0] != null && j < MinisterOnTable[i].MinisterThinking[0].TableListMinister.Count; j++)
                    {
                        try
                        {
                            if (ThinkingChess.TableEqual(MinisterOnTable[i].MinisterThinking[0].TableListMinister[j], Tab))
                            {
                                THIS = this.MinisterOnTable[i].MinisterThinking[0].AStarGreedy[j];
                                Found = true;
                                return THIS;
                            }
                            else
                                for (int ii = 0; ii < MinisterOnTable[i].MinisterThinking[0].AStarGreedy.Count - 1; ii++)
                                    MinisterOnTable[i].MinisterThinking[0].AStarGreedy[ii].FoundOfCurrentTableNode(Tab, Order * -1, ref THIS, ref Found);

                        }
                        catch (Exception t)
                        {
                        }
                    }
                for (int i = KingMidle; i < KingHigh; i++)
                    for (int j = 0; KingOnTable[i] != null && KingOnTable[i].KingThinking[0] != null && j < KingOnTable[i].KingThinking[0].TableListKing.Count; j++)
                    {
                        try
                        {
                            if (ThinkingChess.TableEqual(KingOnTable[i].KingThinking[0].TableListKing[j], Tab))
                            {
                                THIS = this.KingOnTable[i].KingThinking[0].AStarGreedy[j];
                                Found = true;
                                return THIS;
                            }
                            else
                                for (int ii = 0; ii < KingOnTable[i].KingThinking[0].AStarGreedy.Count - 1; ii++)
                                    KingOnTable[i].KingThinking[0].AStarGreedy[ii].FoundOfCurrentTableNode(Tab, Order * -1, ref THIS, ref Found);

                        }
                        catch (Exception t)
                        {
                        }
                    }
            }
            return THIS;
        }
        public AllDraw FoundOfLeafDepenOfKind(int Kind, ref AllDraw Leaf, ref bool Found, int Order, ref int OrderLeaf)
        {
            //if (ThinkingChess.FoundFirstMating > MaxAStarGreedy)
            //7 return Leaf;
            if (Found)
                return Leaf;
            if (Order == 1)
            {

                for (int i = 0; i < SodierMidle; i++)
                    for (int j = 0; SolderesOnTable[i] != null && SolderesOnTable[i].SoldierThinking[0] != null && j < SolderesOnTable[i].SoldierThinking[0].TableListSolder.Count; j++)
                    {

                        try
                        {
                            if (SolderesOnTable[i].SoldierThinking[0].AStarGreedy.Count == 0 && Kind == 1)
                            {
                                Found = true;
                                Leaf = this;
                                return Leaf;

                            }
                            else
                                for (int ii = 0; ii < SolderesOnTable[i].SoldierThinking[0].AStarGreedy.Count - 1; ii++)
                                    SolderesOnTable[i].SoldierThinking[0].AStarGreedy[ii].FoundOfLeafDepenOfKind(Kind, ref Leaf, ref Found, Order * -1, ref OrderLeaf);

                        }

                        catch (Exception t)
                        {
                        }
                    }
                for (int i = 0; i < ElefantMidle; i++)
                    for (int j = 0; ElephantOnTable[i] != null && ElephantOnTable[i].ElefantThinking[0] != null && j < ElephantOnTable[i].ElefantThinking[0].TableListElefant.Count; j++)
                    {
                        try
                        {
                            if (ElephantOnTable[i].ElefantThinking[0].AStarGreedy.Count == 0 && Kind == 2)
                            {
                                Found = true;
                                Leaf = this;
                                return Leaf;
                            }
                            else
                                for (int ii = 0; ii < ElephantOnTable[i].ElefantThinking[0].AStarGreedy.Count - 1; ii++)
                                    ElephantOnTable[i].ElefantThinking[0].AStarGreedy[ii].FoundOfLeafDepenOfKind(Kind, ref Leaf, ref Found, Order * -1, ref OrderLeaf);


                        }
                        catch (Exception t)
                        {
                        }
                    }
                for (int i = 0; i < HourseMidle; i++)
                    for (int j = 0; HoursesOnTable[i] != null && HoursesOnTable[i].HourseThinking[0] != null && j < HoursesOnTable[i].HourseThinking[0].TableListHourse.Count; j++)
                    {
                        try
                        {
                            if (HoursesOnTable[i].HourseThinking[0].AStarGreedy.Count == 0 && Kind == 3)
                            {
                                Found = true;
                                Leaf = this;
                                return Leaf;
                            }
                            else
                                for (int ii = 0; ii < HoursesOnTable[i].HourseThinking[0].AStarGreedy.Count - 1; ii++)
                                    HoursesOnTable[i].HourseThinking[0].AStarGreedy[ii].FoundOfLeafDepenOfKind(Kind, ref Leaf, ref Found, Order * -1, ref OrderLeaf);

                        }
                        catch (Exception t)
                        {
                        }


                    }
                for (int i = 0; i < BridgeMidle; i++)
                    for (int j = 0; BridgesOnTable[i] != null && BridgesOnTable[i].BridgeThinking[0] != null && j < BridgesOnTable[i].BridgeThinking[0].TableListBridge.Count; j++)
                    {
                        try
                        {
                            if (BridgesOnTable[i].BridgeThinking[0].AStarGreedy.Count == 0 && Kind == 4)
                            {
                                Found = true;
                                Leaf = this;
                                return Leaf;
                            }
                            else
                                for (int ii = 0; ii < BridgesOnTable[i].BridgeThinking[0].AStarGreedy.Count - 1; ii++)
                                    BridgesOnTable[i].BridgeThinking[0].AStarGreedy[ii].FoundOfLeafDepenOfKind(Kind, ref Leaf, ref Found, Order * -1, ref OrderLeaf);
                        }
                        catch (Exception t)
                        {
                        }

                    }
                for (int i = 0; i < MinisterMidle; i++)
                    for (int j = 0; MinisterOnTable[i] != null && MinisterOnTable[i].MinisterThinking[0] != null && j < MinisterOnTable[i].MinisterThinking[0].TableListMinister.Count; j++)
                    {
                        try
                        {
                            if (MinisterOnTable[i].MinisterThinking[0].AStarGreedy.Count == 0 && Kind == 5)
                            {
                                Found = true;
                                Leaf = this;
                                return Leaf;
                            }
                            else
                                for (int ii = 0; ii < MinisterOnTable[i].MinisterThinking[0].AStarGreedy.Count - 1; ii++)
                                    MinisterOnTable[i].MinisterThinking[0].AStarGreedy[ii].FoundOfLeafDepenOfKind(Kind, ref Leaf, ref Found, Order * -1, ref OrderLeaf);

                        }
                        catch (Exception t)
                        {
                        }

                    }
                for (int i = 0; i < KingMidle; i++)
                    for (int j = 0; KingOnTable[i] != null && KingOnTable[i].KingThinking[0] != null && j < KingOnTable[i].KingThinking[0].TableListKing.Count; j++)
                    {
                        try
                        {
                            if (KingOnTable[i].KingThinking[0].AStarGreedy.Count == 0 && Kind == 6)
                            {
                                Found = true;
                                Leaf = this;
                                return Leaf;
                            }
                            else
                                for (int ii = 0; ii < KingOnTable[i].KingThinking[0].AStarGreedy.Count - 1; ii++)
                                    KingOnTable[i].KingThinking[0].AStarGreedy[ii].FoundOfLeafDepenOfKind(Kind, ref Leaf, ref Found, Order * -1, ref OrderLeaf);

                        }
                        catch (Exception t)
                        {
                        }

                    }
            }
            else
            {
                for (int i = SodierMidle; i < SodierHigh; i++)
                    for (int j = 0; SolderesOnTable[i] != null && SolderesOnTable[i].SoldierThinking != null && j < SolderesOnTable[i].SoldierThinking[0].TableListSolder.Count; j++)
                    {
                        try
                        {

                            if (SolderesOnTable[i].SoldierThinking[0].AStarGreedy.Count == 0 && Kind == 1)
                            {
                                Found = true;
                                Leaf = this;
                                return Leaf;
                            }
                            else
                                for (int ii = 0; ii < SolderesOnTable[i].SoldierThinking[0].AStarGreedy.Count - 1; ii++)
                                    SolderesOnTable[i].SoldierThinking[0].AStarGreedy[ii].FoundOfLeafDepenOfKind(Kind, ref Leaf, ref Found, Order * -1, ref OrderLeaf);
                        }
                        catch (Exception t)
                        {
                        }
                    }
                for (int i = ElefantMidle; i < ElefantHigh; i++)
                    for (int j = 0; ElephantOnTable[i] != null && ElephantOnTable[i].ElefantThinking[0] != null && j < ElephantOnTable[i].ElefantThinking[0].TableListElefant.Count; j++)
                    {
                        try
                        {

                            if (ElephantOnTable[i].ElefantThinking[0].AStarGreedy.Count == 0 && Kind == 2)
                            {
                                Found = true;
                                Leaf = this;
                                return Leaf;
                            }
                            else
                                for (int ii = 0; ii < ElephantOnTable[i].ElefantThinking[0].AStarGreedy.Count - 1; ii++)
                                    ElephantOnTable[i].ElefantThinking[0].AStarGreedy[ii].FoundOfLeafDepenOfKind(Kind, ref Leaf, ref Found, Order * -1, ref OrderLeaf);
                        }
                        catch (Exception t)
                        {
                        }
                    }
                for (int i = HourseMidle; i < HourseHight; i++)
                    for (int j = 0; HoursesOnTable[i] != null && HoursesOnTable[i].HourseThinking[0] != null && j < HoursesOnTable[i].HourseThinking[0].TableListHourse.Count; j++)
                    {
                        try
                        {

                            if (HoursesOnTable[i].HourseThinking[0].AStarGreedy.Count == 0 && Kind == 3)
                            {
                                Found = true;
                                Leaf = this;
                                return Leaf;
                            }
                            else
                                for (int ii = 0; ii < HoursesOnTable[i].HourseThinking[0].AStarGreedy.Count - 1; ii++)
                                    HoursesOnTable[i].HourseThinking[0].AStarGreedy[ii].FoundOfLeafDepenOfKind(Kind, ref Leaf, ref Found, Order * -1, ref OrderLeaf);
                        }
                        catch (Exception t)
                        {
                        }
                    }
                for (int i = BridgeMidle; i < BridgeHigh; i++)
                    for (int j = 0; BridgesOnTable[i] != null && BridgesOnTable[i].BridgeThinking[0] != null && j < BridgesOnTable[i].BridgeThinking[0].TableListBridge.Count; j++)
                    {
                        try
                        {

                            if (BridgesOnTable[i].BridgeThinking[0].AStarGreedy.Count == 0 && Kind == 4)
                            {
                                Found = true;
                                Leaf = this;
                                return Leaf;
                            }
                            else
                                for (int ii = 0; ii < BridgesOnTable[i].BridgeThinking[0].AStarGreedy.Count - 1; ii++)
                                    BridgesOnTable[i].BridgeThinking[0].AStarGreedy[ii].FoundOfLeafDepenOfKind(Kind, ref Leaf, ref Found, Order * -1, ref OrderLeaf);

                        }
                        catch (Exception t)
                        {
                        }
                    }
                for (int i = MinisterMidle; i < MinisterHigh; i++)
                    for (int j = 0; MinisterOnTable[i] != null && MinisterOnTable[i].MinisterThinking[0] != null && j < MinisterOnTable[i].MinisterThinking[0].TableListMinister.Count; j++)
                    {
                        try
                        {
                            if (MinisterOnTable[i].MinisterThinking[0].AStarGreedy.Count == 0 && Kind == 5)
                            {
                                Found = true;
                                Leaf = this;
                                return Leaf;
                            }
                            else
                                for (int ii = 0; ii < MinisterOnTable[i].MinisterThinking[0].AStarGreedy.Count - 1; ii++)
                                    MinisterOnTable[i].MinisterThinking[0].AStarGreedy[ii].FoundOfLeafDepenOfKind(Kind, ref Leaf, ref Found, Order * -1, ref OrderLeaf);

                        }
                        catch (Exception t)
                        {
                        }
                    }
                for (int i = KingMidle; i < KingHigh; i++)
                    for (int j = 0; KingOnTable[i] != null && KingOnTable[i].KingThinking[0] != null && j < KingOnTable[i].KingThinking[0].TableListKing.Count; j++)
                    {
                        try
                        {
                            if (KingOnTable[i].KingThinking[0].AStarGreedy.Count == 0 && Kind == 6)
                            {
                                Found = true;
                                Leaf = this;
                                return Leaf;

                            }
                            else
                                for (int ii = 0; ii < KingOnTable[i].KingThinking[0].AStarGreedy.Count - 1; ii++)
                                    KingOnTable[i].KingThinking[0].AStarGreedy[ii].FoundOfLeafDepenOfKind(Kind, ref Leaf, ref Found, Order * -1, ref OrderLeaf);


                        }
                        catch (Exception t)
                        {
                        }
                    }
            }
            return Leaf;
        }
        public void FoundOfLeafDepenOfKindFullGame(int Order, int iAStarGreedy, int ii, int jj, int ik, int jjj, ref List<Task> ThA, bool FOUND)
        {
            //if (ThinkingChess.FoundFirstMating > MaxAStarGreedy)
            //   return;
            if (Order == 1)
            {

                for (int i = 0; i < SodierMidle; i++)
                    for (int j = 0; SolderesOnTable[i] != null && SolderesOnTable[i].SoldierThinking[0] != null && j < SolderesOnTable[i].SoldierThinking[0].TableListSolder.Count; j++)
                    {

                        try
                        {
                            if (SolderesOnTable[i].SoldierThinking[0].AStarGreedy.Count == 0)
                            {
                                FullGameThinkingTree(Order, iAStarGreedy, ii, jj, ik, jjj, ref ThA, false);

                            }
                            else
                                for (int iii = 0; iii < SolderesOnTable[i].SoldierThinking[0].AStarGreedy.Count - 1; iii++)
                                    SolderesOnTable[i].SoldierThinking[0].AStarGreedy[iii].FoundOfLeafDepenOfKindFullGame(Order * -1, iAStarGreedy, ii, jj, ik, jjj, ref ThA, FOUND);

                        }

                        catch (Exception t)
                        {
                        }
                    }
                for (int i = 0; i < ElefantMidle; i++)
                    for (int j = 0; ElephantOnTable[i] != null && ElephantOnTable[i].ElefantThinking[0] != null && j < ElephantOnTable[i].ElefantThinking[0].TableListElefant.Count; j++)
                    {
                        try
                        {
                            if (ElephantOnTable[i].ElefantThinking[0].AStarGreedy.Count == 0)
                            {
                                FullGameThinkingTree(Order, iAStarGreedy, ii, jj, ik, jjj, ref ThA, false);
                            }
                            else
                                for (int iii = 0; iii < ElephantOnTable[i].ElefantThinking[0].AStarGreedy.Count - 1; iii++)
                                    ElephantOnTable[i].ElefantThinking[0].AStarGreedy[iii].FoundOfLeafDepenOfKindFullGame(Order * -1, iAStarGreedy, ii, jj, ik, jjj, ref ThA, FOUND);


                        }
                        catch (Exception t)
                        {
                        }
                    }
                for (int i = 0; i < HourseMidle; i++)
                    for (int j = 0; HoursesOnTable[i] != null && HoursesOnTable[i].HourseThinking[0] != null && j < HoursesOnTable[i].HourseThinking[0].TableListHourse.Count; j++)
                    {
                        try
                        {
                            if (HoursesOnTable[i].HourseThinking[0].AStarGreedy.Count == 0)
                            {
                                FullGameThinkingTree(Order, iAStarGreedy, ii, jj, ik, jjj, ref ThA, false);
                            }
                            else
                                for (int iii = 0; iii < HoursesOnTable[i].HourseThinking[0].AStarGreedy.Count - 1; iii++)
                                    HoursesOnTable[i].HourseThinking[0].AStarGreedy[iii].FoundOfLeafDepenOfKindFullGame(Order * -1, iAStarGreedy, ii, jj, ik, jjj, ref ThA, FOUND);

                        }
                        catch (Exception t)
                        {
                        }


                    }
                for (int i = 0; i < BridgeMidle; i++)
                    for (int j = 0; BridgesOnTable[i] != null && BridgesOnTable[i].BridgeThinking[0] != null && j < BridgesOnTable[i].BridgeThinking[0].TableListBridge.Count; j++)
                    {
                        try
                        {
                            if (BridgesOnTable[i].BridgeThinking[0].AStarGreedy.Count == 0)
                            {
                                FullGameThinkingTree(Order, iAStarGreedy, ii, jj, ik, jjj, ref ThA, false);
                            }
                            else
                                for (int iii = 0; iii < BridgesOnTable[i].BridgeThinking[0].AStarGreedy.Count - 1; iii++)
                                    BridgesOnTable[i].BridgeThinking[0].AStarGreedy[iii].FoundOfLeafDepenOfKindFullGame(Order * -1, iAStarGreedy, ii, jj, ik, jjj, ref ThA, FOUND);
                        }
                        catch (Exception t)
                        {
                        }

                    }
                for (int i = 0; i < MinisterMidle; i++)
                    for (int j = 0; MinisterOnTable[i] != null && MinisterOnTable[i].MinisterThinking[0] != null && j < MinisterOnTable[i].MinisterThinking[0].TableListMinister.Count; j++)
                    {
                        try
                        {
                            if (MinisterOnTable[i].MinisterThinking[0].AStarGreedy.Count == 0)
                            {
                                FullGameThinkingTree(Order, iAStarGreedy, ii, jj, ik, jjj, ref ThA, false);
                            }
                            else
                                for (int iii = 0; iii < MinisterOnTable[i].MinisterThinking[0].AStarGreedy.Count - 1; iii++)
                                    MinisterOnTable[i].MinisterThinking[0].AStarGreedy[iii].FoundOfLeafDepenOfKindFullGame(Order * -1, iAStarGreedy, ii, jj, ik, jjj, ref ThA, FOUND);

                        }
                        catch (Exception t)
                        {
                        }

                    }
                for (int i = 0; i < KingMidle; i++)
                    for (int j = 0; KingOnTable[i] != null && KingOnTable[i].KingThinking[0] != null && j < KingOnTable[i].KingThinking[0].TableListKing.Count; j++)
                    {
                        try
                        {
                            if (KingOnTable[i].KingThinking[0].AStarGreedy.Count == 0)
                            {
                                FullGameThinkingTree(Order, iAStarGreedy, ii, jj, ik, jjj, ref ThA, false);
                            }
                            else
                                for (int iii = 0; iii < KingOnTable[i].KingThinking[0].AStarGreedy.Count - 1; iii++)
                                    KingOnTable[i].KingThinking[0].AStarGreedy[iii].FoundOfLeafDepenOfKindFullGame(Order * -1, iAStarGreedy, ii, jj, ik, jjj, ref ThA, FOUND);

                        }
                        catch (Exception t)
                        {
                        }

                    }
            }
            else
            {
                for (int i = SodierMidle; i < SodierHigh; i++)
                    for (int j = 0; SolderesOnTable[i] != null && SolderesOnTable[i].SoldierThinking != null && j < SolderesOnTable[i].SoldierThinking[0].TableListSolder.Count; j++)
                    {
                        try
                        {

                            if (SolderesOnTable[i].SoldierThinking[0].AStarGreedy.Count == 0)
                            {
                                FullGameThinkingTree(Order, iAStarGreedy, ii, jj, ik, jjj, ref ThA, false);
                            }
                            else
                                for (int iii = 0; ii < SolderesOnTable[i].SoldierThinking[0].AStarGreedy.Count - 1; iii++)
                                    SolderesOnTable[i].SoldierThinking[0].AStarGreedy[iii].FoundOfLeafDepenOfKindFullGame(Order * -1, iAStarGreedy, ii, jj, ik, jjj, ref ThA, FOUND);
                        }
                        catch (Exception t)
                        {
                        }
                    }
                for (int i = ElefantMidle; i < ElefantHigh; i++)
                    for (int j = 0; ElephantOnTable[i] != null && ElephantOnTable[i].ElefantThinking[0] != null && j < ElephantOnTable[i].ElefantThinking[0].TableListElefant.Count; j++)
                    {
                        try
                        {

                            if (ElephantOnTable[i].ElefantThinking[0].AStarGreedy.Count == 0)
                            {
                                FullGameThinkingTree(Order, iAStarGreedy, ii, jj, ik, jjj, ref ThA, false);
                            }
                            else
                                for (int iii = 0; iii < ElephantOnTable[i].ElefantThinking[0].AStarGreedy.Count - 1; iii++)
                                    ElephantOnTable[i].ElefantThinking[0].AStarGreedy[iii].FoundOfLeafDepenOfKindFullGame(Order * -1, iAStarGreedy, ii, jj, ik, jjj, ref ThA, FOUND);
                        }
                        catch (Exception t)
                        {
                        }
                    }
                for (int i = HourseMidle; i < HourseHight; i++)
                    for (int j = 0; HoursesOnTable[i] != null && HoursesOnTable[i].HourseThinking[0] != null && j < HoursesOnTable[i].HourseThinking[0].TableListHourse.Count; j++)
                    {
                        try
                        {

                            if (HoursesOnTable[i].HourseThinking[0].AStarGreedy.Count == 0)
                            {
                                FullGameThinkingTree(Order, iAStarGreedy, ii, jj, ik, jjj, ref ThA, false);
                            }
                            else
                                for (int iii = 0; iii < HoursesOnTable[i].HourseThinking[0].AStarGreedy.Count - 1; iii++)
                                    HoursesOnTable[i].HourseThinking[0].AStarGreedy[iii].FoundOfLeafDepenOfKindFullGame(Order * -1, iAStarGreedy, ii, jj, ik, jjj, ref ThA, FOUND);
                        }
                        catch (Exception t)
                        {
                        }
                    }
                for (int i = BridgeMidle; i < BridgeHigh; i++)
                    for (int j = 0; BridgesOnTable[i] != null && BridgesOnTable[i].BridgeThinking[0] != null && j < BridgesOnTable[i].BridgeThinking[0].TableListBridge.Count; j++)
                    {
                        try
                        {

                            if (BridgesOnTable[i].BridgeThinking[0].AStarGreedy.Count == 0)
                            {
                                FullGameThinkingTree(Order, iAStarGreedy, ii, jj, ik, jjj, ref ThA, false);
                            }
                            else
                                for (int iii = 0; iii < BridgesOnTable[i].BridgeThinking[0].AStarGreedy.Count - 1; iii++)
                                    BridgesOnTable[i].BridgeThinking[0].AStarGreedy[iii].FoundOfLeafDepenOfKindFullGame(Order * -1, iAStarGreedy, ii, jj, ik, jjj, ref ThA, FOUND);

                        }
                        catch (Exception t)
                        {
                        }
                    }
                for (int i = MinisterMidle; i < MinisterHigh; i++)
                    for (int j = 0; MinisterOnTable[i] != null && MinisterOnTable[i].MinisterThinking[0] != null && j < MinisterOnTable[i].MinisterThinking[0].TableListMinister.Count; j++)
                    {
                        try
                        {
                            if (MinisterOnTable[i].MinisterThinking[0].AStarGreedy.Count == 0)
                            {
                                FullGameThinkingTree(Order, iAStarGreedy, ii, jj, ik, jjj, ref ThA, false);
                            }
                            else
                                for (int iii = 0; iii < MinisterOnTable[i].MinisterThinking[0].AStarGreedy.Count - 1; iii++)
                                    MinisterOnTable[i].MinisterThinking[0].AStarGreedy[iii].FoundOfLeafDepenOfKindFullGame(Order * -1, iAStarGreedy, ii, jj, ik, jjj, ref ThA, FOUND);

                        }
                        catch (Exception t)
                        {
                        }
                    }
                for (int i = KingMidle; i < KingHigh; i++)
                    for (int j = 0; KingOnTable[i] != null && KingOnTable[i].KingThinking[0] != null && j < KingOnTable[i].KingThinking[0].TableListKing.Count; j++)
                    {
                        try
                        {
                            if (KingOnTable[i].KingThinking[0].AStarGreedy.Count == 0)
                            {
                                FullGameThinkingTree(Order, iAStarGreedy, ii, jj, ik, jjj, ref ThA, false);
                            }
                            else
                                for (int iii = 0; iii < KingOnTable[i].KingThinking[0].AStarGreedy.Count - 1; iii++)
                                    KingOnTable[i].KingThinking[0].AStarGreedy[iii].FoundOfLeafDepenOfKindFullGame(Order * -1, iAStarGreedy, ii, jj, ik, jjj, ref ThA, FOUND);


                        }
                        catch (Exception t)
                        {
                        }
                    }
            }
            return;
        }
        public void MakeRegardAllCheckMateBranches(AllDraw A, int Order)
        {
            int COrder = Order;
            int CDummy = ChessRules.CurrentOrder;

            if (Order == 1)
            {

                for (int i = 0; i < SodierMidle; i++)
                    for (int j = 0; A.SolderesOnTable[i] != null && A.SolderesOnTable[i].SoldierThinking[0] != null && j < A.SolderesOnTable[i].SoldierThinking[0].TableListSolder.Count; j++)
                    {

                        try
                        {
                            A.SolderesOnTable[i].SoldierThinking[0].PenaltyRegardListSolder[i].LearningAlgorithmRegard();
                        }
                        catch (Exception t)
                        {
                        }
                        Order *= -1; ChessRules.CurrentOrder *= -1;
                        try
                        {
                            for (int ii = 0; A.SolderesOnTable[i] != null && A.SolderesOnTable[i].SoldierThinking[0] != null && ii < A.SolderesOnTable[i].SoldierThinking[0].AStarGreedy.Count; ii++)
                                MakeRegardAllCheckMateBranches(A.SolderesOnTable[i].SoldierThinking[0].AStarGreedy[ii], Order);

                        }
                        catch (Exception t)
                        {
                        }
                        Order = COrder; ChessRules.CurrentOrder = CDummy;
                    }
                for (int i = 0; i < ElefantMidle; i++)
                    for (int j = 0; A.ElephantOnTable[i] != null && A.ElephantOnTable[i].ElefantThinking[0] != null && j < A.ElephantOnTable[i].ElefantThinking[0].TableListElefant.Count; j++)
                    {

                        try
                        {
                            A.ElephantOnTable[i].ElefantThinking[0].PenaltyRegardListElefant[j].LearningAlgorithmRegard();

                        }
                        catch (Exception t)
                        {
                        }
                        Order *= -1; ChessRules.CurrentOrder *= -1;
                        try
                        {
                            for (int ii = 0; A.ElephantOnTable[i] != null && A.ElephantOnTable[i].ElefantThinking[0] != null && ii < A.ElephantOnTable[i].ElefantThinking[0].AStarGreedy.Count; ii++)
                                MakeRegardAllCheckMateBranches(A.ElephantOnTable[i].ElefantThinking[0].AStarGreedy[ii], Order);
                        }
                        catch (Exception t)
                        {
                        } Order = COrder; ChessRules.CurrentOrder = CDummy;
                    }
                for (int i = 0; i < HourseMidle; i++)
                    for (int j = 0; A.HoursesOnTable[i] != null && A.HoursesOnTable[i].HourseThinking[0] != null && j < A.HoursesOnTable[i].HourseThinking[0].TableListHourse.Count; j++)
                    {
                        try
                        {
                            A.HoursesOnTable[i].HourseThinking[0].PenaltyRegardListHourse[j].LearningAlgorithmRegard();

                        }
                        catch (Exception t)
                        {
                        }
                        Order *= -1; ChessRules.CurrentOrder *= -1;
                        try
                        {
                            for (int ii = 0; A.HoursesOnTable[i] != null && A.HoursesOnTable[i].HourseThinking[0] != null && ii < A.HoursesOnTable[i].HourseThinking[0].AStarGreedy.Count; ii++)
                                MakeRegardAllCheckMateBranches(A.HoursesOnTable[i].HourseThinking[0].AStarGreedy[ii], Order);
                        }
                        catch (Exception t)
                        {
                        } Order = COrder; ChessRules.CurrentOrder = CDummy;
                    }
                for (int i = 0; i < BridgeMidle; i++)
                    for (int j = 0; A.BridgesOnTable[i] != null && A.BridgesOnTable[i].BridgeThinking[0] != null && j < A.BridgesOnTable[i].BridgeThinking[0].TableListBridge.Count; j++)
                    {
                        try
                        {
                            A.BridgesOnTable[i].BridgeThinking[0].PenaltyRegardListBridge[j].LearningAlgorithmRegard();
                        }
                        catch (Exception t)
                        {
                        }
                        Order *= -1; ChessRules.CurrentOrder *= -1;
                        try
                        {
                            for (int ii = 0; A.BridgesOnTable[i] != null && A.BridgesOnTable[i].BridgeThinking[0] != null && ii < A.BridgesOnTable[i].BridgeThinking[0].AStarGreedy.Count; ii++)
                                MakeRegardAllCheckMateBranches(A.BridgesOnTable[i].BridgeThinking[0].AStarGreedy[ii], Order);
                        }
                        catch (Exception t)
                        {
                        } Order = COrder; ChessRules.CurrentOrder = CDummy;
                    }
                for (int i = 0; i < MinisterMidle; i++)
                    for (int j = 0; A.MinisterOnTable[i] != null && A.MinisterOnTable[i].MinisterThinking[0] != null && j < A.MinisterOnTable[i].MinisterThinking[0].TableListMinister.Count; j++)
                    {
                        try
                        {
                            A.MinisterOnTable[i].MinisterThinking[0].PenaltyRegardListMinister[j].LearningAlgorithmRegard();
                        }
                        catch (Exception t)
                        {
                        }

                        Order *= -1; ChessRules.CurrentOrder *= -1;
                        try
                        {
                            for (int ii = 0; A.MinisterOnTable[i] != null && A.MinisterOnTable[i].MinisterThinking[0] != null && ii < A.MinisterOnTable[i].MinisterThinking[0].AStarGreedy.Count; ii++)
                                MakeRegardAllCheckMateBranches(A.MinisterOnTable[i].MinisterThinking[0].AStarGreedy[ii], Order);
                        }
                        catch (Exception t)
                        {
                        } Order = COrder; ChessRules.CurrentOrder = CDummy;
                    }
                for (int i = 0; i < KingMidle; i++)
                    for (int j = 0; A.KingOnTable[i] != null && A.KingOnTable[i].KingThinking[0] != null && j < A.KingOnTable[i].KingThinking[0].TableListKing.Count; j++)
                    {
                        try
                        {
                            A.KingOnTable[i].KingThinking[0].PenaltyRegardListKing[j].LearningAlgorithmRegard();
                        }
                        catch (Exception t)
                        {
                        }
                        Order *= -1; ChessRules.CurrentOrder *= -1;
                        try
                        {
                            for (int ii = 0; A.KingOnTable[i] != null && A.KingOnTable[i].KingThinking[0] != null && ii < A.KingOnTable[i].KingThinking[0].AStarGreedy.Count; ii++)
                                MakeRegardAllCheckMateBranches(A.KingOnTable[i].KingThinking[0].AStarGreedy[ii], Order);
                        }
                        catch (Exception t)
                        {
                        } Order = COrder; ChessRules.CurrentOrder = CDummy;
                    }
            }
            else
            {
                for (int i = SodierMidle; i < SodierHigh; i++)
                    for (int j = 0; A.SolderesOnTable[i] != null && A.SolderesOnTable[i].SoldierThinking[0] != null && j < A.SolderesOnTable[i].SoldierThinking[0].TableListSolder.Count; j++)
                    {
                        try
                        {
                            A.SolderesOnTable[i].SoldierThinking[0].PenaltyRegardListSolder[i].LearningAlgorithmRegard();
                        }
                        catch (Exception t)
                        {
                        }
                        Order *= -1; ChessRules.CurrentOrder *= -1;
                        try
                        {
                            for (int ii = 0; A.SolderesOnTable[i] != null && A.SolderesOnTable[i].SoldierThinking[0] != null && ii < A.SolderesOnTable[i].SoldierThinking[0].AStarGreedy.Count; ii++)
                                MakeRegardAllCheckMateBranches(A.SolderesOnTable[i].SoldierThinking[0].AStarGreedy[ii], Order);
                        }
                        catch (Exception t)
                        {
                        } Order = COrder; ChessRules.CurrentOrder = CDummy;
                    }
                for (int i = ElefantMidle; i < ElefantHigh; i++)
                    for (int j = 0; A.ElephantOnTable[i] != null && A.ElephantOnTable[i].ElefantThinking[0] != null && j < A.ElephantOnTable[i].ElefantThinking[0].TableListElefant.Count; j++)
                    {
                        try
                        {
                            A.ElephantOnTable[i].ElefantThinking[0].PenaltyRegardListElefant[j].LearningAlgorithmRegard();

                        }
                        catch (Exception t)
                        {
                        }
                        Order *= -1; ChessRules.CurrentOrder *= -1;
                        try
                        {
                            for (int ii = 0; A.ElephantOnTable[i] != null && A.ElephantOnTable[i].ElefantThinking[0] != null && ii < A.ElephantOnTable[i].ElefantThinking[0].AStarGreedy.Count; ii++)
                                MakeRegardAllCheckMateBranches(A.ElephantOnTable[i].ElefantThinking[0].AStarGreedy[ii], Order);
                        }
                        catch (Exception t)
                        {
                        } Order = COrder; ChessRules.CurrentOrder = CDummy;
                    }
                for (int i = HourseMidle; i < HourseHight; i++)
                    for (int j = 0; A.HoursesOnTable[i] != null && A.HoursesOnTable[i].HourseThinking[0] != null && j < A.HoursesOnTable[i].HourseThinking[0].TableListHourse.Count; j++)
                    {
                        try
                        {
                            A.HoursesOnTable[i].HourseThinking[0].PenaltyRegardListHourse[j].LearningAlgorithmRegard();

                        }
                        catch (Exception t)
                        {
                        }
                        Order *= -1; ChessRules.CurrentOrder *= -1;
                        try
                        {
                            for (int ii = 0; A.HoursesOnTable[i] != null && A.HoursesOnTable[i].HourseThinking[0] != null && ii < A.HoursesOnTable[i].HourseThinking[0].AStarGreedy.Count; ii++)
                                MakeRegardAllCheckMateBranches(A.HoursesOnTable[i].HourseThinking[0].AStarGreedy[ii], Order);
                        }
                        catch (Exception t)
                        {
                        } Order = COrder; ChessRules.CurrentOrder = CDummy;
                    }
                for (int i = BridgeMidle; i < BridgeHigh; i++)
                    for (int j = 0; A.BridgesOnTable[i] != null && A.BridgesOnTable[i].BridgeThinking[0] != null && j < A.BridgesOnTable[i].BridgeThinking[0].TableListBridge.Count; j++)
                    {
                        try
                        {
                            A.BridgesOnTable[i].BridgeThinking[0].PenaltyRegardListBridge[j].LearningAlgorithmRegard();
                        }
                        catch (Exception t)
                        {
                        }
                        Order *= -1; ChessRules.CurrentOrder *= -1;
                        try
                        {
                            for (int ii = 0; A.BridgesOnTable[i] != null && A.BridgesOnTable[i].BridgeThinking[0] != null && ii < A.BridgesOnTable[i].BridgeThinking[0].AStarGreedy.Count; ii++)
                                MakeRegardAllCheckMateBranches(A.BridgesOnTable[i].BridgeThinking[0].AStarGreedy[ii], Order);
                        }
                        catch (Exception t)
                        {
                        } Order = COrder; ChessRules.CurrentOrder = CDummy;
                    }
                for (int i = MinisterMidle; i < MinisterHigh; i++)
                    for (int j = 0; A.MinisterOnTable[i] != null && A.MinisterOnTable[i].MinisterThinking[0] != null && j < A.MinisterOnTable[i].MinisterThinking[0].TableListMinister.Count; j++)
                    {
                        try
                        {
                            A.MinisterOnTable[i].MinisterThinking[0].PenaltyRegardListMinister[j].LearningAlgorithmRegard();
                        }
                        catch (Exception t)
                        {
                        }
                        Order *= -1; ChessRules.CurrentOrder *= -1;
                        try
                        {
                            for (int ii = 0; A.MinisterOnTable[i] != null && A.MinisterOnTable[i].MinisterThinking[0] != null && ii < A.MinisterOnTable[i].MinisterThinking[0].AStarGreedy.Count; ii++)
                                MakeRegardAllCheckMateBranches(A.MinisterOnTable[i].MinisterThinking[0].AStarGreedy[ii], Order);
                        }
                        catch (Exception t)
                        {
                        } Order = COrder; ChessRules.CurrentOrder = CDummy;
                    }
                for (int i = KingMidle; i < MinisterHigh; i++)
                    for (int j = 0; A.KingOnTable[i] != null && A.KingOnTable[i].KingThinking[0] != null && j < A.KingOnTable[i].KingThinking[0].TableListKing.Count; j++)
                    {
                        try
                        {
                            A.KingOnTable[i].KingThinking[0].PenaltyRegardListKing[j].LearningAlgorithmRegard();
                        }
                        catch (Exception t)
                        {
                        }
                        Order *= -1; ChessRules.CurrentOrder *= -1;
                        try
                        {
                            for (int ii = 0; A.KingOnTable[i] != null && A.KingOnTable[i].KingThinking[0] != null && ii < A.KingOnTable[i].KingThinking[0].AStarGreedy.Count; ii++)
                                MakeRegardAllCheckMateBranches(A.KingOnTable[i].KingThinking[0].AStarGreedy[ii], Order);
                        }
                        catch (Exception t)
                        {
                        }
                        Order = COrder; ChessRules.CurrentOrder = CDummy;
                    }
            }
        }
        int[,] GrayHuristicAStarGreadySearch(int AStarGreedyi, List<AllDraw> A, Color a, int Order, bool CurrentTableHuristic, ref bool Act)
        {
            ChessRules AB = null;

            int ToCheckMate = -1, ForCheckMate = -1, j, i;
            List<double> Founded = new List<double>();
            int DummyOrder = Order;
            int DummyCurrentOrder = ChessRules.CurrentOrder;
            bool AA = false;
            int Do = 0;
            int[,] TableHuristic = new int[8, 8];

            //For Every Soldeir
            for (i = 0; i < SodierMidle; i++)
            {


                //For Every Soldier Movments AStarGreedy.
                for (int k = 0; k < AllDraw.SodierMovments; k++)
                    //When There is an Movment in such situation.
                    try
                    {
                        for (j = 0; SolderesOnTable[i] != null && SolderesOnTable[i] != null && SolderesOnTable[i].SoldierThinking[k] != null && SolderesOnTable[i].SoldierThinking[k] != null && j < SolderesOnTable[i].SoldierThinking[k].TableListSolder.Count; j++)
                        {
                            {
                                try
                                {
                                    //For Penalty Reagrad Mechanisam of Current Check CheckMate Current Movments.
                                    if (FormRefrigtz.OrderPlate == Order && AStarGreedyi == 1 && UsePenaltyRegardMechnisamT)
                                        if (SolderesOnTable[i].SoldierThinking[k].PenaltyRegardListSolder[j].IsPenaltyAction() == 0)
                                            continue;
                                    int CDummy = ChessRules.CurrentOrder;
                                    int COrder = Order;
                                    try
                                    {
                                        ChessRules.CurrentOrder *= -1;
                                        Order *= -1;
                                        Do = 0;
                                        if (UsePenaltyRegardMechnisamT)
                                        {
                                            for (int ij = 0; ij < SolderesOnTable[i].SoldierThinking[k].AStarGreedy.Count - 1; ij++)
                                                SolderesOnTable[i].SoldierThinking[k].AStarGreedy[ij].IsPenaltyRegardCheckMateAtBranch(Order, ref Do, SolderesOnTable[i].SoldierThinking[k].AStarGreedy[ij]);
                                            Order = COrder;
                                            ChessRules.CurrentOrder = CDummy;

                                            ToCheckMate = -1; ForCheckMate = -1; AA = IsToCheckMateHasLessDeeperThanForCheckMate(this, Order, ref ToCheckMate, ref ForCheckMate, 0); if (Do == -1)
                                                continue;
                                        }
                                    }
                                    catch (Exception tt) { }
                                    Order = COrder;
                                    ChessRules.CurrentOrder = CDummy;
                                    if (FormRefrigtz.OrderPlate == Order && AStarGreedyi == 1 && UsePenaltyRegardMechnisamT)
                                        if ((SolderesOnTable[i].SoldierThinking[k].PenaltyRegardListSolder[j].IsPenaltyAction() != 0 && SolderesOnTable[i].SoldierThinking[k].PenaltyRegardListSolder[j].IsRewardAction() == 1 && AStarGreedyi == 1) || Do == 1 || AA)
                                        {
                                            //Set Table and Huristic Value and Syntax.
                                            Act = true;
                                            FormRefrigtz.LastRow = SolderesOnTable[i].SoldierThinking[k].Row;
                                            FormRefrigtz.LastColumn = SolderesOnTable[i].SoldierThinking[k].Column;

                                            Less = SolderesOnTable[i].SoldierThinking[k].ReturnHuristic(i, j, Order * -1);


                                            TableHuristic = SolderesOnTable[i].SoldierThinking[k].TableListSolder[j];
                                            bool Hit = false;
                                            if (SolderesOnTable[i].SoldierThinking[k].HitNumberSoldier[j] > 0)
                                                Hit = true;
                                            //if (Order == 1)
                                            //SyntaxToWrite = (new ChessRules(ChessRules( ArrangmentsChanged)).CreateStatistic(ArrangmentsChanged,TableHuristic, FormRefrigtz.MovmentsNumber, 1, SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][1], SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][0], Hit, SolderesOnTable[i].SoldierThinking[k].HitNumberSoldier[j], ChessRules.BridgeActBrown, false);
                                            //else
                                            //SyntaxToWrite = (new ChessRules(ChessRules( ArrangmentsChanged)).CreateStatistic(ArrangmentsChanged,TableHuristic, FormRefrigtz.MovmentsNumber, -1, SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][1], SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][0], Hit, SolderesOnTable[i].SoldierThinking[k].HitNumberSoldier[j], ChessRules.BridgeActBrown, false);


                                            ThingsConverter.ActOfClickEqualTow = true;
                                            SolderesOnTable[i].ConvertOperation(SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][0], SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][1], a, SolderesOnTable[i].SoldierThinking[k].TableListSolder[j], Order, false, i);
                                            int Sign = 1;
                                            if (a == Color.Brown)
                                                Sign = -1;


                                            //If there is Soldier Convert.


                                            if (SolderesOnTable[i].Convert)
                                            {
                                                Hit = false;
                                                if (SolderesOnTable[i].SoldierThinking[k].HitNumberSoldier[j] > 0)
                                                    Hit = true;
                                                //if (Order == 1)
                                                //SyntaxToWrite = (new ChessRules(ChessRules( ArrangmentsChanged)).CreateStatistic(ArrangmentsChanged,TableHuristic, FormRefrigtz.MovmentsNumber, 1, SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][1], SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][0], Hit, SolderesOnTable[i].SoldierThinking[k].HitNumberSoldier[j], ChessRules.BridgeActBrown, true);
                                                //else
                                                //SyntaxToWrite = (new ChessRules(ChessRules( ArrangmentsChanged)).CreateStatistic(ArrangmentsChanged,TableHuristic, FormRefrigtz.MovmentsNumber, -1, SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][1], SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][0], Hit, SolderesOnTable[i].SoldierThinking[k].HitNumberSoldier[j], ChessRules.BridgeActBrown, true);

                                                if (SolderesOnTable[i].ConvertedToMinister)
                                                    TableHuristic[SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][0], SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][1]] = 5 * Sign;
                                                else if (SolderesOnTable[i].ConvertedToBridge)
                                                    TableHuristic[SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][0], SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][1]] = 4 * Sign;
                                                else if (SolderesOnTable[i].ConvertedToHourse)
                                                    TableHuristic[SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][0], SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][1]] = 3 * Sign;
                                                else if (SolderesOnTable[i].ConvertedToElefant)
                                                    TableHuristic[SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][0], SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][1]] = 2 * Sign;
                                                TableList.Clear();
                                                TableList.Add(TableHuristic);
                                                if (A.Count > 1)
                                                    SetRowColumn(0);
                                                TableList.Clear();
                                            }
                                            if (Do == 1 || AA)
                                                //return TableHuristic;
                                                continue;
                                        }

                                    //When There is No Movments in Such Order Enemy continue.
                                    if (Order != FormRefrigtz.OrderPlate)
                                        if (SolderesOnTable[i].SoldierThinking[0].ReturnHuristic(i, j, Order * -1) > Less)
                                            continue;
                                    //When There is greater Huristic Movments.
                                    if (SolderesOnTable[i].SoldierThinking[0].ReturnHuristic(i, j, Order * -1) > Less)
                                    {
                                        if (AStarGreedyi == 1) ToFindMovments = true;
                                        //retrive table of current huristic.
                                        int[,] TableS = SolderesOnTable[i].SoldierThinking[k].TableListSolder[j];
                                        int[,] TableSS = SolderesOnTable[i].SoldierThinking[k].TableListSolder[j];

                                        //checked for Legal Movments ArgumentOutOfRangeException curnt game.
                                        if (DynamicAStarGreedytPrograming && !CurrentTableHuristic && AStarGreedyi == 1)
                                        {
                                            try
                                            {
                                                if (!isEnemyThingsinStable(TableS, AllDraw.TableListAction[AllDraw.TableListAction.Count - 1], FormRefrigtz.OrderPlate))
                                                    continue;
                                            }
                                            catch (Exception t)
                                            {

                                                if (!isEnemyThingsinStable(TableS, AllDraw.TableListAction[AllDraw.TableListAction.Count - 1], FormRefrigtz.OrderPlate))
                                                    continue;

                                            }

                                        }
                                        //When there is not Penalty regard mechanism.
                                        //if (!UsePenaltyRegardMechnisamT)
                                        {
                                            AB = new ChessRules(MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, 1, TableS, Order, SolderesOnTable[i].SoldierThinking[k].Row, SolderesOnTable[i].SoldierThinking[k].Column);
                                            //If there is kish or kshachamaz Order.
                                            if (AB.Check(TableS, Order))
                                            {
                                                //When Order is Gray.
                                                if (Order == 1)
                                                {
                                                    //Continue When is kish CheckObjectDangour and AStarGreadyFirstSearch .
                                                    if (AB.CheckGray)
                                                        continue;
                                                }
                                                else
                                                {
                                                    //Continue when CheckBrown and AStarGreadyFirstSearch. 
                                                    if (AB.CheckBrown)
                                                        continue;
                                                }
                                            }
                                            // }
                                            else
                                            {

                                            }
                                            //When Order is gray.
                                            /*if (Order == 1)
                                            {
                                                //When CheckGrayObjectDangour and There is not AStarGreedyt search.
                                                if (AB.CheckGray)
                                                {
                                                    //predict Search.
                                                    Color B;
                                                    if (a == Color.Gray)
                                                        B = Color.Brown;
                                                    else
                                                        B = Color.Gray;
                                                    APredict.TableList.Clear();
                                                    APredict.TableList.Add(TableS);
                                                    APredict.SetRowColumn(0);
                                                    TableHuristic = APredict.InitiatePerdictCheck((int)APredict.SolderesOnTable[i].Row, (int)APredict.SolderesOnTable[i].Column, B, TableS, Order, false);
                                                    if (TableHuristic == null)
                                                        continue;
                                                    else
                                                    {
                                                        Act = true;
                                                        Less = SolderesOnTable[i].SoldierThinking[k].ReturnHuristic(i, j, Order * -1);

                                                        continue;


                                                    }

                                                }
                                            }
                                            else
                                            {
                                                //When Order is Bromn and there is not AStarGreadyFirstSearch.
                                                if (AB.CheckBrown)
                                                {
                                                    //Prdedict Check.
                                                    Color B;
                                                    if (a == Color.Gray)
                                                        B = Color.Brown;
                                                    else
                                                        B = Color.Gray;
                                                    APredict.TableList.Clear();
                                                    APredict.TableList.Add(TableS);
                                                    APredict.SetRowColumn(0);
                                                    TableHuristic = APredict.InitiatePerdictCheck((int)APredict.SolderesOnTable[i].Row, (int)APredict.SolderesOnTable[i].Column, B, TableS, Order, false);
                                                    if (TableHuristic == null)
                                                        continue;

                                                }
                                            }
                                             */
                                        }
                                        //Sodleirs Initiate.
                                        RW1 = i;
                                        CL1 = k;
                                        Ki1 = j;
                                        RW2 = -1;
                                        CL2 = -1;
                                        Ki2 = -1;
                                        RW3 = -1;
                                        CL3 = -1;
                                        Ki3 = -1;
                                        RW4 = -1;
                                        CL4 = -1;
                                        Ki4 = -1;
                                        RW5 = -1;
                                        CL5 = -1;
                                        Ki5 = -1;
                                        RW6 = -1;
                                        CL6 = -1;
                                        Ki6 = -1;
                                        //Set Max of Soldier.
                                        MaxLess1 = (SolderesOnTable[RW1].SoldierThinking[CL1].ReturnHuristic(i, j, Order * -1)
                                            );
                                        //When Soldeirs is Greater than Others these Set Max.
                                        if (MaxLess1 > MaxLess2)
                                            MaxLess2 = -1;
                                        if (MaxLess1 > MaxLess3)
                                            MaxLess3 = -1;
                                        if (MaxLess1 > MaxLess4)
                                            MaxLess4 = -1;
                                        if (MaxLess1 > MaxLess5)
                                            MaxLess5 = -1;
                                        if (MaxLess1 > MaxLess6)
                                            MaxLess6 = -1;

                                        if (AStarGreedyi == 1)
                                        {
                                            if (Order == 1)
                                            {
                                                //THIS.SetBoxText("\r\nChess Huristic Sodier By Bob!");
                                                //THIS.RefreshBoxText();
                                            }
                                            else//If Order is Brown.
                                            {
                                                //THIS.SetBoxText("\r\nChess Huristic Sodier By Alice!");
                                                //THIS.RefreshBoxText();
                                            }
                                            //Set Table and Huristic Value and Syntax.
                                            Act = true;
                                            FormRefrigtz.LastRow = SolderesOnTable[i].SoldierThinking[k].Row;
                                            FormRefrigtz.LastColumn = SolderesOnTable[i].SoldierThinking[k].Column;

                                            Less = SolderesOnTable[i].SoldierThinking[k].ReturnHuristic(i, j, Order * -1);


                                            TableHuristic = SolderesOnTable[i].SoldierThinking[k].TableListSolder[j];
                                            bool Hit = false;
                                            if (SolderesOnTable[i].SoldierThinking[k].HitNumberSoldier[j] > 0)
                                                Hit = true;
                                            //if (Order == 1)
                                            //SyntaxToWrite = (new ChessRules(ChessRules( ArrangmentsChanged)).CreateStatistic(ArrangmentsChanged,TableHuristic, FormRefrigtz.MovmentsNumber, 1, SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][1], SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][0], Hit, SolderesOnTable[i].SoldierThinking[k].HitNumberSoldier[j], ChessRules.BridgeActBrown, false);
                                            // else
                                            //SyntaxToWrite = (new ChessRules(ChessRules( ArrangmentsChanged)).CreateStatistic(ArrangmentsChanged,TableHuristic, FormRefrigtz.MovmentsNumber, -1, SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][1], SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][0], Hit, SolderesOnTable[i].SoldierThinking[k].HitNumberSoldier[j], ChessRules.BridgeActBrown, false);


                                            ThingsConverter.ActOfClickEqualTow = true;
                                            SolderesOnTable[i].ConvertOperation(SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][0], SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][1], a, SolderesOnTable[i].SoldierThinking[k].TableListSolder[j], Order, false, i);
                                            int Sign = 1;
                                            if (a == Color.Brown)
                                                Sign = -1;
                                            //If there is Soldier Convert.
                                            if (SolderesOnTable[i].Convert)
                                            {
                                                Hit = false;
                                                if (SolderesOnTable[i].SoldierThinking[k].HitNumberSoldier[j] > 0)
                                                    Hit = true;
                                                //if (Order == 1)
                                                //SyntaxToWrite = (new ChessRules(ChessRules( ArrangmentsChanged)).CreateStatistic(ArrangmentsChanged,TableHuristic, FormRefrigtz.MovmentsNumber, 1, SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][1], SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][0], Hit, SolderesOnTable[i].SoldierThinking[k].HitNumberSoldier[j], ChessRules.BridgeActBrown, true);
                                                //else
                                                //SyntaxToWrite = (new ChessRules(ChessRules( ArrangmentsChanged)).CreateStatistic(ArrangmentsChanged,TableHuristic, FormRefrigtz.MovmentsNumber, -1, SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][1], SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][0], Hit, SolderesOnTable[i].SoldierThinking[k].HitNumberSoldier[j], ChessRules.BridgeActBrown, true);

                                                if (SolderesOnTable[i].ConvertedToMinister)
                                                    TableHuristic[SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][0], SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][1]] = 5 * Sign;
                                                else if (SolderesOnTable[i].ConvertedToBridge)
                                                    TableHuristic[SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][0], SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][1]] = 4 * Sign;
                                                else if (SolderesOnTable[i].ConvertedToHourse)
                                                    TableHuristic[SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][0], SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][1]] = 3 * Sign;
                                                else if (SolderesOnTable[i].ConvertedToElefant)
                                                    TableHuristic[SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][0], SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][1]] = 2 * Sign;
                                                TableList.Clear();
                                                TableList.Add(TableHuristic);
                                                if (A.Count > 1)
                                                    SetRowColumn(0);
                                                TableList.Clear();

                                            }
                                        }


                                    }
                                    else
                                    {
                                        //Set Table and Huristic Value and Syntax.
                                        try
                                        {
                                            if (AStarGreedyi == 1)
                                            {
                                                if (Order == 1)
                                                {
                                                    //THIS.SetBoxText("\r\nChess Huristic Sodier By Bob!");
                                                    //THIS.RefreshBoxText();
                                                }
                                                else//If Order is Brown.
                                                {
                                                    //THIS.SetBoxText("\r\nChess Huristic Sodier By Alice!");
                                                    //THIS.RefreshBoxText();
                                                }
                                                //TakeRoot.Pointer = this;
                                                //Found of Max Non Probable Movments.
                                                Founded.Clear();
                                                double LessB = Double.MinValue; ;
                                                BeginIndexFoundingMaxLessofMaxList(0, Founded, ref LessB);
                                                RW1 = (int)MaxHuristicAStarGreedytBackWard[0][(int)Founded[0]];
                                                CL1 = (int)MaxHuristicAStarGreedytBackWard[0][(int)Founded[0] + 1];
                                                Ki1 = (int)MaxHuristicAStarGreedytBackWard[0][(int)Founded[0] + 2];
                                                if (Founded[0] != MaxSoldeirFounded)
                                                    continue;
                                                Act = true;
                                                FormRefrigtz.LastRow = SolderesOnTable[RW1].SoldierThinking[CL1].Row;
                                                FormRefrigtz.LastColumn = SolderesOnTable[RW1].SoldierThinking[CL1].Column;

                                                Less = SolderesOnTable[RW1].SoldierThinking[CL1].ReturnHuristic(RW1, Ki1, Order * -1);


                                                TableHuristic = SolderesOnTable[RW1].SoldierThinking[CL1].TableListSolder[Ki1];
                                                bool Hit = false;
                                                if (SolderesOnTable[RW1].SoldierThinking[CL1].HitNumberSoldier[Ki1] > 0)
                                                    Hit = true;
                                                //if (Order == 1)
                                                //SyntaxToWrite = (new ChessRules(ChessRules( ArrangmentsChanged)).CreateStatistic(ArrangmentsChanged,TableHuristic, FormRefrigtz.MovmentsNumber, 1, SolderesOnTable[RW1].SoldierThinking[CL1].RowColumnSoldier[Ki1][1], SolderesOnTable[RW1].SoldierThinking[CL1].RowColumnSoldier[Ki1][0], Hit, SolderesOnTable[RW1].SoldierThinking[CL1].HitNumberSoldier[Ki1], ChessRules.BridgeActBrown, false);
                                                // else
                                                //SyntaxToWrite = (new ChessRules(ChessRules( ArrangmentsChanged)).CreateStatistic(ArrangmentsChanged,TableHuristic, FormRefrigtz.MovmentsNumber, -1, SolderesOnTable[RW1].SoldierThinking[CL1].RowColumnSoldier[Ki1][1], SolderesOnTable[RW1].SoldierThinking[CL1].RowColumnSoldier[Ki1][0], Hit, SolderesOnTable[RW1].SoldierThinking[CL1].HitNumberSoldier[Ki1], ChessRules.BridgeActBrown, false);


                                                ThingsConverter.ActOfClickEqualTow = true;
                                                SolderesOnTable[RW1].ConvertOperation(SolderesOnTable[RW1].SoldierThinking[CL1].RowColumnSoldier[Ki1][0], SolderesOnTable[RW1].SoldierThinking[CL1].RowColumnSoldier[Ki1][1], a, SolderesOnTable[RW1].SoldierThinking[CL1].TableListSolder[Ki1], Order, false, i);
                                                int Sign = 1;
                                                if (a == Color.Brown)
                                                    Sign = -1;
                                                //If there is Soldier Convert.
                                                if (SolderesOnTable[RW1].Convert)
                                                {
                                                    Hit = false;
                                                    if (SolderesOnTable[RW1].SoldierThinking[CL1].HitNumberSoldier[Ki1] > 0)
                                                        Hit = true;
                                                    //if (Order == 1)
                                                    //SyntaxToWrite = (new ChessRules(ChessRules( ArrangmentsChanged)).CreateStatistic(ArrangmentsChanged,TableHuristic, FormRefrigtz.MovmentsNumber, 1, SolderesOnTable[RW1].SoldierThinking[CL1].RowColumnSoldier[Ki1][1], SolderesOnTable[RW1].SoldierThinking[CL1].RowColumnSoldier[Ki1][0], Hit, SolderesOnTable[RW1].SoldierThinking[CL1].HitNumberSoldier[Ki1], ChessRules.BridgeActBrown, true);
                                                    //else
                                                    //SyntaxToWrite = (new ChessRules(ChessRules( ArrangmentsChanged)).CreateStatistic(ArrangmentsChanged,TableHuristic, FormRefrigtz.MovmentsNumber, -1, SolderesOnTable[RW1].SoldierThinking[CL1].RowColumnSoldier[Ki1][1], SolderesOnTable[RW1].SoldierThinking[CL1].RowColumnSoldier[Ki1][0], Hit, SolderesOnTable[RW1].SoldierThinking[CL1].HitNumberSoldier[Ki1], ChessRules.BridgeActBrown, true);

                                                    if (SolderesOnTable[RW1].ConvertedToMinister)
                                                        TableHuristic[SolderesOnTable[RW1].SoldierThinking[CL1].RowColumnSoldier[Ki1][0], SolderesOnTable[RW1].SoldierThinking[CL1].RowColumnSoldier[Ki1][1]] = 5 * Sign;
                                                    else if (SolderesOnTable[RW1].ConvertedToBridge)
                                                        TableHuristic[SolderesOnTable[RW1].SoldierThinking[CL1].RowColumnSoldier[Ki1][0], SolderesOnTable[RW1].SoldierThinking[CL1].RowColumnSoldier[Ki1][1]] = 4 * Sign;
                                                    else if (SolderesOnTable[RW1].ConvertedToHourse)
                                                        TableHuristic[SolderesOnTable[RW1].SoldierThinking[CL1].RowColumnSoldier[Ki1][0], SolderesOnTable[RW1].SoldierThinking[CL1].RowColumnSoldier[Ki1][1]] = 3 * Sign;
                                                    else if (SolderesOnTable[RW1].ConvertedToElefant)
                                                        TableHuristic[SolderesOnTable[RW1].SoldierThinking[CL1].RowColumnSoldier[Ki1][0], SolderesOnTable[RW1].SoldierThinking[CL1].RowColumnSoldier[Ki1][1]] = 2 * Sign;
                                                    TableList.Clear();
                                                    TableList.Add(TableHuristic);
                                                    if (A.Count > 1)
                                                        SetRowColumn(0);
                                                    TableList.Clear();

                                                }
                                            }
                                        }
                                        catch (Exception t)
                                        {

                                        }
                                    }

                                }
                                catch (Exception t)
                                {

                                }
                            }
                        }

                    }
                    catch (Exception t)
                    {

                    } try
                {
                    /* Order *= -1;
                     ChessRules.CurrentOrder *= -1;
                     for (int p = 0; p < SolderesOnTable[i].SoldierThinking[0].AStarGreedy.Count; p++)
                         SolderesOnTable[i].SoldierThinking[0].AStarGreedy[p].HuristicAStarGreedySearch(AStarGreedyi, A, a, ref Less, Order, false);
                     */
                    Order = DummyOrder;
                    ChessRules.CurrentOrder = DummyCurrentOrder;
                }

                catch (Exception t)
                {

                }

                Order = DummyOrder;
                ChessRules.CurrentOrder = DummyCurrentOrder;

            }
            //Do For Remaining Objects same as Soldeir Documentation.
            for (i = 0; i < ElefantMidle; i++)
            {
                for (int k = 0; k < AllDraw.ElefantMovments; k++)
                    try
                    {
                        for (j = 0; ElephantOnTable[i] != null && ElephantOnTable[i] != null && ElephantOnTable[i].ElefantThinking[k] != null && ElephantOnTable[i].ElefantThinking[k] != null && j < ElephantOnTable[i].ElefantThinking[k].TableListElefant.Count; j++)
                        {
                            {
                                try
                                {
                                    //For Penalty Reagrad Mechanisam of Current Check CheckMate Current Movments.
                                    if (FormRefrigtz.OrderPlate == Order && AStarGreedyi == 1 && UsePenaltyRegardMechnisamT)
                                        if (ElephantOnTable[i].ElefantThinking[k].PenaltyRegardListElefant[j].IsPenaltyAction() == 0)
                                            continue;
                                    int CDummy = ChessRules.CurrentOrder;
                                    int COrder = Order;
                                    try
                                    {
                                        ChessRules.CurrentOrder *= -1;
                                        Order *= -1;
                                        Do = 0;
                                        if (UsePenaltyRegardMechnisamT)
                                        {
                                            for (int ij = 0; ij < ElephantOnTable[i].ElefantThinking[0].AStarGreedy.Count - 1; ij++)
                                                ElephantOnTable[i].ElefantThinking[k].AStarGreedy[ij].IsPenaltyRegardCheckMateAtBranch(Order, ref Do, ElephantOnTable[i].ElefantThinking[k].AStarGreedy[ij]);
                                            Order = COrder;
                                            ChessRules.CurrentOrder = CDummy;
                                            ToCheckMate = -1; ForCheckMate = -1; AA = IsToCheckMateHasLessDeeperThanForCheckMate(this, Order, ref ToCheckMate, ref ForCheckMate, 0); if (Do == -1)
                                                continue;
                                        }
                                    }
                                    catch (Exception tt) { }
                                    Order = COrder;
                                    ChessRules.CurrentOrder = CDummy;
                                    if (FormRefrigtz.OrderPlate == Order && AStarGreedyi == 1 && UsePenaltyRegardMechnisamT)
                                        if ((ElephantOnTable[i].ElefantThinking[k].PenaltyRegardListElefant[j].IsPenaltyAction() != 0 && ElephantOnTable[i].ElefantThinking[k].PenaltyRegardListElefant[j].IsRewardAction() == 1 && AStarGreedyi == 1) || Do == 1 || AA)
                                        {
                                            //Set Table and Huristic Value and Syntax.
                                            bool Hit = false;
                                            if (ElephantOnTable[i].ElefantThinking[k].HitNumberElefant[j] > 0)
                                                Hit = true;
                                            // if (Order == 1)
                                            //SyntaxToWrite = (new ChessRules(ChessRules( ArrangmentsChanged)).CreateStatistic(ArrangmentsChanged,TableHuristic, FormRefrigtz.MovmentsNumber, 2, ElephantOnTable[i].ElefantThinking[k].RowColumnElefant[j][1], ElephantOnTable[i].ElefantThinking[k].RowColumnElefant[j][0], Hit, ElephantOnTable[i].ElefantThinking[k].HitNumberElefant[j], ChessRules.BridgeActBrown, false);
                                            // else
                                            //SyntaxToWrite = (new ChessRules(ChessRules( ArrangmentsChanged)).CreateStatistic(ArrangmentsChanged,TableHuristic, FormRefrigtz.MovmentsNumber, -2, ElephantOnTable[i].ElefantThinking[k].RowColumnElefant[j][1], ElephantOnTable[i].ElefantThinking[k].RowColumnElefant[j][0], Hit, ElephantOnTable[i].ElefantThinking[k].HitNumberElefant[j], ChessRules.BridgeActBrown, false);

                                            FormRefrigtz.LastRow = ElephantOnTable[i].ElefantThinking[k].Row;
                                            FormRefrigtz.LastColumn = ElephantOnTable[i].ElefantThinking[k].Column;

                                            Act = true;
                                            Less = ElephantOnTable[i].ElefantThinking[k].ReturnHuristic(i, j, Order * -1); ;
                                            TableHuristic = ElephantOnTable[i].ElefantThinking[k].TableListElefant[j];
                                            if (Do == 1 || AA)
                                                //return TableHuristic;
                                                continue;

                                        }

                                    //When There is No Movments in Such Order Enemy continue.
                                    if (Order != FormRefrigtz.OrderPlate)
                                        if (ElephantOnTable[i].ElefantThinking[0].ReturnHuristic(i, j, Order * -1) > Less)
                                            continue;
                                    //When There is greater Huristic Movments.

                                    if (ElephantOnTable[i].ElefantThinking[0].ReturnHuristic(i, j, Order * -1) > Less)
                                    {
                                        if (AStarGreedyi == 1) ToFindMovments = true;

                                        //retrive table of current huristic.
                                        int[,] TableS = ElephantOnTable[i].ElefantThinking[k].TableListElefant[j];
                                        int[,] TableSS = ElephantOnTable[i].ElefantThinking[k].TableListElefant[j];
                                        //checked for Legal Movments ArgumentOutOfRangeException curnt game.
                                        if (DynamicAStarGreedytPrograming && !CurrentTableHuristic && AStarGreedyi == 1)
                                        {
                                            try
                                            {
                                                if (!isEnemyThingsinStable(TableS, AllDraw.TableListAction[AllDraw.TableListAction.Count - 1], FormRefrigtz.OrderPlate))
                                                    continue;
                                            }
                                            catch (Exception t)
                                            {

                                                if (!isEnemyThingsinStable(TableS, AllDraw.TableListAction[AllDraw.TableListAction.Count - 1], FormRefrigtz.OrderPlate))
                                                    continue;

                                            }


                                        }
                                        //When there is not Penalty regard mechanism.
                                        //if (!UsePenaltyRegardMechnisamT)
                                        {
                                            AB = new ChessRules(MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, 2, TableS, Order, -1, -1);
                                            //If there is kish or kshachamaz Order.
                                            if (AB.Check(TableS, Order))
                                            {
                                                //When Order is Gray.
                                                if (Order == 1)
                                                {
                                                    //Continue When is kish CheckObjectDangour and AStarGreadyFirstSearch .
                                                    if (AB.CheckGray)
                                                        continue;
                                                }
                                                else
                                                {
                                                    //Continue when CheckBrown and AStarGreadyFirstSearch. 
                                                    if (AB.CheckBrown)
                                                        continue;
                                                }
                                            }
                                            else
                                            {

                                            }

                                            //When Order is gray.
                                            /*if (Order == 1)
                                            {
                                                //When CheckGrayObjectDangour and There is not AStarGreedyt search.
                                                if (AB.CheckGray)
                                                {
                                                    //predict Search.
                                                    Color B;
                                                    if (a == Color.Gray)
                                                        B = Color.Brown;
                                                    else
                                                        B = Color.Gray;
                                                    APredict.TableList.Clear();
                                                    APredict.TableList.Add(TableS);
                                                    APredict.SetRowColumn(0);
                                                    TableHuristic = APredict.InitiatePerdictCheck((int)APredict.ElephantOnTable[i].Row, (int)APredict.ElephantOnTable[i].Column, B, TableS, Order, false);
                                                    if (TableHuristic == null)
                                                        continue;
                                                    else
                                                    {
                                                        Act = true;
                                                        Less = ElephantOnTable[i].ElefantThinking[k].ReturnHuristic(i, j, Order * -1);

                                                    }
                                                }
                                            }
                                            else
                                            {
                                                if (AB.CheckBrown)
                                                {
                                                    //predict Search.
                                                    Color B;
                                                    if (a == Color.Gray)
                                                        B = Color.Brown;
                                                    else
                                                        B = Color.Gray;
                                                    APredict.TableList.Clear();
                                                    APredict.TableList.Add(TableS);
                                                    APredict.SetRowColumn(0);
                                                    TableHuristic = APredict.InitiatePerdictCheck((int)APredict.ElephantOnTable[i].Row, (int)APredict.ElephantOnTable[i].Column, B, TableS, Order, false);
                                                    if (TableHuristic == null)
                                                        continue;


                                                }
                                            }

                                             */
                                        }
                                        RW2 = i;
                                        CL2 = k;
                                        Ki2 = j;
                                        RW1 = -1;
                                        CL1 = -1;
                                        Ki1 = -1;
                                        RW3 = -1;
                                        CL3 = -1;
                                        Ki3 = -1;
                                        RW4 = -1;
                                        CL4 = -1;
                                        Ki4 = -1;
                                        RW5 = -1;
                                        CL5 = -1;
                                        Ki5 = -1;
                                        RW6 = -1;
                                        CL6 = -1;
                                        Ki6 = -1;
                                        MaxLess2 = (ElephantOnTable[RW2].ElefantThinking[CL2].ReturnHuristic(RW2, Ki2, Order * -1));
                                        if (MaxLess2 > MaxLess1)
                                            MaxLess1 = -1;
                                        if (MaxLess2 > MaxLess3)
                                            MaxLess3 = -1;
                                        if (MaxLess2 > MaxLess4)
                                            MaxLess4 = -1;
                                        if (MaxLess2 > MaxLess5)
                                            MaxLess5 = -1;
                                        if (MaxLess2 > MaxLess6)
                                            MaxLess6 = -1;

                                        if (AStarGreedyi == 1)
                                        {
                                            if (Order == 1)
                                            {
                                                //THIS.SetBoxText("\r\nChess Huristic Elephant By Bob!");
                                                //THIS.RefreshBoxText();
                                            }
                                            else//If Order is Brown.
                                            {
                                                //THIS.SetBoxText("\r\nChess Huristic Elephant By Alice!");
                                                //THIS.RefreshBoxText();
                                            }//Set Table and Huristic Value and Syntax.
                                            bool Hit = false;
                                            if (ElephantOnTable[i].ElefantThinking[k].HitNumberElefant[j] > 0)
                                                Hit = true;
                                            //if (Order == 1)
                                            //SyntaxToWrite = (new ChessRules(ChessRules( ArrangmentsChanged)).CreateStatistic(ArrangmentsChanged,TableHuristic, FormRefrigtz.MovmentsNumber, 2, ElephantOnTable[i].ElefantThinking[k].RowColumnElefant[j][1], ElephantOnTable[i].ElefantThinking[k].RowColumnElefant[j][0], Hit, ElephantOnTable[i].ElefantThinking[k].HitNumberElefant[j], ChessRules.BridgeActBrown, false);
                                            //else
                                            //SyntaxToWrite = (new ChessRules(ChessRules( ArrangmentsChanged)).CreateStatistic(ArrangmentsChanged,TableHuristic, FormRefrigtz.MovmentsNumber, -2, ElephantOnTable[i].ElefantThinking[k].RowColumnElefant[j][1], ElephantOnTable[i].ElefantThinking[k].RowColumnElefant[j][0], Hit, ElephantOnTable[i].ElefantThinking[k].HitNumberElefant[j], ChessRules.BridgeActBrown, false);

                                            FormRefrigtz.LastRow = ElephantOnTable[i].ElefantThinking[k].Row;
                                            FormRefrigtz.LastColumn = ElephantOnTable[i].ElefantThinking[k].Column;

                                            Act = true;
                                            Less = ElephantOnTable[i].ElefantThinking[k].ReturnHuristic(i, j, Order * -1);
                                            TableHuristic = ElephantOnTable[i].ElefantThinking[k].TableListElefant[j];
                                        }
                                    }
                                    else
                                    {

                                        try
                                        {
                                            if (AStarGreedyi == 1)
                                            {
                                                if (Order == 1)
                                                {
                                                    //THIS.SetBoxText("\r\nChess Huristic Elephant By Bob!");
                                                    //THIS.RefreshBoxText();
                                                }
                                                else//If Order is Brown.
                                                {
                                                    //THIS.SetBoxText("\r\nChess Huristic Elephant By Alice!");
                                                    //THIS.RefreshBoxText();
                                                } //TakeRoot.Pointer = this;
                                                //Found of Max Non Probable Movments.
                                                Founded.Clear();
                                                double LessB = Double.MinValue; ;
                                                BeginIndexFoundingMaxLessofMaxList(0, Founded, ref LessB);
                                                RW2 = (int)MaxHuristicAStarGreedytBackWard[0][(int)Founded[0]];
                                                CL2 = (int)MaxHuristicAStarGreedytBackWard[0][(int)Founded[0] + 1];
                                                Ki2 = (int)MaxHuristicAStarGreedytBackWard[0][(int)Founded[0] + 2];
                                                if (Founded[0] != MaxElephntFounded)
                                                    continue;
                                                bool Hit = false;
                                                if (ElephantOnTable[RW2].ElefantThinking[CL2].HitNumberElefant[Ki2] > 0)
                                                    Hit = true;
                                                // if (Order == 1)
                                                //SyntaxToWrite = (new ChessRules(ChessRules( ArrangmentsChanged)).CreateStatistic(ArrangmentsChanged,TableHuristic, FormRefrigtz.MovmentsNumber, 2, ElephantOnTable[RW2].ElefantThinking[CL2].RowColumnElefant[Ki2][1], ElephantOnTable[RW2].ElefantThinking[CL2].RowColumnElefant[Ki2][0], Hit, ElephantOnTable[RW2].ElefantThinking[CL2].HitNumberElefant[Ki2], ChessRules.BridgeActBrown, false);
                                                // else
                                                //SyntaxToWrite = (new ChessRules(ChessRules( ArrangmentsChanged)).CreateStatistic(ArrangmentsChanged,TableHuristic, FormRefrigtz.MovmentsNumber, -2, ElephantOnTable[RW2].ElefantThinking[CL2].RowColumnElefant[Ki2][1], ElephantOnTable[RW2].ElefantThinking[CL2].RowColumnElefant[Ki2][0], Hit, ElephantOnTable[RW2].ElefantThinking[CL2].HitNumberElefant[Ki2], ChessRules.BridgeActBrown, false);

                                                FormRefrigtz.LastRow = ElephantOnTable[RW2].ElefantThinking[CL2].Row;
                                                FormRefrigtz.LastColumn = ElephantOnTable[RW2].ElefantThinking[CL2].Column;

                                                Act = true;
                                                Less = ElephantOnTable[RW2].ElefantThinking[CL2].ReturnHuristic(RW2, Ki2, Order * -1);
                                                TableHuristic = ElephantOnTable[RW2].ElefantThinking[CL2].TableListElefant[Ki2];
                                            }
                                        }
                                        catch (Exception t)
                                        {

                                        }
                                    }

                                }
                                catch (Exception t)
                                {

                                }
                            }

                        }
                    }
                    catch (Exception t)
                    {

                    } try
                {
                    /*Order *= -1;
                    ChessRules.CurrentOrder = DummyCurrentOrder;
                    for (int p = 0; p < ElephantOnTable[i].ElefantThinking[0].AStarGreedy.Count; p++)
                        ElephantOnTable[i].ElefantThinking[0].AStarGreedy[p].HuristicAStarGreedySearch(AStarGreedyi, A, a, ref Less, Order, false);

                     */
                    Order = DummyOrder;
                    ChessRules.CurrentOrder = DummyCurrentOrder;
                }
                catch (Exception t)
                {

                }

                Order = DummyOrder;
                ChessRules.CurrentOrder = DummyCurrentOrder;
            }

            for (i = 0; i < HourseMidle; i++)
            {
                for (int k = 0; k < AllDraw.HourseMovments; k++)
                    try
                    {
                        for (j = 0; HoursesOnTable[i] != null && HoursesOnTable[i] != null && HoursesOnTable[i].HourseThinking[k] != null && HoursesOnTable[i].HourseThinking[k] != null && j < HoursesOnTable[i].HourseThinking[k].TableListHourse.Count; j++)
                        {
                            {
                                try
                                {
                                    //For Penalty Reagrad Mechanisam of Current Check CheckMate Current Movments.
                                    if (FormRefrigtz.OrderPlate == Order && AStarGreedyi == 1 && UsePenaltyRegardMechnisamT)
                                        if (HoursesOnTable[i].HourseThinking[k].PenaltyRegardListHourse[j].IsPenaltyAction() == 0)
                                            continue;
                                    int CDummy = ChessRules.CurrentOrder;
                                    int COrder = Order;
                                    try
                                    {
                                        ChessRules.CurrentOrder *= -1;
                                        Order *= -1;
                                        Do = 0;
                                        if (UsePenaltyRegardMechnisamT)
                                        {
                                            for (int ij = 0; ij < HoursesOnTable[i].HourseThinking[k].AStarGreedy.Count - 1; ij++)
                                                HoursesOnTable[i].HourseThinking[k].AStarGreedy[ij].IsPenaltyRegardCheckMateAtBranch(Order, ref Do, HoursesOnTable[i].HourseThinking[k].AStarGreedy[ij]);
                                            Order = COrder;
                                            ChessRules.CurrentOrder = CDummy;
                                            ToCheckMate = -1; ForCheckMate = -1; AA = IsToCheckMateHasLessDeeperThanForCheckMate(this, Order, ref ToCheckMate, ref ForCheckMate, 0); if (Do == -1)
                                                continue;
                                        }

                                    }
                                    catch (Exception tt) { }
                                    Order = COrder;
                                    ChessRules.CurrentOrder = CDummy;
                                    if (FormRefrigtz.OrderPlate == Order && AStarGreedyi == 1 && UsePenaltyRegardMechnisamT)
                                        if ((HoursesOnTable[i].HourseThinking[k].PenaltyRegardListHourse[j].IsPenaltyAction() != 0 && HoursesOnTable[i].HourseThinking[k].PenaltyRegardListHourse[j].IsRewardAction() == 1 && AStarGreedyi == 1) || Do == 1 || AA)
                                        {
                                            //Set Table and Huristic Value and Syntax.
                                            bool Hit = false;
                                            if (HoursesOnTable[i].HourseThinking[k].HitNumberHourse[j] > 0)
                                                Hit = true;
                                            //if (Order == 1)
                                            //SyntaxToWrite = (new ChessRules(ChessRules( ArrangmentsChanged)).CreateStatistic(ArrangmentsChanged,TableHuristic, FormRefrigtz.MovmentsNumber, 3, HoursesOnTable[i].HourseThinking[k].RowColumnHourse[j][1], HoursesOnTable[i].HourseThinking[k].RowColumnHourse[j][0], Hit, HoursesOnTable[i].HourseThinking[k].HitNumberHourse[j], ChessRules.BridgeActBrown, false);
                                            // else
                                            //SyntaxToWrite = (new ChessRules(ChessRules( ArrangmentsChanged)).CreateStatistic(ArrangmentsChanged,TableHuristic, FormRefrigtz.MovmentsNumber, -3, HoursesOnTable[i].HourseThinking[k].RowColumnHourse[j][1], HoursesOnTable[i].HourseThinking[k].RowColumnHourse[j][0], Hit, HoursesOnTable[i].HourseThinking[k].HitNumberHourse[j], ChessRules.BridgeActBrown, false);
                                            FormRefrigtz.LastRow = HoursesOnTable[i].HourseThinking[k].Row;
                                            FormRefrigtz.LastColumn = HoursesOnTable[i].HourseThinking[k].Column;

                                            Act = true;
                                            Less = HoursesOnTable[i].HourseThinking[k].ReturnHuristic(i, j, Order * -1);
                                            TableHuristic = HoursesOnTable[i].HourseThinking[k].TableListHourse[j];
                                            if (Do == 1 || AA)
                                                //return TableHuristic;
                                                continue;

                                        }
                                    //When There is No Movments in Such Order Enemy continue.
                                    if (Order != FormRefrigtz.OrderPlate)
                                        if (HoursesOnTable[i].HourseThinking[0].ReturnHuristic(i, j, Order * -1) > Less)
                                            continue;
                                    //When There is greater Huristic Movments.
                                    if (HoursesOnTable[i].HourseThinking[0].ReturnHuristic(i, j, Order * -1) > Less)
                                    {
                                        if (AStarGreedyi == 1) ToFindMovments = true;
                                        //retrive table of current huristic.
                                        int[,] TableS = HoursesOnTable[i].HourseThinking[k].TableListHourse[j];
                                        int[,] TableSS = HoursesOnTable[i].HourseThinking[k].TableListHourse[j];
                                        {
                                            //checked for Legal Movments ArgumentOutOfRangeException curnt game.
                                            if (DynamicAStarGreedytPrograming && !CurrentTableHuristic && AStarGreedyi == 1)
                                            {
                                                try
                                                {
                                                    if (!isEnemyThingsinStable(TableS, AllDraw.TableListAction[AllDraw.TableListAction.Count - 1], FormRefrigtz.OrderPlate))
                                                        continue;
                                                }
                                                catch (Exception t)
                                                {

                                                    if (!isEnemyThingsinStable(TableS, AllDraw.TableListAction[AllDraw.TableListAction.Count - 1], FormRefrigtz.OrderPlate))
                                                        continue;

                                                }

                                            }
                                            //When there is not Penalty regard mechanism.
                                            //if (!UsePenaltyRegardMechnisamT)
                                            {
                                                AB = new ChessRules(MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, 3, TableS, Order, HoursesOnTable[i].HourseThinking[k].Row, HoursesOnTable[i].HourseThinking[k].Column);
                                                //If there is kish or kshachamaz Order.
                                                if (AB.Check(TableS, Order))
                                                {
                                                    //When Order is Gray.
                                                    if (Order == 1)
                                                    {
                                                        //Continue When is kish CheckObjectDangour and AStarGreadyFirstSearch .
                                                        if (AB.CheckGray)
                                                            continue;
                                                    }
                                                    else
                                                    {
                                                        //Continue when CheckBrown and AStarGreadyFirstSearch. 
                                                        if (AB.CheckBrown)
                                                            continue;
                                                    }
                                                }
                                                else
                                                {

                                                }
                                            }


                                            //When Order is gray.
                                            /*if (Order == 1)
                                            {
                                                //When CheckGrayObjectDangour and There is not AStarGreedyt search.
                                                if (AB.CheckGray)
                                                {
                                                    //predict Search.
                                                    Color B;
                                                    if (a == Color.Gray)
                                                        B = Color.Brown;
                                                    else
                                                        B = Color.Gray;
                                                    APredict.TableList.Clear();
                                                    APredict.TableList.Add(TableS);
                                                    APredict.SetRowColumn(0);
                                                    TableHuristic = APredict.InitiatePerdictCheck((int)APredict.HoursesOnTable[i].Row, (int)APredict.HoursesOnTable[i].Column, B, TableS, Order, false);
                                                    if (TableHuristic == null)
                                                        continue;

                                                }
                                            }
                                            else
                                            {
                                                if (AB.CheckBrown)
                                                {
                                                    //predict Search.
                                                    Color B;
                                                    if (a == Color.Gray)
                                                        B = Color.Brown;
                                                    else
                                                        B = Color.Gray;
                                                    APredict.TableList.Clear();
                                                    APredict.TableList.Add(TableS);
                                                    APredict.SetRowColumn(0);
                                                    TableHuristic = APredict.InitiatePerdictCheck((int)APredict.HoursesOnTable[i].Row, (int)APredict.HoursesOnTable[i].Column, B, TableS, Order, false);
                                                    if (TableHuristic == null)
                                                        continue;
                                                    else
                                                    {
                                                        Act = true;
                                                        Less = HoursesOnTable[i].HourseThinking[k].ReturnHuristic(i, j, Order * -1);
                                                        continue;
                                                    }

                                                }
                                            }
                                             */
                                        }
                                        RW3 = i;
                                        CL3 = k;
                                        Ki3 = j;
                                        RW1 = -1;
                                        CL1 = -1;
                                        Ki1 = -1;
                                        RW2 = -1;
                                        CL2 = -1;
                                        Ki2 = -1;
                                        RW4 = -1;
                                        CL4 = -1;
                                        Ki4 = -1;
                                        RW5 = -1;
                                        CL5 = -1;
                                        Ki5 = -1;
                                        RW6 = -1;
                                        CL6 = -1;
                                        Ki6 = -1;
                                        MaxLess3 = (HoursesOnTable[RW3].HourseThinking[CL3].ReturnHuristic(RW3, Ki3, Order * -1));
                                        if (MaxLess3 > MaxLess1)
                                            MaxLess1 = -1;
                                        if (MaxLess3 > MaxLess2)
                                            MaxLess2 = -1;
                                        if (MaxLess3 > MaxLess4)
                                            MaxLess4 = -1;
                                        if (MaxLess3 > MaxLess5)
                                            MaxLess5 = -1;
                                        if (MaxLess3 > MaxLess6)
                                            MaxLess6 = -1;

                                        if (AStarGreedyi == 1)
                                        {
                                            if (Order == 1)
                                            {
                                                //THIS.SetBoxText("\r\nChess Huristic Hourse By Bob!");
                                                //THIS.RefreshBoxText();
                                            }
                                            else//If Order is Brown.
                                            {
                                                //THIS.SetBoxText("\r\nChess Huristic Hourse By Alice!");
                                                //THIS.RefreshBoxText();
                                            } //Set Table and Huristic Value and Syntax.
                                            bool Hit = false;
                                            if (HoursesOnTable[i].HourseThinking[k].HitNumberHourse[j] > 0)
                                                Hit = true;
                                            // if (Order == 1)
                                            //SyntaxToWrite = (new ChessRules(ChessRules( ArrangmentsChanged)).CreateStatistic(ArrangmentsChanged,TableHuristic, FormRefrigtz.MovmentsNumber, 3, HoursesOnTable[i].HourseThinking[k].RowColumnHourse[j][1], HoursesOnTable[i].HourseThinking[k].RowColumnHourse[j][0], Hit, HoursesOnTable[i].HourseThinking[k].HitNumberHourse[j], ChessRules.BridgeActBrown, false);
                                            //else
                                            //SyntaxToWrite = (new ChessRules(ChessRules( ArrangmentsChanged)).CreateStatistic(ArrangmentsChanged,TableHuristic, FormRefrigtz.MovmentsNumber, -3, HoursesOnTable[i].HourseThinking[k].RowColumnHourse[j][1], HoursesOnTable[i].HourseThinking[k].RowColumnHourse[j][0], Hit, HoursesOnTable[i].HourseThinking[k].HitNumberHourse[j], ChessRules.BridgeActBrown, false);
                                            FormRefrigtz.LastRow = HoursesOnTable[i].HourseThinking[k].Row;
                                            FormRefrigtz.LastColumn = HoursesOnTable[i].HourseThinking[k].Column;

                                            Act = true;
                                            Less = HoursesOnTable[i].HourseThinking[k].ReturnHuristic(i, j, Order * -1);
                                            TableHuristic = HoursesOnTable[i].HourseThinking[k].TableListHourse[j];

                                        }

                                    }
                                    else
                                    //Set Table and Huristic Value and Syntax.
                                    {
                                        try
                                        {
                                            if (AStarGreedyi == 1)
                                            {
                                                if (Order == 1)
                                                {
                                                    //THIS.SetBoxText("\r\nChess Huristic Hourse By Bob!");
                                                    //THIS.RefreshBoxText();
                                                }
                                                else//If Order is Brown.
                                                {
                                                    //THIS.SetBoxText("\r\nChess Huristic Hourse By Alice!");
                                                    //THIS.RefreshBoxText();
                                                }  //TakeRoot.Pointer = this;
                                                //Found of Max Non Probable Movments.
                                                Founded.Clear();
                                                double LessB = Double.MinValue; ;
                                                BeginIndexFoundingMaxLessofMaxList(0, Founded, ref LessB);
                                                RW3 = (int)MaxHuristicAStarGreedytBackWard[0][(int)Founded[0]];
                                                CL3 = (int)MaxHuristicAStarGreedytBackWard[0][(int)Founded[0] + 1];
                                                Ki3 = (int)MaxHuristicAStarGreedytBackWard[0][(int)Founded[0] + 2];
                                                if (Founded[0] != MaxHourseFounded)
                                                    continue;
                                                bool Hit = false;
                                                if (HoursesOnTable[RW3].HourseThinking[CL3].HitNumberHourse[Ki3] > 0)
                                                    Hit = true;
                                                // if (Order == 1)
                                                //SyntaxToWrite = (new ChessRules(ChessRules( ArrangmentsChanged)).CreateStatistic(ArrangmentsChanged,TableHuristic, FormRefrigtz.MovmentsNumber, 3, HoursesOnTable[RW3].HourseThinking[CL3].RowColumnHourse[Ki3][1], HoursesOnTable[RW3].HourseThinking[CL3].RowColumnHourse[Ki3][0], Hit, HoursesOnTable[RW3].HourseThinking[CL3].HitNumberHourse[Ki3], ChessRules.BridgeActBrown, false);
                                                // else
                                                //SyntaxToWrite = (new ChessRules(ChessRules( ArrangmentsChanged)).CreateStatistic(ArrangmentsChanged,TableHuristic, FormRefrigtz.MovmentsNumber, -3, HoursesOnTable[RW3].HourseThinking[CL3].RowColumnHourse[Ki3][1], HoursesOnTable[RW3].HourseThinking[CL3].RowColumnHourse[Ki3][0], Hit, HoursesOnTable[RW3].HourseThinking[CL3].HitNumberHourse[Ki3], ChessRules.BridgeActBrown, false);
                                                FormRefrigtz.LastRow = HoursesOnTable[RW3].HourseThinking[CL3].Row;
                                                FormRefrigtz.LastColumn = HoursesOnTable[RW3].HourseThinking[CL3].Column;

                                                Act = true;
                                                Less = HoursesOnTable[RW3].HourseThinking[CL3].ReturnHuristic(RW3, Ki3, Order * -1);
                                                TableHuristic = HoursesOnTable[RW3].HourseThinking[CL3].TableListHourse[Ki3];
                                            }
                                        }
                                        catch (Exception t)
                                        { }
                                    }
                                }
                                catch (Exception t)
                                {

                                }
                            }
                            // else
                            {
                            }


                        }
                    }
                    catch (Exception t)
                    {

                    }
                try
                {
                    /*Order *= -1;
                    ChessRules.CurrentOrder = DummyCurrentOrder;
                    for (int p = 0; p < HoursesOnTable[i].HourseThinking[0].AStarGreedy.Count; p++)
                        HoursesOnTable[i].HourseThinking[0].AStarGreedy[p].HuristicAStarGreedySearch(AStarGreedyi, A, a, ref Less, Order, false);

                     */
                    Order = DummyOrder;
                    ChessRules.CurrentOrder = DummyCurrentOrder;
                }
                catch (Exception t)
                {

                }

            }

            for (i = 0; i < BridgeMidle; i++)
            {
                for (int k = 0; k < AllDraw.BridgeMovments; k++)
                    try
                    {
                        for (j = 0; BridgesOnTable[i] != null && BridgesOnTable[i] != null && BridgesOnTable[i].BridgeThinking[k] != null && BridgesOnTable[i].BridgeThinking[k] != null && j < BridgesOnTable[i].BridgeThinking[k].TableListBridge.Count; j++)
                        {
                            {
                                try
                                {
                                    //For Penalty Reagrad Mechanisam of Current Check CheckMate Current Movments.
                                    if (FormRefrigtz.OrderPlate == Order && AStarGreedyi == 1 && UsePenaltyRegardMechnisamT)
                                        if (BridgesOnTable[i].BridgeThinking[k].PenaltyRegardListBridge[j].IsPenaltyAction() == 0)
                                            continue;
                                    int CDummy = ChessRules.CurrentOrder;
                                    int COrder = Order;
                                    try
                                    {
                                        ChessRules.CurrentOrder *= -1;
                                        Order *= -1;
                                        Do = 0;
                                        if (UsePenaltyRegardMechnisamT)
                                        {
                                            for (int ij = 0; ij < BridgesOnTable[i].BridgeThinking[k].AStarGreedy.Count - 1; ij++)
                                                BridgesOnTable[i].BridgeThinking[k].AStarGreedy[ij].IsPenaltyRegardCheckMateAtBranch(Order, ref Do, BridgesOnTable[i].BridgeThinking[k].AStarGreedy[ij]);
                                            Order = COrder;
                                            ChessRules.CurrentOrder = CDummy;
                                            ToCheckMate = -1; ForCheckMate = -1; AA = IsToCheckMateHasLessDeeperThanForCheckMate(this, Order, ref ToCheckMate, ref ForCheckMate, 0); if (Do == -1)
                                                continue;
                                        }

                                    }
                                    catch (Exception tt) { }
                                    Order = COrder;
                                    ChessRules.CurrentOrder = CDummy;
                                    if (FormRefrigtz.OrderPlate == Order && AStarGreedyi == 1 && UsePenaltyRegardMechnisamT)
                                        if ((BridgesOnTable[i].BridgeThinking[k].PenaltyRegardListBridge[j].IsPenaltyAction() != 0 && BridgesOnTable[i].BridgeThinking[k].PenaltyRegardListBridge[j].IsRewardAction() == 1 && AStarGreedyi == 1) || Do == 1 || AA)
                                        {
                                            //Set Table and Huristic Value and Syntax.
                                            bool Hit = false;
                                            if (BridgesOnTable[i].BridgeThinking[k].HitNumberBridge[j] > 0)
                                                Hit = true;
                                            // if (Order == 1)
                                            //SyntaxToWrite = (new ChessRules(ChessRules( ArrangmentsChanged)).CreateStatistic(ArrangmentsChanged,TableHuristic, FormRefrigtz.MovmentsNumber, 4, BridgesOnTable[i].BridgeThinking[k].RowColumnBridge[j][1], BridgesOnTable[i].BridgeThinking[k].RowColumnBridge[j][0], Hit, BridgesOnTable[i].BridgeThinking[k].HitNumberBridge[j], ChessRules.BridgeActBrown, false);
                                            // else
                                            //SyntaxToWrite = (new ChessRules(ChessRules( ArrangmentsChanged)).CreateStatistic(ArrangmentsChanged,TableHuristic, FormRefrigtz.MovmentsNumber, -4, BridgesOnTable[i].BridgeThinking[k].RowColumnBridge[j][1], BridgesOnTable[i].BridgeThinking[k].RowColumnBridge[j][0], Hit, BridgesOnTable[i].BridgeThinking[k].HitNumberBridge[j], ChessRules.BridgeActBrown, false);

                                            FormRefrigtz.LastRow = BridgesOnTable[i].BridgeThinking[k].Row;
                                            FormRefrigtz.LastColumn = BridgesOnTable[i].BridgeThinking[k].Column;

                                            Act = true;
                                            Less = BridgesOnTable[i].BridgeThinking[k].ReturnHuristic(i, j, Order * -1);
                                            TableHuristic = BridgesOnTable[i].BridgeThinking[k].TableListBridge[j];
                                            if (Do == 1 || AA)
                                                //return TableHuristic;
                                                continue;
                                        }
                                    //When There is No Movments in Such Order Enemy continue.
                                    if (Order != FormRefrigtz.OrderPlate)
                                        if (BridgesOnTable[i].BridgeThinking[0].ReturnHuristic(i, j, Order * -1) > Less) continue;
                                    //When There is greater Huristic Movments.
                                    if (BridgesOnTable[i].BridgeThinking[0].ReturnHuristic(i, j, Order * -1) > Less)
                                    {
                                        if (AStarGreedyi == 1) ToFindMovments = true;
                                        //retrive table of current huristic.

                                        //retrive table of current huristic.
                                        int[,] TableS = BridgesOnTable[i].BridgeThinking[k].TableListBridge[j];
                                        int[,] TableSS = BridgesOnTable[i].BridgeThinking[k].TableListBridge[j];
                                        //checked for Legal Movments ArgumentOutOfRangeException curnt game.
                                        if (DynamicAStarGreedytPrograming && !CurrentTableHuristic && AStarGreedyi == 1)
                                        {
                                            try
                                            {
                                                if (!isEnemyThingsinStable(TableS, AllDraw.TableListAction[AllDraw.TableListAction.Count - 1], FormRefrigtz.OrderPlate))
                                                    continue;
                                            }
                                            catch (Exception t)
                                            {

                                                if (!isEnemyThingsinStable(TableS, AllDraw.TableListAction[AllDraw.TableListAction.Count - 1], FormRefrigtz.OrderPlate))
                                                    continue;

                                            }


                                        }
                                        //When there is not Penalty regard mechanism.
                                        //if (!UsePenaltyRegardMechnisamT)
                                        {
                                            AB = new ChessRules(MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, 4, TableS, Order, BridgesOnTable[i].BridgeThinking[k].Row, BridgesOnTable[i].BridgeThinking[k].Column);
                                            //If there is kish or kshachamaz Order.
                                            if (AB.Check(TableS, Order))
                                            {
                                                //When Order is Gray.
                                                if (Order == 1)
                                                {
                                                    //Continue When is kish CheckObjectDangour and AStarGreadyFirstSearch .
                                                    if (AB.CheckGray)
                                                        continue;
                                                }
                                                else
                                                {
                                                    //Continue when CheckBrown and AStarGreadyFirstSearch. 
                                                    if (AB.CheckBrown)
                                                        continue;
                                                }
                                            }
                                            else
                                            {

                                            }

                                            /* if (Order == 1)
                                             {
                                                 if (AB.CheckGray)
                                                 {
                                                     //predict Search.
                                                     Color B;
                                                     if (a == Color.Gray)
                                                         B = Color.Brown;
                                                     else
                                                         B = Color.Gray;
                                                     APredict.TableList.Clear();
                                                     APredict.TableList.Add(TableS);
                                                     APredict.SetRowColumn(0);
                                                     TableHuristic = APredict.InitiatePerdictCheck((int)APredict.BridgesOnTable[i].Row, (int)APredict.BridgesOnTable[i].Column, B, TableS, Order, false);
                                                     if (TableHuristic == null)
                                                         continue;

                                                 }
                                             }
                                             else
                                             {
                                                 if (AB.CheckBrown)
                                                 {
                                                     //predict Search.
                                                     Color B;
                                                     if (a == Color.Gray)
                                                         B = Color.Brown;
                                                     else
                                                         B = Color.Gray;
                                                     APredict.TableList.Clear();
                                                     APredict.TableList.Add(TableS);
                                                     APredict.SetRowColumn(0);
                                                     TableHuristic = APredict.InitiatePerdictCheck((int)BridgesOnTable[i].Row, (int)BridgesOnTable[i].Column, B, TableS, Order, false);
                                                     if (TableHuristic == null)
                                                         continue;
                                                     else
                                                     {
                                                         Act = true;
                                                         Less = BridgesOnTable[i].BridgeThinking[k].ReturnHuristic(i, j, Order * -1);

                                                         continue;
                                                     }
                                                 }
                                             }
                                             */
                                        }
                                        RW4 = i;
                                        CL4 = k;
                                        Ki4 = j;
                                        RW1 = -1;
                                        CL1 = -1;
                                        Ki1 = -1;
                                        RW2 = -1;
                                        CL2 = -1;
                                        Ki2 = -1;
                                        RW3 = -1;
                                        CL3 = -1;
                                        Ki3 = -1;
                                        RW5 = -1;
                                        CL5 = -1;
                                        Ki5 = -1;
                                        RW6 = -1;
                                        CL6 = -1;
                                        Ki6 = -1;
                                        MaxLess4 = (BridgesOnTable[RW4].BridgeThinking[CL4].ReturnHuristic(RW4, Ki4, Order * -1));
                                        if (MaxLess4 > MaxLess1)
                                            MaxLess1 = -1;
                                        if (MaxLess4 > MaxLess2)
                                            MaxLess2 = -1;
                                        if (MaxLess4 > MaxLess3)
                                            MaxLess3 = -1;
                                        if (MaxLess4 > MaxLess5)
                                            MaxLess5 = -1;
                                        if (MaxLess4 > MaxLess6)
                                            MaxLess6 = -1;


                                        if (AStarGreedyi == 1)
                                        {
                                            if (Order == 1)
                                            {
                                                //THIS.SetBoxText("\r\nChess Huristic Bridges By Bob!");
                                                //THIS.RefreshBoxText();
                                            }
                                            else//If Order is Brown.
                                            {
                                                //THIS.SetBoxText("\r\nChess Huristic Bridges By Alice!");
                                                //THIS.RefreshBoxText();
                                            }  //Set Table and Huristic Value and Syntax.
                                            bool Hit = false;
                                            if (BridgesOnTable[i].BridgeThinking[k].HitNumberBridge[j] > 0)
                                                Hit = true;
                                            // if (Order == 1)
                                            //SyntaxToWrite = (new ChessRules(ChessRules( ArrangmentsChanged)).CreateStatistic(ArrangmentsChanged,TableHuristic, FormRefrigtz.MovmentsNumber, 4, BridgesOnTable[i].BridgeThinking[k].RowColumnBridge[j][1], BridgesOnTable[i].BridgeThinking[k].RowColumnBridge[j][0], Hit, BridgesOnTable[i].BridgeThinking[k].HitNumberBridge[j], ChessRules.BridgeActBrown, false);
                                            // else
                                            //SyntaxToWrite = (new ChessRules(ChessRules( ArrangmentsChanged)).CreateStatistic(ArrangmentsChanged,TableHuristic, FormRefrigtz.MovmentsNumber, -4, BridgesOnTable[i].BridgeThinking[k].RowColumnBridge[j][1], BridgesOnTable[i].BridgeThinking[k].RowColumnBridge[j][0], Hit, BridgesOnTable[i].BridgeThinking[k].HitNumberBridge[j], ChessRules.BridgeActBrown, false);

                                            FormRefrigtz.LastRow = BridgesOnTable[i].BridgeThinking[k].Row;
                                            FormRefrigtz.LastColumn = BridgesOnTable[i].BridgeThinking[k].Column;

                                            Act = true;
                                            Less = BridgesOnTable[i].BridgeThinking[k].ReturnHuristic(i, j, Order * -1);
                                            TableHuristic = BridgesOnTable[i].BridgeThinking[k].TableListBridge[j];

                                        }
                                    }
                                    else//Set Table and Huristic Value and Syntax.
                                    {
                                        try
                                        {
                                            if (AStarGreedyi == 1)
                                            {
                                                if (Order == 1)
                                                {
                                                    //THIS.SetBoxText("\r\nChess Huristic Bridges By Bob!");
                                                    //THIS.RefreshBoxText();
                                                }
                                                else//If Order is Brown.
                                                {
                                                    //THIS.SetBoxText("\r\nChess Huristic Bridges By Alice!");
                                                    //THIS.RefreshBoxText();
                                                }//TakeRoot.Pointer = this;
                                                //Found of Max Non Probable Movments.
                                                Founded.Clear();
                                                double LessB = Double.MinValue; ;
                                                BeginIndexFoundingMaxLessofMaxList(0, Founded, ref LessB);
                                                RW4 = (int)MaxHuristicAStarGreedytBackWard[0][(int)Founded[0]];
                                                CL4 = (int)MaxHuristicAStarGreedytBackWard[0][(int)Founded[0] + 1];
                                                Ki4 = (int)MaxHuristicAStarGreedytBackWard[0][(int)Founded[0] + 2];
                                                if (Founded[0] != MaxBridgesFounded)
                                                    continue;
                                                bool Hit = false;
                                                if (BridgesOnTable[RW4].BridgeThinking[CL4].HitNumberBridge[Ki4] > 0)
                                                    Hit = true;
                                                //  if (Order == 1)
                                                //SyntaxToWrite = (new ChessRules(ChessRules( ArrangmentsChanged)).CreateStatistic(ArrangmentsChanged,TableHuristic, FormRefrigtz.MovmentsNumber, 4, BridgesOnTable[RW4].BridgeThinking[CL4].RowColumnBridge[Ki4][1], BridgesOnTable[RW4].BridgeThinking[CL4].RowColumnBridge[Ki4][0], Hit, BridgesOnTable[RW4].BridgeThinking[CL4].HitNumberBridge[Ki4], ChessRules.BridgeActBrown, false);
                                                //  else
                                                //SyntaxToWrite = (new ChessRules(ChessRules( ArrangmentsChanged)).CreateStatistic(ArrangmentsChanged,TableHuristic, FormRefrigtz.MovmentsNumber, -4, BridgesOnTable[RW4].BridgeThinking[CL4].RowColumnBridge[Ki4][1], BridgesOnTable[RW4].BridgeThinking[CL4].RowColumnBridge[Ki4][0], Hit, BridgesOnTable[RW4].BridgeThinking[CL4].HitNumberBridge[Ki4], ChessRules.BridgeActBrown, false);

                                                FormRefrigtz.LastRow = BridgesOnTable[RW4].BridgeThinking[CL4].Row;
                                                FormRefrigtz.LastColumn = BridgesOnTable[RW4].BridgeThinking[CL4].Column;

                                                Act = true;
                                                Less = BridgesOnTable[RW4].BridgeThinking[CL4].ReturnHuristic(RW4, Ki4, Order * -1);
                                                TableHuristic = BridgesOnTable[RW4].BridgeThinking[CL4].TableListBridge[Ki4];
                                            }
                                        }
                                        catch (Exception t) { }
                                    }
                                }
                                catch (Exception t)
                                {

                                }
                            }
                        }
                    }
                    catch (Exception t)
                    {

                    } try
                {
                    /*Order *= -1;
                    ChessRules.CurrentOrder *= -1;
                    for (int p = 0; p < BridgesOnTable[i].BridgeThinking[0].AStarGreedy.Count; p++)
                        BridgesOnTable[i].BridgeThinking[0].AStarGreedy[p].HuristicAStarGreedySearch(AStarGreedyi, A, a, ref Less, Order, false);
                     */
                    Order = DummyOrder;
                    ChessRules.CurrentOrder = DummyCurrentOrder;
                }
                catch (Exception t)
                {

                }

                Order = DummyOrder;
                ChessRules.CurrentOrder = DummyCurrentOrder;
            }


            for (i = 0; i < MinisterMidle; i++)
            {
                for (int k = 0; k < AllDraw.MinisterMovments; k++)
                    try
                    {
                        for (j = 0; MinisterOnTable[i] != null && MinisterOnTable[i] != null && MinisterOnTable[i].MinisterThinking[k] != null && MinisterOnTable[i].MinisterThinking[k] != null && j < MinisterOnTable[i].MinisterThinking[k].TableListMinister.Count; j++)
                        {
                            {
                                //For Penalty Reagrad Mechanisam of Current Check CheckMate Current Movments.
                                if (FormRefrigtz.OrderPlate == Order && AStarGreedyi == 1 && UsePenaltyRegardMechnisamT)
                                    if (MinisterOnTable[i].MinisterThinking[k].PenaltyRegardListMinister[j].IsPenaltyAction() == 0)
                                        continue;
                                int CDummy = ChessRules.CurrentOrder;
                                int COrder = Order;
                                try
                                {
                                    ChessRules.CurrentOrder *= -1;
                                    Order *= -1;
                                    Do = 0;
                                    if (UsePenaltyRegardMechnisamT)
                                    {
                                        for (int ij = 0; ij < MinisterOnTable[i].MinisterThinking[k].AStarGreedy.Count - 1; ij++)
                                            MinisterOnTable[i].MinisterThinking[k].AStarGreedy[ij].IsPenaltyRegardCheckMateAtBranch(Order, ref Do, MinisterOnTable[i].MinisterThinking[k].AStarGreedy[ij]);
                                        Order = COrder;
                                        ChessRules.CurrentOrder = CDummy;
                                        ToCheckMate = -1; ForCheckMate = -1; AA = IsToCheckMateHasLessDeeperThanForCheckMate(this, Order, ref ToCheckMate, ref ForCheckMate, 0); if (Do == -1)
                                            continue;
                                    }

                                }
                                catch (Exception tt) { }
                                Order = COrder;
                                ChessRules.CurrentOrder = CDummy;
                                if (FormRefrigtz.OrderPlate == Order && AStarGreedyi == 1 && UsePenaltyRegardMechnisamT)
                                    if ((MinisterOnTable[i].MinisterThinking[k].PenaltyRegardListMinister[j].IsPenaltyAction() != 0 && MinisterOnTable[i].MinisterThinking[k].PenaltyRegardListMinister[j].IsRewardAction() == 1 && AStarGreedyi == 1) || Do == 1 || AA)
                                    {
                                        //Set Table and Huristic Value and Syntax.
                                        bool Hit = false;
                                        if (MinisterOnTable[i].MinisterThinking[k].HitNumberMinister[j] > 0)
                                            Hit = true;
                                        //if (Order == 1)
                                        //SyntaxToWrite = (new ChessRules(ChessRules( ArrangmentsChanged)).CreateStatistic(ArrangmentsChanged,TableHuristic, FormRefrigtz.MovmentsNumber, 5, MinisterOnTable[i].MinisterThinking[k].RowColumnMinister[j][1], MinisterOnTable[i].MinisterThinking[k].RowColumnMinister[j][0], Hit, MinisterOnTable[i].MinisterThinking[k].HitNumberBridge[j], ChessRules.BridgeActBrown, false);
                                        else
                                            //SyntaxToWrite = (new ChessRules(ChessRules( ArrangmentsChanged)).CreateStatistic(ArrangmentsChanged,TableHuristic, FormRefrigtz.MovmentsNumber, -5, MinisterOnTable[i].MinisterThinking[k].RowColumnMinister[j][1], MinisterOnTable[i].MinisterThinking[k].RowColumnMinister[j][0], Hit, MinisterOnTable[i].MinisterThinking[k].HitNumberBridge[j], ChessRules.BridgeActBrown, false);

                                            FormRefrigtz.LastRow = MinisterOnTable[i].MinisterThinking[k].Row;
                                        FormRefrigtz.LastColumn = MinisterOnTable[i].MinisterThinking[k].Column;

                                        Act = true;
                                        Less = MinisterOnTable[i].MinisterThinking[k].ReturnHuristic(i, j, Order * -1);
                                        TableHuristic = MinisterOnTable[i].MinisterThinking[k].TableListMinister[j];
                                        if (Do == 1 || AA)
                                            //return TableHuristic;
                                            continue;
                                    }
                                if (Order != FormRefrigtz.OrderPlate)
                                    if (MinisterOnTable[i].MinisterThinking[0].ReturnHuristic(i, j, Order * -1) > Less)
                                        continue;
                                if (MinisterOnTable[i].MinisterThinking[0].ReturnHuristic(i, j, Order * -1) > Less)
                                {
                                    if (AStarGreedyi == 1) ToFindMovments = true;
                                    //retrive table of current huristic.

                                    //retrive table of current huristic.
                                    int[,] TableS = MinisterOnTable[i].MinisterThinking[k].TableListMinister[j];
                                    int[,] TableSS = MinisterOnTable[i].MinisterThinking[k].TableListMinister[j];
                                    //checked for Legal Movments ArgumentOutOfRangeException curnt game.
                                    if (DynamicAStarGreedytPrograming && !CurrentTableHuristic && AStarGreedyi == 1)
                                    {
                                        try
                                        {
                                            if (!isEnemyThingsinStable(TableS, AllDraw.TableListAction[AllDraw.TableListAction.Count - 1], FormRefrigtz.OrderPlate))
                                                continue;
                                        }
                                        catch (Exception t)
                                        {

                                            if (!isEnemyThingsinStable(TableS, AllDraw.TableListAction[AllDraw.TableListAction.Count - 1], FormRefrigtz.OrderPlate))
                                                continue;

                                        }

                                    }
                                    {
                                        //When there is not Penalty regard mechanism.
                                        //if (!UsePenaltyRegardMechnisamT)
                                        {
                                            AB = new ChessRules(MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, 5, TableS, Order, MinisterOnTable[i].MinisterThinking[k].Row, MinisterOnTable[i].MinisterThinking[k].Column);
                                            //If there is kish or kshachamaz Order.
                                            if (AB.Check(TableS, Order))
                                            {
                                                //When Order is Gray.
                                                if (Order == 1)
                                                {
                                                    //Continue When is kish CheckObjectDangour and AStarGreadyFirstSearch .
                                                    if (AB.CheckGray)
                                                        continue;
                                                }
                                                else
                                                {
                                                    //Continue when CheckBrown and AStarGreadyFirstSearch. 
                                                    if (AB.CheckBrown)
                                                        continue;
                                                }
                                            }
                                            else
                                            {

                                            }
                                        }

                                        //When Order is gray.

                                        /*if (Order == 1)
                                        {
                                            //When CheckGrayObjectDangour and There is not AStarGreedyt search.
                                            if (AB.CheckGray)
                                            {
                                                //predict Search.
                                                Color B;
                                                if (a == Color.Gray)
                                                    B = Color.Brown;
                                                else
                                                    B = Color.Gray;
                                                APredict.TableList.Clear();
                                                APredict.TableList.Add(TableS);
                                                APredict.SetRowColumn(0);
                                                TableHuristic = APredict.InitiatePerdictCheck((int)APredict.MinisterOnTable[i].Row, (int)APredict.MinisterOnTable[i].Column, B, TableS, Order, false);
                                                if (TableHuristic == null)
                                                    continue;

                                            }

                                        }
                                        else
                                        {
                                            if (AB.CheckBrown)
                                            {
                                                //predict Search.
                                                Color B;
                                                if (a == Color.Gray)
                                                    B = Color.Brown;
                                                else
                                                    B = Color.Gray;
                                                APredict.TableList.Clear();
                                                APredict.TableList.Add(TableS);
                                                APredict.SetRowColumn(0);
                                                if (null == APredict.InitiatePerdictCheck((int)APredict.MinisterOnTable[i].Row, (int)APredict.MinisterOnTable[i].Column, B, TableS, Order, false))
                                                    continue;

                                            }
                                        }

                                         */
                                    }
                                    RW5 = i;
                                    CL5 = k;
                                    Ki5 = j;
                                    RW1 = -1;
                                    CL1 = -1;
                                    Ki1 = -1;
                                    RW2 = -1;
                                    CL2 = -1;
                                    Ki2 = -1;
                                    RW3 = -1;
                                    CL3 = -1;
                                    Ki3 = -1;
                                    RW4 = -1;
                                    CL4 = -1;
                                    Ki4 = -1;
                                    RW6 = -1;
                                    CL6 = -1;
                                    Ki6 = -1;
                                    MaxLess5 = (MinisterOnTable[RW5].MinisterThinking[CL5].ReturnHuristic(RW5, Ki5, Order * -1));
                                    if (MaxLess5 > MaxLess1)
                                        MaxLess1 = -1;
                                    if (MaxLess5 > MaxLess2)
                                        MaxLess2 = -1;
                                    if (MaxLess5 > MaxLess3)
                                        MaxLess3 = -1;
                                    if (MaxLess5 > MaxLess4)
                                        MaxLess4 = -1;
                                    if (MaxLess5 > MaxLess6)
                                        MaxLess6 = -1;


                                    if (AStarGreedyi == 1)
                                    {
                                        if (Order == 1)
                                        {
                                            //THIS.SetBoxText("\r\nChess Huristic Minister By Bob!");
                                            //THIS.RefreshBoxText();
                                        }
                                        else//If Order is Brown.
                                        {
                                            //THIS.SetBoxText("\r\nChess Huristic Minister By Alice!");
                                            //THIS.RefreshBoxText();
                                        }   //Set Table and Huristic Value and Syntax.
                                        bool Hit = false;
                                        if (MinisterOnTable[i].MinisterThinking[k].HitNumberMinister[j] > 0)
                                            Hit = true;
                                        // if (Order == 1)
                                        //SyntaxToWrite = (new ChessRules(ChessRules( ArrangmentsChanged)).CreateStatistic(ArrangmentsChanged,TableHuristic, FormRefrigtz.MovmentsNumber, 5, MinisterOnTable[i].MinisterThinking[k].RowColumnMinister[j][1], MinisterOnTable[i].MinisterThinking[k].RowColumnMinister[j][0], Hit, MinisterOnTable[i].MinisterThinking[k].HitNumberBridge[j], ChessRules.BridgeActBrown, false);
                                        // else
                                        //SyntaxToWrite = (new ChessRules(ChessRules( ArrangmentsChanged)).CreateStatistic(ArrangmentsChanged,TableHuristic, FormRefrigtz.MovmentsNumber, -5, MinisterOnTable[i].MinisterThinking[k].RowColumnMinister[j][1], MinisterOnTable[i].MinisterThinking[k].RowColumnMinister[j][0], Hit, MinisterOnTable[i].MinisterThinking[k].HitNumberBridge[j], ChessRules.BridgeActBrown, false);

                                        FormRefrigtz.LastRow = MinisterOnTable[i].MinisterThinking[k].Row;
                                        FormRefrigtz.LastColumn = MinisterOnTable[i].MinisterThinking[k].Column;

                                        Act = true;
                                        Less = MinisterOnTable[i].MinisterThinking[k].ReturnHuristic(i, j, Order * -1);
                                        TableHuristic = MinisterOnTable[i].MinisterThinking[k].TableListMinister[j];

                                    }
                                }
                                else//Set Table and Huristic Value and Syntax.
                                {
                                    try
                                    {
                                        if (AStarGreedyi == 1)
                                        {
                                            if (Order == 1)
                                            {
                                                //THIS.SetBoxText("\r\nChess Huristic Minister By Bob!");
                                                //THIS.RefreshBoxText();
                                            }
                                            else//If Order is Brown.
                                            {
                                                //THIS.SetBoxText("\r\nChess Huristic Minister By Alice!");
                                                //THIS.RefreshBoxText();
                                            }  //TakeRoot.Pointer = this;
                                            //Found of Max Non Probable Movments.
                                            Founded.Clear();
                                            double LessB = Double.MinValue; ;
                                            BeginIndexFoundingMaxLessofMaxList(0, Founded, ref LessB);
                                            RW5 = (int)MaxHuristicAStarGreedytBackWard[0][(int)Founded[0]];
                                            CL5 = (int)MaxHuristicAStarGreedytBackWard[0][(int)Founded[0] + 1];
                                            Ki5 = (int)MaxHuristicAStarGreedytBackWard[0][(int)Founded[0] + 2];
                                            if (Founded[0] != MaxMinisterFounded)
                                                continue;
                                            bool Hit = false;
                                            if (MinisterOnTable[RW5].MinisterThinking[CL5].HitNumberMinister[Ki5] > 0)
                                                Hit = true;
                                            // if (Order == 1)
                                            //SyntaxToWrite = (new ChessRules(ChessRules( ArrangmentsChanged)).CreateStatistic(ArrangmentsChanged,TableHuristic, FormRefrigtz.MovmentsNumber, 5, MinisterOnTable[RW5].MinisterThinking[CL5].RowColumnMinister[Ki5][1], MinisterOnTable[RW5].MinisterThinking[CL5].RowColumnMinister[Ki5][0], Hit, MinisterOnTable[RW5].MinisterThinking[CL5].HitNumberBridge[Ki5], ChessRules.BridgeActBrown, false);
                                            // else
                                            //SyntaxToWrite = (new ChessRules(ChessRules( ArrangmentsChanged)).CreateStatistic(ArrangmentsChanged,TableHuristic, FormRefrigtz.MovmentsNumber, -5, MinisterOnTable[RW5].MinisterThinking[CL5].RowColumnMinister[Ki5][1], MinisterOnTable[RW5].MinisterThinking[CL5].RowColumnMinister[Ki5][0], Hit, MinisterOnTable[RW5].MinisterThinking[CL5].HitNumberBridge[Ki5], ChessRules.BridgeActBrown, false);

                                            FormRefrigtz.LastRow = MinisterOnTable[RW5].MinisterThinking[CL5].Row;
                                            FormRefrigtz.LastColumn = MinisterOnTable[RW5].MinisterThinking[CL5].Column;

                                            Act = true;
                                            Less = MinisterOnTable[RW5].MinisterThinking[CL5].ReturnHuristic(RW5, Ki5, Order * -1);
                                            TableHuristic = MinisterOnTable[RW5].MinisterThinking[CL5].TableListMinister[Ki5];
                                        }
                                    }
                                    catch (Exception t)
                                    {

                                    }
                                }
                            }
                        }
                    }
                    catch (Exception t)
                    {

                    }
                try
                {/*
                                Order *= -1;
                                ChessRules.CurrentOrder *= -1;
                                for (int p = 0; p < MinisterOnTable[i].MinisterThinking[0].AStarGreedy.Count; p++)
                                    MinisterOnTable[i].MinisterThinking[0].AStarGreedy[p].HuristicAStarGreedySearch(AStarGreedyi, A, a, ref Less, Order, false);

                              */
                    Order = DummyOrder;
                    ChessRules.CurrentOrder = DummyCurrentOrder;
                }
                catch (Exception t)
                {

                }

                Order = DummyOrder;
                ChessRules.CurrentOrder = DummyCurrentOrder;
            }

            for (i = 0; i < KingMidle; i++)
            {
                for (int k = 0; k < AllDraw.KingMovments; k++)
                    try
                    {
                        for (j = 0; KingOnTable[i] != null && KingOnTable[i] != null && KingOnTable[i].KingThinking[k] != null && KingOnTable[i].KingThinking[k] != null && j < KingOnTable[i].KingThinking[k].TableListKing.Count; j++)
                        {
                            {
                                try
                                {
                                    //For Penalty Reagrad Mechanisam of Current Check CheckMate Current Movments.
                                    if (FormRefrigtz.OrderPlate == Order && AStarGreedyi == 1 && UsePenaltyRegardMechnisamT)
                                        if (KingOnTable[i].KingThinking[k].PenaltyRegardListKing[j].IsPenaltyAction() == 0)
                                            continue;
                                    int CDummy = ChessRules.CurrentOrder;
                                    int COrder = Order;
                                    try
                                    {
                                        ChessRules.CurrentOrder *= -1;
                                        Order *= -1;
                                        Do = 0;
                                        if (UsePenaltyRegardMechnisamT)
                                        {
                                            for (int ij = 0; ij < KingOnTable[i].KingThinking[k].AStarGreedy.Count - 1; ij++)
                                                KingOnTable[i].KingThinking[k].AStarGreedy[ij].IsPenaltyRegardCheckMateAtBranch(Order, ref Do, KingOnTable[i].KingThinking[k].AStarGreedy[ij]);
                                            Order = COrder;
                                            ChessRules.CurrentOrder = CDummy;
                                            ToCheckMate = -1; ForCheckMate = -1; AA = IsToCheckMateHasLessDeeperThanForCheckMate(this, Order, ref ToCheckMate, ref ForCheckMate, 0); if (Do == -1)
                                                continue;
                                        }

                                    }
                                    catch (Exception tt) { }
                                    Order = COrder;
                                    ChessRules.CurrentOrder = CDummy;
                                    if (FormRefrigtz.OrderPlate == Order && AStarGreedyi == 1 && UsePenaltyRegardMechnisamT)
                                        if ((KingOnTable[i].KingThinking[k].PenaltyRegardListKing[j].IsPenaltyAction() != 0 && KingOnTable[i].KingThinking[k].PenaltyRegardListKing[j].IsRewardAction() == 1 && AStarGreedyi == 1) || Do == 1 || AA)
                                        {    //Set Table and Huristic Value and Syntax.
                                            bool Hit = false;
                                            if (KingOnTable[i].KingThinking[k].HitNumberKing[j] > 0)
                                                Hit = true;
                                            //if (Order == 1)
                                            //SyntaxToWrite = (new ChessRules(ChessRules( ArrangmentsChanged)).CreateStatistic(ArrangmentsChanged,TableHuristic, FormRefrigtz.MovmentsNumber, 6, KingOnTable[i].KingThinking[k].RowColumnKing[j][1], KingOnTable[i].KingThinking[k].RowColumnKing[j][0], Hit, KingOnTable[i].KingThinking[k].HitNumberKing[j], ChessRules.BridgeActBrown, false);
                                            //  else
                                            //SyntaxToWrite = (new ChessRules(ChessRules( ArrangmentsChanged)).CreateStatistic(ArrangmentsChanged,TableHuristic, FormRefrigtz.MovmentsNumber, -6, KingOnTable[i].KingThinking[k].RowColumnKing[j][1], KingOnTable[i].KingThinking[k].RowColumnKing[j][0], Hit, KingOnTable[i].KingThinking[k].HitNumberKing[j], ChessRules.BridgeActBrown, false);

                                            FormRefrigtz.LastRow = KingOnTable[i].KingThinking[k].Row;
                                            FormRefrigtz.LastColumn = KingOnTable[i].KingThinking[k].Column;

                                            Act = true;
                                            Less = KingOnTable[i].KingThinking[k].ReturnHuristic(i, j, Order * -1);
                                            TableHuristic = KingOnTable[i].KingThinking[k].TableListKing[j];
                                            if (Do == 1 || AA)
                                                //return TableHuristic;
                                                continue;
                                        }
                                    //When There is No Movments in Such Order Enemy continue.
                                    if (Order != FormRefrigtz.OrderPlate)
                                        if (KingOnTable[i].KingThinking[0].ReturnHuristic(i, j, Order * -1) > Less)
                                            continue;
                                    //When There is greater Huristic Movments.
                                    if (KingOnTable[i].KingThinking[0].ReturnHuristic(i, j, Order * -1) > Less)
                                    {
                                        if (AStarGreedyi == 1) ToFindMovments = true;
                                        //retrive table of current huristic.

                                        //retrive table of current huristic.
                                        int[,] TableS = KingOnTable[i].KingThinking[k].TableListKing[j];
                                        int[,] TableSS = KingOnTable[i].KingThinking[k].TableListKing[j];
                                        //checked for Legal Movments ArgumentOutOfRangeException curnt game.
                                        if (DynamicAStarGreedytPrograming && !CurrentTableHuristic && AStarGreedyi == 1)
                                        {
                                            try
                                            {
                                                if (!isEnemyThingsinStable(TableS, AllDraw.TableListAction[AllDraw.TableListAction.Count - 1], FormRefrigtz.OrderPlate))
                                                    continue;
                                            }
                                            catch (Exception t)
                                            {

                                                if (!isEnemyThingsinStable(TableS, AllDraw.TableListAction[AllDraw.TableListAction.Count - 1], FormRefrigtz.OrderPlate))
                                                    continue;

                                            }
                                        }
                                        //When there is not Penalty regard mechanism.
                                        //if (!UsePenaltyRegardMechnisamT)
                                        {
                                            AB = new ChessRules(MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, 6, TableS, Order, KingOnTable[i].KingThinking[k].Row, KingOnTable[i].KingThinking[k].Column);
                                            //If there is kish or kshachamaz Order.
                                            if (AB.Check(TableS, Order))
                                            {
                                                //When Order is Gray.
                                                if (Order == 1)
                                                {
                                                    //Continue When is kish CheckObjectDangour and AStarGreadyFirstSearch .
                                                    if (AB.CheckGray)
                                                        continue;
                                                }
                                                else
                                                {
                                                    //Continue when CheckBrown and AStarGreadyFirstSearch. 
                                                    if (AB.CheckBrown)
                                                        continue;
                                                }
                                            }
                                            else
                                            {

                                            }

                                            //When Order is gray.
                                            /*                if (Order == 1)
                                                            {
                                                                //When CheckGrayObjectDangour and There is not AStarGreedyt search.
                                                                if (AB.CheckGray)
                                                                {
                                                                    //predict Search.
                                                                    Color B;
                                                                    if (a == Color.Gray)
                                                                        B = Color.Brown;
                                                                    else
                                                                        B = Color.Gray;
                                                                    APredict.TableList.Clear();
                                                                    APredict.TableList.Add(TableS);
                                                                    APredict.SetRowColumn(0);
                                                                    TableHuristic = APredict.InitiatePerdictCheck((int)APredict.KingOnTable[i].Row, (int)APredict.KingOnTable[i].Column, B, TableS, Order, false);
                                                                    if (TableHuristic == null)
                                                                        continue;

                                                                }
                                                            }
                                                            else
                                                            {
                                                                if (AB.CheckBrown)
                                                                {
                                                                    //predict Search.
                                                                    Color B;
                                                                    if (a == Color.Gray)
                                                                        B = Color.Brown;
                                                                    else
                                                                        B = Color.Gray;
                                                                    APredict.TableList.Clear();
                                                                    APredict.TableList.Add(TableS);
                                                                    APredict.SetRowColumn(0);
                                                                    TableHuristic = APredict.InitiatePerdictCheck((int)APredict.KingOnTable[i].Row, (int)APredict.KingOnTable[i].Column, B, TableS, Order, false);
                                                                    if (TableHuristic == null)
                                                                        continue;
                                                                    else
                                                                    {
                                                                        Act = true;
                                                                        Less = KingOnTable[i].KingThinking[k].ReturnHuristic(i, j, Order * -1);
                                                                        continue;
                                                                    }

                                                                }
                                                            }

                                             */
                                        }


                                        RW6 = i;
                                        CL6 = k;
                                        Ki6 = j;
                                        RW1 = -1;
                                        CL1 = -1;
                                        Ki1 = -1;
                                        RW2 = -1;
                                        CL2 = -1;
                                        Ki2 = -1;
                                        RW3 = -1;
                                        CL3 = -1;
                                        Ki3 = -1;
                                        RW4 = -1;
                                        CL4 = -1;
                                        Ki4 = -1;
                                        RW5 = -1;
                                        CL5 = -1;
                                        Ki5 = -1;
                                        MaxLess6 = (KingOnTable[RW6].KingThinking[CL6].ReturnHuristic(RW6, Ki6, Order * -1));
                                        if (MaxLess6 > MaxLess1)
                                            MaxLess1 = -1;
                                        if (MaxLess6 > MaxLess2)
                                            MaxLess2 = -1;
                                        if (MaxLess6 > MaxLess3)
                                            MaxLess3 = -1;
                                        if (MaxLess6 > MaxLess4)
                                            MaxLess4 = -1;
                                        if (MaxLess6 > MaxLess5)
                                            MaxLess5 = -1;


                                        if (AStarGreedyi == 1)
                                        {
                                            if (Order == 1)
                                            {
                                                //THIS.SetBoxText("\r\nChess Huristic King By Bob!");
                                                //THIS.RefreshBoxText();
                                            }
                                            else//If Order is Brown.
                                            {
                                                //THIS.SetBoxText("\r\nChess Huristic King By Alice!");
                                                //THIS.RefreshBoxText();
                                            } //Set Table and Huristic Value and Syntax.
                                            bool Hit = false;
                                            if (KingOnTable[i].KingThinking[k].HitNumberKing[j] > 0)
                                                Hit = true;
                                            // if (Order == 1)
                                            //SyntaxToWrite = (new ChessRules(ChessRules( ArrangmentsChanged)).CreateStatistic(ArrangmentsChanged,TableHuristic, FormRefrigtz.MovmentsNumber, 6, KingOnTable[i].KingThinking[k].RowColumnKing[j][1], KingOnTable[i].KingThinking[k].RowColumnKing[j][0], Hit, KingOnTable[i].KingThinking[k].HitNumberKing[j], ChessRules.BridgeActBrown, false);
                                            // else
                                            //SyntaxToWrite = (new ChessRules(ChessRules( ArrangmentsChanged)).CreateStatistic(ArrangmentsChanged,TableHuristic, FormRefrigtz.MovmentsNumber, -6, KingOnTable[i].KingThinking[k].RowColumnKing[j][1], KingOnTable[i].KingThinking[k].RowColumnKing[j][0], Hit, KingOnTable[i].KingThinking[k].HitNumberKing[j], ChessRules.BridgeActBrown, false);

                                            FormRefrigtz.LastRow = KingOnTable[i].KingThinking[k].Row;
                                            FormRefrigtz.LastColumn = KingOnTable[i].KingThinking[k].Column;

                                            Act = true;
                                            Less = KingOnTable[i].KingThinking[k].ReturnHuristic(i, j, Order * -1);
                                            TableHuristic = KingOnTable[i].KingThinking[k].TableListKing[j];
                                        }


                                    }
                                    else//Set Table and Huristic Value and Syntax.
                                    {
                                        try
                                        {
                                            if (AStarGreedyi == 1)
                                            {
                                                if (Order == 1)
                                                {
                                                    //THIS.SetBoxText("\r\nChess Huristic King By Bob!");
                                                    //THIS.RefreshBoxText();
                                                }
                                                else//If Order is Brown.
                                                {
                                                    //THIS.SetBoxText("\r\nChess Huristic King By Alice!");
                                                    //THIS.RefreshBoxText();
                                                }   //TakeRoot.Pointer = this;
                                                //Found of Max Non Probable Movments.
                                                Founded.Clear();
                                                double LessB = Double.MinValue; ;
                                                BeginIndexFoundingMaxLessofMaxList(0, Founded, ref LessB);
                                                RW6 = (int)MaxHuristicAStarGreedytBackWard[0][(int)Founded[0]];
                                                CL6 = (int)MaxHuristicAStarGreedytBackWard[0][(int)Founded[0] + 1];
                                                Ki6 = (int)MaxHuristicAStarGreedytBackWard[0][(int)Founded[0] + 2];
                                                if (Founded[0] != MaxKingFounded)
                                                    continue;
                                                bool Hit = false;
                                                if (KingOnTable[RW6].KingThinking[CL6].HitNumberKing[Ki6] > 0)
                                                    Hit = true;
                                                //  if (Order == 1)
                                                //SyntaxToWrite = (new ChessRules(ChessRules( ArrangmentsChanged)).CreateStatistic(ArrangmentsChanged,TableHuristic, FormRefrigtz.MovmentsNumber, 6, KingOnTable[RW6].KingThinking[CL6].RowColumnKing[Ki6][1], KingOnTable[RW6].KingThinking[CL6].RowColumnKing[Ki6][0], Hit, KingOnTable[RW6].KingThinking[CL6].HitNumberKing[Ki6], ChessRules.BridgeActBrown, false);
                                                //   else
                                                //SyntaxToWrite = (new ChessRules(ChessRules( ArrangmentsChanged)).CreateStatistic(ArrangmentsChanged,TableHuristic, FormRefrigtz.MovmentsNumber, -6, KingOnTable[RW6].KingThinking[CL6].RowColumnKing[Ki6][1], KingOnTable[RW6].KingThinking[CL6].RowColumnKing[Ki6][0], Hit, KingOnTable[RW6].KingThinking[CL6].HitNumberKing[Ki6], ChessRules.BridgeActBrown, false);

                                                FormRefrigtz.LastRow = KingOnTable[RW6].KingThinking[CL6].Row;
                                                FormRefrigtz.LastColumn = KingOnTable[RW6].KingThinking[CL6].Column;

                                                Act = true;
                                                Less = KingOnTable[RW6].KingThinking[CL6].ReturnHuristic(RW6, Ki6, Order * -1);
                                                TableHuristic = KingOnTable[RW6].KingThinking[CL6].TableListKing[Ki6];
                                            }
                                        }
                                        catch (Exception t)
                                        { }
                                    }
                                }
                                catch (Exception t)
                                {

                                }
                            }
                            // else
                            {
                            }

                        }
                    }
                    catch (Exception t)
                    {

                    } try
                {
                    /* Order *= -1;
                     ChessRules.CurrentOrder *= -1;
                     for (int p = 0; p < KingOnTable[i].KingThinking[0].AStarGreedy.Count; p++)
                         KingOnTable[i].KingThinking[0].AStarGreedy[KingOnTable[i].KingThinking[0].AStarGreedy.Count - 1].HuristicAStarGreedySearch(AStarGreedyi, A, a, ref Less, Order, false);

                     */
                    Order = DummyOrder;
                    ChessRules.CurrentOrder = DummyCurrentOrder;
                }
                catch (Exception t)
                {

                }

                Order = DummyOrder;
                ChessRules.CurrentOrder = DummyCurrentOrder;
            }
            return TableHuristic;
        }
        int[,] BrownHuristicAStarGreaedySearch(int AStarGreedyi, List<AllDraw> A, Color a, int Order, bool CurrentTableHuristic, ref bool Act)
        {
            ChessRules AB = null;

            int ToCheckMate = -1, ForCheckMate = -1, j, i;
            List<double> Founded = new List<double>();
            int DummyOrder = Order;
            int DummyCurrentOrder = ChessRules.CurrentOrder;
            bool AA = false;
            int Do = 0;
            int[,] TableHuristic = new int[8, 8];
            //For Every Soldeir
            for (i = SodierMidle; i < SodierHigh; i++)
            {

                //For Every Soldier Movments AStarGreedy.
                for (int k = 0; k < AllDraw.SodierMovments; k++)
                    //When There is an Movment in such situation.
                    try
                    {
                        for (j = 0; SolderesOnTable[i] != null && SolderesOnTable[i] != null && SolderesOnTable[i].SoldierThinking[k] != null && SolderesOnTable[i].SoldierThinking[k] != null && j < SolderesOnTable[i].SoldierThinking[k].TableListSolder.Count; j++)
                        {
                            try
                            {
                                //For Penalty Reagrad Mechanisam of Current Check CheckMate Current Movments.
                                if (FormRefrigtz.OrderPlate == Order && AStarGreedyi == 1 && UsePenaltyRegardMechnisamT)
                                    if (SolderesOnTable[i].SoldierThinking[k].PenaltyRegardListSolder[j].IsPenaltyAction() == 0)
                                        continue;
                                int CDummy = ChessRules.CurrentOrder;
                                int COrder = Order;
                                try
                                {
                                    ChessRules.CurrentOrder *= -1;
                                    Order *= -1;
                                    Do = 0;
                                    if (UsePenaltyRegardMechnisamT)
                                    {
                                        for (int ij = 0; ij < SolderesOnTable[i].SoldierThinking[k].AStarGreedy.Count - 1; ij++)
                                            SolderesOnTable[i].SoldierThinking[k].AStarGreedy[ij].IsPenaltyRegardCheckMateAtBranch(Order, ref Do, SolderesOnTable[i].SoldierThinking[k].AStarGreedy[ij]);
                                        Order = COrder;
                                        ChessRules.CurrentOrder = CDummy;
                                        ToCheckMate = -1; ForCheckMate = -1; AA = IsToCheckMateHasLessDeeperThanForCheckMate(this, Order, ref ToCheckMate, ref ForCheckMate, 0); if (Do == -1)
                                            continue;
                                    }

                                }
                                catch (Exception tt) { }
                                Order = COrder;
                                ChessRules.CurrentOrder = CDummy;

                                if (FormRefrigtz.OrderPlate == Order && AStarGreedyi == 1 && UsePenaltyRegardMechnisamT)
                                    if ((SolderesOnTable[i].SoldierThinking[k].PenaltyRegardListSolder[j].IsPenaltyAction() != 0 && SolderesOnTable[i].SoldierThinking[k].PenaltyRegardListSolder[j].IsRewardAction() == 1 && AStarGreedyi == 1) || Do == 1 || AA)
                                    {
                                        //Set Table and Huristic Value and Syntax.
                                        Act = true;
                                        FormRefrigtz.LastRow = SolderesOnTable[i].SoldierThinking[k].Row;
                                        FormRefrigtz.LastColumn = SolderesOnTable[i].SoldierThinking[k].Column;

                                        Less = SolderesOnTable[i].SoldierThinking[k].ReturnHuristic(i, j, Order * -1);


                                        TableHuristic = SolderesOnTable[i].SoldierThinking[k].TableListSolder[j];
                                        bool Hit = false;
                                        if (SolderesOnTable[i].SoldierThinking[k].HitNumberSoldier[j] > 0)
                                            Hit = true;
                                        // if (Order == 1)
                                        //SyntaxToWrite = (new ChessRules(ChessRules( ArrangmentsChanged)).CreateStatistic(ArrangmentsChanged,TableHuristic, FormRefrigtz.MovmentsNumber, 1, SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][1], SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][0], Hit, SolderesOnTable[i].SoldierThinking[k].HitNumberSoldier[j], ChessRules.BridgeActBrown, false);
                                        //else
                                        //SyntaxToWrite = (new ChessRules(ChessRules( ArrangmentsChanged)).CreateStatistic(ArrangmentsChanged,TableHuristic, FormRefrigtz.MovmentsNumber, -1, SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][1], SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][0], Hit, SolderesOnTable[i].SoldierThinking[k].HitNumberSoldier[j], ChessRules.BridgeActBrown, false);


                                        ThingsConverter.ActOfClickEqualTow = true;
                                        SolderesOnTable[i].ConvertOperation(SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][0], SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][1], a, SolderesOnTable[i].SoldierThinking[k].TableListSolder[j], Order, false, i);
                                        int Sign = 1;
                                        if (a == Color.Brown)
                                            Sign = -1;
                                        //If there is Soldier Convert.
                                        if (SolderesOnTable[i].Convert)
                                        {
                                            Hit = false;
                                            if (SolderesOnTable[i].SoldierThinking[k].HitNumberSoldier[j] > 0)
                                                Hit = true;
                                            // if (Order == 1)
                                            //SyntaxToWrite = (new ChessRules(ChessRules( ArrangmentsChanged)).CreateStatistic(ArrangmentsChanged,TableHuristic, FormRefrigtz.MovmentsNumber, 1, SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][1], SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][0], Hit, SolderesOnTable[i].SoldierThinking[k].HitNumberSoldier[j], ChessRules.BridgeActBrown, true);
                                            //  else
                                            //SyntaxToWrite = (new ChessRules(ChessRules( ArrangmentsChanged)).CreateStatistic(ArrangmentsChanged,TableHuristic, FormRefrigtz.MovmentsNumber, -1, SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][1], SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][0], Hit, SolderesOnTable[i].SoldierThinking[k].HitNumberSoldier[j], ChessRules.BridgeActBrown, true);

                                            if (SolderesOnTable[i].ConvertedToMinister)
                                                TableHuristic[SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][0], SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][1]] = 5 * Sign;
                                            else if (SolderesOnTable[i].ConvertedToBridge)
                                                TableHuristic[SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][0], SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][1]] = 4 * Sign;
                                            else if (SolderesOnTable[i].ConvertedToHourse)
                                                TableHuristic[SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][0], SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][1]] = 3 * Sign;
                                            else if (SolderesOnTable[i].ConvertedToElefant)
                                                TableHuristic[SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][0], SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][1]] = 2 * Sign;
                                            TableList.Clear();
                                            TableList.Add(TableHuristic);
                                            if (A.Count > 1)
                                                SetRowColumn(0);
                                            TableList.Clear();
                                            if (Do == 1 || AA)
                                                //return TableHuristic;
                                                continue;
                                        }

                                    }
                                //When There is No Movments in Such Order Enemy continue.
                                if (Order != FormRefrigtz.OrderPlate)
                                    if (SolderesOnTable[i].SoldierThinking[0].ReturnHuristic(i, j, Order * -1) > Less)
                                        continue;
                                //When There is greater Huristic Movments.
                                if (SolderesOnTable[i].SoldierThinking[0].ReturnHuristic(i, j, Order * -1) > Less)
                                {
                                    if (AStarGreedyi == 1) ToFindMovments = true;
                                    //retrive table of current huristic.

                                    //if (CheckG || CheckB)
                                    //{
                                    //retrive table of current huristic.
                                    int[,] TableS = SolderesOnTable[i].SoldierThinking[k].TableListSolder[j];

                                    //checked for Legal Movments ArgumentOutOfRangeException curnt game.
                                    if (DynamicAStarGreedytPrograming && !CurrentTableHuristic && AStarGreedyi == 1)
                                    {
                                        try
                                        {
                                            if (!isEnemyThingsinStable(TableS, AllDraw.TableListAction[AllDraw.TableListAction.Count - 1], FormRefrigtz.OrderPlate))
                                                continue;
                                        }
                                        catch (Exception t)
                                        {

                                            if (!isEnemyThingsinStable(TableS, AllDraw.TableListAction[AllDraw.TableListAction.Count - 1], FormRefrigtz.OrderPlate))
                                                continue;

                                        }
                                    }
                                    //When there is not Penalty regard mechanism.
                                    //if (!UsePenaltyRegardMechnisamT)
                                    {
                                        AB = new ChessRules(MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, 1, TableS, Order, SolderesOnTable[i].SoldierThinking[k].Row, SolderesOnTable[i].SoldierThinking[k].Column);
                                        //If there is kish or kshachamaz Order.
                                        if (AB.Check(TableS, Order))
                                        {
                                            //When Order is Gray.
                                            if (Order == 1)
                                            {
                                                //Continue When is kish CheckObjectDangour and AStarGreadyFirstSearch .
                                                if (AB.CheckGray)
                                                    continue;
                                            }
                                            else
                                            {
                                                //Continue when CheckBrown and AStarGreadyFirstSearch. 
                                                if (AB.CheckBrown)
                                                    continue;
                                            }
                                        }
                                        // }
                                        else
                                        {

                                        }
                                        //When Order is gray.
                                        /*               if (Order == 1)
                                                       {
                                                           //When CheckGrayObjectDangour and There is not AStarGreedyt search.
                                                           if (AB.CheckGray)
                                                           {
                                                               //predict Search.
                                                               Color B;
                                                               if (a == Color.Gray)
                                                                   B = Color.Brown;
                                                               else
                                                                   B = Color.Gray;
                                                               APredict.TableList.Clear();
                                                               APredict.TableList.Add(TableS);
                                                               APredict.SetRowColumn(0);
                                                               TableHuristic = APredict.InitiatePerdictCheck((int)APredict.SolderesOnTable[i].Row, (int)APredict.SolderesOnTable[i].Column, B, TableS, Order, false);
                                                               if (TableHuristic == null)
                                                                   continue;
                                                               else
                                                               {
                                                                   Act = true;
                                                                   Less = SolderesOnTable[i].SoldierThinking[k].ReturnHuristic(i, j, Order*-1);

                                                                   continue;


                                                               }

                                                           }
                                                       }
                                                       else
                                                       {
                                                           //When Order is Bromn and there is not AStarGreadyFirstSearch.
                                                           if (AB.CheckBrown)
                                                           {
                                                               //Prdedict Check.
                                                               Color B;
                                                               if (a == Color.Gray)
                                                                   B = Color.Brown;
                                                               else
                                                                   B = Color.Gray;
                                                               APredict.TableList.Clear();
                                                               APredict.TableList.Add(TableS);
                                                               APredict.SetRowColumn(0);
                                                               TableHuristic = APredict.InitiatePerdictCheck((int)APredict.SolderesOnTable[i].Row, (int)APredict.SolderesOnTable[i].Column, B, TableS, Order, false);
                                                               if (TableHuristic == null)
                                                                   continue;

                                                           }
                                                       }
                                         */
                                    }
                                    RW1 = i;
                                    CL1 = k;
                                    Ki1 = j;
                                    RW2 = -1;
                                    CL2 = -1;
                                    Ki2 = -1;
                                    RW3 = -1;
                                    CL3 = -1;
                                    Ki3 = -1;
                                    RW4 = -1;
                                    CL4 = -1;
                                    Ki4 = -1;
                                    RW5 = -1;
                                    CL5 = -1;
                                    Ki5 = -1;
                                    RW6 = -1;
                                    CL6 = -1;
                                    Ki6 = -1;
                                    MaxLess1 = SolderesOnTable[RW1].SoldierThinking[CL1].ReturnHuristic(RW1, Ki1, Order * -1);
                                    if (MaxLess1 > MaxLess2)
                                        MaxLess2 = -1;
                                    if (MaxLess1 > MaxLess3)
                                        MaxLess3 = -1;
                                    if (MaxLess1 > MaxLess4)
                                        MaxLess4 = -1;
                                    if (MaxLess1 > MaxLess5)
                                        MaxLess5 = -1;
                                    if (MaxLess1 > MaxLess6)
                                        MaxLess6 = -1;

                                    //Set Table and Huristic Value and Syntax.
                                    if (AStarGreedyi == 1)
                                    {
                                        if (Order == 1)
                                        {
                                            //THIS.SetBoxText("\r\nChess Huristic Sodier By Bob!");
                                            //THIS.RefreshBoxText();
                                        }
                                        else//If Order is Brown.
                                        {
                                            //THIS.SetBoxText("\r\nChess Huristic Sodier By Alice!");
                                            //THIS.RefreshBoxText();
                                        }//Set Table and Huristic Value and Syntax.
                                        Act = true;
                                        FormRefrigtz.LastRow = SolderesOnTable[i].SoldierThinking[k].Row;
                                        FormRefrigtz.LastColumn = SolderesOnTable[i].SoldierThinking[k].Column;

                                        Less = SolderesOnTable[i].SoldierThinking[k].ReturnHuristic(i, j, Order * -1);


                                        TableHuristic = SolderesOnTable[i].SoldierThinking[k].TableListSolder[j];
                                        bool Hit = false;
                                        if (SolderesOnTable[i].SoldierThinking[k].HitNumberSoldier[j] > 0)
                                            Hit = true;
                                        // if (Order == 1)
                                        //SyntaxToWrite = (new ChessRules(ChessRules( ArrangmentsChanged)).CreateStatistic(ArrangmentsChanged,TableHuristic, FormRefrigtz.MovmentsNumber, 1, SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][1], SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][0], Hit, SolderesOnTable[i].SoldierThinking[k].HitNumberSoldier[j], ChessRules.BridgeActBrown, false);
                                        // else
                                        //SyntaxToWrite = (new ChessRules(ChessRules( ArrangmentsChanged)).CreateStatistic(ArrangmentsChanged,TableHuristic, FormRefrigtz.MovmentsNumber, -1, SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][1], SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][0], Hit, SolderesOnTable[i].SoldierThinking[k].HitNumberSoldier[j], ChessRules.BridgeActBrown, false);


                                        ThingsConverter.ActOfClickEqualTow = true;
                                        SolderesOnTable[i].ConvertOperation(SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][0], SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][1], a, SolderesOnTable[i].SoldierThinking[k].TableListSolder[j], Order, false, i);
                                        int Sign = 1;
                                        if (a == Color.Brown)
                                            Sign = -1;
                                        //If there is Soldier Convert.
                                        if (SolderesOnTable[i].Convert)
                                        {
                                            Hit = false;
                                            if (SolderesOnTable[i].SoldierThinking[k].HitNumberSoldier[j] > 0)
                                                Hit = true;
                                            // if (Order == 1)
                                            //SyntaxToWrite = (new ChessRules(ChessRules( ArrangmentsChanged)).CreateStatistic(ArrangmentsChanged,TableHuristic, FormRefrigtz.MovmentsNumber, 1, SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][1], SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][0], Hit, SolderesOnTable[i].SoldierThinking[k].HitNumberSoldier[j], ChessRules.BridgeActBrown, true);
                                            // else
                                            //SyntaxToWrite = (new ChessRules(ChessRules( ArrangmentsChanged)).CreateStatistic(ArrangmentsChanged,TableHuristic, FormRefrigtz.MovmentsNumber, -1, SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][1], SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][0], Hit, SolderesOnTable[i].SoldierThinking[k].HitNumberSoldier[j], ChessRules.BridgeActBrown, true);

                                            if (SolderesOnTable[i].ConvertedToMinister)
                                                TableHuristic[SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][0], SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][1]] = 5 * Sign;
                                            else if (SolderesOnTable[i].ConvertedToBridge)
                                                TableHuristic[SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][0], SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][1]] = 4 * Sign;
                                            else if (SolderesOnTable[i].ConvertedToHourse)
                                                TableHuristic[SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][0], SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][1]] = 3 * Sign;
                                            else if (SolderesOnTable[i].ConvertedToElefant)
                                                TableHuristic[SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][0], SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][1]] = 2 * Sign;
                                            TableList.Clear();
                                            TableList.Add(TableHuristic);
                                            if (A.Count > 1)
                                                SetRowColumn(0);
                                            TableList.Clear();

                                        }

                                    }
                                    else
                                    {  //Set Table and Huristic Value and Syntax.
                                        try
                                        {
                                            if (AStarGreedyi == 1)
                                            {
                                                if (Order == 1)
                                                {
                                                    //THIS.SetBoxText("\r\nChess Huristic Sodier By Bob!");
                                                    //THIS.RefreshBoxText();
                                                }
                                                else//If Order is Brown.
                                                {
                                                    //THIS.SetBoxText("\r\nChess Huristic Sodier By Alice!");
                                                    //THIS.RefreshBoxText();
                                                }//TakeRoot.Pointer = this;
                                                //Found of Max Non Probable Movments.
                                                Founded.Clear();
                                                double LessB = Double.MinValue; ;
                                                BeginIndexFoundingMaxLessofMaxList(0, Founded, ref LessB);
                                                RW1 = (int)MaxHuristicAStarGreedytBackWard[0][(int)Founded[0]];
                                                CL1 = (int)MaxHuristicAStarGreedytBackWard[0][(int)Founded[0] + 1];
                                                Ki1 = (int)MaxHuristicAStarGreedytBackWard[0][(int)Founded[0] + 2];
                                                if (Founded[0] != MaxSoldeirFounded)
                                                    continue;
                                                Act = true;
                                                FormRefrigtz.LastRow = SolderesOnTable[RW1].SoldierThinking[CL1].Row;
                                                FormRefrigtz.LastColumn = SolderesOnTable[RW1].SoldierThinking[CL1].Column;

                                                Less = SolderesOnTable[RW1].SoldierThinking[CL1].ReturnHuristic(RW1, Ki1, Order * -1);


                                                TableHuristic = SolderesOnTable[RW1].SoldierThinking[CL1].TableListSolder[Ki1];
                                                bool Hit = false;
                                                if (SolderesOnTable[RW1].SoldierThinking[CL1].HitNumberSoldier[Ki1] > 0)
                                                    Hit = true;
                                                // if (Order == 1)
                                                //SyntaxToWrite = (new ChessRules(ChessRules( ArrangmentsChanged)).CreateStatistic(ArrangmentsChanged,TableHuristic, FormRefrigtz.MovmentsNumber, 1, SolderesOnTable[RW1].SoldierThinking[CL1].RowColumnSoldier[Ki1][1], SolderesOnTable[RW1].SoldierThinking[CL1].RowColumnSoldier[Ki1][0], Hit, SolderesOnTable[RW1].SoldierThinking[CL1].HitNumberSoldier[Ki1], ChessRules.BridgeActBrown, false);
                                                // else
                                                //SyntaxToWrite = (new ChessRules(ChessRules( ArrangmentsChanged)).CreateStatistic(ArrangmentsChanged,TableHuristic, FormRefrigtz.MovmentsNumber, -1, SolderesOnTable[RW1].SoldierThinking[CL1].RowColumnSoldier[Ki1][1], SolderesOnTable[RW1].SoldierThinking[CL1].RowColumnSoldier[Ki1][0], Hit, SolderesOnTable[RW1].SoldierThinking[CL1].HitNumberSoldier[Ki1], ChessRules.BridgeActBrown, false);


                                                ThingsConverter.ActOfClickEqualTow = true;
                                                SolderesOnTable[RW1].ConvertOperation(SolderesOnTable[RW1].SoldierThinking[CL1].RowColumnSoldier[Ki1][0], SolderesOnTable[RW1].SoldierThinking[CL1].RowColumnSoldier[Ki1][1], a, SolderesOnTable[RW1].SoldierThinking[CL1].TableListSolder[Ki1], Order, false, i);
                                                int Sign = 1;
                                                if (a == Color.Brown)
                                                    Sign = -1;
                                                //If there is Soldier Convert.
                                                if (SolderesOnTable[RW1].Convert)
                                                {
                                                    Hit = false;
                                                    if (SolderesOnTable[RW1].SoldierThinking[CL1].HitNumberSoldier[Ki1] > 0)
                                                        Hit = true;
                                                    //      if (Order == 1)
                                                    //SyntaxToWrite = (new ChessRules(ChessRules( ArrangmentsChanged)).CreateStatistic(ArrangmentsChanged,TableHuristic, FormRefrigtz.MovmentsNumber, 1, SolderesOnTable[RW1].SoldierThinking[CL1].RowColumnSoldier[Ki1][1], SolderesOnTable[RW1].SoldierThinking[CL1].RowColumnSoldier[Ki1][0], Hit, SolderesOnTable[RW1].SoldierThinking[CL1].HitNumberSoldier[Ki1], ChessRules.BridgeActBrown, true);
                                                    //      else
                                                    //SyntaxToWrite = (new ChessRules(ChessRules( ArrangmentsChanged)).CreateStatistic(ArrangmentsChanged,TableHuristic, FormRefrigtz.MovmentsNumber, -1, SolderesOnTable[RW1].SoldierThinking[CL1].RowColumnSoldier[Ki1][1], SolderesOnTable[RW1].SoldierThinking[CL1].RowColumnSoldier[Ki1][0], Hit, SolderesOnTable[RW1].SoldierThinking[CL1].HitNumberSoldier[Ki1], ChessRules.BridgeActBrown, true);

                                                    if (SolderesOnTable[RW1].ConvertedToMinister)
                                                        TableHuristic[SolderesOnTable[RW1].SoldierThinking[CL1].RowColumnSoldier[Ki1][0], SolderesOnTable[RW1].SoldierThinking[CL1].RowColumnSoldier[Ki1][1]] = 5 * Sign;
                                                    else if (SolderesOnTable[RW1].ConvertedToBridge)
                                                        TableHuristic[SolderesOnTable[RW1].SoldierThinking[CL1].RowColumnSoldier[Ki1][0], SolderesOnTable[RW1].SoldierThinking[CL1].RowColumnSoldier[Ki1][1]] = 4 * Sign;
                                                    else if (SolderesOnTable[RW1].ConvertedToHourse)
                                                        TableHuristic[SolderesOnTable[RW1].SoldierThinking[CL1].RowColumnSoldier[Ki1][0], SolderesOnTable[RW1].SoldierThinking[CL1].RowColumnSoldier[Ki1][1]] = 3 * Sign;
                                                    else if (SolderesOnTable[RW1].ConvertedToElefant)
                                                        TableHuristic[SolderesOnTable[RW1].SoldierThinking[CL1].RowColumnSoldier[Ki1][0], SolderesOnTable[RW1].SoldierThinking[CL1].RowColumnSoldier[Ki1][1]] = 2 * Sign;
                                                    TableList.Clear();
                                                    TableList.Add(TableHuristic);
                                                    if (A.Count > 1)
                                                        SetRowColumn(0);
                                                    TableList.Clear();
                                                }
                                            }
                                        }
                                        catch (Exception t)
                                        {

                                        }

                                    }
                                }
                            }
                            catch (Exception t)
                            {

                            }
                        }
                    }
                    catch (Exception t)
                    {

                    }
                try
                {/*
                                Order *= -1;
                                ChessRules.CurrentOrder *= -1;
                                for (int p = 0; p < SolderesOnTable[i].SoldierThinking[0].AStarGreedy.Count; p++)
                                    SolderesOnTable[i].SoldierThinking[0].AStarGreedy[p].HuristicAStarGreedySearch(AStarGreedyi, A, a, ref Less, Order, false);
                              */
                    Order = DummyOrder;
                    ChessRules.CurrentOrder = DummyCurrentOrder;
                }
                catch (Exception t)
                {

                }

                Order = DummyOrder;
                ChessRules.CurrentOrder = DummyCurrentOrder;
            }
            //Do For Remaining Objects same as Soldeir Documentation.
            for (i = ElefantMidle; i < ElefantHigh; i++)
            {
                for (int k = 0; k < AllDraw.ElefantMovments; k++)
                    try
                    {
                        for (j = 0; ElephantOnTable[i] != null && ElephantOnTable[i] != null && ElephantOnTable[i].ElefantThinking[k] != null && ElephantOnTable[i].ElefantThinking[k] != null && j < ElephantOnTable[i].ElefantThinking[k].TableListElefant.Count; j++)
                        {
                            try
                            {
                                //For Penalty Reagrad Mechanisam of Current Check CheckMate Current Movments.
                                if (FormRefrigtz.OrderPlate == Order && AStarGreedyi == 1 && UsePenaltyRegardMechnisamT)
                                    if (ElephantOnTable[i].ElefantThinking[k].PenaltyRegardListElefant[j].IsPenaltyAction() == 0)
                                        continue;
                                int CDummy = ChessRules.CurrentOrder;
                                int COrder = Order;
                                try
                                {
                                    ChessRules.CurrentOrder *= -1;
                                    Order *= -1;
                                    Do = 0;
                                    if (UsePenaltyRegardMechnisamT)
                                    {
                                        for (int ij = 0; ij < ElephantOnTable[i].ElefantThinking[k].AStarGreedy.Count - 1; ij++)
                                            ElephantOnTable[i].ElefantThinking[k].AStarGreedy[ij].IsPenaltyRegardCheckMateAtBranch(Order, ref Do, ElephantOnTable[i].ElefantThinking[k].AStarGreedy[ij]);
                                        Order = COrder;
                                        ChessRules.CurrentOrder = CDummy;
                                        ToCheckMate = -1; ForCheckMate = -1; AA = IsToCheckMateHasLessDeeperThanForCheckMate(this, Order, ref ToCheckMate, ref ForCheckMate, 0); if (Do == -1)
                                            continue;
                                    }

                                }
                                catch (Exception tt) { }
                                Order = COrder;
                                ChessRules.CurrentOrder = CDummy;
                                if (FormRefrigtz.OrderPlate == Order && AStarGreedyi == 1 && UsePenaltyRegardMechnisamT)
                                    if ((ElephantOnTable[i].ElefantThinking[k].PenaltyRegardListElefant[j].IsPenaltyAction() != 0 && ElephantOnTable[i].ElefantThinking[k].PenaltyRegardListElefant[j].IsRewardAction() == 1 && AStarGreedyi == 1) || Do == 1 || AA)
                                    {
                                        //Set Table and Huristic Value and Syntax.
                                        bool Hit = false;
                                        if (ElephantOnTable[i].ElefantThinking[k].HitNumberElefant[j] > 0)
                                            Hit = true;
                                        //if (Order == 1)
                                        //SyntaxToWrite = (new ChessRules(ChessRules( ArrangmentsChanged)).CreateStatistic(ArrangmentsChanged,TableHuristic, FormRefrigtz.MovmentsNumber, 2, ElephantOnTable[i].ElefantThinking[k].RowColumnElefant[j][1], ElephantOnTable[i].ElefantThinking[k].RowColumnElefant[j][0], Hit, ElephantOnTable[i].ElefantThinking[k].HitNumberElefant[j], ChessRules.BridgeActBrown, false);
                                        //else
                                        //SyntaxToWrite = (new ChessRules(ChessRules( ArrangmentsChanged)).CreateStatistic(ArrangmentsChanged,TableHuristic, FormRefrigtz.MovmentsNumber, -2, ElephantOnTable[i].ElefantThinking[k].RowColumnElefant[j][1], ElephantOnTable[i].ElefantThinking[k].RowColumnElefant[j][0], Hit, ElephantOnTable[i].ElefantThinking[k].HitNumberElefant[j], ChessRules.BridgeActBrown, false);

                                        FormRefrigtz.LastRow = ElephantOnTable[i].ElefantThinking[k].Row;
                                        FormRefrigtz.LastColumn = ElephantOnTable[i].ElefantThinking[k].Column;

                                        Act = true;
                                        Less = ElephantOnTable[i].ElefantThinking[k].ReturnHuristic(i, j, Order * -1);
                                        TableHuristic = ElephantOnTable[i].ElefantThinking[k].TableListElefant[j];
                                        if (Do == 1 || AA)
                                            //return TableHuristic;
                                            continue;
                                    }
                                //When There is No Movments in Such Order Enemy continue.
                                if (ElephantOnTable[i].ElefantThinking[k].PenaltyRegardListElefant[j].IsPenaltyAction() == 0)
                                    continue;
                                //When There is No Movments in Such Order Enemy continue.
                                if (Order != FormRefrigtz.OrderPlate)
                                    if (ElephantOnTable[i].ElefantThinking[0].ReturnHuristic(i, j, Order * -1) > Less)
                                        continue;
                                //When There is greater Huristic Movments.
                                if (ElephantOnTable[i].ElefantThinking[0].ReturnHuristic(i, j, Order * -1) > Less)
                                {
                                    if (AStarGreedyi == 1) ToFindMovments = true;
                                    //retrive table of current huristic.

                                    //if (CheckG || CheckB)
                                    //{
                                    //retrive table of current huristic.
                                    int[,] TableS = ElephantOnTable[i].ElefantThinking[k].TableListElefant[j];
                                    //checked for Legal Movments ArgumentOutOfRangeException curnt game.
                                    if (DynamicAStarGreedytPrograming && !CurrentTableHuristic && AStarGreedyi == 1)
                                    {
                                        try
                                        {
                                            if (!isEnemyThingsinStable(TableS, AllDraw.TableListAction[AllDraw.TableListAction.Count - 1], FormRefrigtz.OrderPlate))
                                                continue;
                                        }
                                        catch (Exception t)
                                        {

                                            if (!isEnemyThingsinStable(TableS, AllDraw.TableListAction[AllDraw.TableListAction.Count - 1], FormRefrigtz.OrderPlate))
                                                continue;

                                        }
                                    }
                                    //When there is not Penalty regard mechanism.
                                    //if (!UsePenaltyRegardMechnisamT)
                                    {
                                        AB = new ChessRules(MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, 2, TableS, Order, ElephantOnTable[i].ElefantThinking[k].Row, ElephantOnTable[i].ElefantThinking[k].Column);
                                        //If there is kish or kshachamaz Order.
                                        if (AB.Check(TableS, Order))
                                        {
                                            //When Order is Gray.
                                            if (Order == 1)
                                            {
                                                //Continue When is kish CheckObjectDangour and AStarGreadyFirstSearch .
                                                if (AB.CheckGray)
                                                    continue;
                                            }
                                            else
                                            {
                                                //Continue when CheckBrown and AStarGreadyFirstSearch. 
                                                if (AB.CheckBrown)
                                                    continue;
                                            }
                                        }
                                        else
                                        {

                                        }

                                        //When Order is gray.
                                        /*                  if (Order == 1)
                                                          {
                                                              //When CheckGrayObjectDangour and There is not AStarGreedyt search.
                                                              if (AB.CheckGray)
                                                              {
                                                                  //predict Search.
                                                                  Color B;
                                                                  if (a == Color.Gray)
                                                                      B = Color.Brown;
                                                                  else
                                                                      B = Color.Gray;
                                                                  APredict.TableList.Clear();
                                                                  APredict.TableList.Add(TableS);
                                                                  APredict.SetRowColumn(0);
                                                                  TableHuristic = APredict.InitiatePerdictCheck((int)APredict.ElephantOnTable[i].Row, (int)APredict.ElephantOnTable[i].Column, B, TableS, Order, false);
                                                                  if (TableHuristic == null)
                                                                      continue;
                                                                  else
                                                                  {
                                                                      Act = true;
                                                                      Less = ElephantOnTable[i].ElefantThinking[k].ReturnHuristic(i, j, Order*-1);

                                                                  }
                                                              }
                                                          }
                                                          else
                                                          {
                                                              if (AB.CheckBrown)
                                                              {
                                                                  //predict Search.
                                                                  Color B;
                                                                  if (a == Color.Gray)
                                                                      B = Color.Brown;
                                                                  else
                                                                      B = Color.Gray;
                                                                  APredict.TableList.Clear();
                                                                  APredict.TableList.Add(TableS);
                                                                  APredict.SetRowColumn(0);
                                                                  TableHuristic = APredict.InitiatePerdictCheck((int)APredict.ElephantOnTable[i].Row, (int)APredict.ElephantOnTable[i].Column, B, TableS, Order, false);
                                                                  if (TableHuristic == null)
                                                                      continue;


                                                              }
                                                          }
                                         */

                                    }
                                    RW2 = i;
                                    CL2 = k;
                                    Ki2 = j;
                                    RW1 = -1;
                                    CL1 = -1;
                                    Ki1 = -1;
                                    RW3 = -1;
                                    CL3 = -1;
                                    Ki3 = -1;
                                    RW4 = -1;
                                    CL4 = -1;
                                    Ki4 = -1;
                                    RW5 = -1;
                                    CL5 = -1;
                                    Ki5 = -1;
                                    RW6 = -1;
                                    CL6 = -1;
                                    Ki6 = -1;
                                    MaxLess2 = (ElephantOnTable[RW2].ElefantThinking[CL2].ReturnHuristic(RW2, Ki2, Order * -1));
                                    if (MaxLess2 > MaxLess1)
                                        MaxLess1 = -1;
                                    if (MaxLess2 > MaxLess3)
                                        MaxLess3 = -1;
                                    if (MaxLess2 > MaxLess4)
                                        MaxLess4 = -1;
                                    if (MaxLess2 > MaxLess5)
                                        MaxLess5 = -1;
                                    if (MaxLess2 > MaxLess6)
                                        MaxLess6 = -1;
                                    if (AStarGreedyi == 1)
                                    {
                                        if (Order == 1)
                                        {
                                            //THIS.SetBoxText("\r\nChess Huristic Elephant By Bob!");
                                            //THIS.RefreshBoxText();
                                        }
                                        else//If Order is Brown.
                                        {
                                            //THIS.SetBoxText("\r\nChess Huristic Elephant By Alice!");
                                            //THIS.RefreshBoxText();
                                        } //Set Table and Huristic Value and Syntax.
                                        bool Hit = false;
                                        if (ElephantOnTable[i].ElefantThinking[k].HitNumberElefant[j] > 0)
                                            Hit = true;
                                        // if (Order == 1)
                                        //SyntaxToWrite = (new ChessRules(ChessRules( ArrangmentsChanged)).CreateStatistic(ArrangmentsChanged,TableHuristic, FormRefrigtz.MovmentsNumber, 2, ElephantOnTable[i].ElefantThinking[k].RowColumnElefant[j][1], ElephantOnTable[i].ElefantThinking[k].RowColumnElefant[j][0], Hit, ElephantOnTable[i].ElefantThinking[k].HitNumberElefant[j], ChessRules.BridgeActBrown, false);
                                        // else
                                        //SyntaxToWrite = (new ChessRules(ChessRules( ArrangmentsChanged)).CreateStatistic(ArrangmentsChanged,TableHuristic, FormRefrigtz.MovmentsNumber, -2, ElephantOnTable[i].ElefantThinking[k].RowColumnElefant[j][1], ElephantOnTable[i].ElefantThinking[k].RowColumnElefant[j][0], Hit, ElephantOnTable[i].ElefantThinking[k].HitNumberElefant[j], ChessRules.BridgeActBrown, false);

                                        FormRefrigtz.LastRow = ElephantOnTable[i].ElefantThinking[k].Row;
                                        FormRefrigtz.LastColumn = ElephantOnTable[i].ElefantThinking[k].Column;

                                        Act = true;
                                        Less = ElephantOnTable[i].ElefantThinking[k].ReturnHuristic(i, j, Order * -1);
                                        TableHuristic = ElephantOnTable[i].ElefantThinking[k].TableListElefant[j];

                                    }
                                }
                                else//Set Table and Huristic Value and Syntax.
                                {
                                    try
                                    {
                                        if (AStarGreedyi == 1)
                                        {
                                            if (Order == 1)
                                            {
                                                //THIS.SetBoxText("\r\nChess Huristic Elephant By Bob!");
                                                //THIS.RefreshBoxText();
                                            }
                                            else//If Order is Brown.
                                            {
                                                //THIS.SetBoxText("\r\nChess Huristic Elephant By Alice!");
                                                //THIS.RefreshBoxText();
                                            }  //TakeRoot.Pointer = this;
                                            //Found of Max Non Probable Movments.
                                            Founded.Clear();
                                            double LessB = Double.MinValue; ;
                                            BeginIndexFoundingMaxLessofMaxList(0, Founded, ref LessB);
                                            RW2 = (int)MaxHuristicAStarGreedytBackWard[0][(int)Founded[0]];
                                            CL2 = (int)MaxHuristicAStarGreedytBackWard[0][(int)Founded[0] + 1];
                                            Ki2 = (int)MaxHuristicAStarGreedytBackWard[0][(int)Founded[0] + 2];
                                            if (Founded[0] != MaxElephntFounded)
                                                continue;
                                            bool Hit = false;
                                            if (ElephantOnTable[RW2].ElefantThinking[CL2].HitNumberElefant[Ki2] > 0)
                                                Hit = true;
                                            // if (Order == 1)
                                            //SyntaxToWrite = (new ChessRules(ChessRules( ArrangmentsChanged)).CreateStatistic(ArrangmentsChanged,TableHuristic, FormRefrigtz.MovmentsNumber, 2, ElephantOnTable[RW2].ElefantThinking[CL2].RowColumnElefant[Ki2][1], ElephantOnTable[RW2].ElefantThinking[CL2].RowColumnElefant[Ki2][0], Hit, ElephantOnTable[RW2].ElefantThinking[CL2].HitNumberElefant[Ki2], ChessRules.BridgeActBrown, false);
                                            // else
                                            //SyntaxToWrite = (new ChessRules(ChessRules( ArrangmentsChanged)).CreateStatistic(ArrangmentsChanged,TableHuristic, FormRefrigtz.MovmentsNumber, -2, ElephantOnTable[RW2].ElefantThinking[CL2].RowColumnElefant[Ki2][1], ElephantOnTable[RW2].ElefantThinking[CL2].RowColumnElefant[Ki2][0], Hit, ElephantOnTable[RW2].ElefantThinking[CL2].HitNumberElefant[Ki2], ChessRules.BridgeActBrown, false);

                                            FormRefrigtz.LastRow = ElephantOnTable[RW2].ElefantThinking[CL2].Row;
                                            FormRefrigtz.LastColumn = ElephantOnTable[RW2].ElefantThinking[CL2].Column;

                                            Act = true;
                                            Less = ElephantOnTable[RW2].ElefantThinking[CL2].ReturnHuristic(RW2, Ki2, Order * -1);
                                            TableHuristic = ElephantOnTable[RW2].ElefantThinking[CL2].TableListElefant[Ki2];
                                        }
                                    }
                                    catch (Exception t)
                                    {

                                    }

                                }

                            }
                            catch (Exception t)
                            {

                            }
                        }
                    }
                    catch (Exception t)
                    {

                    } try
                {
                    /*Order *= -1;
                    ChessRules.CurrentOrder *= -1;
                    for (int p = 0; p < ElephantOnTable[i].ElefantThinking[0].AStarGreedy.Count; p++)
                        ElephantOnTable[i].ElefantThinking[0].AStarGreedy[p].HuristicAStarGreedySearch(AStarGreedyi, A, a, ref Less, Order, false);
                     */
                    Order = DummyOrder;
                    ChessRules.CurrentOrder = DummyCurrentOrder;
                }
                catch (Exception t)
                {

                }

                Order = DummyOrder;
                ChessRules.CurrentOrder = DummyCurrentOrder;
            }

            for (i = HourseMidle; i < HourseHight; i++)
            {
                for (int k = 0; k < AllDraw.HourseMovments; k++)
                    try
                    {
                        for (j = 0; HoursesOnTable[i] != null && HoursesOnTable[i] != null && HoursesOnTable[i].HourseThinking[k] != null && HoursesOnTable[i].HourseThinking[k] != null && j < HoursesOnTable[i].HourseThinking[k].TableListHourse.Count; j++)
                        {
                            try
                            {
                                //For Penalty Reagrad Mechanisam of Current Check CheckMate Current Movments.
                                if (FormRefrigtz.OrderPlate == Order && AStarGreedyi == 1 && UsePenaltyRegardMechnisamT)
                                    if (HoursesOnTable[i].HourseThinking[k].PenaltyRegardListHourse[j].IsPenaltyAction() == 0)
                                        continue;
                                int CDummy = ChessRules.CurrentOrder;
                                int COrder = Order;
                                try
                                {
                                    ChessRules.CurrentOrder *= -1;
                                    Order *= -1;
                                    Do = 0;
                                    if (UsePenaltyRegardMechnisamT)
                                    {
                                        for (int ij = 0; ij < HoursesOnTable[i].HourseThinking[k].AStarGreedy.Count - 1; ij++)
                                            HoursesOnTable[i].HourseThinking[k].AStarGreedy[ij].IsPenaltyRegardCheckMateAtBranch(Order, ref Do, HoursesOnTable[i].HourseThinking[k].AStarGreedy[ij]);
                                        Order = COrder;
                                        ChessRules.CurrentOrder = CDummy;
                                        ToCheckMate = -1; ForCheckMate = -1; AA = IsToCheckMateHasLessDeeperThanForCheckMate(this, Order, ref ToCheckMate, ref ForCheckMate, 0); if (Do == -1)
                                            continue;
                                    }

                                }
                                catch (Exception tt) { }
                                Order = COrder;
                                ChessRules.CurrentOrder = CDummy;
                                if (FormRefrigtz.OrderPlate == Order && AStarGreedyi == 1 && UsePenaltyRegardMechnisamT)
                                    if ((HoursesOnTable[i].HourseThinking[k].PenaltyRegardListHourse[j].IsPenaltyAction() != 0 && HoursesOnTable[i].HourseThinking[k].PenaltyRegardListHourse[j].IsRewardAction() == 1 && AStarGreedyi == 1) || Do == 1 || AA)
                                    {
                                        //Set Table and Huristic Value and Syntax.
                                        bool Hit = false;
                                        if (HoursesOnTable[i].HourseThinking[k].HitNumberHourse[j] > 0)
                                            Hit = true;
                                        //if (Order == 1)
                                        //SyntaxToWrite = (new ChessRules(ChessRules( ArrangmentsChanged)).CreateStatistic(ArrangmentsChanged,TableHuristic, FormRefrigtz.MovmentsNumber, 3, HoursesOnTable[i].HourseThinking[k].RowColumnHourse[j][1], HoursesOnTable[i].HourseThinking[k].RowColumnHourse[j][0], Hit, HoursesOnTable[i].HourseThinking[k].HitNumberHourse[j], ChessRules.BridgeActBrown, false);
                                        //else
                                        //SyntaxToWrite = (new ChessRules(ChessRules( ArrangmentsChanged)).CreateStatistic(ArrangmentsChanged,TableHuristic, FormRefrigtz.MovmentsNumber, -3, HoursesOnTable[i].HourseThinking[k].RowColumnHourse[j][1], HoursesOnTable[i].HourseThinking[k].RowColumnHourse[j][0], Hit, HoursesOnTable[i].HourseThinking[k].HitNumberHourse[j], ChessRules.BridgeActBrown, false);
                                        FormRefrigtz.LastRow = HoursesOnTable[i].HourseThinking[k].Row;
                                        FormRefrigtz.LastColumn = HoursesOnTable[i].HourseThinking[k].Column;

                                        Act = true;
                                        Less = HoursesOnTable[i].HourseThinking[k].ReturnHuristic(i, j, Order * -1);
                                        TableHuristic = HoursesOnTable[i].HourseThinking[k].TableListHourse[j];
                                        if (Do == 1 || AA)
                                            //return TableHuristic;
                                            continue;
                                    }

                                //When There is No Movments in Such Order Enemy continue.
                                if (Order != FormRefrigtz.OrderPlate)
                                    if (HoursesOnTable[i].HourseThinking[0].ReturnHuristic(i, j, Order * -1) > Less)

                                        continue;
                                //When There is greater Huristic Movments.
                                if (HoursesOnTable[i].HourseThinking[0].ReturnHuristic(i, j, Order * -1) > Less)
                                {
                                    if (AStarGreedyi == 1) ToFindMovments = true;
                                    //retrive table of current huristic.

                                    //retrive table of current huristic.
                                    int[,] TableS = HoursesOnTable[i].HourseThinking[k].TableListHourse[j];
                                    {
                                        //checked for Legal Movments ArgumentOutOfRangeException curnt game.
                                        if (DynamicAStarGreedytPrograming && !CurrentTableHuristic && AStarGreedyi == 1)
                                        {
                                            try
                                            {
                                                if (!isEnemyThingsinStable(TableS, AllDraw.TableListAction[AllDraw.TableListAction.Count - 1], FormRefrigtz.OrderPlate))
                                                    continue;
                                            }
                                            catch (Exception t)
                                            {

                                                if (!isEnemyThingsinStable(TableS, AllDraw.TableListAction[AllDraw.TableListAction.Count - 1], FormRefrigtz.OrderPlate))
                                                    continue;

                                            }

                                        }
                                        //When there is not Penalty regard mechanism.
                                        //if (!UsePenaltyRegardMechnisamT)
                                        {
                                            AB = new ChessRules(MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, 3, TableS, Order, HoursesOnTable[i].HourseThinking[k].Row, HoursesOnTable[i].HourseThinking[k].Column);
                                            //If there is kish or kshachamaz Order.
                                            if (AB.Check(TableS, Order))
                                            {
                                                //When Order is Gray.
                                                if (Order == 1)
                                                {
                                                    //Continue When is kish CheckObjectDangour and AStarGreadyFirstSearch .
                                                    if (AB.CheckGray)
                                                        continue;
                                                }
                                                else
                                                {
                                                    //Continue when CheckBrown and AStarGreadyFirstSearch. 
                                                    if (AB.CheckBrown)
                                                        continue;
                                                }
                                            }
                                            else
                                            {

                                            }
                                        }


                                        /*                     //When Order is gray.
                                                             if (Order == 1)
                                                             {
                                                                 //When CheckGrayObjectDangour and There is not AStarGreedyt search.
                                                                 if (AB.CheckGray)
                                                                 {
                                                                     //predict Search.
                                                                     Color B;
                                                                     if (a == Color.Gray)
                                                                         B = Color.Brown;
                                                                     else
                                                                         B = Color.Gray;
                                                                     APredict.TableList.Clear();
                                                                     APredict.TableList.Add(TableS);
                                                                     APredict.SetRowColumn(0);
                                                                     TableHuristic = APredict.InitiatePerdictCheck((int)APredict.HoursesOnTable[i].Row, (int)APredict.HoursesOnTable[i].Column, B, TableS, Order, false);
                                                                     if (TableHuristic == null)
                                                                         continue;

                                                                 }
                                                             }
                                                             else
                                                             {
                                                                 if (AB.CheckBrown)
                                                                 {
                                                                     //predict Search.
                                                                     Color B;
                                                                     if (a == Color.Gray)
                                                                         B = Color.Brown;
                                                                     else
                                                                         B = Color.Gray;
                                                                     APredict.TableList.Clear();
                                                                     APredict.TableList.Add(TableS);
                                                                     APredict.SetRowColumn(0);
                                                                     TableHuristic = APredict.InitiatePerdictCheck((int)APredict.HoursesOnTable[i].Row, (int)APredict.HoursesOnTable[i].Column, B, TableS, Order, false);
                                                                     if (TableHuristic == null)
                                                                         continue;
                                                                     else
                                                                     {
                                                                         Act = true;
                                                                         Less = HoursesOnTable[i].HourseThinking[k].ReturnHuristic(i, j, Order*-1);
                                                                         continue;
                                                                     }

                                                                 }
                                                             }
                                         */
                                    }
                                    RW1 = -1;
                                    CL1 = -1;
                                    Ki1 = -1;
                                    RW2 = -1;
                                    CL2 = -1;
                                    Ki2 = -1;
                                    RW3 = i;
                                    CL3 = k;
                                    Ki3 = j;
                                    RW4 = -1;
                                    CL4 = -1;
                                    Ki4 = -1;
                                    RW5 = -1;
                                    CL5 = -1;
                                    Ki5 = -1;
                                    RW6 = -1;
                                    CL6 = -1;
                                    Ki6 = -1;
                                    MaxLess3 = HoursesOnTable[RW3].HourseThinking[CL3].ReturnHuristic(RW3, Ki3, Order * -1);
                                    if (MaxLess3 > MaxLess1)
                                        MaxLess1 = -1;
                                    if (MaxLess3 > MaxLess2)
                                        MaxLess2 = -1;
                                    if (MaxLess3 > MaxLess4)
                                        MaxLess4 = -1;
                                    if (MaxLess3 > MaxLess5)
                                        MaxLess5 = -1;
                                    if (MaxLess3 > MaxLess6)
                                        MaxLess6 = -1;

                                    if (AStarGreedyi == 1)
                                    {
                                        if (Order == 1)
                                        {
                                            //THIS.SetBoxText("\r\nChess Huristic Hourse By Bob!");
                                            //THIS.RefreshBoxText();
                                        }
                                        else//If Order is Brown.
                                        {
                                            //THIS.SetBoxText("\r\nChess Huristic Hourse By Alice!");
                                            //THIS.RefreshBoxText();
                                        }   //Set Table and Huristic Value and Syntax.
                                        bool Hit = false;
                                        if (HoursesOnTable[i].HourseThinking[k].HitNumberHourse[j] > 0)
                                            Hit = true;
                                        // if (Order == 1)
                                        //SyntaxToWrite = (new ChessRules(ChessRules( ArrangmentsChanged)).CreateStatistic(ArrangmentsChanged,TableHuristic, FormRefrigtz.MovmentsNumber, 3, HoursesOnTable[i].HourseThinking[k].RowColumnHourse[j][1], HoursesOnTable[i].HourseThinking[k].RowColumnHourse[j][0], Hit, HoursesOnTable[i].HourseThinking[k].HitNumberHourse[j], ChessRules.BridgeActBrown, false);
                                        // else
                                        //SyntaxToWrite = (new ChessRules(ChessRules( ArrangmentsChanged)).CreateStatistic(ArrangmentsChanged,TableHuristic, FormRefrigtz.MovmentsNumber, -3, HoursesOnTable[i].HourseThinking[k].RowColumnHourse[j][1], HoursesOnTable[i].HourseThinking[k].RowColumnHourse[j][0], Hit, HoursesOnTable[i].HourseThinking[k].HitNumberHourse[j], ChessRules.BridgeActBrown, false);
                                        FormRefrigtz.LastRow = HoursesOnTable[i].HourseThinking[k].Row;
                                        FormRefrigtz.LastColumn = HoursesOnTable[i].HourseThinking[k].Column;

                                        Act = true;
                                        Less = HoursesOnTable[i].HourseThinking[k].ReturnHuristic(i, j, Order * -1);
                                        TableHuristic = HoursesOnTable[i].HourseThinking[k].TableListHourse[j];

                                    }
                                }
                                else//Set Table and Huristic Value and Syntax.
                                {
                                    try
                                    {
                                        if (AStarGreedyi == 1)
                                        {
                                            if (Order == 1)
                                            {
                                                //THIS.SetBoxText("\r\nChess Huristic Hourse By Bob!");
                                                //THIS.RefreshBoxText();
                                            }
                                            else//If Order is Brown.
                                            {
                                                //THIS.SetBoxText("\r\nChess Huristic Hourse By Alice!");
                                                //THIS.RefreshBoxText();
                                            }//TakeRoot.Pointer = this;
                                            //Found of Max Non Probable Movments.
                                            Founded.Clear();
                                            double LessB = Double.MinValue; ;
                                            BeginIndexFoundingMaxLessofMaxList(0, Founded, ref LessB);
                                            RW3 = (int)MaxHuristicAStarGreedytBackWard[0][(int)Founded[0]];
                                            CL3 = (int)MaxHuristicAStarGreedytBackWard[0][(int)Founded[0] + 1];
                                            Ki3 = (int)MaxHuristicAStarGreedytBackWard[0][(int)Founded[0] + 2];
                                            if (Founded[0] != MaxHourseFounded)
                                                continue;
                                            bool Hit = false;
                                            if (HoursesOnTable[RW3].HourseThinking[CL3].HitNumberHourse[Ki3] > 0)
                                                Hit = true;
                                            // if (Order == 1)
                                            //SyntaxToWrite = (new ChessRules(ChessRules( ArrangmentsChanged)).CreateStatistic(ArrangmentsChanged,TableHuristic, FormRefrigtz.MovmentsNumber, 3, HoursesOnTable[RW3].HourseThinking[CL3].RowColumnHourse[Ki3][1], HoursesOnTable[RW3].HourseThinking[CL3].RowColumnHourse[Ki3][0], Hit, HoursesOnTable[RW3].HourseThinking[CL3].HitNumberHourse[Ki3], ChessRules.BridgeActBrown, false);
                                            // else
                                            //SyntaxToWrite = (new ChessRules(ChessRules( ArrangmentsChanged)).CreateStatistic(ArrangmentsChanged,TableHuristic, FormRefrigtz.MovmentsNumber, -3, HoursesOnTable[RW3].HourseThinking[CL3].RowColumnHourse[Ki3][1], HoursesOnTable[RW3].HourseThinking[CL3].RowColumnHourse[Ki3][0], Hit, HoursesOnTable[RW3].HourseThinking[CL3].HitNumberHourse[Ki3], ChessRules.BridgeActBrown, false);
                                            FormRefrigtz.LastRow = HoursesOnTable[RW3].HourseThinking[CL3].Row;
                                            FormRefrigtz.LastColumn = HoursesOnTable[RW3].HourseThinking[CL3].Column;

                                            Act = true;
                                            Less = HoursesOnTable[RW3].HourseThinking[CL3].ReturnHuristic(RW3, Ki3, Order * -1);
                                            TableHuristic = HoursesOnTable[RW3].HourseThinking[CL3].TableListHourse[Ki3];
                                        }
                                    }
                                    catch (Exception t)
                                    { }


                                }

                            }
                            catch (Exception t)
                            {

                            }
                        }
                    }
                    catch (Exception t)
                    {

                    }
                try
                {
                    /*Order *= -1;
                    ChessRules.CurrentOrder *= -1;
                    for (int p = 0; p < HoursesOnTable[i].HourseThinking[0].AStarGreedy.Count; p++)
                        HoursesOnTable[i].HourseThinking[0].AStarGreedy[p].HuristicAStarGreedySearch(AStarGreedyi, A, a, ref Less, Order, false);
                     */
                    Order = DummyOrder;
                    ChessRules.CurrentOrder = DummyCurrentOrder;
                }
                catch (Exception t)
                {

                }

                Order = DummyOrder;
                ChessRules.CurrentOrder = DummyCurrentOrder;
            }

            for (i = BridgeMidle; i < BridgeHigh; i++)
            {
                for (int k = 0; k < AllDraw.BridgeMovments; k++)
                    try
                    {
                        for (j = 0; BridgesOnTable[i] != null && BridgesOnTable[i] != null && BridgesOnTable[i].BridgeThinking[k] != null && BridgesOnTable[i].BridgeThinking[k] != null && j < BridgesOnTable[i].BridgeThinking[k].TableListBridge.Count; j++)
                        {
                            try
                            {
                                //For Penalty Reagrad Mechanisam of Current Check CheckMate Current Movments.
                                if (FormRefrigtz.OrderPlate == Order && AStarGreedyi == 1 && UsePenaltyRegardMechnisamT)
                                    if (BridgesOnTable[i].BridgeThinking[k].PenaltyRegardListBridge[j].IsPenaltyAction() == 0)
                                        continue;

                                int CDummy = ChessRules.CurrentOrder;
                                int COrder = Order;
                                try
                                {
                                    ChessRules.CurrentOrder *= -1;
                                    Order *= -1;
                                    Do = 0;
                                    if (UsePenaltyRegardMechnisamT)
                                    {
                                        for (int ij = 0; ij < BridgesOnTable[i].BridgeThinking[k].AStarGreedy.Count - 1; ij++)
                                            BridgesOnTable[i].BridgeThinking[k].AStarGreedy[ij].IsPenaltyRegardCheckMateAtBranch(Order, ref Do, BridgesOnTable[i].BridgeThinking[k].AStarGreedy[ij]);
                                        Order = COrder;
                                        ChessRules.CurrentOrder = CDummy;
                                        ToCheckMate = -1; ForCheckMate = -1; AA = IsToCheckMateHasLessDeeperThanForCheckMate(this, Order, ref ToCheckMate, ref ForCheckMate, 0); if (Do == -1)
                                            continue;
                                    }

                                }
                                catch (Exception tt) { }
                                Order = COrder;
                                ChessRules.CurrentOrder = CDummy;
                                if (FormRefrigtz.OrderPlate == Order && AStarGreedyi == 1 && UsePenaltyRegardMechnisamT)
                                    if ((BridgesOnTable[i].BridgeThinking[k].PenaltyRegardListBridge[j].IsPenaltyAction() != 0 && BridgesOnTable[i].BridgeThinking[k].PenaltyRegardListBridge[j].IsRewardAction() == 1 && AStarGreedyi == 1) || Do == 1 || AA)
                                    {
                                        //Set Table and Huristic Value and Syntax.
                                        bool Hit = false;
                                        if (BridgesOnTable[i].BridgeThinking[k].HitNumberBridge[j] > 0)
                                            Hit = true;
                                        // if (Order == 1)
                                        //SyntaxToWrite = (new ChessRules(ChessRules( ArrangmentsChanged)).CreateStatistic(ArrangmentsChanged,TableHuristic, FormRefrigtz.MovmentsNumber, 4, BridgesOnTable[i].BridgeThinking[k].RowColumnBridge[j][1], BridgesOnTable[i].BridgeThinking[k].RowColumnBridge[j][0], Hit, BridgesOnTable[i].BridgeThinking[k].HitNumberBridge[j], ChessRules.BridgeActBrown, false);
                                        // else
                                        //SyntaxToWrite = (new ChessRules(ChessRules( ArrangmentsChanged)).CreateStatistic(ArrangmentsChanged,TableHuristic, FormRefrigtz.MovmentsNumber, -4, BridgesOnTable[i].BridgeThinking[k].RowColumnBridge[j][1], BridgesOnTable[i].BridgeThinking[k].RowColumnBridge[j][0], Hit, BridgesOnTable[i].BridgeThinking[k].HitNumberBridge[j], ChessRules.BridgeActBrown, false);

                                        FormRefrigtz.LastRow = BridgesOnTable[i].BridgeThinking[k].Row;
                                        FormRefrigtz.LastColumn = BridgesOnTable[i].BridgeThinking[k].Column;

                                        Act = true;
                                        Less = BridgesOnTable[i].BridgeThinking[k].ReturnHuristic(i, j, Order * -1);
                                        TableHuristic = BridgesOnTable[i].BridgeThinking[k].TableListBridge[j];
                                        if (Do == 1 || AA)
                                            //return TableHuristic;
                                            continue;
                                    }
                                if (Order != FormRefrigtz.OrderPlate)
                                    if (BridgesOnTable[i].BridgeThinking[0].ReturnHuristic(i, j, Order * -1) > Less)
                                        continue;
                                //When There is greater Huristic Movments.
                                if (BridgesOnTable[i].BridgeThinking[0].ReturnHuristic(i, j, Order * -1) > Less)
                                {
                                    if (AStarGreedyi == 1) ToFindMovments = true;
                                    //retrive table of current huristic.
                                    //retrive table of current huristic.
                                    int[,] TableS = BridgesOnTable[i].BridgeThinking[k].TableListBridge[j];
                                    //checked for Legal Movments ArgumentOutOfRangeException curnt game.
                                    if (DynamicAStarGreedytPrograming && !CurrentTableHuristic && AStarGreedyi == 1)
                                    {
                                        try
                                        {
                                            if (!isEnemyThingsinStable(TableS, AllDraw.TableListAction[AllDraw.TableListAction.Count - 1], FormRefrigtz.OrderPlate))
                                                continue;
                                        }
                                        catch (Exception t)
                                        {

                                            if (!isEnemyThingsinStable(TableS, AllDraw.TableListAction[AllDraw.TableListAction.Count - 1], FormRefrigtz.OrderPlate))
                                                continue;

                                        }

                                    }
                                    //When there is not Penalty regard mechanism.
                                    //if (!UsePenaltyRegardMechnisamT)
                                    {
                                        AB = new ChessRules(MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, 4, TableS, Order, BridgesOnTable[i].BridgeThinking[k].Row, BridgesOnTable[i].BridgeThinking[k].Column);
                                        //If there is kish or kshachamaz Order.
                                        if (AB.Check(TableS, Order))
                                        {
                                            //When Order is Gray.
                                            if (Order == 1)
                                            {
                                                //Continue When is kish CheckObjectDangour and AStarGreadyFirstSearch .
                                                if (AB.CheckGray)
                                                    continue;
                                            }
                                            else
                                            {
                                                //Continue when CheckBrown and AStarGreadyFirstSearch. 
                                                if (AB.CheckBrown)
                                                    continue;
                                            }
                                        }
                                        else
                                        {

                                        }

                                        //When Order is gray.
                                        /*                        if (Order == 1)
                                                                {
                                                                    //When CheckGrayObjectDangour and There is not AStarGreedyt search.
                                                                    if (AB.CheckGray)
                                                                    {
                                                                        //predict Search.
                                                                        Color B;
                                                                        if (a == Color.Gray)
                                                                            B = Color.Brown;
                                                                        else
                                                                            B = Color.Gray;
                                                                        APredict.TableList.Clear();
                                                                        APredict.TableList.Add(TableS);
                                                                        APredict.SetRowColumn(0);
                                                                        TableHuristic = APredict.InitiatePerdictCheck((int)APredict.BridgesOnTable[i].Row, (int)APredict.BridgesOnTable[i].Column, B, TableS, Order, false);
                                                                        if (TableHuristic == null)
                                                                            continue;

                                                                    }
                                                                }
                                                                else
                                                                {
                                                                    if (AB.CheckBrown)
                                                                    {
                                                                        //predict Search.
                                                                        Color B;
                                                                        if (a == Color.Gray)
                                                                            B = Color.Brown;
                                                                        else
                                                                            B = Color.Gray;
                                                                        APredict.TableList.Clear();
                                                                        APredict.TableList.Add(TableS);
                                                                        APredict.SetRowColumn(0);
                                                                        TableHuristic = APredict.InitiatePerdictCheck((int)BridgesOnTable[i].Row, (int)BridgesOnTable[i].Column, B, TableS, Order, false);
                                                                        if (TableHuristic == null)
                                                                            continue;
                                                                        else
                                                                        {
                                                                            Act = true;
                                                                            Less = BridgesOnTable[i].BridgeThinking[k].ReturnHuristic(i, j, Order*-1);


                                                                            continue;
                                                                        }
                                                                    }
                                                                }
                                         */
                                    }
                                    RW4 = i;
                                    CL4 = k;
                                    Ki4 = j;
                                    RW1 = -1;
                                    CL1 = -1;
                                    Ki1 = -1;
                                    RW2 = -1;
                                    CL2 = -1;
                                    Ki2 = -1;
                                    RW3 = -1;
                                    CL3 = -1;
                                    Ki3 = -1;
                                    RW5 = -1;
                                    CL5 = -1;
                                    Ki5 = -1;
                                    RW6 = -1;
                                    CL6 = -1;
                                    Ki6 = -1;
                                    MaxLess4 = (BridgesOnTable[RW4].BridgeThinking[CL4].ReturnHuristic(RW4, Ki4, Order * -1));
                                    if (MaxLess4 > MaxLess1)
                                        MaxLess1 = -1;
                                    if (MaxLess4 > MaxLess2)
                                        MaxLess2 = -1;
                                    if (MaxLess4 > MaxLess3)
                                        MaxLess3 = -1;
                                    if (MaxLess4 > MaxLess5)
                                        MaxLess5 = -1;
                                    if (MaxLess4 > MaxLess6)
                                        MaxLess6 = -1;

                                    if (AStarGreedyi == 1)
                                    {
                                        if (Order == 1)
                                        {
                                            //THIS.SetBoxText("\r\nChess Huristic Bridges By Bob!");
                                            //THIS.RefreshBoxText();
                                        }
                                        else//If Order is Brown.
                                        {
                                            //THIS.SetBoxText("\r\nChess Huristic Bridges By Alice!");
                                            //THIS.RefreshBoxText();
                                        }  //Set Table and Huristic Value and Syntax.
                                        bool Hit = false;
                                        if (BridgesOnTable[i].BridgeThinking[k].HitNumberBridge[j] > 0)
                                            Hit = true;
                                        // if (Order == 1)
                                        //SyntaxToWrite = (new ChessRules(ChessRules( ArrangmentsChanged)).CreateStatistic(ArrangmentsChanged,TableHuristic, FormRefrigtz.MovmentsNumber, 4, BridgesOnTable[i].BridgeThinking[k].RowColumnBridge[j][1], BridgesOnTable[i].BridgeThinking[k].RowColumnBridge[j][0], Hit, BridgesOnTable[i].BridgeThinking[k].HitNumberBridge[j], ChessRules.BridgeActBrown, false);
                                        // else
                                        //SyntaxToWrite = (new ChessRules(ChessRules( ArrangmentsChanged)).CreateStatistic(ArrangmentsChanged,TableHuristic, FormRefrigtz.MovmentsNumber, -4, BridgesOnTable[i].BridgeThinking[k].RowColumnBridge[j][1], BridgesOnTable[i].BridgeThinking[k].RowColumnBridge[j][0], Hit, BridgesOnTable[i].BridgeThinking[k].HitNumberBridge[j], ChessRules.BridgeActBrown, false);

                                        FormRefrigtz.LastRow = BridgesOnTable[i].BridgeThinking[k].Row;
                                        FormRefrigtz.LastColumn = BridgesOnTable[i].BridgeThinking[k].Column;

                                        Act = true;
                                        Less = BridgesOnTable[i].BridgeThinking[k].ReturnHuristic(i, j, Order * -1);
                                        TableHuristic = BridgesOnTable[i].BridgeThinking[k].TableListBridge[j];

                                    }
                                }
                                else//Set Table and Huristic Value and Syntax.
                                {
                                    try
                                    {
                                        if (AStarGreedyi == 1)
                                        {
                                            if (Order == 1)
                                            {
                                                //THIS.SetBoxText("\r\nChess Huristic Bridges By Bob!");
                                                //THIS.RefreshBoxText();
                                            }
                                            else//If Order is Brown.
                                            {
                                                //THIS.SetBoxText("\r\nChess Huristic Bridges By Alice!");
                                                //THIS.RefreshBoxText();
                                            } //TakeRoot.Pointer = this;
                                            //Found of Max Non Probable Movments.
                                            Founded.Clear();
                                            double LessB = Double.MinValue; ;
                                            BeginIndexFoundingMaxLessofMaxList(0, Founded, ref LessB);
                                            RW4 = (int)MaxHuristicAStarGreedytBackWard[0][(int)Founded[0]];
                                            CL4 = (int)MaxHuristicAStarGreedytBackWard[0][(int)Founded[0] + 1];
                                            Ki4 = (int)MaxHuristicAStarGreedytBackWard[0][(int)Founded[0] + 2];
                                            if (Founded[0] != MaxBridgesFounded)
                                                continue;
                                            bool Hit = false;
                                            if (BridgesOnTable[RW4].BridgeThinking[CL4].HitNumberBridge[Ki4] > 0)
                                                Hit = true;
                                            // if (Order == 1)
                                            //SyntaxToWrite = (new ChessRules(ChessRules( ArrangmentsChanged)).CreateStatistic(ArrangmentsChanged,TableHuristic, FormRefrigtz.MovmentsNumber, 4, BridgesOnTable[RW4].BridgeThinking[CL4].RowColumnBridge[Ki4][1], BridgesOnTable[RW4].BridgeThinking[CL4].RowColumnBridge[Ki4][0], Hit, BridgesOnTable[RW4].BridgeThinking[CL4].HitNumberBridge[Ki4], ChessRules.BridgeActBrown, false);
                                            // else
                                            //SyntaxToWrite = (new ChessRules(ChessRules( ArrangmentsChanged)).CreateStatistic(ArrangmentsChanged,TableHuristic, FormRefrigtz.MovmentsNumber, -4, BridgesOnTable[RW4].BridgeThinking[CL4].RowColumnBridge[Ki4][1], BridgesOnTable[RW4].BridgeThinking[CL4].RowColumnBridge[Ki4][0], Hit, BridgesOnTable[RW4].BridgeThinking[CL4].HitNumberBridge[Ki4], ChessRules.BridgeActBrown, false);

                                            FormRefrigtz.LastRow = BridgesOnTable[RW4].BridgeThinking[CL4].Row;
                                            FormRefrigtz.LastColumn = BridgesOnTable[RW4].BridgeThinking[CL4].Column;

                                            Act = true;
                                            Less = BridgesOnTable[RW4].BridgeThinking[CL4].ReturnHuristic(RW4, Ki4, Order * -1);
                                            TableHuristic = BridgesOnTable[RW4].BridgeThinking[CL4].TableListBridge[Ki4];
                                        }
                                    }
                                    catch (Exception t) { }

                                }
                            }
                            catch (Exception t)
                            {

                            }
                        }
                    }
                    catch (Exception t)
                    {

                    } try
                {
                    /*Order *= -1;
                    ChessRules.CurrentOrder *= -1;
                    for (int p = 0; p < BridgesOnTable[i].BridgeThinking[0].AStarGreedy.Count; p++)
                        BridgesOnTable[i].BridgeThinking[0].AStarGreedy[p].HuristicAStarGreedySearch(AStarGreedyi, A, a, ref Less, Order, false);
                     */
                    Order = DummyOrder;
                    ChessRules.CurrentOrder = DummyCurrentOrder;
                }
                catch (Exception t)
                {

                }
                Order = DummyOrder;
                ChessRules.CurrentOrder = DummyCurrentOrder;
            }


            for (i = MinisterMidle; i < MinisterHigh; i++)
            {
                for (int k = 0; k < AllDraw.MinisterMovments; k++)
                    try
                    {
                        for (j = 0; MinisterOnTable[i] != null && MinisterOnTable[i] != null && MinisterOnTable[i].MinisterThinking[k] != null && MinisterOnTable[i].MinisterThinking[k] != null && j < MinisterOnTable[i].MinisterThinking[k].TableListMinister.Count; j++)
                        {
                            try
                            {
                                //For Penalty Reagrad Mechanisam of Current Check CheckMate Current Movments.
                                if (FormRefrigtz.OrderPlate == Order && AStarGreedyi == 1 && UsePenaltyRegardMechnisamT)
                                    if (MinisterOnTable[i].MinisterThinking[k].PenaltyRegardListMinister[j].IsPenaltyAction() == 0)
                                        continue;
                                int CDummy = ChessRules.CurrentOrder;
                                int COrder = Order;
                                try
                                {
                                    ChessRules.CurrentOrder *= -1;
                                    Order *= -1;
                                    Do = 0;
                                    if (UsePenaltyRegardMechnisamT)
                                    {
                                        for (int ij = 0; ij < MinisterOnTable[i].MinisterThinking[k].AStarGreedy.Count - 1; ij++)
                                            MinisterOnTable[i].MinisterThinking[k].AStarGreedy[ij].IsPenaltyRegardCheckMateAtBranch(Order, ref Do, MinisterOnTable[i].MinisterThinking[k].AStarGreedy[ij]);
                                        Order = COrder;
                                        ChessRules.CurrentOrder = CDummy;
                                        ToCheckMate = -1; ForCheckMate = -1; AA = IsToCheckMateHasLessDeeperThanForCheckMate(this, Order, ref ToCheckMate, ref ForCheckMate, 0); if (Do == -1)
                                            continue;
                                    }

                                }
                                catch (Exception tt) { }
                                Order = COrder;
                                ChessRules.CurrentOrder = CDummy;
                                if (FormRefrigtz.OrderPlate == Order && AStarGreedyi == 1 && UsePenaltyRegardMechnisamT)
                                    if ((MinisterOnTable[i].MinisterThinking[k].PenaltyRegardListMinister[j].IsPenaltyAction() != 0 && MinisterOnTable[i].MinisterThinking[k].PenaltyRegardListMinister[j].IsRewardAction() == 1 && AStarGreedyi == 1) || Do == 1 || AA)
                                    {
                                        //Set Table and Huristic Value and Syntax.
                                        bool Hit = false;
                                        if (MinisterOnTable[i].MinisterThinking[k].HitNumberMinister[j] > 0)
                                            Hit = true;
                                        // if (Order == 1)
                                        //SyntaxToWrite = (new ChessRules(ChessRules( ArrangmentsChanged)).CreateStatistic(ArrangmentsChanged,TableHuristic, FormRefrigtz.MovmentsNumber, 5, MinisterOnTable[i].MinisterThinking[k].RowColumnMinister[j][1], MinisterOnTable[i].MinisterThinking[k].RowColumnMinister[j][0], Hit, MinisterOnTable[i].MinisterThinking[k].HitNumberBridge[j], ChessRules.BridgeActBrown, false);
                                        // else
                                        //SyntaxToWrite = (new ChessRules(ChessRules( ArrangmentsChanged)).CreateStatistic(ArrangmentsChanged,TableHuristic, FormRefrigtz.MovmentsNumber, -5, MinisterOnTable[i].MinisterThinking[k].RowColumnMinister[j][1], MinisterOnTable[i].MinisterThinking[k].RowColumnMinister[j][0], Hit, MinisterOnTable[i].MinisterThinking[k].HitNumberBridge[j], ChessRules.BridgeActBrown, false);

                                        FormRefrigtz.LastRow = MinisterOnTable[i].MinisterThinking[k].Row;
                                        FormRefrigtz.LastColumn = MinisterOnTable[i].MinisterThinking[k].Column;

                                        Act = true;
                                        Less = MinisterOnTable[i].MinisterThinking[k].ReturnHuristic(i, j, Order * -1);
                                        TableHuristic = MinisterOnTable[i].MinisterThinking[k].TableListMinister[j];
                                        if (Do == 1 || AA)
                                            //return TableHuristic;
                                            continue;
                                    }
                                //When There is No Movments in Such Order Enemy continue.
                                if (Order != FormRefrigtz.OrderPlate)
                                    if (MinisterOnTable[i].MinisterThinking[0].ReturnHuristic(i, j, Order * -1) > Less)
                                        continue;


                                //When There is greater Huristic Movments.
                                if (MinisterOnTable[i].MinisterThinking[0].ReturnHuristic(i, j, Order * -1) > Less)

                                //retrive table of current huristic.
                                {
                                    if (AStarGreedyi == 1) ToFindMovments = true;
                                    //retrive table of current huristic.
                                    int[,] TableS = MinisterOnTable[i].MinisterThinking[k].TableListMinister[j];
                                    //checked for Legal Movments ArgumentOutOfRangeException curnt game.
                                    if (DynamicAStarGreedytPrograming && !CurrentTableHuristic && AStarGreedyi == 1)
                                    {
                                        try
                                        {
                                            if (!isEnemyThingsinStable(TableS, AllDraw.TableListAction[AllDraw.TableListAction.Count - 1], FormRefrigtz.OrderPlate))
                                                continue;
                                        }
                                        catch (Exception t)
                                        {

                                            if (!isEnemyThingsinStable(TableS, AllDraw.TableListAction[AllDraw.TableListAction.Count - 1], FormRefrigtz.OrderPlate))
                                                continue;

                                        }
                                    }
                                    {
                                        //When there is not Penalty regard mechanism.
                                        //if (!UsePenaltyRegardMechnisamT)
                                        {
                                            AB = new ChessRules(MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, 5, TableS, Order, MinisterOnTable[i].MinisterThinking[k].Row, MinisterOnTable[i].MinisterThinking[k].Column);
                                            //If there is kish or kshachamaz Order.
                                            if (AB.Check(TableS, Order))
                                            {
                                                //When Order is Gray.
                                                if (Order == 1)
                                                {
                                                    //Continue When is kish CheckObjectDangour and AStarGreadyFirstSearch .
                                                    if (AB.CheckGray)
                                                        continue;
                                                }
                                                else
                                                {
                                                    //Continue when CheckBrown and AStarGreadyFirstSearch. 
                                                    if (AB.CheckBrown)
                                                        continue;
                                                }
                                            }
                                            else
                                            {

                                            }
                                        }

                                        //When Order is gray.
                                        /*if (Order == 1)
                                        {
                                            //When CheckGrayObjectDangour and There is not AStarGreedyt search.
                                            if (AB.CheckGray)
                                            {
                                                //predict Search.
                                                Color B;
                                                if (a == Color.Gray)
                                                    B = Color.Brown;
                                                else
                                                    B = Color.Gray;
                                                APredict.TableList.Clear();
                                                APredict.TableList.Add(TableS);
                                                APredict.SetRowColumn(0);
                                                TableHuristic = APredict.InitiatePerdictCheck((int)APredict.MinisterOnTable[i].Row, (int)APredict.MinisterOnTable[i].Column, B, TableS, Order, false);
                                                if (TableHuristic == null)
                                                    continue;
                                                else
                                                {
                                                    Act = true;
                                                    Less = MinisterOnTable[i].MinisterThinking[k].ReturnHuristic(i, j, Order*-1);
                                                    continue;
                                                }
                                            }

                                        }
                                        else
                                        {
                                            if (AB.CheckBrown)
                                            {
                                                //predict Search.
                                                Color B;
                                                if (a == Color.Gray)
                                                    B = Color.Brown;
                                                else
                                                    B = Color.Gray;
                                                APredict.TableList.Clear();
                                                APredict.TableList.Add(TableS);
                                                APredict.SetRowColumn(0);
                                                if (null == APredict.InitiatePerdictCheck((int)APredict.MinisterOnTable[i].Row, (int)APredict.MinisterOnTable[i].Column, B, TableS, Order, false))
                                                    continue;

                                            }
                                        }
                                         */

                                    }
                                    RW5 = i;
                                    CL5 = k;
                                    Ki5 = j;
                                    RW1 = -1;
                                    CL1 = -1;
                                    Ki1 = -1;
                                    RW2 = -1;
                                    CL2 = -1;
                                    Ki2 = -1;
                                    RW3 = -1;
                                    CL3 = -1;
                                    Ki3 = -1;
                                    RW4 = -1;
                                    CL4 = -1;
                                    Ki4 = -1;
                                    RW6 = -1;
                                    CL6 = -1;
                                    Ki6 = -1;
                                    MaxLess5 = (MinisterOnTable[RW5].MinisterThinking[CL5].ReturnHuristic(RW5, Ki5, Order * -1));
                                    if (MaxLess5 > MaxLess1)
                                        MaxLess1 = -1;
                                    if (MaxLess5 > MaxLess2)
                                        MaxLess2 = -1;
                                    if (MaxLess5 > MaxLess3)
                                        MaxLess3 = -1;
                                    if (MaxLess5 > MaxLess4)
                                        MaxLess4 = -1;
                                    if (MaxLess5 > MaxLess6)
                                        MaxLess6 = -1;
                                    if (AStarGreedyi == 1)
                                    {
                                        if (Order == 1)
                                        {
                                            //THIS.SetBoxText("\r\nChess Huristic Minister By Bob!");
                                            //THIS.RefreshBoxText();
                                        }
                                        else//If Order is Brown.
                                        {
                                            //THIS.SetBoxText("\r\nChess Huristic Minister By Alice!");
                                            //THIS.RefreshBoxText();
                                        } //Set Table and Huristic Value and Syntax.
                                        bool Hit = false;
                                        if (MinisterOnTable[i].MinisterThinking[k].HitNumberMinister[j] > 0)
                                            Hit = true;
                                        //  if (Order == 1)
                                        //SyntaxToWrite = (new ChessRules(ChessRules( ArrangmentsChanged)).CreateStatistic(ArrangmentsChanged,TableHuristic, FormRefrigtz.MovmentsNumber, 5, MinisterOnTable[i].MinisterThinking[k].RowColumnMinister[j][1], MinisterOnTable[i].MinisterThinking[k].RowColumnMinister[j][0], Hit, MinisterOnTable[i].MinisterThinking[k].HitNumberMinister[j], ChessRules.BridgeActBrown, false);
                                        // else
                                        //SyntaxToWrite = (new ChessRules(ChessRules( ArrangmentsChanged)).CreateStatistic(ArrangmentsChanged,TableHuristic, FormRefrigtz.MovmentsNumber, -5, MinisterOnTable[i].MinisterThinking[k].RowColumnMinister[j][1], MinisterOnTable[i].MinisterThinking[k].RowColumnMinister[j][0], Hit, MinisterOnTable[i].MinisterThinking[k].HitNumberMinister[j], ChessRules.BridgeActBrown, false);

                                        FormRefrigtz.LastRow = MinisterOnTable[i].MinisterThinking[k].Row;
                                        FormRefrigtz.LastColumn = MinisterOnTable[i].MinisterThinking[k].Column;

                                        Act = true;
                                        Less = MinisterOnTable[i].MinisterThinking[k].ReturnHuristic(i, j, Order * -1);
                                        TableHuristic = MinisterOnTable[i].MinisterThinking[k].TableListMinister[j];

                                    }
                                }
                                else//Set Table and Huristic Value and Syntax.
                                {
                                    try
                                    {
                                        if (AStarGreedyi == 1)
                                        {
                                            if (Order == 1)
                                            {
                                                //THIS.SetBoxText("\r\nChess Huristic Minister By Bob!");
                                                //THIS.RefreshBoxText();
                                            }
                                            else//If Order is Brown.
                                            {
                                                //THIS.SetBoxText("\r\nChess Huristic Minister By Alice!");
                                                //THIS.RefreshBoxText();
                                            }   //TakeRoot.Pointer = this;
                                            //Found of Max Non Probable Movments.
                                            Founded.Clear();
                                            double LessB = Double.MinValue; ;
                                            BeginIndexFoundingMaxLessofMaxList(0, Founded, ref LessB);
                                            RW5 = (int)MaxHuristicAStarGreedytBackWard[0][(int)Founded[0]];
                                            CL5 = (int)MaxHuristicAStarGreedytBackWard[0][(int)Founded[0] + 1];
                                            Ki5 = (int)MaxHuristicAStarGreedytBackWard[0][(int)Founded[0] + 2];
                                            if (Founded[0] != MaxMinisterFounded)
                                                continue;
                                            bool Hit = false;
                                            if (MinisterOnTable[RW5].MinisterThinking[CL5].HitNumberMinister[Ki5] > 0)
                                                Hit = true;
                                            // if (Order == 1)
                                            //SyntaxToWrite = (new ChessRules(ChessRules( ArrangmentsChanged)).CreateStatistic(ArrangmentsChanged,TableHuristic, FormRefrigtz.MovmentsNumber, 5, MinisterOnTable[RW5].MinisterThinking[CL5].RowColumnMinister[Ki5][1], MinisterOnTable[RW5].MinisterThinking[CL5].RowColumnMinister[Ki5][0], Hit, MinisterOnTable[RW5].MinisterThinking[CL5].HitNumberBridge[Ki5], ChessRules.BridgeActBrown, false);
                                            //  else
                                            //SyntaxToWrite = (new ChessRules(ChessRules( ArrangmentsChanged)).CreateStatistic(ArrangmentsChanged,TableHuristic, FormRefrigtz.MovmentsNumber, -5, MinisterOnTable[RW5].MinisterThinking[CL5].RowColumnMinister[Ki5][1], MinisterOnTable[RW5].MinisterThinking[CL5].RowColumnMinister[Ki5][0], Hit, MinisterOnTable[RW5].MinisterThinking[CL5].HitNumberBridge[Ki5], ChessRules.BridgeActBrown, false);

                                            FormRefrigtz.LastRow = MinisterOnTable[RW5].MinisterThinking[CL5].Row;
                                            FormRefrigtz.LastColumn = MinisterOnTable[RW5].MinisterThinking[CL5].Column;

                                            Act = true;
                                            Less = MinisterOnTable[RW5].MinisterThinking[CL5].ReturnHuristic(RW5, Ki5, Order * -1);
                                            TableHuristic = MinisterOnTable[RW5].MinisterThinking[CL5].TableListMinister[Ki5];
                                        }
                                    }
                                    catch (Exception t)
                                    {

                                    }
                                }
                            }
                            catch (Exception t)
                            {

                            }
                        }
                    }
                    catch (Exception t)
                    {

                    }
                try
                {
                    /*   Order *= -1;
                       ChessRules.CurrentOrder *= -1;
                       for (int p = 0; p < MinisterOnTable[i].MinisterThinking[0].AStarGreedy.Count; p++)
                           MinisterOnTable[i].MinisterThinking[0].AStarGreedy[p].HuristicAStarGreedySearch(AStarGreedyi, A, a, ref Less, Order, false);
                     */
                    Order = DummyOrder;
                    ChessRules.CurrentOrder = DummyCurrentOrder;
                }
                catch (Exception t)
                {

                }

                Order = DummyOrder;
                ChessRules.CurrentOrder = DummyCurrentOrder;
            }
            Order = DummyOrder;
            ChessRules.CurrentOrder = DummyCurrentOrder;

            for (i = KingMidle; i < KingHigh; i++)
            {
                for (int k = 0; k < AllDraw.KingMovments; k++)
                    try
                    {
                        for (j = 0; KingOnTable[i] != null && KingOnTable[i] != null && KingOnTable[i].KingThinking[k] != null && KingOnTable[i].KingThinking[k] != null && j < KingOnTable[i].KingThinking[k].TableListKing.Count; j++)
                        {
                            try
                            {
                                if (FormRefrigtz.OrderPlate == Order && AStarGreedyi == 1 && UsePenaltyRegardMechnisamT)
                                    if (KingOnTable[i].KingThinking[k].PenaltyRegardListKing[j].IsPenaltyAction() == 0)
                                        continue;
                                int CDummy = ChessRules.CurrentOrder;
                                int COrder = Order;
                                try
                                {
                                    ChessRules.CurrentOrder *= -1;
                                    Order *= -1;
                                    Do = 0;
                                    if (UsePenaltyRegardMechnisamT)
                                    {
                                        for (int ij = 0; ij < KingOnTable[i].KingThinking[k].AStarGreedy.Count - 1; ij++)
                                            KingOnTable[i].KingThinking[k].AStarGreedy[ij].IsPenaltyRegardCheckMateAtBranch(Order, ref Do, KingOnTable[i].KingThinking[k].AStarGreedy[ij]);
                                        Order = COrder;
                                        ChessRules.CurrentOrder = CDummy;
                                        ToCheckMate = -1; ForCheckMate = -1; AA = IsToCheckMateHasLessDeeperThanForCheckMate(this, Order, ref ToCheckMate, ref ForCheckMate, 0); if (Do == -1)
                                            continue;
                                    }

                                }
                                catch (Exception tt) { }
                                Order = COrder;
                                ChessRules.CurrentOrder = CDummy;
                                if (FormRefrigtz.OrderPlate == Order && AStarGreedyi == 1 && UsePenaltyRegardMechnisamT)
                                    if ((KingOnTable[i].KingThinking[k].PenaltyRegardListKing[j].IsPenaltyAction() != 0 && KingOnTable[i].KingThinking[k].PenaltyRegardListKing[j].IsRewardAction() == 1 && AStarGreedyi == 1) || Do == 1 || AA)
                                    {    //Set Table and Huristic Value and Syntax.
                                        bool Hit = false;
                                        if (KingOnTable[i].KingThinking[k].HitNumberKing[j] > 0)
                                            Hit = true;
                                        // if (Order == 1)
                                        //SyntaxToWrite = (new ChessRules(ChessRules( ArrangmentsChanged)).CreateStatistic(ArrangmentsChanged,TableHuristic, FormRefrigtz.MovmentsNumber, 6, KingOnTable[i].KingThinking[k].RowColumnKing[j][1], KingOnTable[i].KingThinking[k].RowColumnKing[j][0], Hit, KingOnTable[i].KingThinking[k].HitNumberKing[j], ChessRules.BridgeActBrown, false);
                                        // else
                                        //SyntaxToWrite = (new ChessRules(ChessRules( ArrangmentsChanged)).CreateStatistic(ArrangmentsChanged,TableHuristic, FormRefrigtz.MovmentsNumber, -6, KingOnTable[i].KingThinking[k].RowColumnKing[j][1], KingOnTable[i].KingThinking[k].RowColumnKing[j][0], Hit, KingOnTable[i].KingThinking[k].HitNumberKing[j], ChessRules.BridgeActBrown, false);

                                        FormRefrigtz.LastRow = KingOnTable[i].KingThinking[k].Row;
                                        FormRefrigtz.LastColumn = KingOnTable[i].KingThinking[k].Column;

                                        Act = true;
                                        Less = KingOnTable[i].KingThinking[k].ReturnHuristic(i, j, Order * -1);
                                        TableHuristic = KingOnTable[i].KingThinking[k].TableListKing[j];
                                        if (Do == 1 || AA)
                                            //return TableHuristic;
                                            continue;
                                    }
                                //When There is No Movments in Such Order Enemy continue.
                                if (Order != FormRefrigtz.OrderPlate)
                                    if (KingOnTable[i].KingThinking[0].ReturnHuristic(i, j, Order * -1) > Less)
                                        continue;


                                //When There is greater Huristic Movments.
                                if (KingOnTable[i].KingThinking[0].ReturnHuristic(i, j, Order * -1) > Less)
                                //retrive table of current huristic.
                                {
                                    if (AStarGreedyi == 1) ToFindMovments = true;

                                    //retrive table of current huristic.
                                    int[,] TableS = KingOnTable[i].KingThinking[k].TableListKing[j];
                                    //checked for Legal Movments ArgumentOutOfRangeException curnt game.
                                    if (DynamicAStarGreedytPrograming && !CurrentTableHuristic && AStarGreedyi == 1)
                                    {
                                        try
                                        {
                                            if (!isEnemyThingsinStable(TableS, AllDraw.TableListAction[AllDraw.TableListAction.Count - 1], FormRefrigtz.OrderPlate))
                                                continue;
                                        }
                                        catch (Exception t)
                                        {

                                            if (!isEnemyThingsinStable(TableS, AllDraw.TableListAction[AllDraw.TableListAction.Count - 1], FormRefrigtz.OrderPlate))
                                                continue;

                                        }

                                    }
                                    //When there is not Penalty regard mechanism.
                                    //if (!UsePenaltyRegardMechnisamT)
                                    {
                                        AB = new ChessRules(MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, 6, TableS, Order, KingOnTable[i].KingThinking[k].Row, KingOnTable[i].KingThinking[k].Column);
                                        //If there is kish or kshachamaz Order.
                                        if (AB.Check(TableS, Order))
                                        {
                                            //When Order is Gray.
                                            if (Order == 1)
                                            {
                                                //Continue When is kish CheckObjectDangour and AStarGreadyFirstSearch .
                                                if (AB.CheckGray)
                                                    continue;
                                            }
                                            else
                                            {
                                                //Continue when CheckBrown and AStarGreadyFirstSearch. 
                                                if (AB.CheckBrown)
                                                    continue;
                                            }
                                        }
                                        else
                                        {

                                        }

                                        //When Order is gray.
                                        /*if (Order == 1)
                                        {
                                            //When CheckGrayObjectDangour and There is not AStarGreedyt search.
                                            if (AB.CheckGray)
                                            {
                                                //predict Search.
                                                Color B;
                                                if (a == Color.Gray)
                                                    B = Color.Brown;
                                                else
                                                    B = Color.Gray;
                                                APredict.TableList.Clear();
                                                APredict.TableList.Add(TableS);
                                                APredict.SetRowColumn(0);
                                                TableHuristic = APredict.InitiatePerdictCheck((int)APredict.KingOnTable[i].Row, (int)APredict.KingOnTable[i].Column, B, TableS, Order, false);
                                                if (TableHuristic == null)
                                                    continue;

                                            }
                                        }
                                        else
                                        {
                                            if (AB.CheckBrown)
                                            {
                                                //predict Search.
                                                Color B;
                                                if (a == Color.Gray)
                                                    B = Color.Brown;
                                                else
                                                    B = Color.Gray;
                                                APredict.TableList.Clear();
                                                APredict.TableList.Add(TableS);
                                                APredict.SetRowColumn(0);
                                                TableHuristic = APredict.InitiatePerdictCheck((int)APredict.KingOnTable[i].Row, (int)APredict.KingOnTable[i].Column, B, TableS, Order, false);
                                                if (TableHuristic == null)
                                                    continue;
                                                else
                                                {
                                                    Act = true;
                                                    Less = KingOnTable[i].KingThinking[k].ReturnHuristic(i, j, Order*-1);
                                                    continue;
                                                }

                                            }
                                        }
                                         */

                                    }
                                    RW6 = i;
                                    CL6 = k;
                                    Ki6 = j;
                                    RW1 = -1;
                                    CL1 = -1;
                                    Ki1 = -1;
                                    RW2 = -1;
                                    CL2 = -1;
                                    Ki2 = -1;
                                    RW3 = -1;
                                    CL3 = -1;
                                    Ki3 = -1;
                                    RW4 = -1;
                                    CL4 = -1;
                                    Ki4 = -1;
                                    RW5 = -1;
                                    CL5 = -1;
                                    Ki5 = -1;
                                    MaxLess6 = (KingOnTable[RW6].KingThinking[CL6].ReturnHuristic(RW6, Ki6, Order * -1));
                                    if (MaxLess6 > MaxLess1)
                                        MaxLess1 = -1;
                                    if (MaxLess6 > MaxLess2)
                                        MaxLess2 = -1;
                                    if (MaxLess6 > MaxLess3)
                                        MaxLess3 = -1;
                                    if (MaxLess6 > MaxLess4)
                                        MaxLess4 = -1;
                                    if (MaxLess6 > MaxLess5)
                                        MaxLess5 = -1;
                                    if (AStarGreedyi == 1)
                                    {
                                        if (Order == 1)
                                        {
                                            //THIS.SetBoxText("\r\nChess Huristic King By Bob!");
                                            //THIS.RefreshBoxText();
                                        }
                                        else//If Order is Brown.
                                        {
                                            //THIS.SetBoxText("\r\nChess Huristic King By Alice!");
                                            //THIS.RefreshBoxText();
                                        }//Set Table and Huristic Value and Syntax.
                                        bool Hit = false;
                                        if (KingOnTable[i].KingThinking[k].HitNumberKing[j] > 0)
                                            Hit = true;
                                        // if (Order == 1)
                                        //SyntaxToWrite = (new ChessRules(ChessRules( ArrangmentsChanged)).CreateStatistic(ArrangmentsChanged,TableHuristic, FormRefrigtz.MovmentsNumber, 6, KingOnTable[i].KingThinking[k].RowColumnKing[j][1], KingOnTable[i].KingThinking[k].RowColumnKing[j][0], Hit, KingOnTable[i].KingThinking[k].HitNumberKing[j], ChessRules.BridgeActBrown, false);
                                        // else
                                        //SyntaxToWrite = (new ChessRules(ChessRules( ArrangmentsChanged)).CreateStatistic(ArrangmentsChanged,TableHuristic, FormRefrigtz.MovmentsNumber, -6, KingOnTable[i].KingThinking[k].RowColumnKing[j][1], KingOnTable[i].KingThinking[k].RowColumnKing[j][0], Hit, KingOnTable[i].KingThinking[k].HitNumberKing[j], ChessRules.BridgeActBrown, false);

                                        FormRefrigtz.LastRow = KingOnTable[i].KingThinking[k].Row;
                                        FormRefrigtz.LastColumn = KingOnTable[i].KingThinking[k].Column;

                                        Act = true;
                                        Less = KingOnTable[i].KingThinking[k].ReturnHuristic(i, j, Order * -1);
                                        TableHuristic = KingOnTable[i].KingThinking[k].TableListKing[j];

                                    }
                                }
                                else//Set Table and Huristic Value and Syntax.
                                {
                                    try
                                    {
                                        if (AStarGreedyi == 1)
                                        {
                                            if (Order == 1)
                                            {
                                                //THIS.SetBoxText("\r\nChess Huristic King By Bob!");
                                                //THIS.RefreshBoxText();
                                            }
                                            else//If Order is Brown.
                                            {
                                                //THIS.SetBoxText("\r\nChess Huristic King By Alice!");
                                                //THIS.RefreshBoxText();
                                            }//TakeRoot.Pointer = this;
                                            //Found of Max Non Probable Movments.
                                            Founded.Clear();
                                            double LessB = Double.MinValue; ;
                                            BeginIndexFoundingMaxLessofMaxList(0, Founded, ref LessB);
                                            if (Founded[0] != 1)
                                                continue;
                                            RW6 = (int)MaxHuristicAStarGreedytBackWard[0][(int)Founded[0]];
                                            CL6 = (int)MaxHuristicAStarGreedytBackWard[0][(int)Founded[0] + 1];
                                            Ki6 = (int)MaxHuristicAStarGreedytBackWard[0][(int)Founded[0] + 2];
                                            if (Founded[0] != MaxKingFounded)
                                                continue;
                                            bool Hit = false;
                                            if (KingOnTable[RW6].KingThinking[CL6].HitNumberKing[Ki6] > 0)
                                                Hit = true;
                                            //if (Order == 1)
                                            //SyntaxToWrite = (new ChessRules(ChessRules( ArrangmentsChanged)).CreateStatistic(ArrangmentsChanged,TableHuristic, FormRefrigtz.MovmentsNumber, 6, KingOnTable[RW6].KingThinking[CL6].RowColumnKing[Ki6][1], KingOnTable[RW6].KingThinking[CL6].RowColumnKing[Ki6][0], Hit, KingOnTable[RW6].KingThinking[CL6].HitNumberKing[Ki6], ChessRules.BridgeActBrown, false);
                                            //else
                                            //SyntaxToWrite = (new ChessRules(ChessRules( ArrangmentsChanged)).CreateStatistic(ArrangmentsChanged,TableHuristic, FormRefrigtz.MovmentsNumber, -6, KingOnTable[RW6].KingThinking[CL6].RowColumnKing[Ki6][1], KingOnTable[RW6].KingThinking[CL6].RowColumnKing[Ki6][0], Hit, KingOnTable[RW6].KingThinking[CL6].HitNumberKing[Ki6], ChessRules.BridgeActBrown, false);

                                            FormRefrigtz.LastRow = KingOnTable[RW6].KingThinking[CL6].Row;
                                            FormRefrigtz.LastColumn = KingOnTable[RW6].KingThinking[CL6].Column;

                                            Act = true;
                                            Less = KingOnTable[RW6].KingThinking[CL6].ReturnHuristic(RW6, Ki6, Order * -1);
                                            TableHuristic = KingOnTable[RW6].KingThinking[CL6].TableListKing[Ki6];
                                        }
                                    }
                                    catch (Exception t)
                                    { }

                                }

                                //else
                                {
                                }
                            }
                            catch (Exception t)
                            {

                            }
                        }
                    }
                    catch (Exception t)
                    {

                    }
                try
                {
                    /*Order *= -1;
                    ChessRules.CurrentOrder *= -1;
                    for (int p = 0; p < KingOnTable[i].KingThinking[0].AStarGreedy.Count; p++)
                        KingOnTable[i].KingThinking[0].AStarGreedy[p].HuristicAStarGreedySearch(AStarGreedyi, A, a, ref Less, Order, false);
                     */
                    Order = DummyOrder;
                    ChessRules.CurrentOrder = DummyCurrentOrder;
                }
                catch (Exception t)
                {

                }

                Order = DummyOrder;
                ChessRules.CurrentOrder = DummyCurrentOrder;
            }
            return TableHuristic;
        }
        //AStarGreedy First Huristic Method.
        public int[,] HuristicAStarGreedySearch(int AStarGreedyi, List<AllDraw> A, Color a, int Order, bool CurrentTableHuristic)
        {
            int[,] TableHuristic = new int[8, 8];

            ChessRules AB = null;
            AStarGreedyi++;
            bool AA = false;
            int Do = 0;
            // if (AStarGreedyi > MaxAStarGreedy)
            //   return TableHuristic;
            int DummyOrder = Order;
            int DummyCurrentOrder = ChessRules.CurrentOrder;
            //Initiate For Dynamic Backward Current AStarGreedyi Non Minus Founded Max Movments Detection Global Variables.
            List<double> Founded = new List<double>();
            //Initiateing Indicating Huristic Multiple Same Value Best Found of Movments.
            MaxLess1 = -1;
            MaxLess2 = -1;
            MaxLess3 = -1;
            MaxLess4 = -1;
            MaxLess5 = -1;
            MaxLess6 = -1;
            RW1 = -1;
            CL1 = -1;
            Ki1 = -1;
            RW2 = -1;
            CL2 = -1;
            Ki2 = -1;
            RW3 = -1;
            CL3 = -1;
            Ki3 = -1;
            RW4 = -1;
            CL4 = -1;
            Ki4 = -1;
            RW5 = -1;
            CL5 = -1;
            Ki5 = -1;
            RW6 = -1;
            CL6 = -1;
            Ki6 = -1;

            double[] BacWard = new double[25];
            if (AStarGreedyi > MaxAStarGreedy)
                return TableHuristic;
            int i = 0, j = 0;
            bool Act = false;
            int ToCheckMate = 0, ForCheckMate = 0;
            /*if (Order == 1)
            {
                //THIS.SetBoxText("\r\nChess Huristic By Bob!");
                //THIS.RefreshBoxText();
            }
            else//If Order is Brown.
            {
                //THIS.SetBoxText("\r\nChess Huristic By Alice!");
                //THIS.RefreshBoxText();
            }*/
            //When There is Some A.Count
            {
                //FormatException Every BridgeMovments.
                {
                    if (Order == 1)
                    {
                        TableHuristic = GrayHuristicAStarGreadySearch(AStarGreedyi, A, a, Order, CurrentTableHuristic, ref Act);
                    }
                    else
                    {
                        TableHuristic = BrownHuristicAStarGreaedySearch(AStarGreedyi, A, a, Order, CurrentTableHuristic, ref Act);
                    }

                }

            }
            Order = DummyOrder;
            ChessRules.CurrentOrder = DummyCurrentOrder;
            //Store In Local Variable and Dynamic Purpose Proccessing.
            //Every Non Minuse Non Idept in List Has Gretest Max Order.
            //Is Desired of Idept Oner Best Movments.
            BacWard[0] = AStarGreedyi;

            BacWard[1] = MaxLess1;
            BacWard[2] = RW1;
            BacWard[3] = RW1;
            BacWard[4] = Ki1;


            BacWard[5] = MaxLess2;
            BacWard[6] = RW2;
            BacWard[7] = RW2;
            BacWard[8] = Ki2;

            BacWard[9] = MaxLess3;
            BacWard[10] = RW3;
            BacWard[11] = RW3;
            BacWard[12] = Ki3;

            BacWard[13] = MaxLess4;
            BacWard[14] = RW4;
            BacWard[15] = RW4;
            BacWard[16] = Ki4;

            BacWard[17] = MaxLess5;
            BacWard[18] = RW5;
            BacWard[19] = RW5;
            BacWard[20] = Ki5;

            BacWard[21] = MaxLess6;
            BacWard[22] = RW6;
            BacWard[23] = RW6;
            BacWard[24] = Ki6;

            //We Have Information of Maximum of Huristic in Each Level and Table.
            MaxHuristicAStarGreedytBackWard.Add(BacWard);
            MaxHuristicAStarGreedytBackWardTable.Add(TableHuristic);

            Founded.Clear();
            //If Found retrun table.
            if (Act)
                return TableHuristic;
            //Return what found table.
            return TableHuristic;

        }
        //Common Non AStarGreedy Huristic Method.
        public int[,] Huristic(List<AllDraw> A, Color a, int ij, int Order)
        {
            //Inititae Local Varibales.
            int i = 0, j = 0;
            int[,] Table = new int[8, 8];
            ChessRules AA = null;
            bool Act = false;
            int ii = ij;
            //If List Exist.
            if (A.Count > 0)
            {
                //Fo All Soldeirs.
                for (i = 0; i < SodierHigh; i++)
                {
                    //Calculate Thinking Operation of Current Soldier.
                    for (int k = 0; k < AllDraw.SodierMovments; k++)
                        for (j = 0; SolderesOnTable[i] != null && SolderesOnTable[i].SoldierThinking[k] != null && j < SolderesOnTable[i].SoldierThinking[k].TableListSolder.Count; j++)
                        {
                            try
                            {
                                //If there is Penalty Situation Continue.
                                if (Order == FormRefrigtz.OrderPlate)
                                    if (SolderesOnTable[i].SoldierThinking[k].PenaltyRegardListSolder[j].IsPenaltyAction() == 0 && !NoTableFound)
                                        continue;
                                //For Higher Huristic Values.
                                if (SolderesOnTable[i].SoldierThinking[0].ReturnHuristic(i, j, Order) > Less)
                                {
                                    //Initiate Table of Current Object.
                                    int[,] TableS = SolderesOnTable[i].SoldierThinking[k].TableListSolder[j];

                                    {
                                        AA = new ChessRules(MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, 1, TableS, Order, SolderesOnTable[i].SoldierThinking[k].Row, SolderesOnTable[i].SoldierThinking[k].Column);
                                        //Achamaz Check CheckMate of Current Table.
                                        if (AA.ObjectDangourKingMove(Order, TableS, false) && !NoTableFound)
                                        {
                                            //If Order is Gray.
                                            if (Order == 1)
                                            {
                                                if (AA.CheckGrayObjectDangour && AStarGreadyFirstSearch)
                                                    continue;
                                            }
                                            else//If Order is Brown.
                                            {
                                                if (AA.CheckBrownObjectDangour && AStarGreadyFirstSearch)
                                                    continue;
                                            }
                                        }
                                    }
                                    if (Order == 1)//If Order is Gray.
                                    {
                                        //If CheckObjectDangour Occured and AStarGreedy Huristic Not Exist.
                                        if (AA.CheckGrayObjectDangour && !AStarGreadyFirstSearch)
                                        {
                                            //Prdeict Huristic.
                                            Color B;
                                            if (a == Color.Gray)
                                                B = Color.Brown;
                                            else
                                                B = Color.Gray;
                                            APredict.TableList.Clear();
                                            APredict.TableList.Add(TableS);
                                            APredict.SetRowColumn(0);
                                            Table = APredict.InitiatePerdictCheck((int)APredict.SolderesOnTable[i].Row, (int)APredict.SolderesOnTable[i].Column, B, TableS, Order, false);
                                            if (Table == null)
                                                continue;
                                            else
                                            {
                                                AA = new ChessRules(MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, 1, Table, FormRefrigtz.OrderPlate, -1, -1);
                                                AA.Check(Table, FormRefrigtz.OrderPlate);
                                                if (AA.CheckGray)
                                                {
                                                    Table = null;
                                                    continue;
                                                }
                                                if (FormRefrigtz.OrderPlate == -1 && AA.CheckGray)
                                                {
                                                    Table = null;
                                                    continue;
                                                } Act = true;
                                                Less = SolderesOnTable[i].SoldierThinking[k].ReturnHuristic(i, j, Order * -10);
                                                continue;
                                            }


                                        }
                                    }
                                    else
                                    {
                                        if (AA.CheckBrownObjectDangour && !AStarGreadyFirstSearch)
                                        {
                                            //Prdeict Huristic.
                                            Color B;
                                            if (a == Color.Gray)
                                                B = Color.Brown;
                                            else
                                                B = Color.Gray;
                                            APredict.TableList.Clear();
                                            APredict.TableList.Add(TableS);
                                            APredict.SetRowColumn(0);
                                            Table = APredict.InitiatePerdictCheck((int)(APredict.SolderesOnTable[i].Row), (int)APredict.SolderesOnTable[i].Column, B, TableS, Order, false);
                                            if (Table == null)
                                                continue;
                                            AA = new ChessRules(MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, 1, Table, FormRefrigtz.OrderPlate, -1, -1);
                                            AA.Check(Table, FormRefrigtz.OrderPlate);
                                            if (AA.CheckGray)
                                            {
                                                Table = null;
                                                continue;
                                            }
                                            if (FormRefrigtz.OrderPlate == -1 && AA.CheckGray)
                                            {
                                                Table = null;
                                                continue;
                                            }

                                        }
                                    }
                                    //Initaiet Local Varibale and Syntax and Table Found.
                                    RW = i;
                                    CL = k;
                                    Ki = 1;
                                    Act = true;
                                    FormRefrigtz.LastRow = SolderesOnTable[i].SoldierThinking[k].Row;
                                    FormRefrigtz.LastColumn = SolderesOnTable[i].SoldierThinking[k].Column;

                                    Less = SolderesOnTable[i].SoldierThinking[k].HuristicListSolder[j][0] + SolderesOnTable[i].SoldierThinking[k].HuristicListSolder[j][1] + SolderesOnTable[i].SoldierThinking[k].HuristicListSolder[j][2] + SolderesOnTable[i].SoldierThinking[k].HuristicListSolder[j][3];


                                    Table = SolderesOnTable[i].SoldierThinking[k].TableListSolder[j];
                                    bool Hit = false;
                                    if (SolderesOnTable[i].SoldierThinking[k].HitNumberSoldier[j] > 0)
                                        Hit = true;


                                    ThingsConverter.ActOfClickEqualTow = true;
                                    SolderesOnTable[i].ConvertOperation(SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][0], SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][1], a, SolderesOnTable[i].SoldierThinking[k].TableListSolder[j], Order, false, i);
                                    int Sign = 1;
                                    if (a == Color.Brown)
                                        Sign = -1;
                                    if (SolderesOnTable[i].Convert)
                                    {
                                        Hit = false;
                                        if (SolderesOnTable[i].SoldierThinking[k].HitNumberSoldier[j] > 0)
                                            Hit = true;

                                        if (SolderesOnTable[i].ConvertedToMinister)
                                            Table[SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][0], SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][1]] = 5 * Sign;
                                        else if (SolderesOnTable[i].ConvertedToBridge)
                                            Table[SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][0], SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][1]] = 4 * Sign;
                                        else if (SolderesOnTable[i].ConvertedToHourse)
                                            Table[SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][0], SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][1]] = 3 * Sign;
                                        else if (SolderesOnTable[i].ConvertedToElefant)
                                            Table[SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][0], SolderesOnTable[i].SoldierThinking[k].RowColumnSoldier[j][1]] = 2 * Sign;
                                        TableList.Clear();
                                        TableList.Add(Table);
                                        SetRowColumn(0);
                                        TableList.Clear();

                                    }


                                }
                            }
                            catch (Exception t)
                            {

                            }
                        }

                }
                //Calculate Thinking Operation of Current Elephant.                   
                for (i = 0; i < ElefantHigh; i++)
                {
                    for (int k = 0; k < AllDraw.ElefantMovments; k++)
                        for (j = 0; ElephantOnTable[i] != null && ElephantOnTable[i].ElefantThinking[k] != null && j < ElephantOnTable[i].ElefantThinking[k].TableListElefant.Count; j++)
                        {
                            try
                            {
                                //If there is Penalty Situation Continue.
                                if (Order == FormRefrigtz.OrderPlate)
                                    if (ElephantOnTable[i].ElefantThinking[k].PenaltyRegardListElefant[j].IsPenaltyAction() == 0 && !NoTableFound)
                                        continue;

                                //For Higher Huristic Values.
                                if (ElephantOnTable[i].ElefantThinking[0].ReturnHuristic(i, j, Order) > Less)
                                {

                                    //Initiate Table of Current Object.
                                    int[,] TableS = ElephantOnTable[i].ElefantThinking[k].TableListElefant[j];
                                    {
                                        AA = new ChessRules(MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, 2, TableS, Order, ElephantOnTable[i].ElefantThinking[k].Row, ElephantOnTable[i].ElefantThinking[k].Column);
                                        //Achamaz Check CheckMate of Current Table.
                                        if (AA.ObjectDangourKingMove(Order, TableS, false) && !NoTableFound)
                                        {
                                            //If Order is Gray.
                                            if (Order == 1)
                                            {
                                                if (AA.CheckGrayObjectDangour && AStarGreadyFirstSearch)
                                                    continue;
                                            }
                                            else//If Order is Brown.
                                            {
                                                if (AA.CheckBrownObjectDangour && AStarGreadyFirstSearch)
                                                    continue;
                                            }
                                        }
                                    }
                                    if (Order == 1)//If Order is Gray.
                                    {
                                        //If CheckObjectDangour Occured and AStarGreedy Huristic Not Exist.
                                        if (AA.CheckGrayObjectDangour && !AStarGreadyFirstSearch)
                                        {
                                            //Prdeict Huristic.
                                            Color B;
                                            if (a == Color.Gray)
                                                B = Color.Brown;
                                            else
                                                B = Color.Gray;
                                            APredict.TableList.Clear();
                                            APredict.TableList.Add(TableS);
                                            APredict.SetRowColumn(0);
                                            Table = APredict.InitiatePerdictCheck((int)(APredict.ElephantOnTable[i].Row), (int)APredict.ElephantOnTable[i].Column, B, TableS, Order, false);
                                            AA = new ChessRules(MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, 2, Table, FormRefrigtz.OrderPlate, -1, -1);
                                            AA.Check(Table, FormRefrigtz.OrderPlate);
                                            if (AA.CheckGray)
                                            {
                                                Table = null;
                                                continue;
                                            }
                                            if (FormRefrigtz.OrderPlate == -1 && AA.CheckGray)
                                            {
                                                Table = null;
                                                continue;
                                            } if (Table == null)
                                                continue;
                                            else
                                            {
                                                RW = i;
                                                CL = k;
                                                Ki = 1;
                                                Act = true;
                                                Less = ElephantOnTable[i].ElefantThinking[k].HuristicListElefant[j][0] + ElephantOnTable[i].ElefantThinking[k].HuristicListElefant[j][1] + ElephantOnTable[i].ElefantThinking[k].HuristicListElefant[j][2] + ElephantOnTable[i].ElefantThinking[k].HuristicListElefant[j][3];

                                            }
                                        }
                                    }
                                    else
                                    {
                                        if (AA.CheckBrownObjectDangour && !AStarGreadyFirstSearch)
                                        {
                                            //Prdeict Huristic.
                                            Color B;
                                            if (a == Color.Gray)
                                                B = Color.Brown;
                                            else
                                                B = Color.Gray;
                                            APredict.TableList.Clear();
                                            APredict.TableList.Add(TableS);
                                            APredict.SetRowColumn(ii);
                                            Table = APredict.InitiatePerdictCheck((int)APredict.ElephantOnTable[i].Row, (int)APredict.ElephantOnTable[i].Column, B, TableS, Order, false);
                                            if (Table == null)
                                                continue;
                                            AA = new ChessRules(MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, 1, Table, FormRefrigtz.OrderPlate, -1, -1);
                                            AA.Check(Table, FormRefrigtz.OrderPlate);
                                            if (AA.CheckGray)
                                            {
                                                Table = null;
                                                continue;
                                            }
                                            if (FormRefrigtz.OrderPlate == -1 && AA.CheckGray)
                                            {
                                                Table = null;
                                                continue;
                                            }


                                        }
                                    }
                                    //Initaiet Local Varibale and Syntax and Table Found.
                                    bool Hit = false;
                                    if (ElephantOnTable[i].ElefantThinking[k].HitNumberElefant[j] > 0)
                                        Hit = true;

                                    FormRefrigtz.LastRow = ElephantOnTable[i].ElefantThinking[k].Row;
                                    FormRefrigtz.LastColumn = ElephantOnTable[i].ElefantThinking[k].Column;

                                    RW = i;
                                    CL = k;
                                    Ki = 2;
                                    Act = true;
                                    Less = ElephantOnTable[i].ElefantThinking[k].HuristicListElefant[j][0] + ElephantOnTable[i].ElefantThinking[k].HuristicListElefant[j][1] + ElephantOnTable[i].ElefantThinking[k].HuristicListElefant[j][2] + ElephantOnTable[i].ElefantThinking[k].HuristicListElefant[j][3];
                                    Table = ElephantOnTable[i].ElefantThinking[k].TableListElefant[j];

                                }
                            }
                            catch (Exception t)
                            {

                            }
                        }

                }
                //Calculate Thinking Operation of Current Hourse.                   
                for (i = 0; i < HourseHight; i++)
                {

                    for (int k = 0; k < AllDraw.HourseMovments; k++)
                        for (j = 0; HoursesOnTable[i] != null && HoursesOnTable[i].HourseThinking[k] != null && j < HoursesOnTable[i].HourseThinking[k].TableListHourse.Count; j++)
                        {
                            try
                            {
                                //If there is Penalty Situation Continue.
                                if (Order == FormRefrigtz.OrderPlate)
                                    if (HoursesOnTable[i].HourseThinking[k].PenaltyRegardListHourse[j].IsPenaltyAction() == 0 && !NoTableFound)
                                        continue;


                                //For Higher Huristic Values.
                                if (HoursesOnTable[i].HourseThinking[0].ReturnHuristic(i, j, Order) > Less)
                                {
                                    //Initiate Table of Current Object.
                                    int[,] TableS = HoursesOnTable[i].HourseThinking[k].TableListHourse[j];
                                    {
                                        {
                                            AA = new ChessRules(MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, 3, TableS, Order, HoursesOnTable[i].HourseThinking[k].Row, HoursesOnTable[i].HourseThinking[k].Column);
                                            //Achamaz Check CheckMate of Current Table.
                                            if (AA.ObjectDangourKingMove(Order, TableS, false) && !NoTableFound)
                                            {
                                                //If Order is Gray.
                                                if (Order == 1)
                                                {
                                                    if (AA.CheckGrayObjectDangour && AStarGreadyFirstSearch)
                                                        continue;
                                                }
                                                else//If Order is Brown.
                                                {
                                                    if (AA.CheckBrownObjectDangour && AStarGreadyFirstSearch)
                                                        continue;
                                                }
                                            }
                                            else
                                            {

                                            }
                                        }
                                    }

                                    if (Order == 1)//If Order is Gray.
                                    {
                                        //If CheckObjectDangour Occured and AStarGreedy Huristic Not Exist.
                                        if (AA.CheckGrayObjectDangour && !AStarGreadyFirstSearch)
                                        {
                                            //Prdeict Huristic.
                                            Color B;
                                            if (a == Color.Gray)
                                                B = Color.Brown;
                                            else
                                                B = Color.Gray;
                                            APredict.TableList.Clear();
                                            APredict.TableList.Add(TableS);
                                            APredict.SetRowColumn(0);
                                            Table = APredict.InitiatePerdictCheck((int)APredict.HoursesOnTable[i].Row, (int)APredict.HoursesOnTable[i].Column, B, TableS, Order, false);
                                            if (Table == null)
                                                continue;
                                            AA = new ChessRules(MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, 3, Table, FormRefrigtz.OrderPlate, -1, -1);
                                            AA.Check(Table, FormRefrigtz.OrderPlate);
                                            if (AA.CheckGray)
                                            {
                                                Table = null;
                                                continue;
                                            }
                                            if (FormRefrigtz.OrderPlate == -1 && AA.CheckGray)
                                            {
                                                Table = null;
                                                continue;
                                            }
                                        }
                                    }
                                    else
                                    {
                                        if (AA.CheckBrownObjectDangour && !AStarGreadyFirstSearch)
                                        {
                                            //Prdeict Huristic.
                                            Color B;
                                            if (a == Color.Gray)
                                                B = Color.Brown;
                                            else
                                                B = Color.Gray;
                                            APredict.TableList.Clear();
                                            APredict.TableList.Add(TableS);
                                            APredict.SetRowColumn(0);
                                            Table = APredict.InitiatePerdictCheck((int)APredict.HoursesOnTable[i].Row, (int)APredict.HoursesOnTable[i].Column, B, TableS, Order, false);
                                            if (Table == null)
                                                continue;
                                            else
                                            {
                                                AA = new ChessRules(MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, 3, Table, FormRefrigtz.OrderPlate, -1, -1);
                                                AA.Check(Table, FormRefrigtz.OrderPlate);
                                                if (AA.CheckGray)
                                                {
                                                    Table = null;
                                                    continue;
                                                }
                                                if (FormRefrigtz.OrderPlate == -1 && AA.CheckGray)
                                                {
                                                    Table = null;
                                                    continue;
                                                }
                                                RW = i;
                                                CL = k;
                                                Ki = 1;
                                                Act = true;
                                                Less = HoursesOnTable[i].HourseThinking[k].HuristicListHourse[j][0] + HoursesOnTable[i].HourseThinking[k].HuristicListHourse[j][1] + HoursesOnTable[i].HourseThinking[k].HuristicListHourse[j][2] + HoursesOnTable[i].HourseThinking[k].HuristicListHourse[j][3];
                                                continue;
                                            }

                                        }
                                    }
                                    //Initaiet Local Varibale and Syntax and Table Found.
                                    bool Hit = false;
                                    if (HoursesOnTable[i].HourseThinking[k].HitNumberHourse[j] > 0)
                                        Hit = true;
                                    FormRefrigtz.LastRow = HoursesOnTable[i].HourseThinking[k].Row;
                                    FormRefrigtz.LastColumn = HoursesOnTable[i].HourseThinking[k].Column;

                                    RW = i;
                                    CL = k;
                                    Ki = 3;
                                    Act = true;
                                    Less = HoursesOnTable[i].HourseThinking[k].HuristicListHourse[j][0] + HoursesOnTable[i].HourseThinking[k].HuristicListHourse[j][1] + HoursesOnTable[i].HourseThinking[k].HuristicListHourse[j][2] + HoursesOnTable[i].HourseThinking[k].HuristicListHourse[j][3];
                                    Table = HoursesOnTable[i].HourseThinking[k].TableListHourse[j];

                                }
                            }
                            catch (Exception t)
                            {

                            }
                        }


                }
                //Calculate Thinking Operation of Current Bridges.
                for (i = 0; i < BridgeHigh; i++)
                {
                    for (int k = 0; k < AllDraw.BridgeMovments; k++)
                        for (j = 0; BridgesOnTable[i] != null && BridgesOnTable[i].BridgeThinking[k] != null && j < BridgesOnTable[i].BridgeThinking[k].TableListBridge.Count; j++)
                        {
                            try
                            {
                                //If there is Penalty Situation Continue.
                                if (Order == FormRefrigtz.OrderPlate)
                                    if (BridgesOnTable[i].BridgeThinking[k].PenaltyRegardListBridge[j].IsPenaltyAction() == 0 && !NoTableFound)
                                        continue;
                                //For Higher Huristic Values.
                                if (BridgesOnTable[i].BridgeThinking[0].ReturnHuristic(i, j, Order) > Less)
                                {
                                    //Initiate Table of Current Object.
                                    int[,] TableS = BridgesOnTable[i].BridgeThinking[k].TableListBridge[j];
                                    {
                                        AA = new ChessRules(MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, 4, TableS, Order, BridgesOnTable[i].BridgeThinking[k].Row, BridgesOnTable[i].BridgeThinking[k].Column);
                                        //Achamaz Check CheckMate of Current Table.
                                        if (AA.ObjectDangourKingMove(Order, TableS, false) && !NoTableFound)
                                        {
                                            //If Order is Gray.
                                            if (Order == 1)
                                            {
                                                if (AA.CheckGrayObjectDangour && AStarGreadyFirstSearch)
                                                    continue;
                                            }
                                            else//If Order is Brown.
                                            {
                                                if (AA.CheckBrownObjectDangour && AStarGreadyFirstSearch)
                                                    continue;
                                            }
                                        }
                                    }
                                    if (Order == 1)//If Order is Gray.
                                    {
                                        //If CheckObjectDangour Occured and AStarGreedy Huristic Not Exist.
                                        if (AA.CheckGrayObjectDangour && !AStarGreadyFirstSearch)
                                        {
                                            //Prdeict Huristic.
                                            Color B;
                                            if (a == Color.Gray)
                                                B = Color.Brown;
                                            else
                                                B = Color.Gray;
                                            APredict.TableList.Clear();
                                            APredict.TableList.Add(TableS);
                                            APredict.SetRowColumn(0);
                                            Table = APredict.InitiatePerdictCheck((int)APredict.BridgesOnTable[i].Row, (int)APredict.BridgesOnTable[i].Column, B, TableS, Order, false);
                                            if (Table == null)
                                                continue;
                                            AA = new ChessRules(MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, 4, Table, FormRefrigtz.OrderPlate, -1, -1);
                                            AA.Check(Table, FormRefrigtz.OrderPlate);
                                            if (AA.CheckGray)
                                            {
                                                Table = null;
                                                continue;
                                            }
                                            if (FormRefrigtz.OrderPlate == -1 && AA.CheckGray)
                                            {
                                                Table = null;
                                                continue;
                                            }

                                        }
                                    }
                                    else
                                    {
                                        if (AA.CheckBrownObjectDangour && !AStarGreadyFirstSearch)
                                        {
                                            //Prdeict Huristic.
                                            Color B;
                                            if (a == Color.Gray)
                                                B = Color.Brown;
                                            else
                                                B = Color.Gray;
                                            APredict.TableList.Clear();
                                            APredict.TableList.Add(TableS);
                                            APredict.SetRowColumn(0);
                                            Table = APredict.InitiatePerdictCheck((int)BridgesOnTable[i].Row, (int)BridgesOnTable[i].Column, B, TableS, Order, false);
                                            if (Table == null)
                                                continue;
                                            else
                                            {
                                                AA = new ChessRules(MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, 4, Table, FormRefrigtz.OrderPlate, -1, -1);
                                                AA.Check(Table, FormRefrigtz.OrderPlate);
                                                if (AA.CheckGray)
                                                    continue;
                                                if (FormRefrigtz.OrderPlate == -1 && AA.CheckGray)
                                                    continue;

                                                RW = i;
                                                CL = k;
                                                Ki = 1;
                                                Act = true;
                                                Less = BridgesOnTable[i].BridgeThinking[k].HuristicListBridge[j][0] + BridgesOnTable[i].BridgeThinking[k].HuristicListBridge[j][1] + BridgesOnTable[i].BridgeThinking[k].HuristicListBridge[j][2] + BridgesOnTable[i].BridgeThinking[k].HuristicListBridge[j][3];

                                                continue;
                                            }
                                        }
                                    }
                                    //Initaiet Local Varibale and Syntax and Table Found.
                                    bool Hit = false;
                                    if (BridgesOnTable[i].BridgeThinking[k].HitNumberBridge[j] > 0)
                                        Hit = true;

                                    FormRefrigtz.LastRow = BridgesOnTable[i].BridgeThinking[k].Row;
                                    FormRefrigtz.LastColumn = BridgesOnTable[i].BridgeThinking[k].Column;

                                    RW = i;
                                    CL = k;
                                    Ki = 4;
                                    Act = true;
                                    Less = BridgesOnTable[i].BridgeThinking[k].ReturnHuristic(i, j, Order);
                                    Table = BridgesOnTable[i].BridgeThinking[k].TableListBridge[j];

                                }
                            }
                            catch (Exception t)
                            {

                            }
                        }

                }
                //Calculate Thinking Operation of Current Minister.          
                for (i = 0; i < MinisterHigh; i++)
                {
                    for (int k = 0; k < AllDraw.MinisterMovments; k++)
                        for (j = 0; MinisterOnTable[i] != null && MinisterOnTable[i].MinisterThinking[k] != null && j < MinisterOnTable[i].MinisterThinking[k].TableListMinister.Count; j++)
                        {
                            try
                            {
                                //If there is Penalty Situation Continue.
                                if (Order == FormRefrigtz.OrderPlate)
                                    if (MinisterOnTable[i].MinisterThinking[k].PenaltyRegardListMinister[j].IsPenaltyAction() == 0 && !NoTableFound)
                                        continue;
                                //For Higher Huristic Values.
                                if (MinisterOnTable[i].MinisterThinking[k].ReturnHuristic(i, j, Order) > Less)
                                {
                                    //Initiate Table of Current Object.
                                    int[,] TableS = MinisterOnTable[i].MinisterThinking[k].TableListMinister[j];
                                    {
                                        {
                                            AA = new ChessRules(MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, 5, TableS, Order, MinisterOnTable[i].MinisterThinking[k].Row, MinisterOnTable[i].MinisterThinking[k].Column);
                                            //Achamaz Check CheckMate of Current Table.
                                            if (AA.ObjectDangourKingMove(Order, TableS, false) && !NoTableFound)
                                            {
                                                //If Order is Gray.
                                                if (Order == 1)
                                                {
                                                    if (AA.CheckGrayObjectDangour && AStarGreadyFirstSearch)
                                                        continue;
                                                }
                                                else//If Order is Brown.
                                                {
                                                    if (AA.CheckBrownObjectDangour && AStarGreadyFirstSearch)
                                                        continue;
                                                }
                                            }
                                        }
                                    }
                                    if (Order == 1)//If Order is Gray.
                                    {
                                        //If CheckObjectDangour Occured and AStarGreedy Huristic Not Exist.
                                        if (AA.CheckGrayObjectDangour && !AStarGreadyFirstSearch)
                                        {
                                            //Prdeict Huristic.
                                            Color B;
                                            if (a == Color.Gray)
                                                B = Color.Brown;
                                            else
                                                B = Color.Gray;
                                            APredict.TableList.Clear();
                                            APredict.TableList.Add(TableS);
                                            APredict.SetRowColumn(0);
                                            Table = APredict.InitiatePerdictCheck((int)APredict.MinisterOnTable[i].Row, (int)APredict.MinisterOnTable[i].Column, B, TableS, Order, false);
                                            if (Table == null)
                                                continue;
                                            AA = new ChessRules(MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, 5, Table, FormRefrigtz.OrderPlate, -1, -1);
                                            AA.Check(Table, FormRefrigtz.OrderPlate);
                                            if (AA.CheckGray)
                                            {
                                                Table = null;
                                                continue;
                                            }
                                            if (FormRefrigtz.OrderPlate == -1 && AA.CheckGray)
                                            {
                                                Table = null;
                                                continue;
                                            }

                                        }

                                    }
                                    else
                                    {
                                        if (AA.CheckBrownObjectDangour && !AStarGreadyFirstSearch)
                                        {
                                            //Prdeict Huristic.
                                            Color B;
                                            if (a == Color.Gray)
                                                B = Color.Brown;
                                            else
                                                B = Color.Gray;
                                            APredict.TableList.Clear();
                                            APredict.TableList.Add(TableS);
                                            APredict.SetRowColumn(0);
                                            if (null == APredict.InitiatePerdictCheck((int)APredict.MinisterOnTable[i].Row, (int)APredict.MinisterOnTable[i].Column, B, TableS, Order, false))
                                                continue;

                                        }
                                    }
                                    //Initaiet Local Varibale and Syntax and Table Found.
                                    bool Hit = false;
                                    if (MinisterOnTable[i].MinisterThinking[k].HitNumberMinister[j] > 0)
                                        Hit = true;

                                    FormRefrigtz.LastRow = MinisterOnTable[i].MinisterThinking[k].Row;
                                    FormRefrigtz.LastColumn = MinisterOnTable[i].MinisterThinking[k].Column;

                                    RW = i;
                                    CL = k;
                                    Ki = 5;
                                    Act = true;
                                    Less = MinisterOnTable[i].MinisterThinking[k].HuristicListMinister[j][0] + MinisterOnTable[i].MinisterThinking[k].HuristicListMinister[j][1] + MinisterOnTable[i].MinisterThinking[k].HuristicListMinister[j][2] + MinisterOnTable[i].MinisterThinking[k].HuristicListMinister[j][3];
                                    Table = MinisterOnTable[i].MinisterThinking[k].TableListMinister[j];

                                }
                            }
                            catch (Exception t)
                            {

                            }
                        }

                }
                //Calculate Thinking Operation of Current King.                   
                for (i = 0; i < KingHigh; i++)
                {
                    for (int k = 0; k < AllDraw.KingMovments; k++)
                        for (j = 0; KingOnTable[i] != null && KingOnTable[i].KingThinking[k] != null && j < KingOnTable[i].KingThinking[k].TableListKing.Count; j++)
                        {
                            try
                            {
                                //If there is Penalty Situation Continue.
                                if (Order == FormRefrigtz.OrderPlate)
                                    if (KingOnTable[i].KingThinking[k].PenaltyRegardListKing[j].IsPenaltyAction() == 0 && !NoTableFound)
                                        continue;
                                //For Higher Huristic Values.
                                if (KingOnTable[i].KingThinking[0].ReturnHuristic(i, j, Order) > Less)
                                {
                                    //Initiate Table of Current Object.
                                    int[,] TableS = KingOnTable[i].KingThinking[k].TableListKing[j];
                                    {
                                        AA = new ChessRules(MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, 6, TableS, Order, KingOnTable[i].KingThinking[k].Row, KingOnTable[i].KingThinking[k].Column);
                                        //Achamaz Check CheckMate of Current Table.
                                        if (AA.ObjectDangourKingMove(Order, TableS, false) && !NoTableFound)
                                        {
                                            //If Order is Gray.
                                            if (Order == 1)
                                            {
                                                if (AA.CheckGrayObjectDangour && AStarGreadyFirstSearch)
                                                    continue;
                                            }
                                            else//If Order is Brown.
                                            {
                                                if (AA.CheckBrownObjectDangour && AStarGreadyFirstSearch)
                                                    continue;
                                            }
                                        }
                                        else
                                        {

                                        }
                                    }
                                    if (Order == 1)//If Order is Gray.
                                    {
                                        //If CheckObjectDangour Occured and AStarGreedy Huristic Not Exist.
                                        if (AA.CheckGrayObjectDangour && !AStarGreadyFirstSearch)
                                        {
                                            //Prdeict Huristic.
                                            Color B;
                                            if (a == Color.Gray)
                                                B = Color.Brown;
                                            else
                                                B = Color.Gray;
                                            APredict.TableList.Clear();
                                            APredict.TableList.Add(TableS);
                                            APredict.SetRowColumn(0);
                                            Table = APredict.InitiatePerdictCheck((int)APredict.KingOnTable[i].Row, (int)APredict.KingOnTable[i].Column, B, TableS, Order, false);
                                            if (Table == null)
                                                continue;
                                            AA = new ChessRules(MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, 6, Table, FormRefrigtz.OrderPlate, -1, -1);
                                            AA.Check(Table, FormRefrigtz.OrderPlate);
                                            if (AA.CheckGray)
                                            {
                                                Table = null;
                                                continue;
                                            }
                                            if (FormRefrigtz.OrderPlate == -1 && AA.CheckGray)
                                            {
                                                Table = null;
                                                continue;
                                            }

                                        }
                                    }
                                    else
                                    {
                                        if (AA.CheckBrownObjectDangour && !AStarGreadyFirstSearch)
                                        {
                                            //Prdeict Huristic.
                                            Color B;
                                            if (a == Color.Gray)
                                                B = Color.Brown;
                                            else
                                                B = Color.Gray;
                                            APredict.TableList.Clear();
                                            APredict.TableList.Add(TableS);
                                            APredict.SetRowColumn(0);
                                            Table = APredict.InitiatePerdictCheck((int)APredict.KingOnTable[i].Row, (int)APredict.KingOnTable[i].Column, B, TableS, Order, false);
                                            if (Table == null)
                                                continue;
                                            AA = new ChessRules(MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, 6, Table, FormRefrigtz.OrderPlate, -1, -1);
                                            AA.Check(Table, FormRefrigtz.OrderPlate);
                                            if (AA.CheckGray)
                                            {
                                                Table = null;
                                                continue;
                                            }
                                            if (FormRefrigtz.OrderPlate == -1 && AA.CheckGray)
                                            {
                                                Table = null;
                                                continue;
                                            }
                                            else
                                            {
                                                RW = i;
                                                CL = k;
                                                Ki = 1;
                                                Act = true;
                                                Less = KingOnTable[i].KingThinking[k].HuristicListKing[j][0] + KingOnTable[i].KingThinking[k].HuristicListKing[j][1] + KingOnTable[i].KingThinking[k].HuristicListKing[j][2] + KingOnTable[i].KingThinking[k].HuristicListKing[j][3];
                                                continue;
                                            }

                                        }
                                    }
                                    //Initaiet Local Varibale and Syntax and Table Found.
                                    bool Hit = false;
                                    if (MinisterOnTable[i].MinisterThinking[k].HitNumberMinister[j] > 0)
                                        Hit = true;

                                    FormRefrigtz.LastRow = KingOnTable[i].KingThinking[k].Row;
                                    FormRefrigtz.LastColumn = KingOnTable[i].KingThinking[k].Column;

                                    RW = i;
                                    CL = k;
                                    Ki = 6;
                                    Act = true;
                                    Less = KingOnTable[i].KingThinking[k].ReturnHuristic(i, j, Order);
                                    Table = KingOnTable[i].KingThinking[k].TableListKing[j];

                                }
                            }
                            catch (Exception t)
                            {

                            }
                        }

                }
            }
            //If There is A Movments Return Table.
            if (Act)
                return Table;
            //What Kind Of Table.

            return Table;
        }
        //Genethic Algorithm Game Method.
        public void InitiateGenetic(int ii, int jj, Color a, int[,] Table, int Order, bool TB)
        {
            //Initiate Local and Global Variables.
            int Current = ChessRules.CurrentOrder;
            int DummyOrder = Order;
            ADraw.Clear();
            TableList.Clear();
            TableList.Add(Table);
            SetRowColumn(0);
            TableList.Clear();
            ThinkingChess.NotSolvedKingDanger = false;
            LoopHuristicIndex = 0;
            //For One time.
            for (int i = 0; i < 1; i++)
            {
                //If Order is Gray.
                if (Order == 1)
                {
                    //THIS.SetBoxText("\r\nChess Genetic By Bob!");
                    //THIS.RefreshBoxText();
                }
                else//If Order is Brown.
                {
                    //THIS.SetBoxText("\r\nChess Genetic By Alice!");
                    //THIS.RefreshBoxText();

                }
                //Initiate Local Variables.
                int[,] TablInit = new int[8, 8];
                if (Order == 1)
                    a = Color.Gray;
                else
                    a = Color.Brown;
                int In = 0;
                //Found Of Random Movments.
                do
                {
                    if (Order == 1)
                        In = (new System.Random()).Next(0, 8);
                    else
                        In = (new System.Random()).Next(8, 16);
                } while (SolderesOnTable[In] == null);


                //If Order is Gray.
                if (Order == 1)
                {
                    //THIS.SetBoxText("\r\nGenetic Algorithm Begin AStarGreedy " + i.ToString() + " By Bob!");
                    //THIS.RefreshBoxText();
                }
                else//If Order is Brown.
                {
                    //THIS.SetBoxText("\r\nGenetic Algirithm Begin AStarGreedy " + i.ToString() + " By Alice!");
                    //THIS.RefreshBoxText();

                }
                //Found Of Genetic Algorithm Movments By GeneticAlgorithm Call Objectsand Method.
                ChessGeneticAlgorithm R = (new ChessGeneticAlgorithm(MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged));
                //Found Table.
                int[,] Tab = R.GenerateTable(TableListAction, 0, Order);
                //If Order is Gray.
                if (Order == 1)
                {
                    //THIS.SetBoxText("\r\nGenetic Algorithm Finsished AStarGreedy " + i.ToString() + " By Bob!");
                    //THIS.RefreshBoxText();
                }
                else//If Order is Brown.
                {
                    //THIS.SetBoxText("\r\nGenetic Algirithm Finished AStarGreedy " + i.ToString() + " By Alice!");
                    //THIS.RefreshBoxText();

                }

                //If Table Found.
                if (Tab != null)
                {
                    //Construct a Clone Copy of Table.
                    for (int iii = 0; iii < 8; iii++)
                        for (int jjj = 0; jjj < 8; jjj++)
                        {
                            TablInit[iii, jjj] = Tab[iii, jjj];
                        }
                    //Initiate a Table.
                    Table = new int[8, 8];
                    //Construct a Clone Copy of Table.
                    for (int iii = 0; iii < 8; iii++)
                        for (int jjj = 0; jjj < 8; jjj++)
                        {
                            Table[iii, jjj] = TablInit[iii, jjj];
                        }
                    //Initiate Local and Global Varibales.
                    TableList.Add(TablInit);
                    ClList.Add(CL);
                    RWList.Add(RW);
                    KiList.Add(Ki);
                    // Order = Order * -1;
                    // ChessRules.CurrentOrder = Order;
                    AStarGreedy++;
                    //return;

                }
            }
            //Determination of CheckMate Consideration.
            (new ChessRules(MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, 1, Table, Order, -1, -1)).CheckMate(Table, Order);

            //Reconstruction of Order Global Varibales.
            Order = DummyOrder;
            ChessRules.CurrentOrder = Current;


        }
       
        void do_check(System.Collections.Concurrent.ConcurrentBag<Task> t)
        {
            WaitSome = true;
            try
            {
                foreach (Task ij in t)
                {
                    ij.Start();
                    //Thread.Sleep(10);
                }


                Parallel.ForEach(t, items => Task.WaitAll(items));
            }
            catch (Exception tt)
            {

            }
            WaitSome = false;
        }
        //AStarGreedy First Initiat Thinking Main Method.
        public AllDraw InitiateAStarGreedytOneNode(int iAStarGreedy, int ii, int jj, Color a, int[,] Tab, int Order, int iIndex, int KindIndex
            )
        {
            SetObjectNumbers(Tab);
            List<Task> ThA = new List<Task>();
            int[,] Table = new int[8, 8];
            for (int iii = 0; iii < 8; iii++)
                for (int jjj = 0; jjj < 8; jjj++)
                    Table[iii, jjj] = Tab[iii, jjj];
            var parallelOptions = new ParallelOptions();
            parallelOptions.MaxDegreeOfParallelism = PlatformHelper.ProcessorCount;
            ThinkingChess.BeginThread = 0;
            ThinkingChess.EndThread = 0;
            //Initiate of global Variables Byte Local Variables.
            int DummyOrder = new int();
            DummyOrder = Order;
            int DummyCurrentOrder = new int();
            DummyCurrentOrder = ChessRules.CurrentOrder;
            List<Task> tH = new List<Task>();
            bool SA = false;
            bool EA = false;
            bool HA = false;
            bool BA = false;
            bool MA = false;
            bool KA = false;
            bool MaxNotFound = true;
            int i = 0, ik = 0;
            int[,] TablInit = new int[8, 8];
            if (Order == 1)
                a = Color.Gray;
            else
                a = Color.Brown;
            int j = 0;
            if (iAStarGreedy >= MaxAStarGreedy)
                return null;
            iAStarGreedy++;

            {
                //Initiate Of Local Variables.
                {


                    {
                        //If Order is Gray.
                        if (Order == 1)
                        {
                            //For Gray Soldeirs Objects. 
                            //                    for (i = 0; i < SodierMidle; i++)
                            if (KindIndex == 1)
                            {
                                try
                                {
                                    Order = DummyOrder;
                                    ChessRules.CurrentOrder = DummyCurrentOrder;
                                    //If Solders Not Exist Continue and Traversal Back.
                                    //If There is no Thinking Movments on Current Object 
                                    if (FormRefrigtz.Blitz)
                                    {
                                        //Thinking of Gray Solder Operation.
                                        SolderesOnTable[iIndex].SoldierThinking[0].ThinkingBegin = true;
                                        SolderesOnTable[iIndex].SoldierThinking[0].ThinkingFinished = false;
                                        SolderesOnTable[iIndex].SoldierThinking[0].t = new Task(new Action(SolderesOnTable[iIndex].SoldierThinking[0].Thinking));
                                        SolderesOnTable[iIndex].SoldierThinking[0].t.Start();
                                        if (SolderesOnTable[iIndex].SoldierThinking[0].t != null) { Object tttt = new Object(); lock (tttt) { tH.Add(SolderesOnTable[iIndex].SoldierThinking[0].t); } }
                                    }
                                    else if (!FormRefrigtz.Blitz)
                                    //If There is A Soldeir Movments.                                   
                                    {

                                        //Thinking of Gray Soldeir Operations.
                                        SolderesOnTable[iIndex].SoldierThinking[0].ThinkingBegin = true;
                                        SolderesOnTable[iIndex].SoldierThinking[0].ThinkingFinished = false;
                                        SolderesOnTable[iIndex].SoldierThinking[0].t = new Task(new Action(SolderesOnTable[iIndex].SoldierThinking[0].Thinking));
                                        SolderesOnTable[iIndex].SoldierThinking[0].t.Start();
                                        if (SolderesOnTable[iIndex].SoldierThinking[0].t != null) { Object tttt = new Object(); lock (tttt) { tH.Add(SolderesOnTable[iIndex].SoldierThinking[0].t); } }
                                    }
                                }
                                catch (Exception t)
                                {
                                    //SolderesOnTable[iIndex] = null;

                                }
                            }
                            //Progressing.
                            //For All Gray Elephant Objects.

                            if (KindIndex == 2)
                            {
                                try
                                {
                                    Order = DummyOrder;
                                    ChessRules.CurrentOrder = DummyCurrentOrder;
                                    //Ignore of Non Exist Current Elephant Gray Objects.
                                    if (FormRefrigtz.Blitz)
                                    {
                                        //Operational Thinking Gray Elephant. 
                                        ElephantOnTable[iIndex].ElefantThinking[0].ThinkingBegin = true;
                                        ElephantOnTable[iIndex].ElefantThinking[0].ThinkingFinished = false;
                                        ElephantOnTable[iIndex].ElefantThinking[0].t = new Task(new Action(ElephantOnTable[iIndex].ElefantThinking[0].Thinking));
                                        ElephantOnTable[iIndex].ElefantThinking[0].t.Start();
                                        if (ElephantOnTable[iIndex].ElefantThinking[0].t != null) { Object tttt = new Object(); lock (tttt) { tH.Add(ElephantOnTable[iIndex].ElefantThinking[0].t); } }
                                    }//If There is Movment Thinking Gary Elphant Object List.
                                    else if (!FormRefrigtz.Blitz)
                                    {
                                        //For Every Gray Elephant Thinking Movments.
                                        //Gray Elephant Object Thinking Operations.
                                        ElephantOnTable[iIndex].ElefantThinking[0].ThinkingBegin = true;
                                        ElephantOnTable[iIndex].ElefantThinking[0].ThinkingFinished = false;
                                        ElephantOnTable[iIndex].ElefantThinking[0].t = new Task(new Action(ElephantOnTable[iIndex].ElefantThinking[0].Thinking));
                                        ElephantOnTable[iIndex].ElefantThinking[0].t.Start();
                                        if (ElephantOnTable[iIndex].ElefantThinking[0].t != null) { Object tttt = new Object(); lock (tttt) { tH.Add(ElephantOnTable[iIndex].ElefantThinking[0].t); } }
                                    }
                                }
                                catch (Exception t)
                                {

                                }
                            }
                            //Progressing.

                            //For All Gray Hourse Objects.
                            if (KindIndex == 3)
                            {
                                try
                                {
                                    Order = DummyOrder;
                                    ChessRules.CurrentOrder = DummyCurrentOrder;

                                    if (FormRefrigtz.Blitz)
                                    {
                                        //Thinking of Gray Hourse Oprational.
                                        HoursesOnTable[iIndex].HourseThinking[0].ThinkingBegin = true;
                                        HoursesOnTable[iIndex].HourseThinking[0].ThinkingFinished = false;
                                        HoursesOnTable[iIndex].HourseThinking[0].t = new Task(new Action(HoursesOnTable[iIndex].HourseThinking[0].Thinking));
                                        HoursesOnTable[iIndex].HourseThinking[0].t.Start();
                                        if (HoursesOnTable[iIndex].HourseThinking[0].t != null) { Object tttt = new Object(); lock (tttt) { tH.Add(HoursesOnTable[iIndex].HourseThinking[0].t); } }
                                    }
                                    else if (!FormRefrigtz.Blitz)//If Table List Exist int The Thinking.
                                    {

                                        //Thinking Operation of Gray Hourse.
                                        HoursesOnTable[iIndex].HourseThinking[0].TableT = HoursesOnTable[iIndex].HourseThinking[0].TableListHourse[j];
                                        HoursesOnTable[iIndex].HourseThinking[0].ThinkingBegin = true;
                                        HoursesOnTable[iIndex].HourseThinking[0].ThinkingFinished = false;
                                        HoursesOnTable[iIndex].HourseThinking[0].t = new Task(new Action(HoursesOnTable[iIndex].HourseThinking[0].Thinking));
                                        HoursesOnTable[iIndex].HourseThinking[0].t.Start();
                                        if (HoursesOnTable[iIndex].HourseThinking[0].t != null) { Object tttt = new Object(); lock (tttt) { tH.Add(HoursesOnTable[iIndex].HourseThinking[0].t); } }
                                    }
                                }
                                catch (Exception t)
                                {

                                }
                            }
                            //Progressing.


                            if (KindIndex == 4)
                            {
                                try
                                {
                                    Order = DummyOrder;
                                    ChessRules.CurrentOrder = DummyCurrentOrder;
                                    if (FormRefrigtz.Blitz)
                                    {
                                        //When There is Possible Thinking Bridge of Gray Table
                                        //Thinking of Gray Bridges Operational.
                                        BridgesOnTable[iIndex].BridgeThinking[0].ThinkingBegin = true;
                                        BridgesOnTable[iIndex].BridgeThinking[0].ThinkingFinished = false;
                                        BridgesOnTable[iIndex].BridgeThinking[0].t = new Task(new Action(BridgesOnTable[iIndex].BridgeThinking[0].Thinking));
                                        BridgesOnTable[iIndex].BridgeThinking[0].t.Start();
                                        if (BridgesOnTable[iIndex].BridgeThinking[0].t != null) { Object tttt = new Object(); lock (tttt) { tH.Add(BridgesOnTable[iIndex].BridgeThinking[0].t); } }

                                    }
                                    else if (!FormRefrigtz.Blitz)
                                    {
                                        //When There is Possible Thinking Bridge of Gray Table
                                        //Thinking of Gray Bridges  Objective Movments.
                                        BridgesOnTable[iIndex].BridgeThinking[0].TableT = BridgesOnTable[iIndex].BridgeThinking[0].TableListBridge[j];
                                        BridgesOnTable[iIndex].BridgeThinking[0].ThinkingBegin = true;
                                        BridgesOnTable[iIndex].BridgeThinking[0].ThinkingFinished = false;
                                        BridgesOnTable[iIndex].BridgeThinking[0].t = new Task(new Action(BridgesOnTable[iIndex].BridgeThinking[0].Thinking));
                                        BridgesOnTable[iIndex].BridgeThinking[0].t.Start();
                                        if (BridgesOnTable[iIndex].BridgeThinking[0].t != null) { Object tttt = new Object(); lock (tttt) { tH.Add(BridgesOnTable[iIndex].BridgeThinking[0].t); } }
                                    }
                                }
                                catch (Exception t)
                                {

                                }
                            }
                            if (KindIndex == 5)
                            {
                                try
                                {
                                    Order = DummyOrder;
                                    ChessRules.CurrentOrder = DummyCurrentOrder;
                                    if (FormRefrigtz.Blitz)
                                    {//When There is Table Gray Minister Count of Thinking.
                                        //Thinking of Gray Minister Operational.
                                        MinisterOnTable[iIndex].MinisterThinking[0].ThinkingBegin = true;
                                        MinisterOnTable[iIndex].MinisterThinking[0].ThinkingFinished = false;
                                        //MinisterOnTable[iIndex].MinisterThinking[0].t = new Task(new Action(MinisterOnTable[iIndex].MinisterThinking[0].Thinking));
                                        MinisterOnTable[iIndex].MinisterThinking[0].t.Start();
                                        if (MinisterOnTable[iIndex].MinisterThinking[0].t != null) { Object tttt = new Object(); lock (tttt) { tH.Add(MinisterOnTable[iIndex].MinisterThinking[0].t); } }
                                    }
                                    else if (!FormRefrigtz.Blitz)//When There is Table Gray Minister Count of Thinking.
                                    {
                                        //Thinking.
                                        MinisterOnTable[iIndex].Table = MinisterOnTable[iIndex].MinisterThinking[0].TableListMinister[j];
                                        MinisterOnTable[iIndex].MinisterThinking[0].ThinkingBegin = true;
                                        MinisterOnTable[iIndex].MinisterThinking[0].ThinkingFinished = false;
                                        //MinisterOnTable[iIndex].MinisterThinking[0].t = new Task(new Action(MinisterOnTable[iIndex].MinisterThinking[0].Thinking));
                                        MinisterOnTable[iIndex].MinisterThinking[0].t.Start();
                                        if (MinisterOnTable[iIndex].MinisterThinking[0].t != null) { Object tttt = new Object(); lock (tttt) { tH.Add(MinisterOnTable[iIndex].MinisterThinking[0].t); } }
                                    }
                                }
                                catch (Exception t)
                                {

                                }
                            }

                            if (KindIndex == 6)
                            {

                                try
                                {
                                    Order = DummyOrder;
                                    ChessRules.CurrentOrder = DummyCurrentOrder;
                                    if (FormRefrigtz.Blitz)
                                    {//When Thinking Gray King Count of Existing Operations.
                                        //Thinking Of Gray King Operatins.
                                        KingOnTable[iIndex].KingThinking[0].ThinkingBegin = true;
                                        KingOnTable[iIndex].KingThinking[0].ThinkingFinished = false;
                                        KingOnTable[iIndex].KingThinking[0].t = new Task(new Action(KingOnTable[iIndex].KingThinking[0].Thinking));
                                        KingOnTable[iIndex].KingThinking[0].t.Start();
                                        if (KingOnTable[iIndex].KingThinking[0].t != null) { Object tttt = new Object(); lock (tttt) { tH.Add(KingOnTable[iIndex].KingThinking[0].t); } }
                                    }
                                    else if (!FormRefrigtz.Blitz)//When Thinking Gray King Count of Existing Operations.
                                    {
                                        //Gray King Thinking Operations.                                        
                                        KingOnTable[iIndex].KingThinking[0].ThinkingBegin = true;
                                        KingOnTable[iIndex].KingThinking[0].ThinkingFinished = false;
                                        KingOnTable[iIndex].KingThinking[0].t = new Task(new Action(KingOnTable[iIndex].KingThinking[0].Thinking));
                                        KingOnTable[iIndex].KingThinking[0].t.Start();
                                        if (KingOnTable[iIndex].KingThinking[0].t != null) { Object tttt = new Object(); lock (tttt) { tH.Add(KingOnTable[iIndex].KingThinking[0].t); } }
                                    }
                                }
                                catch (Exception t)
                                {
                                    // KingOnTable[iIndex] = null;

                                }
                            }
                        }
                        else//Brown Order Considarations.
                        {

                            if (KindIndex == -1)
                            {
                                try
                                {
                                    Order = DummyOrder;
                                    ChessRules.CurrentOrder = DummyCurrentOrder;
                                    if (FormRefrigtz.Blitz)//When There is Current Brown Existing Objective Thinking Movments.
                                    {
                                        //Wheen Brown King Object There is Not Continue Traversal Back.
                                        //Thinking Operations of Brown Current Objects.
                                        SolderesOnTable[iIndex].SoldierThinking[0].ThinkingBegin = true;
                                        SolderesOnTable[iIndex].SoldierThinking[0].ThinkingFinished = false;
                                        SolderesOnTable[iIndex].SoldierThinking[0].t = new Task(new Action(SolderesOnTable[iIndex].SoldierThinking[0].Thinking));
                                        SolderesOnTable[iIndex].SoldierThinking[0].t.Start();
                                        if (SolderesOnTable[iIndex].SoldierThinking[0].t != null) { Object tttt = new Object(); lock (tttt) { tH.Add(SolderesOnTable[iIndex].SoldierThinking[0].t); } }

                                    }

                                    else if (!FormRefrigtz.Blitz)//When There is Current Brown Existing Objective Thinking Movments.
                                    {
                                        //Thinking of Thinking Brown CurrentTable Objective Operations.
                                        SolderesOnTable[iIndex].SoldierThinking[0].ThinkingBegin = true;
                                        SolderesOnTable[iIndex].SoldierThinking[0].ThinkingFinished = false;
                                        SolderesOnTable[iIndex].SoldierThinking[0].t = new Task(new Action(SolderesOnTable[iIndex].SoldierThinking[0].Thinking));
                                        SolderesOnTable[iIndex].SoldierThinking[0].t.Start();
                                        if (SolderesOnTable[iIndex].SoldierThinking[0].t != null) { Object tttt = new Object(); lock (tttt) { tH.Add(SolderesOnTable[iIndex].SoldierThinking[0].t); } }

                                    }
                                }
                                catch (Exception t)
                                {

                                }
                            }
                            if (KindIndex == -2)
                            {
                                try
                                {
                                    if (FormRefrigtz.Blitz)
                                    {//When There is Current Brown Existing Objective Thinking Movments.
                                        Order = DummyOrder;
                                        ChessRules.CurrentOrder = DummyCurrentOrder;
                                        //Thinking Operations of Brown Current Objects.
                                        ElephantOnTable[iIndex].ElefantThinking[0].ThinkingBegin = true;
                                        ElephantOnTable[iIndex].ElefantThinking[0].ThinkingFinished = false;
                                        ElephantOnTable[iIndex].ElefantThinking[0].t = new Task(new Action(ElephantOnTable[iIndex].ElefantThinking[0].Thinking));
                                        ElephantOnTable[iIndex].ElefantThinking[0].t.Start();
                                        if (ElephantOnTable[iIndex].ElefantThinking[0].t != null) { Object tttt = new Object(); lock (tttt) { tH.Add(ElephantOnTable[iIndex].ElefantThinking[0].t); } }
                                    }
                                    else if (!FormRefrigtz.Blitz)//When There is Current Brown Existing Objective Thinking Movments.
                                    {
                                        //Inititae Local Varibale By Global Gray Elephant Objects Varibales.
                                        //Thinking of Thinking Brown CurrentTable Objective Operations.                                                   
                                        ElephantOnTable[iIndex].ElefantThinking[0].ThinkingBegin = true;
                                        ElephantOnTable[iIndex].ElefantThinking[0].ThinkingFinished = false;
                                        ElephantOnTable[iIndex].ElefantThinking[0].t = new Task(new Action(ElephantOnTable[iIndex].ElefantThinking[0].Thinking));
                                        ElephantOnTable[iIndex].ElefantThinking[0].t.Start();
                                        if (ElephantOnTable[iIndex].ElefantThinking[0].t != null) { Object tttt = new Object(); lock (tttt) { tH.Add(ElephantOnTable[iIndex].ElefantThinking[0].t); } }
                                    }
                                }
                                catch (Exception t)
                                {

                                }
                            }
                            //Progressing.
                            try
                            {
                                EA = true;
                                //IncreaseprogressBarRefregitzValue(//THIS.progressBarVerify, increasedProgress);
                                //THIS.progressBarVerify.Invalidate();
                                //SetprogressBarUpdate(//THIS.progressBarVerify);
                            }
                            catch (Exception t) { }


                            if (KindIndex == -3)
                            {
                                try
                                {
                                    Order = DummyOrder;
                                    ChessRules.CurrentOrder = DummyCurrentOrder;
                                    if (!FormRefrigtz.Blitz)
                                    {//When There is Current Brown Existing Objective Thinking Movments.
                                        //Thinking Operations of Brown Current Objects.
                                        //HoursesOnTable[iIndex].HourseThinking[0].TableT = HoursesOnTable[iIndex].HourseThinking[0].TableT;
                                        HoursesOnTable[iIndex].HourseThinking[0].ThinkingBegin = true;
                                        HoursesOnTable[iIndex].HourseThinking[0].ThinkingFinished = false;
                                        HoursesOnTable[iIndex].HourseThinking[0].t = new Task(new Action(HoursesOnTable[iIndex].HourseThinking[0].Thinking));
                                        HoursesOnTable[iIndex].HourseThinking[0].t.Start();
                                        if (HoursesOnTable[iIndex].HourseThinking[0].t != null) { Object tttt = new Object(); lock (tttt) { tH.Add(HoursesOnTable[iIndex].HourseThinking[0].t); } }
                                    }
                                    else if (!FormRefrigtz.Blitz)//When There is Current Brown Existing Objective Thinking Movments.
                                    {
                                        //Thinking of Thinking Brown CurrentTable Objective Operations.                                          SolderesOnTable[iIndex].SoldierThinking[0].Table = SolderesOnTable[iIndex].SoldierThinking[0].TableListSolder[j];
                                        HoursesOnTable[iIndex].HourseThinking[0].ThinkingBegin = true;
                                        HoursesOnTable[iIndex].HourseThinking[0].ThinkingFinished = false;
                                        HoursesOnTable[iIndex].HourseThinking[0].t = new Task(new Action(HoursesOnTable[iIndex].HourseThinking[0].Thinking));
                                        HoursesOnTable[iIndex].HourseThinking[0].t.Start();
                                        if (HoursesOnTable[iIndex].HourseThinking[0].t != null) { Object tttt = new Object(); lock (tttt) { tH.Add(HoursesOnTable[iIndex].HourseThinking[0].t); } }


                                    }
                                }
                                catch (Exception t)
                                {

                                }
                            }
                            //Progressing.




                            if (KindIndex == -4)
                            {
                                try
                                {
                                    Order = DummyOrder;
                                    ChessRules.CurrentOrder = DummyCurrentOrder;
                                    if (!FormRefrigtz.Blitz)
                                    {//When There is Current Brown Existing Objective Thinking Movments.
                                        //Thinking Operations of Brown Current Objects.
                                        BridgesOnTable[iIndex].BridgeThinking[0].ThinkingBegin = true;
                                        BridgesOnTable[iIndex].BridgeThinking[0].ThinkingFinished = false;
                                        BridgesOnTable[iIndex].BridgeThinking[0].t = new Task(new Action(BridgesOnTable[iIndex].BridgeThinking[0].Thinking));
                                        BridgesOnTable[iIndex].BridgeThinking[0].t.Start();
                                        if (BridgesOnTable[iIndex].BridgeThinking[0].t != null) { Object tttt = new Object(); lock (tttt) { tH.Add(BridgesOnTable[iIndex].BridgeThinking[0].t); } }
                                    }
                                    else if (!FormRefrigtz.Blitz)//When There is Current Brown Existing Objective Thinking Movments.
                                    {
                                        //Thinking of Thinking Brown CurrentTable Objective Operations.        
                                        BridgesOnTable[iIndex].BridgeThinking[0].ThinkingBegin = true;
                                        BridgesOnTable[iIndex].BridgeThinking[0].ThinkingFinished = false;
                                        BridgesOnTable[iIndex].BridgeThinking[0].t = new Task(new Action(BridgesOnTable[iIndex].BridgeThinking[0].Thinking));
                                        BridgesOnTable[iIndex].BridgeThinking[0].t.Start();
                                        if (BridgesOnTable[iIndex].BridgeThinking[0].t != null) { Object tttt = new Object(); lock (tttt) { tH.Add(BridgesOnTable[iIndex].BridgeThinking[0].t); } }
                                    }
                                }
                                catch (Exception t)
                                {

                                }
                            }
                            try
                            {
                                BA = true;
                                //IncreaseprogressBarRefregitzValue(//THIS.progressBarVerify, increasedProgress);
                                //THIS.progressBarVerify.Invalidate();
                                //SetprogressBarUpdate(//THIS.progressBarVerify);
                            }
                            catch (Exception t) { }
                            if (KindIndex == -5)
                            {
                                try
                                {
                                    Order = DummyOrder;
                                    ChessRules.CurrentOrder = DummyCurrentOrder;
                                    if (!FormRefrigtz.Blitz)
                                    {//When There is Current Brown Existing Objective Thinking Movments.
                                        //Thinking Operations of Brown Current Objects.
                                        MinisterOnTable[iIndex].MinisterThinking[0].ThinkingBegin = true;
                                        MinisterOnTable[iIndex].MinisterThinking[0].ThinkingFinished = false;
                                        MinisterOnTable[iIndex].MinisterThinking[0].t = new Task(new Action(MinisterOnTable[iIndex].MinisterThinking[0].Thinking));
                                        MinisterOnTable[iIndex].MinisterThinking[0].t.Start();
                                        if (MinisterOnTable[iIndex].MinisterThinking[0].t != null) { Object tttt = new Object(); lock (tttt) { tH.Add(MinisterOnTable[iIndex].MinisterThinking[0].t); } }
                                    }
                                    else if (!FormRefrigtz.Blitz)//When There is Current Brown Existing Objective Thinking Movments.
                                    {
                                        //Thinking of Thinking Brown CurrentTable Objective Operations.                                          SolderesOnTable[iIndex].SoldierThinking[0].Table = SolderesOnTable[iIndex].SoldierThinking[0].TableListSolder[j];
                                        MinisterOnTable[iIndex].MinisterThinking[0].ThinkingBegin = true;
                                        MinisterOnTable[iIndex].MinisterThinking[0].ThinkingFinished = false;
                                        MinisterOnTable[iIndex].MinisterThinking[0].t = new Task(new Action(MinisterOnTable[iIndex].MinisterThinking[0].Thinking));
                                        MinisterOnTable[iIndex].MinisterThinking[0].t.Start();
                                        if (MinisterOnTable[iIndex].MinisterThinking[0].t != null) { Object tttt = new Object(); lock (tttt) { tH.Add(MinisterOnTable[iIndex].MinisterThinking[0].t); } }

                                    }
                                }
                                catch (Exception t)
                                {

                                }
                            }
                            //Progressing.
                            try
                            {
                                MA = true;
                                //IncreaseprogressBarRefregitzValue(//THIS.progressBarVerify, increasedProgress);
                                //THIS.progressBarVerify.Invalidate();
                                //SetprogressBarUpdate(//THIS.progressBarVerify);
                            }
                            catch (Exception t) { }

                            if (KindIndex == -6)
                            {
                                try
                                {
                                    Order = DummyOrder;
                                    ChessRules.CurrentOrder = DummyCurrentOrder;
                                    if (!FormRefrigtz.Blitz)
                                    {//When There is Current Brown Existing Objective Thinking Movments.
                                        //Thinking Operations of Brown Current Objects.
                                        KingOnTable[iIndex].KingThinking[0].ThinkingBegin = true;
                                        KingOnTable[iIndex].KingThinking[0].ThinkingFinished = false;
                                        KingOnTable[iIndex].KingThinking[0].t = new Task(new Action(KingOnTable[iIndex].KingThinking[0].Thinking));
                                        KingOnTable[iIndex].KingThinking[0].t.Start();
                                        if (KingOnTable[iIndex].KingThinking[0].t != null) { Object tttt = new Object(); lock (tttt) { tH.Add(KingOnTable[iIndex].KingThinking[0].t); } }

                                    }
                                    else if (!FormRefrigtz.Blitz)//When There is Current Brown Existing Objective Thinking Movments.
                                    {
                                        //Thinking of Thinking Brown CurrentTable Objective Operations.       
                                        KingOnTable[iIndex].KingThinking[0].TableT = KingOnTable[iIndex].KingThinking[0].TableListKing[j];
                                        KingOnTable[iIndex].KingThinking[0].ThinkingBegin = true;
                                        KingOnTable[iIndex].KingThinking[0].ThinkingFinished = false;
                                        KingOnTable[iIndex].KingThinking[0].t = new Task(new Action(KingOnTable[iIndex].KingThinking[0].Thinking));
                                        KingOnTable[iIndex].KingThinking[0].t.Start();
                                        if (KingOnTable[iIndex].KingThinking[0].t != null) { Object tttt = new Object(); lock (tttt) { tH.Add(KingOnTable[iIndex].KingThinking[0].t); } }

                                    }

                                }
                                catch (Exception t)
                                {
                                    KingOnTable[iIndex] = null;

                                }
                            }
                            try
                            {
                                //IncreaseprogressBarRefregitzValue(//THIS.progressBarVerify, increasedProgress);
                                //THIS.progressBarVerify.Invalidate();
                                //SetprogressBarUpdate(//THIS.progressBarVerify);
                            }
                            catch (Exception t) { }
                        }
                    }
                    //Thread arrayT = new Thread(() => do_check(tH));
                    //rayT.Start();

                    //ile (WaitSome) { Thread.Sleep(1000); }
                    {
                        try
                        {
                            /*foreach (Task ij in tH)
                            {
                                ij.Start();
                                //Thread.Sleep(10);
                            }
                             */


                            Parallel.ForEach(tH, items => Task.WaitAll(items));
                        }
                        catch (Exception tt)
                        {

                        }
                    }
                }
                //while ((ThinkingChess.BeginThread) != (ThinkingChess.EndThread))
                //{
            }
            bool FOUND = false;
            if (KindIndex == 1 || KindIndex == -1)
            {
                SolderesOnTable[iIndex].SoldierThinking[0].AStarGreedy.Add(new AllDraw(MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, ref THIS));
                SolderesOnTable[iIndex].SoldierThinking[0].AStarGreedy[SolderesOnTable[iIndex].SoldierThinking[0].AStarGreedy.Count - 1].TableList.Clear();
                SolderesOnTable[iIndex].SoldierThinking[0].AStarGreedy[SolderesOnTable[iIndex].SoldierThinking[0].AStarGreedy.Count - 1].TableList.Add(CloneATable(Tab));
                SolderesOnTable[iIndex].SoldierThinking[0].AStarGreedy[SolderesOnTable[iIndex].SoldierThinking[0].AStarGreedy.Count - 1].SetRowColumn(0);
                SolderesOnTable[iIndex].SoldierThinking[0].AStarGreedy[SolderesOnTable[iIndex].SoldierThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt(iAStarGreedy, ii, jj, a, Tab, Order * -1, false, FOUND);
            }
            else
                if (KindIndex == 2 || KindIndex == -2)
                {
                    ElephantOnTable[iIndex].ElefantThinking[0].AStarGreedy.Add(new AllDraw(MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, ref THIS));
                    ElephantOnTable[iIndex].ElefantThinking[0].AStarGreedy[ElephantOnTable[iIndex].ElefantThinking[0].AStarGreedy.Count - 1].TableList.Clear();
                    ElephantOnTable[iIndex].ElefantThinking[0].AStarGreedy[ElephantOnTable[iIndex].ElefantThinking[0].AStarGreedy.Count - 1].TableList.Add(CloneATable(Tab));
                    ElephantOnTable[iIndex].ElefantThinking[0].AStarGreedy[ElephantOnTable[iIndex].ElefantThinking[0].AStarGreedy.Count - 1].SetRowColumn(0);
                    ElephantOnTable[iIndex].ElefantThinking[0].AStarGreedy[ElephantOnTable[iIndex].ElefantThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt(iAStarGreedy, ii, jj, a, Tab, Order * -1, false, FOUND);
                }
                else
                    if (KindIndex == 3 || KindIndex == -3)
                    {
                        HoursesOnTable[iIndex].HourseThinking[0].AStarGreedy.Add(new AllDraw(MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, ref THIS));
                        HoursesOnTable[iIndex].HourseThinking[0].AStarGreedy[HoursesOnTable[iIndex].HourseThinking[0].AStarGreedy.Count - 1].TableList.Clear();
                        HoursesOnTable[iIndex].HourseThinking[0].AStarGreedy[HoursesOnTable[iIndex].HourseThinking[0].AStarGreedy.Count - 1].TableList.Add(CloneATable(Tab));
                        HoursesOnTable[iIndex].HourseThinking[0].AStarGreedy[HoursesOnTable[iIndex].HourseThinking[0].AStarGreedy.Count - 1].SetRowColumn(0);
                        HoursesOnTable[iIndex].HourseThinking[0].AStarGreedy[HoursesOnTable[iIndex].HourseThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt(iAStarGreedy, ii, jj, a, Tab, Order * -1, false, FOUND);
                    }
                    else
                        if (KindIndex == 4 || KindIndex == -4)
                        {
                            BridgesOnTable[iIndex].BridgeThinking[0].AStarGreedy.Add(new AllDraw(MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, ref THIS));
                            BridgesOnTable[iIndex].BridgeThinking[0].AStarGreedy[BridgesOnTable[iIndex].BridgeThinking[0].AStarGreedy.Count - 1].TableList.Clear();
                            BridgesOnTable[iIndex].BridgeThinking[0].AStarGreedy[BridgesOnTable[iIndex].BridgeThinking[0].AStarGreedy.Count - 1].TableList.Add(CloneATable(Tab));
                            BridgesOnTable[iIndex].BridgeThinking[0].AStarGreedy[BridgesOnTable[iIndex].BridgeThinking[0].AStarGreedy.Count - 1].SetRowColumn(0);
                            BridgesOnTable[iIndex].BridgeThinking[0].AStarGreedy[BridgesOnTable[iIndex].BridgeThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt(iAStarGreedy, ii, jj, a, Tab, Order * -1, false, FOUND);
                        }
                        else
                            if (KindIndex == 5 || KindIndex == -5)
                            {
                                MinisterOnTable[iIndex].MinisterThinking[0].AStarGreedy.Add(new AllDraw(MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, ref THIS));
                                MinisterOnTable[iIndex].MinisterThinking[0].AStarGreedy[MinisterOnTable[iIndex].MinisterThinking[0].AStarGreedy.Count - 1].TableList.Clear();
                                MinisterOnTable[iIndex].MinisterThinking[0].AStarGreedy[MinisterOnTable[iIndex].MinisterThinking[0].AStarGreedy.Count - 1].TableList.Add(CloneATable(Tab));
                                MinisterOnTable[iIndex].MinisterThinking[0].AStarGreedy[MinisterOnTable[iIndex].MinisterThinking[0].AStarGreedy.Count - 1].SetRowColumn(0);
                                MinisterOnTable[iIndex].MinisterThinking[0].AStarGreedy[MinisterOnTable[iIndex].MinisterThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt(iAStarGreedy, ii, jj, a, Tab, Order * -1, false, FOUND);
                            }
                            else
                                if (KindIndex == 6 || KindIndex == -6)
                                {
                                    KingOnTable[iIndex].KingThinking[0].AStarGreedy.Add(new AllDraw(MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, ref THIS));
                                    KingOnTable[iIndex].KingThinking[0].AStarGreedy[MinisterOnTable[iIndex].MinisterThinking[0].AStarGreedy.Count - 1].TableList.Clear();
                                    KingOnTable[iIndex].KingThinking[0].AStarGreedy[MinisterOnTable[iIndex].MinisterThinking[0].AStarGreedy.Count - 1].TableList.Add(CloneATable(Tab));
                                    KingOnTable[iIndex].KingThinking[0].AStarGreedy[MinisterOnTable[iIndex].MinisterThinking[0].AStarGreedy.Count - 1].SetRowColumn(0);
                                    KingOnTable[iIndex].KingThinking[0].AStarGreedy[MinisterOnTable[iIndex].MinisterThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt(iAStarGreedy, ii, jj, a, Tab, Order * -1, false, FOUND);
                                }
            //                } 
            Order = DummyOrder;
            ChessRules.CurrentOrder = DummyCurrentOrder;



            Order = DummyOrder;
            ChessRules.CurrentOrder = DummyCurrentOrder;
            if (iAStarGreedy == 1)
                ThinkingFinished = true;
            return this;//.CopyRemeiningItems(Dummy, Order);
            //return 
            //>;
        }

        //AStarGreedy First Initiat Thinking Main Method.
        public AllDraw InitiateAStarGreedyt(int iAStarGreedy, int ii, int jj, Color a, int[,] Tab, int Order, bool TB, bool FOUND//, ref Refrigtz.Timer timer, ref Refrigtz.Timer TimerColor, ref double Less
            )
        {
            SetObjectNumbers(Tab);
            List<Task> ThA = new List<Task>();
            int[,] Table = new int[8, 8];
            for (int iii = 0; iii < 8; iii++)
                for (int jjj = 0; jjj < 8; jjj++)
                    Table[iii, jjj] = Tab[iii, jjj];
            var parallelOptions = new ParallelOptions();
            parallelOptions.MaxDegreeOfParallelism = PlatformHelper.ProcessorCount;
            ThinkingChess.BeginThread = 0;
            ThinkingChess.EndThread = 0;
            //Initiate of global Variables Byte Local Variables.
            int DummyOrder = new int();
            DummyOrder = Order;
            int DummyCurrentOrder = new int();
            DummyCurrentOrder = ChessRules.CurrentOrder;
            List<Task> tH = new List<Task>();
            bool SA = false;
            bool EA = false;
            bool HA = false;
            bool BA = false;
            bool MA = false;
            bool KA = false;
            bool MaxNotFound = true;
            int i = 0, ik = 0;
            int[,] TablInit = new int[8, 8];
            if (Order == 1)
                a = Color.Gray;
            else
                a = Color.Brown;
            int j = 0;
            if (iAStarGreedy >= MaxAStarGreedy)
                return null;
            iAStarGreedy++;

            if (!FOUND)
            {

                /*try
                         {
                             Program.StackOverflowDetector.Recur();

                         }
                         catch (Exception t)
                         {
                             return null;
                         }

                 */


                //Retrun Recursive Method Condition.
                // ChessRules AAA = new ChessRules(MovementsAStarGreedyHuristicFoundT,IgnoreSelfObjectsT,UsePenaltyRegardMechnisamT,BestMovmentsT,PredictHuristicT,OnlySelfT,AStarGreedyHuristicT,ArrangmentsChanged,Order);
                //if (AAA.CheckMate(Table, Order)) 
                //  if (AAA.CheckMateGray || AAA.CheckMateBrown)                
                //       return null;

                //     if (ThinkingChess.FoundFirstMating > MaxAStarGreedy)
                //       return null;


                //if (MovementsAStarGreedyHuristicFoundT && iAStarGreedy != 1)
                //    return null;
                //Incrimentes of Recursive Varibale.
                //End Refrigtz.Timer Condition Limitation.
                //timer.MidleAStarGreedytTimer(iAStarGreedy);
                //Mathematicall Formula for Calculation AStarGreedytMaxLevel Not Work.
                //int //S = (TimerColor.AStarGreedytiLevelMaxInitiate(timer, iAStarGreedy));
                //if (S == 1)
                //AStarGreedyiLevelMax += 1;
                //else
                //have to Zero. Non Decreamet Algorithm not found.
                //AStarGreedyiLevelMax = 0;
                //Consideration of Recursive Condition.
                //if (iAStarGreedy > AStarGreedyiLevelMax && iAStarGreedy != 1 && !FormRefrigtz.Blitz)
                //   {

                //      return null;
                //  } 
                //Initiate of Local Varibales.
                //If Order is Gray.
                /*if (Order == 1)
                {
                    //THIS.SetBoxText("\r\nChess Thinking AStarGreedy " + iAStarGreedy.ToString() + " By Bob!");
                    //THIS.RefreshBoxText();
                }
                else//If Order is Brown.
                {
                    //THIS.SetBoxText("\r\nChess Thinking AStarGreedy " + iAStarGreedy.ToString() + " By Alice!");
                    //THIS.RefreshBoxText();
                }*/
                //Initiate Of Local Variables.
                {


                    {
                        //If Order is Gray.
                        if (Order == 1)
                        {




                            //For Gray Soldeirs Objects. 
                            for (i = 0; i < SodierMidle; i++)
                            {
                                try
                                {
                                    Order = DummyOrder;
                                    ChessRules.CurrentOrder = DummyCurrentOrder;
                                    //If Solders Not Exist Continue and Traversal Back.
                                    if (SolderesOnTable[i] == null)
                                        continue;
                                    //Initiate of Local Variables By Global Objective Gray Current Solder.
                                    ii = (int)SolderesOnTable[i].Row;
                                    jj = (int)SolderesOnTable[i].Column;
                                    //Construction of Thinking Gray Soldier By Local Variables.
                                    SolderesOnTable[i] = new DrawSoldier(MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, ii, jj, a, Table, Order, false, i); ;
                                    //If There is no Thinking Movments on Current Object 

                                    if (SolderesOnTable[i].SoldierThinking[0].TableListSolder.Count == 0)
                                    {
                                        //For All Movable Gray Solders.
                                        for (j = 0; j < AllDraw.SodierMovments; j++)
                                        {
                                            //Thinking of Gray Solder Operation.
                                            SolderesOnTable[i].SoldierThinking[0].ThinkingBegin = true;
                                            SolderesOnTable[i].SoldierThinking[0].ThinkingFinished = false;
                                            SolderesOnTable[i].SoldierThinking[0].t = new Task(new Action(SolderesOnTable[i].SoldierThinking[0].Thinking));
                                            SolderesOnTable[i].SoldierThinking[0].t.Start();
                                            if (SolderesOnTable[i].SoldierThinking[0].t != null) { Object tttt = new Object(); lock (tttt) { tH.Add(SolderesOnTable[i].SoldierThinking[0].t); } }
                                            // Wait(this, i, j, 0, 1, false);
                                            //SolderesOnTable[i].SoldierThinking[0].t.Abort();
                                            //SolderesOnTable[i].SoldierThinking[0].t.Wait();
                                            //When Thinking Not Successful Continue.
                                            if (SolderesOnTable[i].SoldierThinking[0].TableListSolder.Count == 0)
                                                continue;
                                            /*if (Order == 1)
                                            {
                                                //THIS.SetBoxText("\r\nChess Thinking AStarGreedy " + iAStarGreedy.ToString() + " For Soldeirs By Bob!");
                                                //THIS.RefreshBoxText();
                                            }
                                            else//If Order is Brown.
                                            {
                                                //THIS.SetBoxText("\r\nChess Thinking AStarGreedy " + iAStarGreedy.ToString() + " For Soldeirs By Alice!");
                                                //THIS.RefreshBoxText();
                                            }
                                             */
                                            Order = DummyOrder;
                                            ChessRules.CurrentOrder = DummyCurrentOrder;
                                            if (Order * -1 == 1)
                                                a = Color.Gray;
                                            else
                                                a = Color.Brown;
                                            Order *= -1;
                                            ChessRules.CurrentOrder *= -1;
                                            //Operation of AStarGreedy Caaling Main Method.
                                            SolderesOnTable[i].SoldierThinking[0].AStarGreedy.Add(new AllDraw(MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, ref THIS));
                                            // SolderesOnTable[i].SoldierThinking[0].AStarGreedy[SolderesOnTable[i].SoldierThinking[0].AStarGreedy.Count - 1].SolderesOnTable[i] = newDrawSoldier(MovementsAStarGreedyHuristicFoundT,IgnoreSelfObjectsT,UsePenaltyRegardMechnisamT,BestMovmentsT,PredictHuristicT,OnlySelfT,AStarGreedyHuristicT,ArrangmentsChanged, SolderesOnTable[i].Row, SolderesOnTable[i].Column, SolderesOnTable[i].color, SolderesOnTable[i].Table, SolderesOnTable[i].Order, false, SolderesOnTable[i].Current);
                                            this.Clone(SolderesOnTable[i].SoldierThinking[0].AStarGreedy[SolderesOnTable[i].SoldierThinking[0].AStarGreedy.Count - 1]);
                                            if (!FormRefrigtz.Blitz)
                                                SolderesOnTable[i].SoldierThinking[0].AStarGreedy[SolderesOnTable[i].SoldierThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt(iAStarGreedy, ii, jj, a, Table, Order, false, FOUND);
                                            //Initiate of Local Order By Global Variable. 
                                            Order = DummyOrder;
                                            ChessRules.CurrentOrder = DummyCurrentOrder;
                                            //Refrigtz.Timer Finsining Thinking. 
                                            //S = (TimerColor.AStarGreedytiLevelMaxInitiate(timer, iAStarGreedy));
                                            //if (S == -1)    //have to Zero. Non Decreamet Algorithm not found.
                                            //AStarGreedyiLevelMax = 0;

                                            if (iAStarGreedy > AStarGreedyiLevelMax && iAStarGreedy != 1)
                                            {
                                                SolderesOnTable[i].SoldierThinking[0].AStarGreedy = null;
                                                return null;
                                            }


                                        }
                                    }
                                    else if (!FormRefrigtz.Blitz)
                                    //If There is A Soldeir Movments.                                   
                                    {
                                        //For Numbers of Gray Soldeirs Movements.
                                        for (j = 0; j < SolderesOnTable[i].SoldierThinking[0].TableListSolder.Count; j++)
                                        {

                                            //Thinking of Gray Soldeir Operations.
                                            SolderesOnTable[i].SoldierThinking[0].TableT = SolderesOnTable[i].SoldierThinking[0].TableListSolder[j];
                                            SolderesOnTable[i].SoldierThinking[0].ThinkingBegin = true;
                                            SolderesOnTable[i].SoldierThinking[0].ThinkingFinished = false;
                                            SolderesOnTable[i].SoldierThinking[0].t = new Task(new Action(SolderesOnTable[i].SoldierThinking[0].Thinking));
                                            SolderesOnTable[i].SoldierThinking[0].t.Start();
                                            if (SolderesOnTable[i].SoldierThinking[0].t != null) { Object tttt = new Object(); lock (tttt) { tH.Add(SolderesOnTable[i].SoldierThinking[0].t); } }

                                            //Wait For Thinking Finishing.
                                            // Wait(this, i, j, 0, 1, false);
                                            //SolderesOnTable[i].SoldierThinking[0].t.Abort();
                                            //SolderesOnTable[i].SoldierThinking[0].t.Wait();
                                            if (SolderesOnTable[i].SoldierThinking[0].TableListSolder.Count == 0)
                                                continue;
                                            //Initiate of Local Varibale By Global Orders.
                                            Order = DummyOrder;
                                            ChessRules.CurrentOrder = DummyCurrentOrder;
                                            if (Order * -1 == 1)
                                                a = Color.Gray;
                                            else
                                                a = Color.Brown;
                                            Order *= -1;
                                            ChessRules.CurrentOrder *= -1;
                                            SolderesOnTable[i].SoldierThinking[0].AStarGreedy.Add(new AllDraw(MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, ref THIS));
                                            //SolderesOnTable[i].SoldierThinking[0].AStarGreedy[SolderesOnTable[i].SoldierThinking[0].AStarGreedy.Count - 1].SolderesOnTable[i] = newDrawSoldier(MovementsAStarGreedyHuristicFoundT,IgnoreSelfObjectsT,UsePenaltyRegardMechnisamT,BestMovmentsT,PredictHuristicT,OnlySelfT,AStarGreedyHuristicT,ArrangmentsChanged, SolderesOnTable[i].Row, SolderesOnTable[i].Column, SolderesOnTable[i].color, SolderesOnTable[i].Table, SolderesOnTable[i].Order, false, SolderesOnTable[i].Current);
                                            this.Clone(SolderesOnTable[i].SoldierThinking[0].AStarGreedy[SolderesOnTable[i].SoldierThinking[0].AStarGreedy.Count - 1]);
                                            //Dummy = this.CopyRemeiningItems(Dummy, Order * -1);
                                            //Dummy = this.CopyRemeiningItems(Dummy, Order * -1);
                                            //Initaie Order Gray.
                                            Order = DummyOrder;
                                            ChessRules.CurrentOrder = DummyCurrentOrder;
                                            //Refrigtz.Timer of Finishing Calling.
                                            //S = (TimerColor.AStarGreedytiLevelMaxInitiate(timer, iAStarGreedy));
                                            //if (S == -1)    //have to Zero. Non Decreamet Algorithm not found.
                                            //AStarGreedyiLevelMax = 0;

                                            if (iAStarGreedy > AStarGreedyiLevelMax && iAStarGreedy != 1)
                                            {
                                                SolderesOnTable[i].SoldierThinking[0].AStarGreedy = null;
                                                return null;
                                            }


                                        }
                                    }
                                }
                                catch (Exception t)
                                {
                                    //SolderesOnTable[i] = null;

                                }
                            }
                            //Progressing.
                            try
                            {
                                SA = true;
                                //IncreaseprogressBarRefregitzValue(//THIS.progressBarVerify, increasedProgress);
                                //THIS.progressBarVerify.Invalidate();
                                //SetprogressBarUpdate(//THIS.progressBarVerify);
                            }
                            catch (Exception t) { }
                            //For All Gray Elephant Objects.
                            for (i = 0; i < ElefantMidle; i++)
                            {
                                try
                                {
                                    Order = DummyOrder;
                                    ChessRules.CurrentOrder = DummyCurrentOrder;
                                    //Ignore of Non Exist Current Elephant Gray Objects.
                                    if (ElephantOnTable[i] == null)
                                        continue;
                                    //Inititae Local Varibale By Global Gray Elephant Objects Varibales.
                                    ii = (int)ElephantOnTable[i].Row;
                                    jj = (int)ElephantOnTable[i].Column;
                                    //Construction of Thinking Objects By Local Varibales.
                                    ElephantOnTable[i] = new DrawElefant(MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, ii, jj, a, Table, Order, false, i); ;
                                    //If There is Not Thinking Objetive List Elephant Gray. 
                                    if (ElephantOnTable[i].ElefantThinking[0].TableListElefant.Count == 0)
                                    {
                                        //For All Possible Movments.
                                        for (j = 0; j < AllDraw.ElefantMovments; j++)
                                        {
                                            //Operational Thinking Gray Elephant. 
                                            ElephantOnTable[i].ElefantThinking[0].ThinkingBegin = true;
                                            ElephantOnTable[i].ElefantThinking[0].ThinkingFinished = false;
                                            ElephantOnTable[i].ElefantThinking[0].t = new Task(new Action(ElephantOnTable[i].ElefantThinking[0].Thinking));
                                            ElephantOnTable[i].ElefantThinking[0].t.Start();
                                            if (ElephantOnTable[i].ElefantThinking[0].t != null) { Object tttt = new Object(); lock (tttt) { tH.Add(ElephantOnTable[i].ElefantThinking[0].t); } }

                                            //Wait Until Thinking Finished.
                                            // Wait(this, i, j, 0, 2, false);
                                            //ElephantOnTable[i].ElefantThinking[0].t.Abort();
                                            //ElephantOnTable[i].ElefantThinking[0].t.Wait();
                                            //Continue When There is Not Thinking Results.
                                            if (ElephantOnTable[i].ElefantThinking[0].TableListElefant.Count == 0)
                                                continue;
                                            /*
                                            if (Order == 1)
                                            {
                                                //THIS.SetBoxText("\r\nChess Thinking AStarGreedy " + iAStarGreedy.ToString() + " For Elephant By Bob!");
                                                //THIS.RefreshBoxText();
                                            }
                                            else//If Order is Brown.
                                            {
                                                //THIS.SetBoxText("\r\nChess Thinking AStarGreedy " + iAStarGreedy.ToString() + " For Elephant By Alice!");
                                                //THIS.RefreshBoxText();
                                            }
                                             */
                                            //Initiate of Local Varibale By Global Orders.
                                            Order = DummyOrder;
                                            ChessRules.CurrentOrder = DummyCurrentOrder;
                                            if (Order * -1 == 1)
                                                a = Color.Gray;
                                            else
                                                a = Color.Brown;
                                            Order *= -1;
                                            ChessRules.CurrentOrder *= -1;
                                            ElephantOnTable[i].ElefantThinking[0].AStarGreedy.Add(new AllDraw(MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, ref THIS));
                                            //ElephantOnTable[i].ElefantThinking[0].AStarGreedy[ElephantOnTable[i].ElefantThinking[0].AStarGreedy.Count - 1].ElephantOnTable[i] = new DrawElefant(MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT,ArrangmentsChanged, ElephantOnTable[i].Row, ElephantOnTable[i].Column, ElephantOnTable[i].color, ElephantOnTable[i].Table, ElephantOnTable[i].Order, false, ElephantOnTable[i].Current);
                                            this.Clone(ElephantOnTable[i].ElefantThinking[0].AStarGreedy[ElephantOnTable[i].ElefantThinking[0].AStarGreedy.Count - 1]);
                                            //Dummy = this.CopyRemeiningItems(Dummy, Order * -1);
                                            if (!FormRefrigtz.Blitz)
                                                ElephantOnTable[i].ElefantThinking[0].AStarGreedy[ElephantOnTable[i].ElefantThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt(iAStarGreedy, ii, jj, a, Table, Order, false, FOUND);
                                            //Global Order Initiate.
                                            Order = DummyOrder;
                                            ChessRules.CurrentOrder = DummyCurrentOrder;
                                            //Refrigtz.Timer Finishing Operational Recursive Ended.
                                            //S = (TimerColor.AStarGreedytiLevelMaxInitiate(timer, iAStarGreedy));
                                            //if (S == -1)    //have to Zero. Non Decreamet Algorithm not found.
                                            //AStarGreedyiLevelMax = 0;

                                            if (iAStarGreedy > AStarGreedyiLevelMax && iAStarGreedy != 1)
                                            {

                                                ElephantOnTable[i].ElefantThinking[0].AStarGreedy = null;
                                                return null;
                                            }

                                        }
                                    }//If There is Movment Thinking Gary Elphant Object List.
                                    else if (!FormRefrigtz.Blitz)
                                    {
                                        //For Every Gray Elephant Thinking Movments.
                                        for (j = 0; j < ElephantOnTable[i].ElefantThinking[0].TableListElefant.Count; j++)
                                        {

                                            //Gray Elephant Object Thinking Operations.
                                            ElephantOnTable[i].ElefantThinking[0].TableT = ElephantOnTable[i].ElefantThinking[0].TableListElefant[j];
                                            ElephantOnTable[i].ElefantThinking[0].ThinkingBegin = true;
                                            ElephantOnTable[i].ElefantThinking[0].ThinkingFinished = false;
                                            ElephantOnTable[i].ElefantThinking[0].t = new Task(new Action(ElephantOnTable[i].ElefantThinking[0].Thinking));
                                            ElephantOnTable[i].ElefantThinking[0].t.Start();
                                            if (ElephantOnTable[i].ElefantThinking[0].t != null) { Object tttt = new Object(); lock (tttt) { tH.Add(ElephantOnTable[i].ElefantThinking[0].t); } }

                                            //Wait While Thinking Finishing.
                                            // Wait(this, i, j, 0, 2, false);
                                            //ElephantOnTable[i].ElefantThinking[0].t.Abort();
                                            //ElephantOnTable[i].ElefantThinking[0].t.Wait();
                                            //When Thinking Object Not Exist Continue.
                                            if (ElephantOnTable[i].ElefantThinking[0].TableListElefant.Count == 0)
                                                continue;
                                            //Initiate of Local Varibale By Global Orders.
                                            Order = DummyOrder;
                                            ChessRules.CurrentOrder = DummyCurrentOrder;
                                            if (Order * -1 == 1)
                                                a = Color.Gray;
                                            else
                                                a = Color.Brown;
                                            Order *= -1;
                                            ChessRules.CurrentOrder *= -1;
                                            ElephantOnTable[i].ElefantThinking[0].AStarGreedy.Add(new AllDraw(MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, ref THIS));
                                            //ElephantOnTable[i].ElefantThinking[0].AStarGreedy[ElephantOnTable[i].ElefantThinking[0].AStarGreedy.Count - 1].ElephantOnTable[i] = new DrawElefant(MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT,ArrangmentsChanged, ElephantOnTable[i].Row, ElephantOnTable[i].Column, ElephantOnTable[i].color, ElephantOnTable[i].Table, ElephantOnTable[i].Order, false, ElephantOnTable[i].Current);
                                            this.Clone(ElephantOnTable[i].ElefantThinking[0].AStarGreedy[ElephantOnTable[i].ElefantThinking[0].AStarGreedy.Count - 1]);
                                            //Dummy = this.CopyRemeiningItems(Dummy, Order * -1);
                                            //Initiatiozation Global Order 
                                            Order = DummyOrder;
                                            ChessRules.CurrentOrder = DummyCurrentOrder;
                                            //Refrigtz.Timer Finsihing Recursive Operations.
                                            //S = (TimerColor.AStarGreedytiLevelMaxInitiate(timer, iAStarGreedy));
                                            //if (S == -1)    //have to Zero. Non Decreamet Algorithm not found.
                                            //AStarGreedyiLevelMax = 0;

                                            if (iAStarGreedy > AStarGreedyiLevelMax && iAStarGreedy != 1)
                                            {
                                                ElephantOnTable[i].ElefantThinking[0].AStarGreedy = null;
                                                return null;
                                            }

                                        }
                                    }
                                }
                                catch (Exception t)
                                {

                                }
                            }
                            //Progressing.
                            try
                            {
                                EA = true;
                                //IncreaseprogressBarRefregitzValue(//THIS.progressBarVerify, increasedProgress);
                                //THIS.progressBarVerify.Invalidate();
                                //SetprogressBarUpdate(//THIS.progressBarVerify);
                            }
                            catch (Exception t) { }

                            //For All Gray Hourse Objects.
                            for (i = 0; i < HourseMidle; i++)
                            {
                                try
                                {
                                    Order = DummyOrder;
                                    ChessRules.CurrentOrder = DummyCurrentOrder;
                                    //Ignore of Non Exist Current Gray Hourse Objects.
                                    if (HoursesOnTable[i] == null)
                                        continue;
                                    //Initiate of Local Variables By Global Gray Hourse Objectives.
                                    ii = (int)HoursesOnTable[i].Row;
                                    jj = (int)HoursesOnTable[i].Column;
                                    //Construction of Gray Hourse Thinking Objects..
                                    HoursesOnTable[i] = new DrawHourse(MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, ii, jj, a, Table, Order, false, i); ;
                                    //When There is Not HourseList Count. 
                                    if (HoursesOnTable[i].HourseThinking[0].TableListHourse.Count == 0)
                                    {
                                        //For All Possible Movments.
                                        for (j = 0; j < AllDraw.HourseMovments; j++)
                                        {
                                            //Thinking of Gray Hourse Oprational.
                                            HoursesOnTable[i].HourseThinking[0].ThinkingBegin = true;
                                            HoursesOnTable[i].HourseThinking[0].ThinkingFinished = false;
                                            HoursesOnTable[i].HourseThinking[0].t = new Task(new Action(HoursesOnTable[i].HourseThinking[0].Thinking));
                                            HoursesOnTable[i].HourseThinking[0].t.Start();
                                            if (HoursesOnTable[i].HourseThinking[0].t != null) { Object tttt = new Object(); lock (tttt) { tH.Add(HoursesOnTable[i].HourseThinking[0].t); } }
                                            //Wait While Thinking Finished.
                                            // Wait(this, i, j, 0, 3, false);
                                            //HoursesOnTable[i].HourseThinking[0].t.Abort();
                                            //HoursesOnTable[i].HourseThinking[0].t.Wait();
                                            //When Thinking of Hourse List Not Successful Constinue.
                                            if (HoursesOnTable[i].HourseThinking[0].TableListHourse.Count == 0)
                                                continue;
                                            /*if (Order == 1)
                                            {
                                                //THIS.SetBoxText("\r\nChess Thinking AStarGreedy " + iAStarGreedy.ToString() + " For Hourse By Bob!");
                                                //THIS.RefreshBoxText();
                                            }
                                            else//If Order is Brown.
                                            {
                                                //THIS.SetBoxText("\r\nChess Thinking AStarGreedy " + iAStarGreedy.ToString() + " For Hourse By Alice!");
                                                //THIS.RefreshBoxText();
                                            }
                                             */
                                            //Initiate of Local Varibale By Global Orders.
                                            Order = DummyOrder;
                                            ChessRules.CurrentOrder = DummyCurrentOrder;
                                            if (Order * -1 == 1)
                                                a = Color.Gray;
                                            else
                                                a = Color.Brown;
                                            Order *= -1;
                                            ChessRules.CurrentOrder *= -1;
                                            HoursesOnTable[i].HourseThinking[0].AStarGreedy.Add(new AllDraw(MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, ref THIS));
                                            //HoursesOnTable[i].HourseThinking[0].AStarGreedy[HoursesOnTable[i].HourseThinking[0].AStarGreedy.Count - 1].HoursesOnTable[i] = new DrawHourse(MovementsAStarGreedyHuristicFoundT,IgnoreSelfObjectsT,UsePenaltyRegardMechnisamT,BestMovmentsT,PredictHuristicT,OnlySelfT,AStarGreedyHuristicT,ArrangmentsChanged, HoursesOnTable[i].Row, HoursesOnTable[i].Column, HoursesOnTable[i].color, HoursesOnTable[i].Table, HoursesOnTable[i].Order, false, HoursesOnTable[i].Current);
                                            this.Clone(HoursesOnTable[i].HourseThinking[0].AStarGreedy[HoursesOnTable[i].HourseThinking[0].AStarGreedy.Count - 1]);
                                            //Dummy = this.CopyRemeiningItems(Dummy, Order * -1);
                                            if (!FormRefrigtz.Blitz)
                                                HoursesOnTable[i].HourseThinking[0].AStarGreedy[HoursesOnTable[i].HourseThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt(iAStarGreedy, ii, jj, a, Table, Order, false, FOUND);
                                            //Global Order.
                                            Order = DummyOrder;
                                            ChessRules.CurrentOrder = DummyCurrentOrder;
                                            //Refrigtz.Timer Finishing Recursive Ending.
                                            //S = (TimerColor.AStarGreedytiLevelMaxInitiate(timer, iAStarGreedy));
                                            //if (S == -1)    //have to Zero. Non Decreamet Algorithm not found.
                                            //AStarGreedyiLevelMax = 0;

                                            if (iAStarGreedy > AStarGreedyiLevelMax && iAStarGreedy != 1)
                                            {
                                                HoursesOnTable[i].HourseThinking[0].AStarGreedy = null;
                                                return null;
                                            }


                                        }
                                    }
                                    else if (!FormRefrigtz.Blitz)//If Table List Exist int The Thinking.
                                    {
                                        //For All Possible Movments of Thinking.
                                        for (j = 0; j < HoursesOnTable[i].HourseThinking[0].TableListHourse.Count; j++)
                                        {

                                            //Thinking Operation of Gray Hourse.
                                            HoursesOnTable[i].HourseThinking[0].TableT = HoursesOnTable[i].HourseThinking[0].TableListHourse[j];
                                            HoursesOnTable[i].HourseThinking[0].ThinkingBegin = true;
                                            HoursesOnTable[i].HourseThinking[0].ThinkingFinished = false;
                                            HoursesOnTable[i].HourseThinking[0].t = new Task(new Action(HoursesOnTable[i].HourseThinking[0].Thinking));
                                            HoursesOnTable[i].HourseThinking[0].t.Start();
                                            if (HoursesOnTable[i].HourseThinking[0].t != null) { Object tttt = new Object(); lock (tttt) { tH.Add(HoursesOnTable[i].HourseThinking[0].t); } }

                                            //Wait For Thinking Finsished.
                                            // Wait(this, i, j, 0, 3, false);
                                            //HoursesOnTable[i].HourseThinking[0].t.Abort();
                                            //HoursesOnTable[i].HourseThinking[0].t.Wait();
                                            //If Thinking Not Successful of the Thinking Operation Continue Traversal Back.
                                            if (HoursesOnTable[i].HourseThinking[0].TableListHourse.Count == 0)
                                                continue;
                                            //Operational Thinking of AStarGreedy Recursive Calling <MainMethod.
                                            Order = DummyOrder;
                                            ChessRules.CurrentOrder = DummyCurrentOrder;
                                            if (Order * -1 == 1)
                                                a = Color.Gray;
                                            else
                                                a = Color.Brown;
                                            Order *= -1;
                                            ChessRules.CurrentOrder *= -1;
                                            HoursesOnTable[i].HourseThinking[0].AStarGreedy.Add(new AllDraw(MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, ref THIS));
                                            //HoursesOnTable[i].HourseThinking[0].AStarGreedy[HoursesOnTable[i].HourseThinking[0].AStarGreedy.Count - 1].HoursesOnTable[i] = new DrawHourse(MovementsAStarGreedyHuristicFoundT,IgnoreSelfObjectsT,UsePenaltyRegardMechnisamT,BestMovmentsT,PredictHuristicT,OnlySelfT,AStarGreedyHuristicT,ArrangmentsChanged, HoursesOnTable[i].Row, HoursesOnTable[i].Column, HoursesOnTable[i].color, HoursesOnTable[i].Table, HoursesOnTable[i].Order, false, HoursesOnTable[i].Current);
                                            this.Clone(HoursesOnTable[i].HourseThinking[0].AStarGreedy[HoursesOnTable[i].HourseThinking[0].AStarGreedy.Count - 1]);
                                            //Dummy = this.CopyRemeiningItems(Dummy, Order * -1);
                                            //Iniateie of Glbal Varibale By Local Varibales.
                                            Order = DummyOrder;
                                            ChessRules.CurrentOrder = DummyCurrentOrder;
                                            //Refrigtz.Timer End of Thinking Finsishing Recursively.
                                            //S = (TimerColor.AStarGreedytiLevelMaxInitiate(timer, iAStarGreedy));
                                            //if (S == -1)    //have to Zero. Non Decreamet Algorithm not found.
                                            //AStarGreedyiLevelMax = 0;

                                            if (iAStarGreedy > AStarGreedyiLevelMax && iAStarGreedy != 1)
                                            {
                                                HoursesOnTable[i].HourseThinking[0].AStarGreedy = null;
                                                return null;
                                            }


                                        }

                                    }
                                }
                                catch (Exception t)
                                {

                                }
                            }
                            //Progressing.
                            try
                            {
                                HA = false;
                                //IncreaseprogressBarRefregitzValue(//THIS.progressBarVerify, increasedProgress);
                                //THIS.progressBarVerify.Invalidate();
                                //SetprogressBarUpdate(//THIS.progressBarVerify);
                            }
                            catch (Exception t) { }


                            //For All Possible Gray Bridges Objects.
                            for (i = 0; i < BridgeMidle; i++)
                            {
                                try
                                {
                                    Order = DummyOrder;
                                    ChessRules.CurrentOrder = DummyCurrentOrder;
                                    //When Current Bridges Gray Not Exist Continue Traversal Back.
                                    if (BridgesOnTable[i] == null)
                                        continue;
                                    //Initaiate of Local Varibales By Global Varoiables.
                                    ii = (int)BridgesOnTable[i].Row;
                                    jj = (int)BridgesOnTable[i].Column;
                                    //Construction of Thinking Variables By Local Variables.
                                    BridgesOnTable[i] = new DrawBridge(MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, ii, jj, a, Table, Order, false, i); ;
                                    //When Count of Table Bridges of Thinking Not Exist Do Operational.
                                    if (BridgesOnTable[i].BridgeThinking[0].TableListBridge.Count == 0)
                                    {
                                        //For All Possible Movments.
                                        for (j = 0; j < AllDraw.BridgeMovments; j++)
                                        {
                                            //Thinking of Gray Bridges Operational.
                                            BridgesOnTable[i].BridgeThinking[0].ThinkingBegin = true;
                                            BridgesOnTable[i].BridgeThinking[0].ThinkingFinished = false;
                                            BridgesOnTable[i].BridgeThinking[0].t = new Task(new Action(BridgesOnTable[i].BridgeThinking[0].Thinking));
                                            BridgesOnTable[i].BridgeThinking[0].t.Start();
                                            if (BridgesOnTable[i].BridgeThinking[0].t != null) { Object tttt = new Object(); lock (tttt) { tH.Add(BridgesOnTable[i].BridgeThinking[0].t); } }

                                            //Wait For Thinking of curent Object Finished.
                                            // Wait(this, i, j, 0, 4, false);
                                            //BridgesOnTable[i].BridgeThinking[0].t.Abort();
                                            //BridgesOnTable[i].BridgeThinking[0].t.Wait();
                                            //When Bridges Thinking Not Successfule Continue Traversal Back.
                                            if (BridgesOnTable[i].BridgeThinking[0].TableListBridge.Count == 0)
                                                continue;
                                            /*if (Order == 1)
                                            {
                                                //THIS.SetBoxText("\r\nChess Thinking AStarGreedy " + iAStarGreedy.ToString() + " For Bridges By Bob!");
                                                //THIS.RefreshBoxText();
                                            }
                                            else//If Order is Brown.
                                            {
                                                //THIS.SetBoxText("\r\nChess Thinking AStarGreedy " + iAStarGreedy.ToString() + " For Bridges By Alice!");
                                                //THIS.RefreshBoxText();
                                            }

                                             */
                                            //Initiate of Local Varibale By Global Orders.
                                            Order = DummyOrder;
                                            ChessRules.CurrentOrder = DummyCurrentOrder;
                                            if (Order * -1 == 1)
                                                a = Color.Gray;
                                            else
                                                a = Color.Brown;
                                            Order *= -1;
                                            ChessRules.CurrentOrder *= -1;
                                            BridgesOnTable[i].BridgeThinking[0].AStarGreedy.Add(new AllDraw(MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, ref THIS));
                                            //BridgesOnTable[i].BridgeThinking[0].AStarGreedy[BridgesOnTable[i].BridgeThinking[0].AStarGreedy.Count - 1].BridgesOnTable[i] = new DrawBridge(MovementsAStarGreedyHuristicFoundT,IgnoreSelfObjectsT,UsePenaltyRegardMechnisamT,BestMovmentsT,PredictHuristicT,OnlySelfT,AStarGreedyHuristicT,ArrangmentsChanged, BridgesOnTable[i].Row, BridgesOnTable[i].Column, BridgesOnTable[i].color, BridgesOnTable[i].Table, BridgesOnTable[i].Order, false, BridgesOnTable[i].Current);
                                            this.Clone(BridgesOnTable[i].BridgeThinking[0].AStarGreedy[BridgesOnTable[i].BridgeThinking[0].AStarGreedy.Count - 1]);
                                            //Dummy = this.CopyRemeiningItems(Dummy, Order * -1);
                                            if (!FormRefrigtz.Blitz)
                                                BridgesOnTable[i].BridgeThinking[0].AStarGreedy[BridgesOnTable[i].BridgeThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt(iAStarGreedy, ii, jj, a, Table, Order, false, FOUND);
                                            Order = DummyOrder;
                                            ChessRules.CurrentOrder = DummyCurrentOrder;
                                            //Finishing of Tiimer Limitation Constraint.
                                            //S = (TimerColor.AStarGreedytiLevelMaxInitiate(timer, iAStarGreedy));
                                            //if (S == -1)    //have to Zero. Non Decreamet Algorithm not found.
                                            //AStarGreedyiLevelMax = 0;

                                            if (iAStarGreedy > AStarGreedyiLevelMax && iAStarGreedy != 1)
                                            {
                                                BridgesOnTable[i].BridgeThinking[0].AStarGreedy = null;
                                                return null;
                                            }
                                        }
                                    }
                                    else if (!FormRefrigtz.Blitz)//When There is Possible Thinking Bridge of Gray Table
                                    {
                                        //for Each Thinknking  Movments of Gray Bridges do Perational.
                                        for (j = 0; j < BridgesOnTable[i].BridgeThinking[0].TableListBridge.Count; j++)
                                        {

                                            //Thinking of Gray Bridges  Objective Movments.
                                            BridgesOnTable[i].BridgeThinking[0].TableT = BridgesOnTable[i].BridgeThinking[0].TableListBridge[j];
                                            BridgesOnTable[i].BridgeThinking[0].ThinkingBegin = true;
                                            BridgesOnTable[i].BridgeThinking[0].ThinkingFinished = false;
                                            BridgesOnTable[i].BridgeThinking[0].t = new Task(new Action(BridgesOnTable[i].BridgeThinking[0].Thinking));
                                            BridgesOnTable[i].BridgeThinking[0].t.Start();
                                            if (BridgesOnTable[i].BridgeThinking[0].t != null) { Object tttt = new Object(); lock (tttt) { tH.Add(BridgesOnTable[i].BridgeThinking[0].t); } }
                                            //Wait For Thinking Finished.
                                            // Wait(this, i, j, 0, 4, false);
                                            //BridgesOnTable[i].BridgeThinking[0].t.Abort();
                                            //BridgesOnTable[i].BridgeThinking[0].t.Wait();
                                            //If Gray Bridges Thinking Not Successful Continue Traversal Back.
                                            if (BridgesOnTable[i].BridgeThinking[0].TableListBridge.Count == 0)
                                                continue;
                                            //Thinking of Gray Bridges AStarGreedy Traversal Back Operations.
                                            Order = DummyOrder;
                                            ChessRules.CurrentOrder = DummyCurrentOrder;
                                            if (Order * -1 == 1)
                                                a = Color.Gray;
                                            else
                                                a = Color.Brown;
                                            Order *= -1;
                                            ChessRules.CurrentOrder *= -1;
                                            BridgesOnTable[i].BridgeThinking[0].AStarGreedy.Add(new AllDraw(MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, ref THIS));
                                            //BridgesOnTable[i].BridgeThinking[0].AStarGreedy[BridgesOnTable[i].BridgeThinking[0].AStarGreedy.Count - 1].BridgesOnTable[i] = new DrawBridge(MovementsAStarGreedyHuristicFoundT,IgnoreSelfObjectsT,UsePenaltyRegardMechnisamT,BestMovmentsT,PredictHuristicT,OnlySelfT,AStarGreedyHuristicT,ArrangmentsChanged, BridgesOnTable[i].Row, BridgesOnTable[i].Column, BridgesOnTable[i].color, BridgesOnTable[i].Table, BridgesOnTable[i].Order, false, BridgesOnTable[i].Current);
                                            this.Clone(BridgesOnTable[i].BridgeThinking[0].AStarGreedy[BridgesOnTable[i].BridgeThinking[0].AStarGreedy.Count - 1]);
                                            //Dummy = this.CopyRemeiningItems(Dummy, Order * -1);
                                            //Initiate of Global Varibales By Local Varibales.
                                            Order = DummyOrder;
                                            ChessRules.CurrentOrder = DummyCurrentOrder;
                                            //thinking of Finished Refrigtz.Timer.
                                            //S = (TimerColor.AStarGreedytiLevelMaxInitiate(timer, iAStarGreedy));
                                            //if (S == -1)    //have to Zero. Non Decreamet Algorithm not found.
                                            //AStarGreedyiLevelMax = 0;

                                            if (iAStarGreedy > AStarGreedyiLevelMax && iAStarGreedy != 1)
                                            {
                                                BridgesOnTable[i].BridgeThinking[0].AStarGreedy = null;
                                                return null;
                                            }
                                        }

                                    }
                                }
                                catch (Exception t)
                                {

                                }
                            }
                            //Progressing.
                            try
                            {
                                BA = true;
                                //IncreaseprogressBarRefregitzValue(//THIS.progressBarVerify, increasedProgress);
                                //THIS.progressBarVerify.Invalidate();
                                //SetprogressBarUpdate(//THIS.progressBarVerify);
                            }
                            catch (Exception t) { }
                            try
                            {
                                //For All Possible Gray Minister Movments.
                                for (i = 0; i < MinisterMidle; i++)
                                {
                                    Order = DummyOrder;
                                    ChessRules.CurrentOrder = DummyCurrentOrder;
                                    //For Each Non Exist Gray Minister Objectives.
                                    if (MinisterOnTable[i] == null)
                                        continue;
                                    //Inititate Local Variables By Global Varibales.
                                    ii = (int)MinisterOnTable[i].Row;
                                    jj = (int)MinisterOnTable[i].Column;
                                    //Construction of Thinking Objects Gray Minister.
                                    MinisterOnTable[i] = new DrawMinister(MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, ii, jj, a, Table, Order, false, i); ;
                                    //If There is Not Minister Of Gray In The Thinking Table List.   
                                    if (MinisterOnTable[i].MinisterThinking[0].TableListMinister.Count == 0)
                                    {
                                        //For All Possible Movments.
                                        for (j = 0; j < AllDraw.MinisterMovments; j++)
                                        {
                                            //Thinking of Gray Minister Operational.
                                            MinisterOnTable[i].MinisterThinking[0].ThinkingBegin = true;
                                            MinisterOnTable[i].MinisterThinking[0].ThinkingFinished = false;
                                            //MinisterOnTable[i].MinisterThinking[0].t = new Task(new Action(MinisterOnTable[i].MinisterThinking[0].Thinking));
                                            MinisterOnTable[i].MinisterThinking[0].t.Start();
                                            if (MinisterOnTable[i].MinisterThinking[0].t != null) { Object tttt = new Object(); lock (tttt) { tH.Add(MinisterOnTable[i].MinisterThinking[0].t); } }
                                            //Wait For Thinking Finsihed.
                                            // Wait(this, i, j, 0, 5, false);
                                            //MinisterOnTable[i].MinisterThinking[0].t.Abort();
                                            //MinisterOnTable[i].MinisterThinking[0].t.Wait();
                                            //If Gray Minister Thinking Not Successful Continue Traversal Back.                                      
                                            if (MinisterOnTable[i].MinisterThinking[0].TableListMinister.Count == 0)
                                                continue;
                                            /*if (Order == 1)
                                            {
                                                //THIS.SetBoxText("\r\nChess Thinking AStarGreedy " + iAStarGreedy.ToString() + " For Minister By Bob!");
                                                //THIS.RefreshBoxText();
                                            }
                                            else//If Order is Brown.
                                            {
                                                //THIS.SetBoxText("\r\nChess Thinking AStarGreedy " + iAStarGreedy.ToString() + " For Minister By Alice!");
                                                //THIS.RefreshBoxText();
                                            }
                                             */
                                            //Initiate of Local Varibale By Global Orders.
                                            Order = DummyOrder;
                                            ChessRules.CurrentOrder = DummyCurrentOrder;
                                            if (Order * -1 == 1)
                                                a = Color.Gray;
                                            else
                                                a = Color.Brown;
                                            Order *= -1;
                                            ChessRules.CurrentOrder *= -1;
                                            //Thinking of AStarGreedy Gray Minister Recursive Main Calling.
                                            MinisterOnTable[i].MinisterThinking[0].AStarGreedy.Add(new AllDraw(MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, ref THIS));
                                            //MinisterOnTable[i].MinisterThinking[0].AStarGreedy[MinisterOnTable[i].MinisterThinking[0].AStarGreedy.Count - 1].MinisterOnTable[i] = new DrawMinister(MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT,ArrangmentsChanged, MinisterOnTable[i].Row, MinisterOnTable[i].Column, MinisterOnTable[i].color, MinisterOnTable[i].Table, MinisterOnTable[i].Order, false, MinisterOnTable[i].Current);
                                            this.Clone(MinisterOnTable[i].MinisterThinking[0].AStarGreedy[MinisterOnTable[i].MinisterThinking[0].AStarGreedy.Count - 1]);
                                            //Dummy = this.CopyRemeiningItems(Dummy, Order * -1);
                                            if (!FormRefrigtz.Blitz)
                                                MinisterOnTable[i].MinisterThinking[0].AStarGreedy[MinisterOnTable[i].MinisterThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt(iAStarGreedy, ii, jj, a, Table, Order, false, FOUND);
                                            //Initiate of Global Varibales By Local Varibales.
                                            Order = DummyOrder;
                                            ChessRules.CurrentOrder = DummyCurrentOrder;
                                            //Refrigtz.Timer Finishing Recursive. 
                                            //S = (TimerColor.AStarGreedytiLevelMaxInitiate(timer, iAStarGreedy));
                                            //if (S == -1)    //have to Zero. Non Decreamet Algorithm not found.
                                            //AStarGreedyiLevelMax = 0;

                                            if (iAStarGreedy > AStarGreedyiLevelMax && iAStarGreedy != 1)
                                            {
                                                MinisterOnTable[i].MinisterThinking[0].AStarGreedy = null;
                                                return null;
                                            }
                                        }
                                    }
                                    else if (!FormRefrigtz.Blitz)//When There is Table Gray Minister Count of Thinking.
                                    {
                                        //For Each Table Gray Minister Count Thinking.
                                        for (j = 0; j < MinisterOnTable[i].MinisterThinking[0].TableListMinister.Count; j++)
                                        {
                                            //Thinking.
                                            MinisterOnTable[i].Table = MinisterOnTable[i].MinisterThinking[0].TableListMinister[j];
                                            MinisterOnTable[i].MinisterThinking[0].ThinkingBegin = true;
                                            MinisterOnTable[i].MinisterThinking[0].ThinkingFinished = false;
                                            //MinisterOnTable[i].MinisterThinking[0].t = new Task(new Action(MinisterOnTable[i].MinisterThinking[0].Thinking));
                                            MinisterOnTable[i].MinisterThinking[0].t.Start();
                                            if (MinisterOnTable[i].MinisterThinking[0].t != null) { Object tttt = new Object(); lock (tttt) { tH.Add(MinisterOnTable[i].MinisterThinking[0].t); } }
                                            //Wait For thinking finsishing.
                                            // Wait(this, i, j, 0, 5, false);
                                            //MinisterOnTable[i].MinisterThinking[0].t.Abort();
                                            //MinisterOnTable[i].MinisterThinking[0].t.Wait();
                                            //If Thinking of Table Gray M inister Thinking Not Successfull  Continuue traversal Back. 
                                            if (MinisterOnTable[i].MinisterThinking[0].TableListMinister.Count == 0)
                                                continue;
                                            //Initiate of Local Varibale By Global Orders.
                                            Order = DummyOrder;
                                            ChessRules.CurrentOrder = DummyCurrentOrder;
                                            if (Order * -1 == 1)
                                                a = Color.Gray;
                                            else
                                                a = Color.Brown;
                                            Order *= -1;
                                            ChessRules.CurrentOrder *= -1;
                                            MinisterOnTable[i].MinisterThinking[0].AStarGreedy.Add(new AllDraw(MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, ref THIS));
                                            //MinisterOnTable[i].MinisterThinking[0].AStarGreedy[MinisterOnTable[i].MinisterThinking[0].AStarGreedy.Count - 1].MinisterOnTable[i] = new DrawMinister(MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT,ArrangmentsChanged, MinisterOnTable[i].Row, MinisterOnTable[i].Column, MinisterOnTable[i].color, MinisterOnTable[i].Table, MinisterOnTable[i].Order, false, MinisterOnTable[i].Current);
                                            this.Clone(MinisterOnTable[i].MinisterThinking[0].AStarGreedy[MinisterOnTable[i].MinisterThinking[0].AStarGreedy.Count - 1]);
                                            //Dummy = this.CopyRemeiningItems(Dummy, Order * -1);
                                            //Initiate of Global Vaaribalke By Local Varibales.
                                            Order = DummyOrder;
                                            ChessRules.CurrentOrder = DummyCurrentOrder;
                                            //Refrigtz.Timer  Finsishing Recursive End Call.
                                            //S = (TimerColor.AStarGreedytiLevelMaxInitiate(timer, iAStarGreedy));
                                            //if (S == -1)    //have to Zero. Non Decreamet Algorithm not found.
                                            //AStarGreedyiLevelMax = 0;

                                            if (iAStarGreedy > AStarGreedyiLevelMax && iAStarGreedy != 1)
                                            {
                                                MinisterOnTable[i].MinisterThinking[0].AStarGreedy = null;
                                                return null;
                                            }
                                        }

                                    }
                                }
                            }
                            catch (Exception t)
                            {

                            }
                            //Progressing.
                            try
                            {
                                MA = true;
                                //IncreaseprogressBarRefregitzValue(//THIS.progressBarVerify, increasedProgress);
                                //THIS.progressBarVerify.Invalidate();
                                //SetprogressBarUpdate(//THIS.progressBarVerify);
                            }
                            catch (Exception t) { }


                            //For All Possible Gray King Objects.
                            for (i = 0; i < KingMidle; i++)
                            {
                                try
                                {
                                    Order = DummyOrder;
                                    ChessRules.CurrentOrder = DummyCurrentOrder;
                                    //If There is Not Current Object Continue Traversal Back.
                                    if (KingOnTable[i] == null)
                                        continue;
                                    //Initiate Local varibale By Global Objective Varibales.
                                    ii = (int)(int)KingOnTable[i].Row;
                                    jj = (int)KingOnTable[i].Column;
                                    //Construction of Gray King Thinking Objects.
                                    KingOnTable[i] = new DrawKing(MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, ii, jj, a, Table, Order, false, i); ;
                                    //When There is Not Thinking Table Gray King Movments.
                                    if (KingOnTable[i].KingThinking[0].TableListKing.Count == 0)
                                    {
                                        //For All Possible Gray King Movments.
                                        for (j = 0; j < AllDraw.KingMovments; j++)
                                        {
                                            //Thinking Of Gray King Operatins.
                                            KingOnTable[i].KingThinking[0].ThinkingBegin = true;
                                            KingOnTable[i].KingThinking[0].ThinkingFinished = false;
                                            KingOnTable[i].KingThinking[0].t = new Task(new Action(KingOnTable[i].KingThinking[0].Thinking));
                                            KingOnTable[i].KingThinking[0].t.Start();
                                            if (KingOnTable[i].KingThinking[0].t != null) { Object tttt = new Object(); lock (tttt) { tH.Add(KingOnTable[i].KingThinking[0].t); } }
                                            //Wait For Thinking Finishing.
                                            // Wait(this, i, j, 0, 6, false);
                                            //KingOnTable[i].KingThinking[0].t.Abort();
                                            //KingOnTable[i].KingThinking[0].t.Wait();
                                            if (KingOnTable[i].KingThinking[0].TableListKing.Count == 0)
                                                continue;
                                            /*if (Order == 1)
                                            {
                                                //THIS.SetBoxText("\r\nChess Thinking AStarGreedy " + iAStarGreedy.ToString() + " For King By Bob!");
                                                //THIS.RefreshBoxText();
                                            }
                                            else//If Order is Brown.
                                            {
                                                //THIS.SetBoxText("\r\nChess Thinking AStarGreedy " + iAStarGreedy.ToString() + " For King By Alice!");
                                                //THIS.RefreshBoxText();
                                            }
                                             */
                                            //Initiate of Local Varibale By Global Orders.
                                            Order = DummyOrder;
                                            ChessRules.CurrentOrder = DummyCurrentOrder;
                                            if (Order * -1 == 1)
                                                a = Color.Gray;
                                            else
                                                a = Color.Brown;
                                            Order *= -1;
                                            ChessRules.CurrentOrder *= -1;
                                            KingOnTable[i].KingThinking[0].AStarGreedy.Add(new AllDraw(MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, ref THIS));
                                            //KingOnTable[i].KingThinking[0].AStarGreedy[KingOnTable[i].KingThinking[0].AStarGreedy.Count - 1].KingOnTable[i] = new DrawKing(MovementsAStarGreedyHuristicFoundT,IgnoreSelfObjectsT,UsePenaltyRegardMechnisamT,BestMovmentsT,PredictHuristicT,OnlySelfT,AStarGreedyHuristicT,ArrangmentsChanged, KingOnTable[i].Row, KingOnTable[i].Column, KingOnTable[i].color, KingOnTable[i].Table, KingOnTable[i].Order, false, KingOnTable[i].Current);
                                            this.Clone(KingOnTable[i].KingThinking[0].AStarGreedy[KingOnTable[i].KingThinking[0].AStarGreedy.Count - 1]);
                                            //Dummy = this.CopyRemeiningItems(Dummy, Order * -1);
                                            //KingOnTable[i].KingThinking[0].Clone(ref KingOnTable[i].KingThinking[0].AStarGreedy[KingOnTable[i].KingThinking[0].AStarGreedy.Count - 1].KingOnTable[i].KingThinking[0]);
                                            if (!FormRefrigtz.Blitz)
                                                KingOnTable[i].KingThinking[0].AStarGreedy[KingOnTable[i].KingThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt(iAStarGreedy, ii, jj, a, Table, Order, false, FOUND);
                                            //Initiate of Global Variables BVy Local Variables.
                                            Order = DummyOrder;
                                            ChessRules.CurrentOrder = DummyCurrentOrder;
                                            //End Refrigtz.Timer of  Recursive Functions.
                                            //S = (TimerColor.AStarGreedytiLevelMaxInitiate(timer, iAStarGreedy));
                                            //if (S == -1)    //have to Zero. Non Decreamet Algorithm not found.
                                            //AStarGreedyiLevelMax = 0;

                                            if (iAStarGreedy > AStarGreedyiLevelMax && iAStarGreedy != 1)
                                            {
                                                KingOnTable[i].KingThinking[0].AStarGreedy = null;
                                                return null;
                                            }
                                        }


                                    }
                                    else if (!FormRefrigtz.Blitz)//When Thinking Gray King Count of Existing Operations.
                                    {
                                        //For Each Existing Gray King Thinking Count Objects Movments.
                                        for (j = 0; j < KingOnTable[i].KingThinking[0].TableListKing.Count; j++)
                                        {
                                            //Gray King Thinking Operations.                                        
                                            KingOnTable[i].KingThinking[0].ThinkingBegin = true;
                                            KingOnTable[i].KingThinking[0].ThinkingFinished = false;
                                            KingOnTable[i].KingThinking[0].t = new Task(new Action(KingOnTable[i].KingThinking[0].Thinking));
                                            KingOnTable[i].KingThinking[0].t.Start();
                                            if (KingOnTable[i].KingThinking[0].t != null) { Object tttt = new Object(); lock (tttt) { tH.Add(KingOnTable[i].KingThinking[0].t); } }
                                            //Wait For Thinking Finsishing.
                                            // Wait(this, i, j, 0, 6, false);

                                            //KingOnTable[i].KingThinking[0].t.Abort();
                                            //KingOnTable[i].KingThinking[0].t.Wait();
                                            //If There is Thinking of Gray King Movments.
                                            if (KingOnTable[i].KingThinking[0].TableListKing.Count == 0)
                                                continue;
                                            //Initiate of Local Varibale By Global Orders.
                                            Order = DummyOrder;
                                            ChessRules.CurrentOrder = DummyCurrentOrder;
                                            if (Order * -1 == 1)
                                                a = Color.Gray;
                                            else
                                                a = Color.Brown;
                                            Order *= -1;
                                            ChessRules.CurrentOrder *= -1;
                                            KingOnTable[i].KingThinking[0].AStarGreedy.Add(new AllDraw(MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, ref THIS));
                                            //KingOnTable[i].KingThinking[0].AStarGreedy[KingOnTable[i].KingThinking[0].AStarGreedy.Count - 1].KingOnTable[i] = new DrawKing(MovementsAStarGreedyHuristicFoundT,IgnoreSelfObjectsT,UsePenaltyRegardMechnisamT,BestMovmentsT,PredictHuristicT,OnlySelfT,AStarGreedyHuristicT,ArrangmentsChanged, KingOnTable[i].Row, KingOnTable[i].Column, KingOnTable[i].color, KingOnTable[i].Table, KingOnTable[i].Order, false, KingOnTable[i].Current);
                                            this.Clone(KingOnTable[i].KingThinking[0].AStarGreedy[KingOnTable[i].KingThinking[0].AStarGreedy.Count - 1]);
                                            //Dummy = this.CopyRemeiningItems(Dummy, Order * -1);
                                            //Initaiet of Global Varibales By Local Varibales.
                                            Order = DummyOrder;
                                            ChessRules.CurrentOrder = DummyCurrentOrder;
                                            //End Refrigtz.Timer Finsishing Recursive Calling.
                                            //S = (TimerColor.AStarGreedytiLevelMaxInitiate(timer, iAStarGreedy));
                                            //if (S == -1)    //have to Zero. Non Decreamet Algorithm not found.
                                            //AStarGreedyiLevelMax = 0;

                                            if (iAStarGreedy > AStarGreedyiLevelMax && iAStarGreedy != 1)
                                            {
                                                KingOnTable[i].KingThinking[0].AStarGreedy = null;
                                                return null;
                                            }
                                        }


                                    }
                                    try
                                    {
                                        KA = true;
                                        //IncreaseprogressBarRefregitzValue(//THIS.progressBarVerify, increasedProgress);
                                        //THIS.progressBarVerify.Invalidate();
                                        //SetprogressBarUpdate(//THIS.progressBarVerify);
                                    }
                                    catch (Exception t) { }
                                }
                                catch (Exception t)
                                {
                                    // KingOnTable[i] = null;

                                }
                            }
                        }
                        else//Brown Order Considarations.
                        {


                            //For Each Objects of Brown Sodiers.
                            for (i = SodierMidle; i < SodierHigh; i++)
                            {
                                try
                                {
                                    Order = DummyOrder;
                                    ChessRules.CurrentOrder = DummyCurrentOrder;
                                    //Wheen Brown King Object There is Not Continue Traversal Back.
                                    if (SolderesOnTable[i] == null)
                                        continue;
                                    //Initiate Local varibale By Global Objective Varibales.
                                    ii = (int)SolderesOnTable[i].Row;
                                    jj = (int)SolderesOnTable[i].Column;
                                    //Construction of Thinking Brown Current Objects.
                                    SolderesOnTable[i] = new DrawSoldier(MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, ii, jj, a, Table, Order, false, i); ;
                                    {
                                        //When There is Current Brown Object Table List Thinking Objective Movments.
                                        if (SolderesOnTable[i].SoldierThinking[0].TableListSolder.Count == 0)
                                        {
                                            //For Each Brown Possible Movments. 
                                            for (j = 0; j < AllDraw.SodierMovments; j++)
                                            {
                                                //Thinking Operations of Brown Current Objects.
                                                SolderesOnTable[i].SoldierThinking[0].ThinkingBegin = true;
                                                SolderesOnTable[i].SoldierThinking[0].ThinkingFinished = false;
                                                SolderesOnTable[i].SoldierThinking[0].t = new Task(new Action(SolderesOnTable[i].SoldierThinking[0].Thinking));
                                                SolderesOnTable[i].SoldierThinking[0].t.Start();
                                                if (SolderesOnTable[i].SoldierThinking[0].t != null) { Object tttt = new Object(); lock (tttt) { tH.Add(SolderesOnTable[i].SoldierThinking[0].t); } }
                                                //Wait For Brown Current Objects Thinking Finishing.
                                                // Wait(this, i, j, 0, 1, false);
                                                //SolderesOnTable[i].SoldierThinking[0].t.Abort();
                                                //SolderesOnTable[i].SoldierThinking[0].t.Wait();
                                                //If There is Not Brown Thinking Successfule Objective Movments. 
                                                if (SolderesOnTable[i].SoldierThinking[0].TableListSolder.Count == 0)
                                                    continue;
                                                /* if (Order == 1)
                                                 {
                                                     //THIS.SetBoxText("\r\nChess Thinking AStarGreedy " + iAStarGreedy.ToString() + " For Soldier By Bob!");
                                                     //THIS.RefreshBoxText();
                                                 }
                                                 else//If Order is Brown.
                                                 {
                                                     //THIS.SetBoxText("\r\nChess Thinking AStarGreedy " + iAStarGreedy.ToString() + " For Soldier By Alice!");
                                                     //THIS.RefreshBoxText();
                                                 }
                                                 */
                                                //Initiate of Local Varibale By Global Orders.
                                                Order = DummyOrder;
                                                ChessRules.CurrentOrder = DummyCurrentOrder;
                                                if (Order * -1 == 1)
                                                    a = Color.Gray;
                                                else
                                                    a = Color.Brown;
                                                Order *= -1;
                                                ChessRules.CurrentOrder *= -1;
                                                SolderesOnTable[i].SoldierThinking[0].AStarGreedy.Add(new AllDraw(MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, ref THIS));
                                                //SolderesOnTable[i].SoldierThinking[0].AStarGreedy[SolderesOnTable[i].SoldierThinking[0].AStarGreedy.Count - 1].SolderesOnTable[i] = newDrawSoldier(MovementsAStarGreedyHuristicFoundT,IgnoreSelfObjectsT,UsePenaltyRegardMechnisamT,BestMovmentsT,PredictHuristicT,OnlySelfT,AStarGreedyHuristicT,ArrangmentsChanged, SolderesOnTable[i].Row, SolderesOnTable[i].Column, SolderesOnTable[i].color, SolderesOnTable[i].Table, SolderesOnTable[i].Order, false, SolderesOnTable[i].Current);
                                                this.Clone(SolderesOnTable[i].SoldierThinking[0].AStarGreedy[SolderesOnTable[i].SoldierThinking[0].AStarGreedy.Count - 1]);
                                                //Dummy = this.CopyRemeiningItems(Dummy, Order * -1);
                                                if (!FormRefrigtz.Blitz)
                                                    SolderesOnTable[i].SoldierThinking[0].AStarGreedy[SolderesOnTable[i].SoldierThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt(iAStarGreedy, ii, jj, a, Table, Order, false, FOUND);
                                                //Initaite Of Brown Order Global Varibales By Local Varibales.
                                                Order = DummyOrder;
                                                ChessRules.CurrentOrder = DummyCurrentOrder;
                                                //Refrigtz.Timer finsishing of Ending Operation in Recursive Calling.
                                                //S = (TimerColor.AStarGreedytiLevelMaxInitiate(timer, iAStarGreedy));
                                                //if (S == -1)    //have to Zero. Non Decreamet Algorithm not found.
                                                //AStarGreedyiLevelMax = 0;

                                                if (iAStarGreedy > AStarGreedyiLevelMax && iAStarGreedy != 1)
                                                {
                                                    SolderesOnTable[i].SoldierThinking[0].AStarGreedy = null;
                                                    return null;
                                                }
                                            }

                                        }

                                        else if (!FormRefrigtz.Blitz)//When There is Current Brown Existing Objective Thinking Movments.
                                        {
                                            //For Each Current Brown Existing Objective Thinking Movments.
                                            for (j = 0; j < SolderesOnTable[i].SoldierThinking[0].TableListSolder.Count; j++)
                                            {
                                                //Thinking of Thinking Brown CurrentTable Objective Operations.
                                                SolderesOnTable[i].SoldierThinking[0].ThinkingBegin = true;
                                                SolderesOnTable[i].SoldierThinking[0].ThinkingFinished = false;
                                                SolderesOnTable[i].SoldierThinking[0].t = new Task(new Action(SolderesOnTable[i].SoldierThinking[0].Thinking));
                                                SolderesOnTable[i].SoldierThinking[0].t.Start();
                                                if (SolderesOnTable[i].SoldierThinking[0].t != null) { Object tttt = new Object(); lock (tttt) { tH.Add(SolderesOnTable[i].SoldierThinking[0].t); } }
                                                //Wait For Brown Current Objects Thinking Finishing.
                                                // Wait(this, i, j, 0, 1, false);
                                                //SolderesOnTable[i].SoldierThinking[0].t.Abort();
                                                //SolderesOnTable[i].SoldierThinking[0].t.Wait();
                                                //If There is Not Brown Thinking Successfule Thinking Objective Movments. 
                                                if (SolderesOnTable[i].SoldierThinking[0].TableListSolder.Count == 0)
                                                    continue;
                                                //AStarGreedy Brown Thinking of Thinking Curretn Object Recursive Main Method Calling.                                           
                                                Order = DummyOrder;
                                                ChessRules.CurrentOrder = DummyCurrentOrder;
                                                if (Order * -1 == 1)
                                                    a = Color.Gray;
                                                else
                                                    a = Color.Brown;
                                                Order *= -1;
                                                ChessRules.CurrentOrder *= -1;
                                                SolderesOnTable[i].SoldierThinking[0].AStarGreedy.Add(new AllDraw(MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, ref THIS));
                                                //SolderesOnTable[i].SoldierThinking[0].AStarGreedy[SolderesOnTable[i].SoldierThinking[0].AStarGreedy.Count - 1].SolderesOnTable[i] = newDrawSoldier(MovementsAStarGreedyHuristicFoundT,IgnoreSelfObjectsT,UsePenaltyRegardMechnisamT,BestMovmentsT,PredictHuristicT,OnlySelfT,AStarGreedyHuristicT,ArrangmentsChanged, SolderesOnTable[i].Row, SolderesOnTable[i].Column, SolderesOnTable[i].color, SolderesOnTable[i].Table, SolderesOnTable[i].Order, false, SolderesOnTable[i].Current);
                                                this.Clone(SolderesOnTable[i].SoldierThinking[0].AStarGreedy[SolderesOnTable[i].SoldierThinking[0].AStarGreedy.Count - 1]);
                                                //Dummy = this.CopyRemeiningItems(Dummy, Order * -1);
                                                //Initaite Of Brown Order Global Varibales By Local Varibales.
                                                Order = DummyOrder;
                                                ChessRules.CurrentOrder = DummyCurrentOrder;
                                                //Refrigtz.Timer finsishing of Ending Operation in Recursive Calling.
                                                //S = (TimerColor.AStarGreedytiLevelMaxInitiate(timer, iAStarGreedy));
                                                //if (S == -1)    //have to Zero. Non Decreamet Algorithm not found.
                                                //AStarGreedyiLevelMax = 0;

                                                if (iAStarGreedy > AStarGreedyiLevelMax && iAStarGreedy != 1)
                                                {
                                                    SolderesOnTable[i].SoldierThinking[0].AStarGreedy = null;
                                                    return null;
                                                }
                                            }

                                        }
                                    }
                                }
                                catch (Exception t)
                                {

                                }
                            }
                            try
                            {
                                SA = true;
                                //IncreaseprogressBarRefregitzValue(//THIS.progressBarVerify, increasedProgress);
                                //THIS.progressBarVerify.Invalidate();
                                //SetprogressBarUpdate(//THIS.progressBarVerify);
                            }
                            catch (Exception t) { }
                            for (i = ElefantMidle; i < ElefantHigh; i++)
                            {
                                try
                                {
                                    Order = DummyOrder;
                                    ChessRules.CurrentOrder = DummyCurrentOrder;
                                    if (ElephantOnTable[i] == null)
                                        continue;
                                    //Initiate Local varibale By Global Objective Varibales.
                                    ii = (int)ElephantOnTable[i].Row;
                                    jj = (int)ElephantOnTable[i].Column;
                                    //Construction of Thinking Brown Current Objects.
                                    ElephantOnTable[i] = new DrawElefant(MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, ii, jj, a, Table, Order, false, i); ;
                                    {
                                        //When There is Current Brown Object Table List Thinking Objective Movments.
                                        if (ElephantOnTable[i].ElefantThinking[0].TableListElefant.Count == 0)
                                        {
                                            //For Each Brown Possible Movments. 
                                            for (j = 0; j < AllDraw.ElefantMovments; j++)
                                            {
                                                //Thinking Operations of Brown Current Objects.
                                                ElephantOnTable[i].ElefantThinking[0].ThinkingBegin = true;
                                                ElephantOnTable[i].ElefantThinking[0].ThinkingFinished = false;
                                                ElephantOnTable[i].ElefantThinking[0].t = new Task(new Action(ElephantOnTable[i].ElefantThinking[0].Thinking));
                                                ElephantOnTable[i].ElefantThinking[0].t.Start();
                                                if (ElephantOnTable[i].ElefantThinking[0].t != null) { Object tttt = new Object(); lock (tttt) { tH.Add(ElephantOnTable[i].ElefantThinking[0].t); } }
                                                //Wait For Brown Current Objects Thinking Finishing.
                                                // Wait(this, i, j, 0, 2, false);
                                                //ElephantOnTable[i].ElefantThinking[0].t.Abort();
                                                //ElephantOnTable[i].ElefantThinking[0].t.Wait();
                                                //If There is Not Brown Thinking Successfule Objective Movments. 
                                                if (ElephantOnTable[i].ElefantThinking[0].TableListElefant.Count == 0)
                                                    continue;
                                                /*if (Order == 1)
                                                {
                                                    //THIS.SetBoxText("\r\nChess Thinking AStarGreedy " + iAStarGreedy.ToString() + " For Elephant By Bob!");
                                                    //THIS.RefreshBoxText();
                                                }
                                                else//If Order is Brown.
                                                {
                                                    //THIS.SetBoxText("\r\nChess Thinking AStarGreedy " + iAStarGreedy.ToString() + " For Elephant By Alice!");
                                                    //THIS.RefreshBoxText();
                                                }

                                                 */
                                                //Initiate of Local Varibale By Global Orders.
                                                Order = DummyOrder;
                                                ChessRules.CurrentOrder = DummyCurrentOrder;
                                                if (Order * -1 == 1)
                                                    a = Color.Gray;
                                                else
                                                    a = Color.Brown;
                                                Order *= -1;
                                                ChessRules.CurrentOrder *= -1;
                                                ElephantOnTable[i].ElefantThinking[0].AStarGreedy.Add(new AllDraw(MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, ref THIS));
                                                //ElephantOnTable[i].ElefantThinking[0].AStarGreedy[ElephantOnTable[i].ElefantThinking[0].AStarGreedy.Count - 1].ElephantOnTable[i] = new DrawElefant(MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT,ArrangmentsChanged, ElephantOnTable[i].Row, ElephantOnTable[i].Column, ElephantOnTable[i].color, ElephantOnTable[i].Table, ElephantOnTable[i].Order, false, ElephantOnTable[i].Current);
                                                this.ElephantOnTable[i].Clone(ref ElephantOnTable[i].ElefantThinking[0].AStarGreedy[ElephantOnTable[i].ElefantThinking[0].AStarGreedy.Count - 1].ElephantOnTable[i]);
                                                //Dummy = this.CopyRemeiningItems(Dummy, Order * -1);
                                                if (!FormRefrigtz.Blitz)
                                                    ElephantOnTable[i].ElefantThinking[0].AStarGreedy[ElephantOnTable[i].ElefantThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt(iAStarGreedy, ii, jj, a, Table, Order, false, FOUND);
                                                //Initaite Of Brown Order Global Varibales By Local Varibales.
                                                Order = DummyOrder;
                                                ChessRules.CurrentOrder = DummyCurrentOrder;
                                                //Refrigtz.Timer finsishing of Ending Operation in Recursive Calling.
                                                //S = (TimerColor.AStarGreedytiLevelMaxInitiate(timer, iAStarGreedy));
                                                //if (S == -1)    //have to Zero. Non Decreamet Algorithm not found.
                                                //AStarGreedyiLevelMax = 0;

                                                if (iAStarGreedy > AStarGreedyiLevelMax && iAStarGreedy != 1)
                                                {
                                                    ElephantOnTable[i].ElefantThinking[0].AStarGreedy = null;
                                                    return null;
                                                }
                                            }
                                        }
                                        else if (!FormRefrigtz.Blitz)//When There is Current Brown Existing Objective Thinking Movments.
                                        {
                                            //For Each Current Brown Existing Objective Thinking Movments.
                                            for (j = 0; j < ElephantOnTable[i].ElefantThinking[0].TableListElefant.Count; j++)
                                            {
                                                //Inititae Local Varibale By Global Gray Elephant Objects Varibales.
                                                //Thinking of Thinking Brown CurrentTable Objective Operations.                                                   
                                                ElephantOnTable[i].ElefantThinking[0].ThinkingBegin = true;
                                                ElephantOnTable[i].ElefantThinking[0].ThinkingFinished = false;
                                                ElephantOnTable[i].ElefantThinking[0].t = new Task(new Action(ElephantOnTable[i].ElefantThinking[0].Thinking));
                                                ElephantOnTable[i].ElefantThinking[0].t.Start();
                                                if (ElephantOnTable[i].ElefantThinking[0].t != null) { Object tttt = new Object(); lock (tttt) { tH.Add(ElephantOnTable[i].ElefantThinking[0].t); } }
                                                //Wait For Brown Current Objects Thinking Finishing.
                                                // Wait(this, i, j, 0, 2, false);
                                                //ElephantOnTable[i].ElefantThinking[0].t.Abort();
                                                //ElephantOnTable[i].ElefantThinking[0].t.Wait();
                                                //If There is Not Brown Thinking Successfule Thinking Objective Movments. 
                                                if (ElephantOnTable[i].ElefantThinking[0].TableListElefant.Count == 0)
                                                    continue;
                                                //Initiate of Local Varibale By Global Orders.
                                                ChessRules.CurrentOrder = DummyCurrentOrder;
                                                if (Order * -1 == 1)
                                                    a = Color.Gray;
                                                else
                                                    a = Color.Brown;
                                                Order *= -1;
                                                ChessRules.CurrentOrder *= -1;
                                                ElephantOnTable[i].ElefantThinking[0].AStarGreedy.Add(new AllDraw(MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, ref THIS));
                                                //ElephantOnTable[i].ElefantThinking[0].AStarGreedy[ElephantOnTable[i].ElefantThinking[0].AStarGreedy.Count - 1].ElephantOnTable[i] = new DrawElefant(MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT,ArrangmentsChanged, ElephantOnTable[i].Row, ElephantOnTable[i].Column, ElephantOnTable[i].color, ElephantOnTable[i].Table, ElephantOnTable[i].Order, false, ElephantOnTable[i].Current);
                                                this.Clone(ElephantOnTable[i].ElefantThinking[0].AStarGreedy[ElephantOnTable[i].ElefantThinking[0].AStarGreedy.Count - 1]);
                                                //Dummy = this.CopyRemeiningItems(Dummy, Order * -1);
                                                //Initaite Of Brown Order Global Varibales By Local Varibales.
                                                Order = DummyOrder;
                                                ChessRules.CurrentOrder = DummyCurrentOrder;
                                                //Refrigtz.Timer finsishing of Ending Operation in Recursive Calling.
                                                //S = (TimerColor.AStarGreedytiLevelMaxInitiate(timer, iAStarGreedy));
                                                //if (S == -1)    //have to Zero. Non Decreamet Algorithm not found.
                                                //AStarGreedyiLevelMax = 0;

                                                if (iAStarGreedy > AStarGreedyiLevelMax && iAStarGreedy != 1)
                                                {
                                                    ElephantOnTable[i].ElefantThinking[0].AStarGreedy = null;
                                                    return null;
                                                }
                                            }
                                        }
                                    }
                                }
                                catch (Exception t)
                                {

                                }
                            }
                            //Progressing.
                            try
                            {
                                EA = true;
                                //IncreaseprogressBarRefregitzValue(//THIS.progressBarVerify, increasedProgress);
                                //THIS.progressBarVerify.Invalidate();
                                //SetprogressBarUpdate(//THIS.progressBarVerify);
                            }
                            catch (Exception t) { }


                            for (i = HourseMidle; i < HourseHight; i++)
                            {
                                try
                                {
                                    Order = DummyOrder;
                                    ChessRules.CurrentOrder = DummyCurrentOrder;
                                    if (HoursesOnTable[i] == null)
                                        continue;
                                    //Initiate Local varibale By Global Objective Varibales.
                                    ii = (int)HoursesOnTable[i].Row;
                                    jj = (int)HoursesOnTable[i].Column;
                                    //Construction of Thinking Brown Current Objects.
                                    HoursesOnTable[i] = new DrawHourse(MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, ii, jj, a, Table, Order, false, i); ;

                                    {
                                        //When There is Current Brown Object Table List Thinking Objective Movments.
                                        if (HoursesOnTable[i].HourseThinking[0].TableListHourse.Count == 0)
                                        {
                                            //For Each Brown Possible Movments. 
                                            for (j = 0; j < AllDraw.HourseMovments; j++)
                                            {
                                                //Thinking Operations of Brown Current Objects.
                                                //HoursesOnTable[i].HourseThinking[0].TableT = HoursesOnTable[i].HourseThinking[0].TableT;
                                                HoursesOnTable[i].HourseThinking[0].ThinkingBegin = true;
                                                HoursesOnTable[i].HourseThinking[0].ThinkingFinished = false;
                                                HoursesOnTable[i].HourseThinking[0].t = new Task(new Action(HoursesOnTable[i].HourseThinking[0].Thinking));
                                                HoursesOnTable[i].HourseThinking[0].t.Start();
                                                if (HoursesOnTable[i].HourseThinking[0].t != null) { Object tttt = new Object(); lock (tttt) { tH.Add(HoursesOnTable[i].HourseThinking[0].t); } }
                                                //Wait For Brown Current Objects Thinking Finishing.
                                                // Wait(this, i, j, 0, 3, false);
                                                //HoursesOnTable[i].HourseThinking[0].t.Abort();
                                                //HoursesOnTable[i].HourseThinking[0].t.Wait();
                                                //If There is Not Brown Thinking Successfule Objective Movments. 
                                                if (HoursesOnTable[i].HourseThinking[0].TableListHourse.Count == 0)
                                                    continue;
                                                /*if (Order == 1)
                                                {
                                                    //THIS.SetBoxText("\r\nChess Thinking AStarGreedy " + iAStarGreedy.ToString() + " For Hourse By Bob!");
                                                    //THIS.RefreshBoxText();
                                                }
                                                else//If Order is Brown.
                                                {
                                                    //THIS.SetBoxText("\r\nChess Thinking AStarGreedy " + iAStarGreedy.ToString() + " For Hourse By Alice!");
                                                    //THIS.RefreshBoxText();
                                                }

                                                 */
                                                //Initiate of Local Varibale By Global Orders.
                                                Order = DummyOrder;
                                                ChessRules.CurrentOrder = DummyCurrentOrder;
                                                if (Order * -1 == 1)
                                                    a = Color.Gray;
                                                else
                                                    a = Color.Brown;
                                                Order *= -1;
                                                ChessRules.CurrentOrder *= -1;
                                                //AStarGreedy Brown Thinking Curretn Object Recursive Main Method Calling.
                                                //AllDraw AdumnmyConstructedD = new AllDraw(MovementsAStarGreedyHuristicFoundT,IgnoreSelfObjectsT,UsePenaltyRegardMechnisamT,BestMovmentsT,PredictHuristicT,OnlySelfT,AStarGreedyHuristicT,ArrangmentsChanged,ref THIS);
                                                //this.CopyRemeiningItems(AdumnmyConstructedD);
                                                //AdumnmyConstructedD.HoursesOnTable[i].HourseThinking[0] = HoursesOnTable[i].HourseThinking[0];
                                                //Dummy = AdumnmyConstructedD;
                                                //int[,] Taba = ADraw[0].HuristicCurrentTable(ADraw[0], a, Order);
                                                HoursesOnTable[i].HourseThinking[0].AStarGreedy.Add(new AllDraw(MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, ref THIS));
                                                //HoursesOnTable[i].HourseThinking[0].AStarGreedy[HoursesOnTable[i].HourseThinking[0].AStarGreedy.Count - 1].HoursesOnTable[i] = new DrawHourse(MovementsAStarGreedyHuristicFoundT,IgnoreSelfObjectsT,UsePenaltyRegardMechnisamT,BestMovmentsT,PredictHuristicT,OnlySelfT,AStarGreedyHuristicT,ArrangmentsChanged, HoursesOnTable[i].Row, HoursesOnTable[i].Column, HoursesOnTable[i].color, HoursesOnTable[i].Table, HoursesOnTable[i].Order, false, HoursesOnTable[i].Current);
                                                this.Clone(HoursesOnTable[i].HourseThinking[0].AStarGreedy[HoursesOnTable[i].HourseThinking[0].AStarGreedy.Count - 1]);
                                                //HoursesOnTable[i].HourseThinking[0].AStarGreedy[HoursesOnTable[i].HourseThinking[0].AStarGreedy.Count - 1].TableList.Clear();
                                                //HoursesOnTable[i].HourseThinking[0].AStarGreedy[HoursesOnTable[i].HourseThinking[0].AStarGreedy.Count - 1].TableList.Add(HoursesOnTable[i].HourseThinking[0].Table);
                                                //HoursesOnTable[i].HourseThinking[0].AStarGreedy[HoursesOnTable[i].HourseThinking[0].AStarGreedy.Count - 1].SetRowColumn(0);
                                                //Dummy = this.CopyRemeiningItems(Dummy, Order * -1);
                                                //HoursesOnTable[i].HourseThinking[0].Clone(ref HoursesOnTable[i].HourseThinking[0].AStarGreedy[HoursesOnTable[i].HourseThinking[0].AStarGreedy.Count - 1].HoursesOnTable[i].HourseThinking[0]);
                                                if (!FormRefrigtz.Blitz)
                                                    HoursesOnTable[i].HourseThinking[0].AStarGreedy[HoursesOnTable[i].HourseThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt(iAStarGreedy, ii, jj, a, Table, Order, false, FOUND);
                                                //HoursesOnTable[i].HourseThinking[0].AStarGreedy[HoursesOnTable[i].HourseThinking[0].AStarGreedy.Count - 1].Clone(HoursesOnTable[i].HourseThinking[0].AStarGreedy[HoursesOnTable[i].HourseThinking[0].AStarGreedy.Count - 1]);
                                                //Initaite Of Brown Order Global Varibales By Local Varibales.
                                                Order = DummyOrder;
                                                ChessRules.CurrentOrder = DummyCurrentOrder;
                                                //Refrigtz.Timer finsishing of Ending Operation in Recursive Calling.
                                                //S = (TimerColor.AStarGreedytiLevelMaxInitiate(timer, iAStarGreedy));
                                                //if (S == -1)    //have to Zero. Non Decreamet Algorithm not found.
                                                //AStarGreedyiLevelMax = 0;

                                                if (iAStarGreedy > AStarGreedyiLevelMax && iAStarGreedy != 1)
                                                {
                                                    HoursesOnTable[i].HourseThinking[0].AStarGreedy = null;
                                                    return null;
                                                }

                                            }
                                        }
                                        else if (!FormRefrigtz.Blitz)//When There is Current Brown Existing Objective Thinking Movments.
                                        {
                                            //For Each Current Brown Existing Objective Thinking Movments.
                                            for (j = 0; j < HoursesOnTable[i].HourseThinking[0].TableListHourse.Count; j++)
                                            {
                                                //Thinking of Thinking Brown CurrentTable Objective Operations.                                          SolderesOnTable[i].SoldierThinking[0].Table = SolderesOnTable[i].SoldierThinking[0].TableListSolder[j];
                                                HoursesOnTable[i].HourseThinking[0].ThinkingBegin = true;
                                                HoursesOnTable[i].HourseThinking[0].ThinkingFinished = false;
                                                HoursesOnTable[i].HourseThinking[0].t = new Task(new Action(HoursesOnTable[i].HourseThinking[0].Thinking));
                                                HoursesOnTable[i].HourseThinking[0].t.Start();
                                                if (HoursesOnTable[i].HourseThinking[0].t != null) { Object tttt = new Object(); lock (tttt) { tH.Add(HoursesOnTable[i].HourseThinking[0].t); } }
                                                //Wait For Brown Current Objects Thinking Finishing.
                                                // Wait(this, i, j, 0, 3, false);
                                                //HoursesOnTable[i].HourseThinking[0].t.Abort();
                                                //HoursesOnTable[i].HourseThinking[0].t.Wait();
                                                //If There is Not Brown Thinking Successfule Thinking Objective Movments. 
                                                if (HoursesOnTable[i].HourseThinking[0].TableListHourse.Count == 0)
                                                    continue;
                                                //Initiate of Local Varibale By Global Orders.
                                                ChessRules.CurrentOrder *= -1;
                                                //AStarGreedy Brown Thinking of Thinking Curretn Object Recursive Main Method Calling.                                           
                                                Order = DummyOrder;
                                                ChessRules.CurrentOrder = DummyCurrentOrder;
                                                if (Order * -1 == 1)
                                                    a = Color.Gray;
                                                else
                                                    a = Color.Brown;
                                                Order *= -1;
                                                ChessRules.CurrentOrder *= -1;
                                                HoursesOnTable[i].HourseThinking[0].AStarGreedy.Add(new AllDraw(MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, ref THIS));
                                                //HoursesOnTable[i].HourseThinking[0].AStarGreedy[HoursesOnTable[i].HourseThinking[0].AStarGreedy.Count - 1].HoursesOnTable[i] = new DrawHourse(MovementsAStarGreedyHuristicFoundT,IgnoreSelfObjectsT,UsePenaltyRegardMechnisamT,BestMovmentsT,PredictHuristicT,OnlySelfT,AStarGreedyHuristicT,ArrangmentsChanged, HoursesOnTable[i].Row, HoursesOnTable[i].Column, HoursesOnTable[i].color, HoursesOnTable[i].Table, HoursesOnTable[i].Order, false, HoursesOnTable[i].Current);
                                                this.Clone(HoursesOnTable[i].HourseThinking[0].AStarGreedy[HoursesOnTable[i].HourseThinking[0].AStarGreedy.Count - 1]);
                                                //Dummy = this.CopyRemeiningItems(Dummy, Order * -1);
                                                //Initaite Of Brown Order Global Varibales By Local Varibales.
                                                Order = DummyOrder;
                                                ChessRules.CurrentOrder = DummyCurrentOrder;
                                                //Refrigtz.Timer finsishing of Ending Operation in Recursive Calling.
                                                //S = (TimerColor.AStarGreedytiLevelMaxInitiate(timer, iAStarGreedy));
                                                //if (S == -1)    //have to Zero. Non Decreamet Algorithm not found.
                                                //AStarGreedyiLevelMax = 0;

                                                if (iAStarGreedy > AStarGreedyiLevelMax && iAStarGreedy != 1)
                                                {
                                                    HoursesOnTable[i].HourseThinking[0].AStarGreedy = null;
                                                    return null;
                                                }

                                            }
                                        }

                                    }
                                }
                                catch (Exception t)
                                {

                                }
                            }
                            //Progressing.
                            try
                            {
                                HA = true;
                                //IncreaseprogressBarRefregitzValue(//THIS.progressBarVerify, increasedProgress);
                                //THIS.progressBarVerify.Invalidate();
                                //SetprogressBarUpdate(//THIS.progressBarVerify);
                            }
                            catch (Exception t) { }



                            for (i = BridgeMidle; i < BridgeHigh; i++)
                            {
                                try
                                {
                                    Order = DummyOrder;
                                    ChessRules.CurrentOrder = DummyCurrentOrder;
                                    if (BridgesOnTable[i] == null)
                                        continue;
                                    //Initiate Local varibale By Global Objective Varibales.
                                    ii = (int)BridgesOnTable[i].Row;
                                    jj = (int)BridgesOnTable[i].Column;
                                    //Construction of Thinking Brown Current Objects.
                                    BridgesOnTable[i] = new DrawBridge(MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, ii, jj, a, Table, Order, false, i); ;

                                    {
                                        //When There is Current Brown Object Table List Thinking Objective Movments.
                                        if (BridgesOnTable[i].BridgeThinking[0].TableListBridge.Count == 0)
                                        {
                                            //For Each Brown Possible Movments. 
                                            for (j = 0; j < AllDraw.BridgeMovments; j++)
                                            {
                                                //Thinking Operations of Brown Current Objects.
                                                BridgesOnTable[i].BridgeThinking[0].ThinkingBegin = true;
                                                BridgesOnTable[i].BridgeThinking[0].ThinkingFinished = false;
                                                BridgesOnTable[i].BridgeThinking[0].t = new Task(new Action(BridgesOnTable[i].BridgeThinking[0].Thinking));
                                                BridgesOnTable[i].BridgeThinking[0].t.Start();
                                                if (BridgesOnTable[i].BridgeThinking[0].t != null) { Object tttt = new Object(); lock (tttt) { tH.Add(BridgesOnTable[i].BridgeThinking[0].t); } }
                                                //Wait For Brown Current Objects Thinking Finishing.
                                                // Wait(this, i, j, 0, 4, false);
                                                //BridgesOnTable[i].BridgeThinking[0].t.Abort();
                                                ///BridgesOnTable[i].BridgeThinking[0].t.Wait();
                                                //If There is Not Brown Thinking Successfule Objective Movments. 
                                                if (BridgesOnTable[i].BridgeThinking[0].TableListBridge.Count == 0)
                                                    continue;
                                                /*if (Order == 1)
                                                {
                                                    //THIS.SetBoxText("\r\nChess Thinking AStarGreedy " + iAStarGreedy.ToString() + " For Bridges By Bob!");
                                                    //THIS.RefreshBoxText();
                                                }
                                                else//If Order is Brown.
                                                {
                                                    //THIS.SetBoxText("\r\nChess Thinking AStarGreedy " + iAStarGreedy.ToString() + " For Bridges By Alice!");
                                                    //THIS.RefreshBoxText();
                                                }

                                                 */
                                                //Initiate of Local Varibale By Global Orders.
                                                Order = DummyOrder;
                                                ChessRules.CurrentOrder = DummyCurrentOrder;
                                                if (Order * -1 == 1)
                                                    a = Color.Gray;
                                                else
                                                    a = Color.Brown;
                                                Order *= -1;
                                                ChessRules.CurrentOrder *= -1;
                                                BridgesOnTable[i].BridgeThinking[0].AStarGreedy.Add(new AllDraw(MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, ref THIS));
                                                //BridgesOnTable[i].BridgeThinking[0].AStarGreedy[BridgesOnTable[i].BridgeThinking[0].AStarGreedy.Count - 1].BridgesOnTable[i] = new DrawBridge(MovementsAStarGreedyHuristicFoundT,IgnoreSelfObjectsT,UsePenaltyRegardMechnisamT,BestMovmentsT,PredictHuristicT,OnlySelfT,AStarGreedyHuristicT,ArrangmentsChanged, BridgesOnTable[i].Row, BridgesOnTable[i].Column, BridgesOnTable[i].color, BridgesOnTable[i].Table, BridgesOnTable[i].Order, false, BridgesOnTable[i].Current);
                                                this.Clone(BridgesOnTable[i].BridgeThinking[0].AStarGreedy[BridgesOnTable[i].BridgeThinking[0].AStarGreedy.Count - 1]);
                                                //Dummy = this.CopyRemeiningItems(Dummy, Order * -1);
                                                if (!FormRefrigtz.Blitz)
                                                    BridgesOnTable[i].BridgeThinking[0].AStarGreedy[BridgesOnTable[i].BridgeThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt(iAStarGreedy, ii, jj, a, Table, Order, false, FOUND);
                                                //Initaite Of Brown Order Global Varibales By Local Varibales.
                                                Order = DummyOrder;
                                                ChessRules.CurrentOrder = DummyCurrentOrder;
                                                //Refrigtz.Timer finsishing of Ending Operation in Recursive Calling.
                                                //S = (TimerColor.AStarGreedytiLevelMaxInitiate(timer, iAStarGreedy));
                                                //if (S == -1)    //have to Zero. Non Decreamet Algorithm not found.
                                                //AStarGreedyiLevelMax = 0;

                                                if (iAStarGreedy > AStarGreedyiLevelMax && iAStarGreedy != 1)
                                                {
                                                    BridgesOnTable[i].BridgeThinking[0].AStarGreedy = null;
                                                    return null;
                                                }
                                            }
                                        }
                                        else if (!FormRefrigtz.Blitz)//When There is Current Brown Existing Objective Thinking Movments.
                                        {
                                            //For Each Current Brown Existing Objective Thinking Movments.
                                            for (j = 0; j < BridgesOnTable[i].BridgeThinking[0].TableListBridge.Count; j++)
                                            {
                                                //Thinking of Thinking Brown CurrentTable Objective Operations.        
                                                BridgesOnTable[i].BridgeThinking[0].ThinkingBegin = true;
                                                BridgesOnTable[i].BridgeThinking[0].ThinkingFinished = false;
                                                BridgesOnTable[i].BridgeThinking[0].t = new Task(new Action(BridgesOnTable[i].BridgeThinking[0].Thinking));
                                                BridgesOnTable[i].BridgeThinking[0].t.Start();
                                                if (BridgesOnTable[i].BridgeThinking[0].t != null) { Object tttt = new Object(); lock (tttt) { tH.Add(BridgesOnTable[i].BridgeThinking[0].t); } }
                                                //Wait For Brown Current Objects Thinking Finishing.
                                                // Wait(this, i, j, 0, 4, false);
                                                //BridgesOnTable[i].BridgeThinking[0].t.Abort();
                                                //BridgesOnTable[i].BridgeThinking[0].t.Wait();
                                                //If There is Not Brown Thinking Successfule Thinking Objective Movments. 
                                                if (BridgesOnTable[i].BridgeThinking[0].TableListBridge.Count == 0)
                                                    continue;
                                                //AStarGreedy Brown Thinking of Thinking Curretn Object Recursive Main Method Calling.                                           
                                                Order = DummyOrder;
                                                ChessRules.CurrentOrder = DummyCurrentOrder;
                                                if (Order * -1 == 1)
                                                    a = Color.Gray;
                                                else
                                                    a = Color.Brown;
                                                Order *= -1;
                                                ChessRules.CurrentOrder *= -1;
                                                BridgesOnTable[i].BridgeThinking[0].AStarGreedy.Add(new AllDraw(MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, ref THIS));
                                                //BridgesOnTable[i].BridgeThinking[0].AStarGreedy[BridgesOnTable[i].BridgeThinking[0].AStarGreedy.Count - 1].BridgesOnTable[i] = new DrawBridge(MovementsAStarGreedyHuristicFoundT,IgnoreSelfObjectsT,UsePenaltyRegardMechnisamT,BestMovmentsT,PredictHuristicT,OnlySelfT,AStarGreedyHuristicT,ArrangmentsChanged, BridgesOnTable[i].Row, BridgesOnTable[i].Column, BridgesOnTable[i].color, BridgesOnTable[i].Table, BridgesOnTable[i].Order, false, BridgesOnTable[i].Current);
                                                this.Clone(BridgesOnTable[i].BridgeThinking[0].AStarGreedy[BridgesOnTable[i].BridgeThinking[0].AStarGreedy.Count - 1]);
                                                //Dummy = this.CopyRemeiningItems(Dummy, Order * -1);
                                                //Initaite Of Brown Order Global Varibales By Local Varibales.
                                                Order = DummyOrder;
                                                ChessRules.CurrentOrder = DummyCurrentOrder;
                                                //Refrigtz.Timer finsishing of Ending Operation in Recursive Calling.
                                                //S = (TimerColor.AStarGreedytiLevelMaxInitiate(timer, iAStarGreedy));
                                                //if (S == -1)    //have to Zero. Non Decreamet Algorithm not found.
                                                //AStarGreedyiLevelMax = 0;

                                                if (iAStarGreedy > AStarGreedyiLevelMax && iAStarGreedy != 1)
                                                {
                                                    BridgesOnTable[i].BridgeThinking[0].AStarGreedy = null;
                                                    return null;
                                                }
                                            }
                                        }

                                    }
                                }
                                catch (Exception t)
                                {

                                }
                            }
                            try
                            {
                                BA = true;
                                //IncreaseprogressBarRefregitzValue(//THIS.progressBarVerify, increasedProgress);
                                //THIS.progressBarVerify.Invalidate();
                                //SetprogressBarUpdate(//THIS.progressBarVerify);
                            }
                            catch (Exception t) { }
                            for (i = MinisterMidle; i < MinisterHigh; i++)
                            {
                                try
                                {
                                    Order = DummyOrder;
                                    ChessRules.CurrentOrder = DummyCurrentOrder;
                                    if (MinisterOnTable[i] == null)
                                        continue;
                                    //Initiate Local varibale By Global Objective Varibales.
                                    ii = (int)MinisterOnTable[i].Row;
                                    jj = (int)MinisterOnTable[i].Column;
                                    //Construction of Thinking Brown Current Objects.
                                    MinisterOnTable[i] = new DrawMinister(MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, ii, jj, a, Table, Order, false, i); ;

                                    //When There is Current Brown Object Table List Thinking Objective Movments.
                                    if (MinisterOnTable[i].MinisterThinking[0].TableListMinister.Count == 0)
                                    {
                                        //For Each Brown Possible Movments. 
                                        for (j = 0; j < AllDraw.MinisterMovments; j++)
                                        {
                                            //Thinking Operations of Brown Current Objects.
                                            MinisterOnTable[i].MinisterThinking[0].ThinkingBegin = true;
                                            MinisterOnTable[i].MinisterThinking[0].ThinkingFinished = false;
                                            MinisterOnTable[i].MinisterThinking[0].t = new Task(new Action(MinisterOnTable[i].MinisterThinking[0].Thinking));
                                            MinisterOnTable[i].MinisterThinking[0].t.Start();
                                            if (MinisterOnTable[i].MinisterThinking[0].t != null) { Object tttt = new Object(); lock (tttt) { tH.Add(MinisterOnTable[i].MinisterThinking[0].t); } }
                                            //Wait For Brown Current Objects Thinking Finishing.
                                            // Wait(this, i, j, 0, 5, false);
                                            //MinisterOnTable[i].MinisterThinking[0].t.Abort();
                                            //MinisterOnTable[i].MinisterThinking[0].t.Wait();
                                            //If There is Not Brown Thinking Successfule Objective Movments. 
                                            if (MinisterOnTable[i].MinisterThinking[0].TableListMinister.Count == 0)
                                                continue;
                                            /*if (Order == 1)
                                            {
                                                //THIS.SetBoxText("\r\nChess Thinking AStarGreedy " + iAStarGreedy.ToString() + " For Minister By Bob!");
                                                //THIS.RefreshBoxText();
                                            }
                                            else//If Order is Brown.
                                            {
                                                //THIS.SetBoxText("\r\nChess Thinking AStarGreedy " + iAStarGreedy.ToString() + " For Minister By Alice!");
                                                //THIS.RefreshBoxText();
                                            }

                                             */
                                            //Initiate of Local Varibale By Global Orders.
                                            Order = DummyOrder;
                                            ChessRules.CurrentOrder = DummyCurrentOrder;
                                            if (Order * -1 == 1)
                                                a = Color.Gray;
                                            else
                                                a = Color.Brown;
                                            Order *= -1;
                                            ChessRules.CurrentOrder *= -1;
                                            //AStarGreedy Brown Thinking of Thinking Curretn Object Recursive Main Method Calling.                                           
                                            MinisterOnTable[i].MinisterThinking[0].AStarGreedy.Add(new AllDraw(MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, ref THIS));
                                            //MinisterOnTable[i].MinisterThinking[0].AStarGreedy[MinisterOnTable[i].MinisterThinking[0].AStarGreedy.Count - 1].MinisterOnTable[i] = new DrawMinister(MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT,ArrangmentsChanged, MinisterOnTable[i].Row, MinisterOnTable[i].Column, MinisterOnTable[i].color, MinisterOnTable[i].Table, MinisterOnTable[i].Order, false, MinisterOnTable[i].Current);
                                            this.Clone(MinisterOnTable[i].MinisterThinking[0].AStarGreedy[MinisterOnTable[i].MinisterThinking[0].AStarGreedy.Count - 1]);
                                            //Dummy = this.CopyRemeiningItems(Dummy, Order * -1);
                                            if (!FormRefrigtz.Blitz)
                                                MinisterOnTable[i].MinisterThinking[0].AStarGreedy[MinisterOnTable[i].MinisterThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt(iAStarGreedy, ii, jj, a, Table, Order, false, FOUND);
                                            //Initaite Of Brown Order Global Varibales By Local Varibales.
                                            Order = DummyOrder;
                                            ChessRules.CurrentOrder = DummyCurrentOrder;
                                            //Refrigtz.Timer finsishing of Ending Operation in Recursive Calling.
                                            //S = (TimerColor.AStarGreedytiLevelMaxInitiate(timer, iAStarGreedy));
                                            //if (S == -1)    //have to Zero. Non Decreamet Algorithm not found.
                                            //AStarGreedyiLevelMax = 0;

                                            if (iAStarGreedy > AStarGreedyiLevelMax && iAStarGreedy != 1)
                                            {
                                                MinisterOnTable[i].MinisterThinking[0].AStarGreedy = null;
                                                return null;
                                            }
                                        }
                                    }
                                    else if (!FormRefrigtz.Blitz)//When There is Current Brown Existing Objective Thinking Movments.
                                    {
                                        //For Each Current Brown Existing Objective Thinking Movments.
                                        for (j = 0; j < MinisterOnTable[i].MinisterThinking[0].TableListMinister.Count; j++)
                                        {
                                            //Thinking of Thinking Brown CurrentTable Objective Operations.                                          SolderesOnTable[i].SoldierThinking[0].Table = SolderesOnTable[i].SoldierThinking[0].TableListSolder[j];
                                            MinisterOnTable[i].MinisterThinking[0].ThinkingBegin = true;
                                            MinisterOnTable[i].MinisterThinking[0].ThinkingFinished = false;
                                            MinisterOnTable[i].MinisterThinking[0].t = new Task(new Action(MinisterOnTable[i].MinisterThinking[0].Thinking));
                                            MinisterOnTable[i].MinisterThinking[0].t.Start();
                                            if (MinisterOnTable[i].MinisterThinking[0].t != null) { Object tttt = new Object(); lock (tttt) { tH.Add(MinisterOnTable[i].MinisterThinking[0].t); } }
                                            //Wait For Brown Current Objects Thinking Finishing.
                                            // Wait(this, i, j, 0, 5, false);
                                            //MinisterOnTable[i].MinisterThinking[0].t.Abort();
                                            //MinisterOnTable[i].MinisterThinking[0].t.Wait();
                                            //If There is Not Brown Thinking Successfule Thinking Objective Movments. 
                                            if (MinisterOnTable[i].MinisterThinking[0].TableListMinister.Count == 0)
                                                continue;
                                            //AStarGreedy Brown Thinking of Thinking Curretn Object Recursive Main Method Calling.                                           
                                            Order = DummyOrder;
                                            ChessRules.CurrentOrder = DummyCurrentOrder;
                                            if (Order * -1 == 1)
                                                a = Color.Gray;
                                            else
                                                a = Color.Brown;
                                            Order *= -1;
                                            ChessRules.CurrentOrder *= -1;
                                            MinisterOnTable[i].MinisterThinking[0].AStarGreedy.Add(new AllDraw(MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, ref THIS));
                                            //MinisterOnTable[i].MinisterThinking[0].AStarGreedy[MinisterOnTable[i].MinisterThinking[0].AStarGreedy.Count - 1].MinisterOnTable[i] = new DrawMinister(MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT,ArrangmentsChanged, MinisterOnTable[i].Row, MinisterOnTable[i].Column, MinisterOnTable[i].color, MinisterOnTable[i].Table, MinisterOnTable[i].Order, false, MinisterOnTable[i].Current);
                                            this.Clone(MinisterOnTable[i].MinisterThinking[0].AStarGreedy[MinisterOnTable[i].MinisterThinking[0].AStarGreedy.Count - 1]);
                                            //Dummy = this.CopyRemeiningItems(Dummy, Order * -1);
                                            //Initaite Of Brown Order Global Varibales By Local Varibales.
                                            Order = DummyOrder;
                                            ChessRules.CurrentOrder = DummyCurrentOrder;
                                            //Refrigtz.Timer finsishing of Ending Operation in Recursive Calling.
                                            //S = (TimerColor.AStarGreedytiLevelMaxInitiate(timer, iAStarGreedy));
                                            //if (S == -1)    //have to Zero. Non Decreamet Algorithm not found.
                                            //AStarGreedyiLevelMax = 0;

                                            if (iAStarGreedy > AStarGreedyiLevelMax && iAStarGreedy != 1)
                                            {
                                                MinisterOnTable[i].MinisterThinking[0].AStarGreedy = null;
                                                return null;
                                            }
                                        }

                                    }
                                }
                                catch (Exception t)
                                {

                                }
                            }
                            //Progressing.
                            try
                            {
                                MA = true;
                                //IncreaseprogressBarRefregitzValue(//THIS.progressBarVerify, increasedProgress);
                                //THIS.progressBarVerify.Invalidate();
                                //SetprogressBarUpdate(//THIS.progressBarVerify);
                            }
                            catch (Exception t) { }

                            for (i = KingMidle; i < KingHigh; i++)
                            {
                                try
                                {
                                    Order = DummyOrder;
                                    ChessRules.CurrentOrder = DummyCurrentOrder;
                                    if (KingOnTable[i] == null)
                                        continue;
                                    //Initiate Local varibale By Global Objective Varibales.
                                    ii = (int)KingOnTable[i].Row;
                                    jj = (int)KingOnTable[i].Column;
                                    //Construction of Thinking Brown Current Objects.
                                    KingOnTable[i] = new DrawKing(MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, ii, jj, a, Table, Order, false, i); ;

                                    //When There is Current Brown Object Table List Thinking Objective Movments.
                                    if (KingOnTable[i].KingThinking[0].TableListKing.Count == 0)
                                    {
                                        //For Each Brown Possible Movments. 
                                        for (j = 0; j < AllDraw.KingMovments; j++)
                                        {
                                            //Thinking Operations of Brown Current Objects.
                                            KingOnTable[i].KingThinking[0].ThinkingBegin = true;
                                            KingOnTable[i].KingThinking[0].ThinkingFinished = false;
                                            KingOnTable[i].KingThinking[0].t = new Task(new Action(KingOnTable[i].KingThinking[0].Thinking));
                                            KingOnTable[i].KingThinking[0].t.Start();
                                            if (KingOnTable[i].KingThinking[0].t != null) { Object tttt = new Object(); lock (tttt) { tH.Add(KingOnTable[i].KingThinking[0].t); } }
                                            //Wait For Brown Current Objects Thinking Finishing.
                                            // Wait(this, i, j, 0, 6, false);
                                            // KingOnTable[i].KingThinking[0].t.Abort();
                                            //KingOnTable[i].KingThinking[0].t.Wait();
                                            //If There is Not Brown Thinking Successfule Objective Movments. 
                                            if (KingOnTable[i].KingThinking[0].TableListKing.Count == 0)
                                                continue;
                                            /*if (Order == 1)
                                            {
                                                //THIS.SetBoxText("\r\nChess Thinking AStarGreedy " + iAStarGreedy.ToString() + " For King By Bob!");
                                                //THIS.RefreshBoxText();
                                            }
                                            else//If Order is Brown.
                                            {
                                                //THIS.SetBoxText("\r\nChess Thinking AStarGreedy " + iAStarGreedy.ToString() + " For King By Alice!");
                                                //THIS.RefreshBoxText();
                                            }
                                             */
                                            //Initiate of Local Varibale By Global Orders.
                                            Order = DummyOrder;
                                            ChessRules.CurrentOrder = DummyCurrentOrder;
                                            if (Order * -1 == 1)
                                                a = Color.Gray;
                                            else
                                                a = Color.Brown;
                                            Order *= -1;
                                            ChessRules.CurrentOrder *= -1;
                                            KingOnTable[i].KingThinking[0].AStarGreedy.Add(new AllDraw(MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, ref THIS));
                                            //KingOnTable[i].KingThinking[0].AStarGreedy[KingOnTable[i].KingThinking[0].AStarGreedy.Count - 1].KingOnTable[i] = new DrawKing(MovementsAStarGreedyHuristicFoundT,IgnoreSelfObjectsT,UsePenaltyRegardMechnisamT,BestMovmentsT,PredictHuristicT,OnlySelfT,AStarGreedyHuristicT,ArrangmentsChanged, KingOnTable[i].Row, KingOnTable[i].Column, KingOnTable[i].color, KingOnTable[i].Table, KingOnTable[i].Order, false, KingOnTable[i].Current);
                                            this.Clone(KingOnTable[i].KingThinking[0].AStarGreedy[KingOnTable[i].KingThinking[0].AStarGreedy.Count - 1]);
                                            //Dummy = this.CopyRemeiningItems(Dummy, Order * -1);
                                            if (!FormRefrigtz.Blitz)
                                                KingOnTable[i].KingThinking[0].AStarGreedy[KingOnTable[i].KingThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt(iAStarGreedy, ii, jj, a, Table, Order, false, FOUND);
                                            //Initaite Of Brown Order Global Varibales By Local Varibales.
                                            Order = DummyOrder;
                                            ChessRules.CurrentOrder = DummyCurrentOrder;
                                            //Refrigtz.Timer finsishing of Ending Operation in Recursive Calling.
                                            //S = (TimerColor.AStarGreedytiLevelMaxInitiate(timer, iAStarGreedy));
                                            //if (S == -1)    //have to Zero. Non Decreamet Algorithm not found.
                                            //AStarGreedyiLevelMax = 0;

                                            if (iAStarGreedy > AStarGreedyiLevelMax && iAStarGreedy != 1)
                                            {
                                                KingOnTable[i].KingThinking[0].AStarGreedy = null;
                                                return null;
                                            }

                                        }
                                    }
                                    else if (!FormRefrigtz.Blitz)//When There is Current Brown Existing Objective Thinking Movments.
                                    {
                                        //For Each Current Brown Existing Objective Thinking Movments.
                                        for (j = 0; j < KingOnTable[i].KingThinking[0].TableListKing.Count; j++)
                                        {
                                            //Initiate Local varibale By Global Objective Varibales.
                                            //Thinking of Thinking Brown CurrentTable Objective Operations.       
                                            KingOnTable[i].KingThinking[0].TableT = KingOnTable[i].KingThinking[0].TableListKing[j];
                                            KingOnTable[i].KingThinking[0].ThinkingBegin = true;
                                            KingOnTable[i].KingThinking[0].ThinkingFinished = false;
                                            KingOnTable[i].KingThinking[0].t = new Task(new Action(KingOnTable[i].KingThinking[0].Thinking));
                                            KingOnTable[i].KingThinking[0].t.Start();
                                            if (KingOnTable[i].KingThinking[0].t != null) { Object tttt = new Object(); lock (tttt) { tH.Add(KingOnTable[i].KingThinking[0].t); } }
                                            //Wait For Brown Current Objects Thinking Finishing.
                                            // Wait(this, i, j, 0, 6, false);
                                            //KingOnTable[i].KingThinking[0].t.Abort();
                                            //KingOnTable[i].KingThinking[0].t.Wait();
                                            //If There is Not Brown Thinking Successfule Thinking Objective Movments. 
                                            if (KingOnTable[i].KingThinking[0].TableListKing.Count == 0)
                                                continue;


                                            //AStarGreedy Brown Thinking of Thinking Curretn Object Recursive Main Method Calling.                                           
                                            Order = DummyOrder;
                                            ChessRules.CurrentOrder = DummyCurrentOrder;
                                            if (Order * -1 == 1)
                                                a = Color.Gray;
                                            else
                                                a = Color.Brown;
                                            Order *= -1;
                                            ChessRules.CurrentOrder *= -1;
                                            KingOnTable[i].KingThinking[0].AStarGreedy.Add(new AllDraw(MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, ref THIS));
                                            //KingOnTable[i].KingThinking[0].AStarGreedy[KingOnTable[i].KingThinking[0].AStarGreedy.Count - 1].KingOnTable[i] = new DrawKing(MovementsAStarGreedyHuristicFoundT,IgnoreSelfObjectsT,UsePenaltyRegardMechnisamT,BestMovmentsT,PredictHuristicT,OnlySelfT,AStarGreedyHuristicT,ArrangmentsChanged, KingOnTable[i].Row, KingOnTable[i].Column, KingOnTable[i].color, KingOnTable[i].Table, KingOnTable[i].Order, false, KingOnTable[i].Current);
                                            this.Clone(KingOnTable[i].KingThinking[0].AStarGreedy[KingOnTable[i].KingThinking[0].AStarGreedy.Count - 1]);
                                            //Dummy = this.CopyRemeiningItems(Dummy, Order * -1);
                                            //Initaite Of Brown Order Global Varibales By Local Varibales.
                                            Order = DummyOrder;
                                            ChessRules.CurrentOrder = DummyCurrentOrder;
                                            //Refrigtz.Timer finsishing of Ending Operation in Recursive Calling.
                                            //S = (TimerColor.AStarGreedytiLevelMaxInitiate(timer, iAStarGreedy));
                                            //if (S == -1)    //have to Zero. Non Decreamet Algorithm not found.
                                            //AStarGreedyiLevelMax = 0;

                                            if (iAStarGreedy > AStarGreedyiLevelMax && iAStarGreedy != 1)
                                            {
                                                KingOnTable[i].KingThinking[0].AStarGreedy = null;
                                                return null;
                                            }

                                        }

                                    }

                                }
                                catch (Exception t)
                                {
                                    KingOnTable[i] = null;

                                }
                            }
                            try
                            {
                                //IncreaseprogressBarRefregitzValue(//THIS.progressBarVerify, increasedProgress);
                                //THIS.progressBarVerify.Invalidate();
                                //SetprogressBarUpdate(//THIS.progressBarVerify);
                            }
                            catch (Exception t) { }
                        }
                    }
                    //Thread arrayT = new Thread(() => do_check(tH));
                    //rayT.Start();

                    //ile (WaitSome) { Thread.Sleep(1000); }
                    {
                        try
                        {
                            /*foreach (Task ij in tH)
                            {
                                ij.Start();
                                //Thread.Sleep(10);
                            }
                             */


                            Parallel.ForEach(tH, items => Task.WaitAll(items));
                        }
                        catch (Exception tt)
                        {

                        }
                    }
                }
                //while ((ThinkingChess.BeginThread) != (ThinkingChess.EndThread))
                //{
            }
            //                } 
            Order = DummyOrder;
            ChessRules.CurrentOrder = DummyCurrentOrder;

            //Blitz Condition Section
            if (//iAStarGreedy != MaxAStarGreedy && 
                FormRefrigtz.Blitz)
            {
                //to found of best movment in current dept.
                //initiate local variables.
                List<double> iF = new List<double>(), jF = new List<double>(), kF = new List<double>();
                List<List<double>> ObjectNumber = null;
                //found of best movment index.
                //depend of found act inner thinking tree development.
                if (!(FormRefrigtz.Blitz))
                    ObjectNumber = FoundOfBestMovments(iAStarGreedy - 1, ref iF, ref jF, ref kF, this, a, Order);

                Order = DummyOrder;
                ChessRules.CurrentOrder = DummyCurrentOrder;
                //Condition of Order Consideration.
                if ((!FormRefrigtz.Blitz) && (ObjectNumber[0].Count > 0 || ObjectNumber[1].Count > 0 || ObjectNumber[2].Count > 0 || ObjectNumber[3].Count > 0 || ObjectNumber[4].Count > 0 || ObjectNumber[5].Count > 0))
                {

                    //Gray Order.
                    if (Order * -1 == 1)
                        a = Color.Gray;
                    else
                        //Brown Order.
                        a = Color.Brown;
                    //Next Order.
                    Order *= -1;
                    ChessRules.CurrentOrder *= -1;
                }


                BlitzGameThinkingTree(Order, iAStarGreedy, ik, j, ref ThA, false);


                //Initiate of Local and Global Vriables.
                Order = DummyOrder;
                ChessRules.CurrentOrder = DummyCurrentOrder;

                //Gray Order.
                if (Order == 1)
                {
                    //THIS.SetBoxText("\r\nChess Thinking AStarGreedy " + iAStarGreedy.ToString() + " By Bob Finished!");
                    //THIS.RefreshBoxText();
                }
                else
                {
                    //THIS.SetBoxText("\r\nChess Thinking AStarGreedy " + iAStarGreedy.ToString() + " By Alice Finished");
                    //THIS.RefreshBoxText();
                }

                AStarGreedyIndexVlue = AStarGreedy;
                AStarGreedy++;
                Order = DummyOrder;
                ChessRules.CurrentOrder = DummyCurrentOrder;
            }
            else
            {
                if (FOUND)
                {
                    FoundOfLeafDepenOfKindFullGame(Order, iAStarGreedy, ii, jj, ik, j, ref ThA, FOUND);
                }
                else
                    FullGameThinkingTree(Order, iAStarGreedy, ii, jj, ik, j, ref ThA, false);
                /*if (Order == 1)
                {
                    //THIS.SetBoxText("\r\nChess Thinking AStarGreedy " + iAStarGreedy.ToString() + " By Bob Finished!");
                    //THIS.RefreshBoxText();
                }
                else
                {
                    //THIS.SetBoxText("\r\nChess Thinking AStarGreedy " + iAStarGreedy.ToString() + " By Alice Finished");
                    //THIS.RefreshBoxText();
                }

                 */

            }

            //if (FormRefrigtz.Blitz)
            try
            {
                /*foreach(Task t in ThA)
                {
                    t.Start();
                }
                 */
                Parallel.ForEach(ThA, items => Task.WaitAll(items));
            }
            catch (Exception t)
            {

                //MessageBox.Show(t.ToString());
            }

            Order = DummyOrder;
            ChessRules.CurrentOrder = DummyCurrentOrder;
            if (iAStarGreedy == 1)
                ThinkingFinished = true;
            return this;//.CopyRemeiningItems(Dummy, Order);
            //return 
            //>;
        }
        void BlitzGameThinkingTree(int Order, int iAStarGreedy, int ik, int j, ref List<Task> ThA, bool FOUND)
        {             //Initiatye Variables.
            int DummyOrder = Order;
            int DummyCurrentOrder = ChessRules.CurrentOrder;

            Color a;
            if (Order * -1 == 1)
                a = Color.Gray;
            else
                a = Color.Brown;
            Order *= -1;
            ChessRules.CurrentOrder *= -1;
            int[] Index = new int[6];

            int[] jIndex = new int[6];
            double PreviousLessS = Double.MinValue, PreviousLessE = Double.MinValue, PreviousLessH = Double.MinValue, PreviousLessB = Double.MinValue, PreviousLessM = Double.MinValue, PreviousLessK = Double.MinValue;
            //For Gray Order calculating foreach Objects Maximum total Huristic Count Incl;usively.
            if (Order == 1)
            {
                Index[0] = -1;
                //Soldeir
                for (ik = SodierMidle; ik < SodierHigh; ik++)
                    try
                    {
                        for (j = 0; j < SolderesOnTable[ik].SoldierThinking[0].HuristicListSolder.Count; j++)
                        {
                            if (SolderesOnTable[ik].SoldierThinking[0].ReturnHuristic(-1, j, Order) < PreviousLessS || SolderesOnTable[ik].SoldierThinking[0].PenaltyRegardListSolder[j].IsPenaltyAction() == 0)
                            {
                                //SolderesOnTable[ik].SoldierThinking[0].AStarGreedy = null;
                                //SolderesOnTable[ik] = null;
                                //continue;
                            }
                            else
                            {
                                PreviousLessS = SolderesOnTable[ik].SoldierThinking[0].ReturnHuristic(-1, j, Order);
                                Index[0] = ik;
                                jIndex[0] = j;
                            }




                        }

                        //Elephant
                    }
                    catch (Exception t) { }

                Index[1] = -1;
                //Elephant
                for (ik = ElefantMidle; ik < ElefantHigh; ik++)
                    try
                    {
                        for (j = 0; j < ElephantOnTable[ik].ElefantThinking[0].HuristicListElefant.Count; j++)
                        {
                            if (ElephantOnTable[ik].ElefantThinking[0].ReturnHuristic(-1, j, Order) < PreviousLessE || ElephantOnTable[ik].ElefantThinking[0].PenaltyRegardListElefant[j].IsPenaltyAction() == 0)
                            {
                                //ElephantOnTable[ik].ElefantThinking[0].AStarGreedy = null;
                                //ElephantOnTable[ik] = null;
                                //continue;
                            }
                            else
                            {
                                PreviousLessE = ElephantOnTable[ik].ElefantThinking[0].ReturnHuristic(-1, j, Order);
                                Index[1] = ik;
                                jIndex[1] = j;
                            }


                        }
                    }
                    catch (Exception t) { }
                Index[2] = -1;
                //Hourse.
                for (ik = HourseMidle; ik < HourseHight; ik++)
                    try
                    {
                        for (j = 0; j < HoursesOnTable[ik].HourseThinking[0].HuristicListHourse.Count; j++)
                        {

                            if (HoursesOnTable[ik].HourseThinking[0].ReturnHuristic(-1, j, Order) < PreviousLessH || HoursesOnTable[ik].HourseThinking[0].PenaltyRegardListHourse[j].IsPenaltyAction() == 0)
                            {
                                //HoursesOnTable[ik].HourseThinking[0].AStarGreedy = null;
                                //continue;
                            }
                            else
                            {
                                PreviousLessH = HoursesOnTable[ik].HourseThinking[0].ReturnHuristic(-1, j, Order);
                                Index[2] = ik;
                                jIndex[2] = j;
                            }


                        }
                    }
                    catch (Exception t) { }
                Index[3] = -1;
                //Bridge.
                for (ik = BridgeMidle; ik < BridgeHigh; ik++)
                    try
                    {
                        for (j = 0; j < BridgesOnTable[ik].BridgeThinking[0].HuristicListBridge.Count; j++)
                        {
                            if (BridgesOnTable[ik].BridgeThinking[0].ReturnHuristic(-1, j, Order) < PreviousLessB || BridgesOnTable[ik].BridgeThinking[0].PenaltyRegardListBridge[j].IsPenaltyAction() == 0)
                            {

                                //BridgesOnTable[ik].BridgeThinking[0].AStarGreedy = null;
                                //BridgesOnTable[ik] = null;
                                //continue;
                            }

                            else
                            {
                                PreviousLessB = BridgesOnTable[ik].BridgeThinking[0].ReturnHuristic(-1, j, Order);
                                Index[3] = ik;
                                jIndex[3] = j;
                            }


                        }
                    }
                    catch (Exception t) { }
                Index[4] = -1;
                //Minister.
                for (ik = MinisterMidle; ik < MinisterHigh; ik++)
                    try
                    {
                        for (j = 0; j < MinisterOnTable[ik].MinisterThinking[0].HuristicListMinister.Count; j++)
                        {

                            if (MinisterOnTable[ik].MinisterThinking[0].ReturnHuristic(-1, j, Order) < PreviousLessM || MinisterOnTable[ik].MinisterThinking[0].PenaltyRegardListMinister[j].IsPenaltyAction() == 0)
                            {
                                //MinisterOnTable[ik].MinisterThinking[0].AStarGreedy = null;
                                // MinisterOnTable[ik] = null;

                                // continue;
                            }
                            else
                            {
                                Index[4] = ik;
                                jIndex[4] = j;
                                PreviousLessM = MinisterOnTable[ik].MinisterThinking[0].ReturnHuristic(-1, j, Order);
                            }


                        }
                    }
                    catch (Exception t) { }

                Index[5] = -1;
                //King.
                for (ik = KingMidle; ik < KingHigh; ik++)
                    try
                    {

                        for (j = 0; j < KingOnTable[ik].KingThinking[0].HuristicListKing.Count; j++)
                        {
                            if (KingOnTable[ik].KingThinking[0].ReturnHuristic(-1, j, Order) < PreviousLessK || KingOnTable[ik].KingThinking[0].PenaltyRegardListKing[j].IsPenaltyAction() == 0)
                            {
                                //KingOnTable[ik].KingThinking[0].AStarGreedy = null;
                                //KingOnTable[ik] = null;
                                //continue;
                            }
                            else
                            {
                                Index[5] = ik;
                                jIndex[5] = j;
                                PreviousLessK = KingOnTable[ik].KingThinking[0].ReturnHuristic(-1, j, Order);
                            }


                        }
                    }
                    catch (Exception t) { }
                int JI = MaxOfThreeHuristic(PreviousLessS, PreviousLessE, PreviousLessH, PreviousLessB, PreviousLessM, PreviousLessK);
                if (JI != -1)
                {
                    //if (JI == 0)
                    if (Index[0] != -1)
                    {
                        if (SolderesOnTable[Index[0]].SoldierThinking[0].AStarGreedy.Count == 0)
                            SolderesOnTable[Index[0]].SoldierThinking[0].AStarGreedy.Add(new AllDraw(MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, ref THIS));
                        SolderesOnTable[Index[0]].SoldierThinking[0].AStarGreedy[SolderesOnTable[Index[0]].SoldierThinking[0].AStarGreedy.Count - 1].TableList.Clear();
                        SolderesOnTable[Index[0]].SoldierThinking[0].AStarGreedy[SolderesOnTable[Index[0]].SoldierThinking[0].AStarGreedy.Count - 1].TableList.Add(SolderesOnTable[Index[0]].SoldierThinking[0].TableListSolder[jIndex[0]]);
                        SolderesOnTable[Index[0]].SoldierThinking[0].AStarGreedy[SolderesOnTable[Index[0]].SoldierThinking[0].AStarGreedy.Count - 1].SetRowColumn(0);
                        //SolderesOnTable[Index[0]].SoldierThinking[0].AStarGreedy[SolderesOnTable[Index[0]].SoldierThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt(iAStarGreedy, ii, jj, a, SolderesOnTable[Index[0]].SoldierThinking[0].TableListSolder[jIndex[0]], Order, false);
                        //ParameterizedThreadStart start = new ParameterizedThreadStart(SolderesOnTable[Index[0]].SoldierThinking[0].AStarGreedy[SolderesOnTable[Index[0]].SoldierThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt);
                        Task array = new Task(() => SolderesOnTable[Index[0]].SoldierThinking[0].AStarGreedy[SolderesOnTable[Index[0]].SoldierThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt(iAStarGreedy, SolderesOnTable[Index[0]].SoldierThinking[0].RowColumnSoldier[jIndex[0]][0], SolderesOnTable[Index[0]].SoldierThinking[0].RowColumnSoldier[jIndex[0]][1], a, SolderesOnTable[Index[0]].SoldierThinking[0].TableListSolder[jIndex[0]], Order, false, FOUND));
                        Object ttttt = new Object(); lock (ttttt) { ThA.Add(array); }
                        //array.Name = "S" + i.ToString();
                        array.Start();

                    }
                    //Initiatye Variables.
                    Order = DummyOrder;
                    ChessRules.CurrentOrder = DummyCurrentOrder;


                    if (Order * -1 == 1)
                        a = Color.Gray;
                    else
                        a = Color.Brown;
                    Order *= -1;
                    ChessRules.CurrentOrder *= -1;
                    //if (JI == 1)
                    if (Index[1] != -1)
                    {
                        if (ElephantOnTable[Index[1]].ElefantThinking[0].AStarGreedy.Count == 0)
                            ElephantOnTable[Index[1]].ElefantThinking[0].AStarGreedy.Add(new AllDraw(MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, ref THIS));
                        ElephantOnTable[Index[1]].ElefantThinking[0].AStarGreedy[ElephantOnTable[Index[1]].ElefantThinking[0].AStarGreedy.Count - 1].TableList.Clear();
                        ElephantOnTable[Index[1]].ElefantThinking[0].AStarGreedy[ElephantOnTable[Index[1]].ElefantThinking[0].AStarGreedy.Count - 1].TableList.Add(ElephantOnTable[Index[1]].ElefantThinking[0].TableListElefant[jIndex[1]]);
                        ElephantOnTable[Index[1]].ElefantThinking[0].AStarGreedy[ElephantOnTable[Index[1]].ElefantThinking[0].AStarGreedy.Count - 1].SetRowColumn(0);
                        //ElephantOnTable[Index[1]].ElefantThinking[0].AStarGreedy[ElephantOnTable[Index[1]].ElefantThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt(iAStarGreedy, ii, jj, a, ElephantOnTable[Index[1]].ElefantThinking[0].TableListElefant[jIndex[1]], Order, false);
                        //ParameterizedThreadStart start = new ParameterizedThreadStart(ElephantOnTable[Index[1]].ElefantThinking[0].AStarGreedy[ElephantOnTable[Index[1]].ElefantThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt);
                        Task array = new Task(() => ElephantOnTable[Index[1]].ElefantThinking[0].AStarGreedy[ElephantOnTable[Index[1]].ElefantThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt(iAStarGreedy, ElephantOnTable[Index[1]].ElefantThinking[0].RowColumnElefant[jIndex[1]][0], ElephantOnTable[Index[1]].ElefantThinking[0].RowColumnElefant[jIndex[1]][1], a, ElephantOnTable[Index[1]].ElefantThinking[0].TableListElefant[jIndex[1]], Order, false, FOUND));
                        Object ttttt = new Object(); lock (ttttt) { ThA.Add(array); }
                        //array.Name = "E" + i.ToString();
                        array.Start();

                    }
                    //Initiatye Variables.
                    Order = DummyOrder;
                    ChessRules.CurrentOrder = DummyCurrentOrder;


                    if (Order * -1 == 1)
                        a = Color.Gray;
                    else
                        a = Color.Brown;
                    Order *= -1;
                    ChessRules.CurrentOrder *= -1;
                    //if (JI == 2)
                    if (Index[2] != -1)
                    {
                        if (HoursesOnTable[Index[2]].HourseThinking[0].AStarGreedy.Count == 0)
                            HoursesOnTable[Index[2]].HourseThinking[0].AStarGreedy.Add(new AllDraw(MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, ref THIS));
                        HoursesOnTable[Index[2]].HourseThinking[0].AStarGreedy[HoursesOnTable[Index[2]].HourseThinking[0].AStarGreedy.Count - 1].TableList.Clear(); ;
                        HoursesOnTable[Index[2]].HourseThinking[0].AStarGreedy[HoursesOnTable[Index[2]].HourseThinking[0].AStarGreedy.Count - 1].TableList.Add(HoursesOnTable[Index[2]].HourseThinking[0].TableListHourse[jIndex[2]]);
                        HoursesOnTable[Index[2]].HourseThinking[0].AStarGreedy[HoursesOnTable[Index[2]].HourseThinking[0].AStarGreedy.Count - 1].SetRowColumn(0);
                        //HoursesOnTable[Index[2]].HourseThinking[0].AStarGreedy[HoursesOnTable[Index[2]].HourseThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt(iAStarGreedy, ii, jj, a, HoursesOnTable[Index[2]].HourseThinking[0].TableListHourse[jIndex[2]], Order, false);
                        //ParameterizedThreadStart start = new ParameterizedThreadStart(HoursesOnTable[Index[2]].HourseThinking[0].AStarGreedy[HoursesOnTable[Index[2]].HourseThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt);
                        Task array = new Task(() => HoursesOnTable[Index[2]].HourseThinking[0].AStarGreedy[HoursesOnTable[Index[2]].HourseThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt(iAStarGreedy, HoursesOnTable[Index[2]].HourseThinking[0].RowColumnHourse[jIndex[2]][0], HoursesOnTable[Index[2]].HourseThinking[0].RowColumnHourse[jIndex[2]][1], a, HoursesOnTable[Index[2]].HourseThinking[0].TableListHourse[jIndex[2]], Order, false, FOUND));
                        Object ttttt = new Object(); lock (ttttt) { ThA.Add(array); }
                        //array.Name = "H" + i.ToString();
                        array.Start();

                    }
                    //Initiatye Variables.
                    Order = DummyOrder;
                    ChessRules.CurrentOrder = DummyCurrentOrder;


                    if (Order * -1 == 1)
                        a = Color.Gray;
                    else
                        a = Color.Brown;
                    Order *= -1;
                    ChessRules.CurrentOrder *= -1;
                    //if (JI == 3)
                    if (Index[3] != -1)
                    {
                        if (BridgesOnTable[Index[3]].BridgeThinking[0].AStarGreedy.Count == 0)
                            BridgesOnTable[Index[3]].BridgeThinking[0].AStarGreedy.Add(new AllDraw(MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, ref THIS));
                        BridgesOnTable[Index[3]].BridgeThinking[0].AStarGreedy[BridgesOnTable[Index[3]].BridgeThinking[0].AStarGreedy.Count - 1].TableList.Clear();
                        BridgesOnTable[Index[3]].BridgeThinking[0].AStarGreedy[BridgesOnTable[Index[3]].BridgeThinking[0].AStarGreedy.Count - 1].TableList.Add(BridgesOnTable[Index[3]].BridgeThinking[0].TableListBridge[jIndex[3]]);
                        BridgesOnTable[Index[3]].BridgeThinking[0].AStarGreedy[BridgesOnTable[Index[3]].BridgeThinking[0].AStarGreedy.Count - 1].SetRowColumn(0);
                        //BridgesOnTable[Index[3]].BridgeThinking[0].AStarGreedy[BridgesOnTable[Index[3]].BridgeThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt(iAStarGreedy, ii, jj, a, BridgesOnTable[Index[3]].BridgeThinking[0].TableListBridge[jIndex[3]], Order, false);
                        //ParameterizedThreadStart start = new ParameterizedThreadStart(BridgesOnTable[Index[3]].BridgeThinking[0].AStarGreedy[BridgesOnTable[Index[3]].BridgeThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt);
                        Task array = new Task(() => BridgesOnTable[Index[3]].BridgeThinking[0].AStarGreedy[BridgesOnTable[Index[3]].BridgeThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt(iAStarGreedy, BridgesOnTable[Index[3]].BridgeThinking[0].RowColumnBridge[jIndex[3]][0], BridgesOnTable[Index[3]].BridgeThinking[0].RowColumnBridge[jIndex[3]][1], a, BridgesOnTable[Index[3]].BridgeThinking[0].TableListBridge[jIndex[3]], Order, false, FOUND));
                        Object ttttt = new Object(); lock (ttttt) { ThA.Add(array); }
                        //array.Name = "B" + i.ToString();
                        array.Start();

                    }
                    //Initiatye Variables.
                    Order = DummyOrder;
                    ChessRules.CurrentOrder = DummyCurrentOrder;


                    if (Order * -1 == 1)
                        a = Color.Gray;
                    else
                        a = Color.Brown;
                    Order *= -1;
                    ChessRules.CurrentOrder *= -1;
                    //if (JI == 4)
                    if (Index[4] != -1)
                    {
                        if (MinisterOnTable[Index[4]].MinisterThinking[0].AStarGreedy.Count == 0)
                            MinisterOnTable[Index[4]].MinisterThinking[0].AStarGreedy.Add(new AllDraw(MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, ref THIS));
                        MinisterOnTable[Index[4]].MinisterThinking[0].AStarGreedy[MinisterOnTable[Index[4]].MinisterThinking[0].AStarGreedy.Count - 1].TableList.Clear();
                        MinisterOnTable[Index[4]].MinisterThinking[0].AStarGreedy[MinisterOnTable[Index[4]].MinisterThinking[0].AStarGreedy.Count - 1].TableList.Add(MinisterOnTable[Index[4]].MinisterThinking[0].TableListMinister[jIndex[4]]);
                        MinisterOnTable[Index[4]].MinisterThinking[0].AStarGreedy[MinisterOnTable[Index[4]].MinisterThinking[0].AStarGreedy.Count - 1].SetRowColumn(0);
                        //MinisterOnTable[Index[4]].MinisterThinking[0].AStarGreedy[MinisterOnTable[Index[4]].MinisterThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt(iAStarGreedy, ii, jj, a, MinisterOnTable[Index[4]].MinisterThinking[0].TableListMinister[jIndex[4]], Order, false);
                        //ParameterizedThreadStart start = new ParameterizedThreadStart(MinisterOnTable[Index[4]].MinisterThinking[0].AStarGreedy[MinisterOnTable[Index[4]].MinisterThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt);
                        Task array = new Task(() => MinisterOnTable[Index[4]].MinisterThinking[0].AStarGreedy[MinisterOnTable[Index[4]].MinisterThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt(iAStarGreedy, MinisterOnTable[Index[4]].MinisterThinking[0].RowColumnMinister[jIndex[4]][0], MinisterOnTable[Index[4]].MinisterThinking[0].RowColumnMinister[jIndex[4]][1], a, MinisterOnTable[Index[4]].MinisterThinking[0].TableListMinister[jIndex[4]], Order, false, FOUND));
                        Object ttttt = new Object(); lock (ttttt) { ThA.Add(array); }
                        //array.Name = "M" + i.ToString();
                        array.Start();

                    }
                    //Initiatye Variables.
                    Order = DummyOrder;
                    ChessRules.CurrentOrder = DummyCurrentOrder;


                    if (Order * -1 == 1)
                        a = Color.Gray;
                    else
                        a = Color.Brown;
                    Order *= -1;
                    ChessRules.CurrentOrder *= -1;
                    //if (JI == 5)
                    if (Index[5] != -1)
                    {
                        if (KingOnTable[Index[5]].KingThinking[0].AStarGreedy.Count == 0)
                            KingOnTable[Index[5]].KingThinking[0].AStarGreedy.Add(new AllDraw(MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, ref THIS));
                        KingOnTable[Index[5]].KingThinking[0].AStarGreedy[KingOnTable[Index[5]].KingThinking[0].AStarGreedy.Count - 1].TableList.Clear();
                        KingOnTable[Index[5]].KingThinking[0].AStarGreedy[KingOnTable[Index[5]].KingThinking[0].AStarGreedy.Count - 1].TableList.Add(KingOnTable[Index[5]].KingThinking[0].TableListKing[jIndex[5]]);
                        KingOnTable[Index[5]].KingThinking[0].AStarGreedy[KingOnTable[Index[5]].KingThinking[0].AStarGreedy.Count - 1].SetRowColumn(0);
                        //KingOnTable[Index[5]].KingThinking[0].AStarGreedy[KingOnTable[Index[5]].KingThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt(iAStarGreedy, ii, jj, a, KingOnTable[Index[5]].KingThinking[0].TableListKing[jIndex[5]], Order, false);
                        //ParameterizedThreadStart start = new ParameterizedThreadStart(KingOnTable[Index[5]].KingThinking[0].AStarGreedy[KingOnTable[Index[5]].KingThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt);
                        Task array = new Task(() => KingOnTable[Index[5]].KingThinking[0].AStarGreedy[KingOnTable[Index[5]].KingThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt(iAStarGreedy, KingOnTable[Index[5]].KingThinking[0].RowColumnKing[jIndex[5]][0], KingOnTable[Index[5]].KingThinking[0].RowColumnKing[jIndex[5]][1], a, KingOnTable[Index[5]].KingThinking[0].TableListKing[jIndex[5]], Order, false, FOUND));
                        Object ttttt = new Object(); lock (ttttt) { ThA.Add(array); }
                        //array.Name = "K" + i.ToString();
                        array.Start();

                    }
                }
            }
            //For Brown Order Blitz Game Calculate Maximum Huristic Inclusive AStarGreedy First Game Search.
            else
            {
                Index[0] = -1;
                for (ik = 0; ik < SodierMidle; ik++)
                    try
                    {

                        //Soldier.
                        for (j = 0; j < SolderesOnTable[ik].SoldierThinking[0].HuristicListSolder.Count; j++)
                        {
                            if (SolderesOnTable[ik].SoldierThinking[0].ReturnHuristic(-1, j, Order) < PreviousLessS || SolderesOnTable[ik].SoldierThinking[0].PenaltyRegardListSolder[j].IsPenaltyAction() == 0)
                            {
                                //SolderesOnTable[ik].SoldierThinking[0].AStarGreedy = null;
                                //SolderesOnTable[ik] = null;
                                //continue;
                            }
                            else
                            {
                                Index[0] = ik;
                                jIndex[0] = j;
                                PreviousLessS = SolderesOnTable[ik].SoldierThinking[0].ReturnHuristic(-1, j, Order); ;
                            }
                        }

                    }
                    catch (Exception t) { }

                Index[1] = -1;
                //Elephant
                for (ik = 0; ik < ElefantMidle; ik++)
                    try
                    {
                        for (j = 0; j < ElephantOnTable[ik].ElefantThinking[0].HuristicListElefant.Count; j++)
                        {
                            if (ElephantOnTable[ik].ElefantThinking[0].ReturnHuristic(-1, j, Order) < PreviousLessE || ElephantOnTable[ik].ElefantThinking[0].PenaltyRegardListElefant[j].IsPenaltyAction() == 0)
                            {
                                //ElephantOnTable[ik].ElefantThinking[0].AStarGreedy = null;
                                //ElephantOnTable[ik] = null;
                                //continue;
                            }
                            else
                            {
                                Index[1] = ik;
                                jIndex[1] = j;
                                PreviousLessE = ElephantOnTable[ik].ElefantThinking[0].ReturnHuristic(-1, j, Order);
                            }


                        }
                    }
                    catch (Exception t) { }

                Index[2] = -1;
                //Hourse.
                for (ik = 0; ik < HourseMidle; ik++)
                    try
                    {
                        for (j = 0; j < HoursesOnTable[ik].HourseThinking[0].HuristicListHourse.Count; j++)
                        {
                            if (HoursesOnTable[ik].HourseThinking[0].ReturnHuristic(-1, j, Order) < PreviousLessH || HoursesOnTable[ik].HourseThinking[0].PenaltyRegardListHourse[j].IsPenaltyAction() == 0)
                            {
                                //HoursesOnTable[ik].HourseThinking[0].AStarGreedy = null;
                                //HoursesOnTable[ik] = null;
                                //continue;
                            }
                            else
                            {
                                Index[2] = ik;
                                jIndex[2] = j;
                                PreviousLessH = HoursesOnTable[ik].HourseThinking[0].ReturnHuristic(-1, j, Order); ;
                            }



                        }
                    }
                    catch (Exception t) { }

                Index[3] = -1;
                //Bridges.
                for (ik = 0; ik < BridgeMidle; ik++)
                    try
                    {
                        for (j = 0; j < BridgesOnTable[ik].BridgeThinking[0].HuristicListBridge.Count; j++)
                        {
                            if (BridgesOnTable[ik].BridgeThinking[0].ReturnHuristic(-1, j, Order) < PreviousLessB || BridgesOnTable[ik].BridgeThinking[0].PenaltyRegardListBridge[j].IsPenaltyAction() == 0)
                            {

                                //BridgesOnTable[ik].BridgeThinking[0].AStarGreedy = null;
                                //BridgesOnTable[ik] = null;
                                //continue;
                            }

                            else
                            {
                                Index[3] = ik;
                                jIndex[3] = j;
                                PreviousLessB = BridgesOnTable[ik].BridgeThinking[0].ReturnHuristic(-1, j, Order); ;
                            }



                        }
                    }
                    catch (Exception t) { }

                Index[4] = -1;
                //Minister.
                for (ik = 0; ik < MinisterMidle; ik++)
                    try
                    {
                        for (j = 0; j < MinisterOnTable[ik].MinisterThinking[0].HuristicListMinister.Count; j++)
                        {
                            if (MinisterOnTable[ik].MinisterThinking[0].ReturnHuristic(-1, j, Order) < PreviousLessM || MinisterOnTable[ik].MinisterThinking[0].PenaltyRegardListMinister[j].IsPenaltyAction() == 0)
                            {
                                //MinisterOnTable[ik].MinisterThinking[0].AStarGreedy = null;
                                //MinisterOnTable[ik] = null;
                                //continue;
                            }
                            else
                            {
                                Index[4] = ik;
                                jIndex[4] = j;
                                PreviousLessM = MinisterOnTable[ik].MinisterThinking[0].ReturnHuristic(-1, j, Order); ;
                            }


                        }
                    }
                    catch (Exception t) { }

                Index[5] = -1;
                //King.
                for (ik = 0; ik < KingMidle; ik++)
                    try
                    {
                        for (j = 0; j < KingOnTable[ik].KingThinking[0].HuristicListKing.Count; j++)
                        {
                            if (KingOnTable[ik].KingThinking[0].ReturnHuristic(-1, j, Order) < PreviousLessK || KingOnTable[ik].KingThinking[0].PenaltyRegardListKing[j].IsPenaltyAction() == 0)
                            {
                                //KingOnTable[ik].KingThinking[0].AStarGreedy = null;
                                //KingOnTable[ik] = null;
                                //continue;
                            }
                            else
                            {
                                Index[5] = ik;
                                jIndex[5] = j;
                                PreviousLessK = KingOnTable[ik].KingThinking[0].ReturnHuristic(-1, j, Order); ;
                            }



                        }
                    }
                    catch (Exception t) { }
                int JI = MaxOfThreeHuristic(PreviousLessS, PreviousLessE, PreviousLessH, PreviousLessB, PreviousLessM, PreviousLessK);
                if (JI != -1)
                {
                    //if (JI == 0)
                    if (Index[0] != -1)
                    {
                        if (SolderesOnTable[Index[0]].SoldierThinking[0].AStarGreedy.Count == 0)
                            SolderesOnTable[Index[0]].SoldierThinking[0].AStarGreedy.Add(new AllDraw(MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, ref THIS));
                        SolderesOnTable[Index[0]].SoldierThinking[0].AStarGreedy[SolderesOnTable[Index[0]].SoldierThinking[0].AStarGreedy.Count - 1].TableList.Clear();
                        SolderesOnTable[Index[0]].SoldierThinking[0].AStarGreedy[SolderesOnTable[Index[0]].SoldierThinking[0].AStarGreedy.Count - 1].TableList.Add(SolderesOnTable[Index[0]].SoldierThinking[0].TableListSolder[jIndex[0]]);
                        SolderesOnTable[Index[0]].SoldierThinking[0].AStarGreedy[SolderesOnTable[Index[0]].SoldierThinking[0].AStarGreedy.Count - 1].SetRowColumn(0);
                        //SolderesOnTable[Index[0]].SoldierThinking[0].AStarGreedy[SolderesOnTable[Index[0]].SoldierThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt(iAStarGreedy, ii, jj, a, SolderesOnTable[Index[0]].SoldierThinking[0].TableListSolder[jIndex[0]], Order, false);
                        //ParameterizedThreadStart start = new ParameterizedThreadStart(SolderesOnTable[Index[0]].SoldierThinking[0].AStarGreedy[SolderesOnTable[Index[0]].SoldierThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt);
                        Task array = new Task(() => SolderesOnTable[Index[0]].SoldierThinking[0].AStarGreedy[SolderesOnTable[Index[0]].SoldierThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt(iAStarGreedy, SolderesOnTable[Index[0]].SoldierThinking[0].RowColumnSoldier[jIndex[0]][0], SolderesOnTable[Index[0]].SoldierThinking[0].RowColumnSoldier[jIndex[0]][1], a, SolderesOnTable[Index[0]].SoldierThinking[0].TableListSolder[jIndex[0]], Order, false, FOUND));
                        Object ttttt = new Object(); lock (ttttt) { ThA.Add(array); }
                        //array.Name = "S" + i.ToString();
                        array.Start();

                    }
                    //Initiatye Variables.
                    Order = DummyOrder;
                    ChessRules.CurrentOrder = DummyCurrentOrder;


                    if (Order * -1 == 1)
                        a = Color.Gray;
                    else
                        a = Color.Brown;
                    Order *= -1;
                    ChessRules.CurrentOrder *= -1;
                    //if (JI == 1)
                    if (Index[1] != -1)
                    {
                        if (ElephantOnTable[Index[1]].ElefantThinking[0].AStarGreedy.Count == 0)
                            ElephantOnTable[Index[1]].ElefantThinking[0].AStarGreedy.Add(new AllDraw(MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, ref THIS));
                        ElephantOnTable[Index[1]].ElefantThinking[0].AStarGreedy[ElephantOnTable[Index[1]].ElefantThinking[0].AStarGreedy.Count - 1].TableList.Clear();
                        ElephantOnTable[Index[1]].ElefantThinking[0].AStarGreedy[ElephantOnTable[Index[1]].ElefantThinking[0].AStarGreedy.Count - 1].TableList.Add(ElephantOnTable[Index[1]].ElefantThinking[0].TableListElefant[jIndex[1]]);
                        ElephantOnTable[Index[1]].ElefantThinking[0].AStarGreedy[ElephantOnTable[Index[1]].ElefantThinking[0].AStarGreedy.Count - 1].SetRowColumn(0);
                        //ElephantOnTable[Index[1]].ElefantThinking[0].AStarGreedy[ElephantOnTable[Index[1]].ElefantThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt(iAStarGreedy, ii, jj, a, ElephantOnTable[Index[1]].ElefantThinking[0].TableListElefant[jIndex[1]], Order, false);
                        //ParameterizedThreadStart start = new ParameterizedThreadStart(ElephantOnTable[Index[1]].ElefantThinking[0].AStarGreedy[ElephantOnTable[Index[1]].ElefantThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt);
                        Task array = new Task(() => ElephantOnTable[Index[1]].ElefantThinking[0].AStarGreedy[ElephantOnTable[Index[1]].ElefantThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt(iAStarGreedy, ElephantOnTable[Index[1]].ElefantThinking[0].RowColumnElefant[jIndex[1]][0], ElephantOnTable[Index[1]].ElefantThinking[0].RowColumnElefant[jIndex[1]][1], a, ElephantOnTable[Index[1]].ElefantThinking[0].TableListElefant[jIndex[1]], Order, false, FOUND));
                        Object ttttt = new Object(); lock (ttttt) { ThA.Add(array); }
                        //array.Name = "E" + i.ToString();
                        array.Start();

                    }
                    //Initiatye Variables.
                    Order = DummyOrder;
                    ChessRules.CurrentOrder = DummyCurrentOrder;


                    if (Order * -1 == 1)
                        a = Color.Gray;
                    else
                        a = Color.Brown;
                    Order *= -1;
                    ChessRules.CurrentOrder *= -1;
                    //if (JI == 2)
                    if (Index[2] != -1)
                    {
                        if (HoursesOnTable[Index[2]].HourseThinking[0].AStarGreedy.Count == 0)
                            HoursesOnTable[Index[2]].HourseThinking[0].AStarGreedy.Add(new AllDraw(MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, ref THIS));
                        HoursesOnTable[Index[2]].HourseThinking[0].AStarGreedy[HoursesOnTable[Index[2]].HourseThinking[0].AStarGreedy.Count - 1].TableList.Clear(); ;
                        HoursesOnTable[Index[2]].HourseThinking[0].AStarGreedy[HoursesOnTable[Index[2]].HourseThinking[0].AStarGreedy.Count - 1].TableList.Add(HoursesOnTable[Index[2]].HourseThinking[0].TableListHourse[jIndex[2]]);
                        HoursesOnTable[Index[2]].HourseThinking[0].AStarGreedy[HoursesOnTable[Index[2]].HourseThinking[0].AStarGreedy.Count - 1].SetRowColumn(0);
                        //HoursesOnTable[Index[2]].HourseThinking[0].AStarGreedy[HoursesOnTable[Index[2]].HourseThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt(iAStarGreedy, ii, jj, a, HoursesOnTable[Index[2]].HourseThinking[0].TableListHourse[jIndex[2]], Order, false);
                        //ParameterizedThreadStart start = new ParameterizedThreadStart(HoursesOnTable[Index[2]].HourseThinking[0].AStarGreedy[HoursesOnTable[Index[2]].HourseThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt);
                        Task array = new Task(() => HoursesOnTable[Index[2]].HourseThinking[0].AStarGreedy[HoursesOnTable[Index[2]].HourseThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt(iAStarGreedy, HoursesOnTable[Index[2]].HourseThinking[0].RowColumnHourse[jIndex[2]][0], HoursesOnTable[Index[2]].HourseThinking[0].RowColumnHourse[jIndex[2]][1], a, HoursesOnTable[Index[2]].HourseThinking[0].TableListHourse[jIndex[2]], Order, false, FOUND));
                        Object ttttt = new Object(); lock (ttttt) { ThA.Add(array); }
                        //array.Name = "H" + i.ToString();
                        array.Start();

                    }
                    //Initiatye Variables.
                    Order = DummyOrder;
                    ChessRules.CurrentOrder = DummyCurrentOrder;


                    if (Order * -1 == 1)
                        a = Color.Gray;
                    else
                        a = Color.Brown;
                    Order *= -1;
                    ChessRules.CurrentOrder *= -1;
                    //if (JI == 3)
                    if (Index[3] != -1)
                    {
                        if (BridgesOnTable[Index[3]].BridgeThinking[0].AStarGreedy.Count == 0)
                            BridgesOnTable[Index[3]].BridgeThinking[0].AStarGreedy.Add(new AllDraw(MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, ref THIS));
                        BridgesOnTable[Index[3]].BridgeThinking[0].AStarGreedy[BridgesOnTable[Index[3]].BridgeThinking[0].AStarGreedy.Count - 1].TableList.Clear();
                        BridgesOnTable[Index[3]].BridgeThinking[0].AStarGreedy[BridgesOnTable[Index[3]].BridgeThinking[0].AStarGreedy.Count - 1].TableList.Add(BridgesOnTable[Index[3]].BridgeThinking[0].TableListBridge[jIndex[3]]);
                        BridgesOnTable[Index[3]].BridgeThinking[0].AStarGreedy[BridgesOnTable[Index[3]].BridgeThinking[0].AStarGreedy.Count - 1].SetRowColumn(0);
                        //BridgesOnTable[Index[3]].BridgeThinking[0].AStarGreedy[BridgesOnTable[Index[3]].BridgeThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt(iAStarGreedy, ii, jj, a, BridgesOnTable[Index[3]].BridgeThinking[0].TableListBridge[jIndex[3]], Order, false);
                        //ParameterizedThreadStart start = new ParameterizedThreadStart(BridgesOnTable[Index[3]].BridgeThinking[0].AStarGreedy[BridgesOnTable[Index[3]].BridgeThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt);
                        Task array = new Task(() => BridgesOnTable[Index[3]].BridgeThinking[0].AStarGreedy[BridgesOnTable[Index[3]].BridgeThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt(iAStarGreedy, BridgesOnTable[Index[3]].BridgeThinking[0].RowColumnBridge[jIndex[3]][0], BridgesOnTable[Index[3]].BridgeThinking[0].RowColumnBridge[jIndex[3]][1], a, BridgesOnTable[Index[3]].BridgeThinking[0].TableListBridge[jIndex[3]], Order, false, FOUND));
                        Object ttttt = new Object(); lock (ttttt) { ThA.Add(array); }
                        //array.Name = "B" + i.ToString();
                        array.Start();

                    }
                    //Initiatye Variables.
                    Order = DummyOrder;
                    ChessRules.CurrentOrder = DummyCurrentOrder;


                    if (Order * -1 == 1)
                        a = Color.Gray;
                    else
                        a = Color.Brown;
                    Order *= -1;
                    ChessRules.CurrentOrder *= -1;
                    //if (JI == 4)
                    if (Index[4] != -1)
                    {
                        if (MinisterOnTable[Index[4]].MinisterThinking[0].AStarGreedy.Count == 0)
                            MinisterOnTable[Index[4]].MinisterThinking[0].AStarGreedy.Add(new AllDraw(MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, ref THIS));
                        MinisterOnTable[Index[4]].MinisterThinking[0].AStarGreedy[MinisterOnTable[Index[4]].MinisterThinking[0].AStarGreedy.Count - 1].TableList.Clear();
                        MinisterOnTable[Index[4]].MinisterThinking[0].AStarGreedy[MinisterOnTable[Index[4]].MinisterThinking[0].AStarGreedy.Count - 1].TableList.Add(MinisterOnTable[Index[4]].MinisterThinking[0].TableListMinister[jIndex[4]]);
                        MinisterOnTable[Index[4]].MinisterThinking[0].AStarGreedy[MinisterOnTable[Index[4]].MinisterThinking[0].AStarGreedy.Count - 1].SetRowColumn(0);
                        //MinisterOnTable[Index[4]].MinisterThinking[0].AStarGreedy[MinisterOnTable[Index[4]].MinisterThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt(iAStarGreedy, ii, jj, a, MinisterOnTable[Index[4]].MinisterThinking[0].TableListMinister[jIndex[4]], Order, false);
                        //ParameterizedThreadStart start = new ParameterizedThreadStart(MinisterOnTable[Index[4]].MinisterThinking[0].AStarGreedy[MinisterOnTable[Index[4]].MinisterThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt);
                        Task array = new Task(() => MinisterOnTable[Index[4]].MinisterThinking[0].AStarGreedy[MinisterOnTable[Index[4]].MinisterThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt(iAStarGreedy, MinisterOnTable[Index[4]].MinisterThinking[0].RowColumnMinister[jIndex[4]][0], MinisterOnTable[Index[4]].MinisterThinking[0].RowColumnMinister[jIndex[4]][1], a, MinisterOnTable[Index[4]].MinisterThinking[0].TableListMinister[jIndex[4]], Order, false, FOUND));
                        Object ttttt = new Object(); lock (ttttt) { ThA.Add(array); }
                        //array.Name = "M" + i.ToString();
                        array.Start();

                    }
                    //Initiatye Variables.
                    Order = DummyOrder;
                    ChessRules.CurrentOrder = DummyCurrentOrder;


                    if (Order * -1 == 1)
                        a = Color.Gray;
                    else
                        a = Color.Brown;
                    Order *= -1;
                    ChessRules.CurrentOrder *= -1;
                    //if (JI == 5)
                    if (Index[5] != -1)
                    {
                        if (KingOnTable[Index[5]].KingThinking[0].AStarGreedy.Count == 0)
                            KingOnTable[Index[5]].KingThinking[0].AStarGreedy.Add(new AllDraw(MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, ref THIS));
                        KingOnTable[Index[5]].KingThinking[0].AStarGreedy[KingOnTable[Index[5]].KingThinking[0].AStarGreedy.Count - 1].TableList.Clear();
                        KingOnTable[Index[5]].KingThinking[0].AStarGreedy[KingOnTable[Index[5]].KingThinking[0].AStarGreedy.Count - 1].TableList.Add(KingOnTable[Index[5]].KingThinking[0].TableListKing[jIndex[5]]);
                        KingOnTable[Index[5]].KingThinking[0].AStarGreedy[KingOnTable[Index[5]].KingThinking[0].AStarGreedy.Count - 1].SetRowColumn(0);
                        //KingOnTable[Index[5]].KingThinking[0].AStarGreedy[KingOnTable[Index[5]].KingThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt(iAStarGreedy, ii, jj, a, KingOnTable[Index[5]].KingThinking[0].TableListKing[jIndex[5]], Order, false);
                        //ParameterizedThreadStart start = new ParameterizedThreadStart(KingOnTable[Index[5]].KingThinking[0].AStarGreedy[KingOnTable[Index[5]].KingThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt);
                        Task array = new Task(() => KingOnTable[Index[5]].KingThinking[0].AStarGreedy[KingOnTable[Index[5]].KingThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt(iAStarGreedy, KingOnTable[Index[5]].KingThinking[0].RowColumnKing[jIndex[5]][0], KingOnTable[Index[5]].KingThinking[0].RowColumnKing[jIndex[5]][1], a, KingOnTable[Index[5]].KingThinking[0].TableListKing[jIndex[5]], Order, false, FOUND));
                        Object ttttt = new Object(); lock (ttttt) { ThA.Add(array); }
                        //array.Name = "K" + i.ToString();
                        array.Start();

                    }
                }


            }
        }
        void FullGameThinkingTree(int Order, int iAStarGreedy, int ii, int jj, int ik, int j, ref List<Task> ThA, bool FOUND)
        {                     //Initiatye Variables.
            int DummyOrder = Order;
            int DummyCurrentOrder = ChessRules.CurrentOrder;

            Color a;
            if (Order * -1 == 1)
                a = Color.Gray;
            else
                a = Color.Brown;
            Order *= -1;
            if (Order == 1)
            {
                //Index[0] = -1;
                //Soldeir
                try
                {
                    for (ik = SodierMidle; ik < SodierHigh; ik++)
                    {
                        {
                            for (j = 0; j < SolderesOnTable[ik].SoldierThinking[0].TableListSolder.Count; j++)
                            {
                                if (SolderesOnTable[ik].SoldierThinking[0].PenaltyRegardListSolder[j].IsPenaltyAction() != 0)
                                {
                                    //if (JI == 0)
                                    // if (Index[0] != -1)
                                    {
                                        // if (SolderesOnTable[ik].SoldierThinking[0].AStarGreedy.Count == 0)
                                        SolderesOnTable[ik].SoldierThinking[0].AStarGreedy.Add(new AllDraw(MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, ref THIS));
                                        SolderesOnTable[ik].SoldierThinking[0].AStarGreedy[SolderesOnTable[ik].SoldierThinking[0].AStarGreedy.Count - 1].TableList.Clear();
                                        SolderesOnTable[ik].SoldierThinking[0].AStarGreedy[SolderesOnTable[ik].SoldierThinking[0].AStarGreedy.Count - 1].TableList.Add(CloneATable(SolderesOnTable[ik].SoldierThinking[0].TableListSolder[j]));
                                        SolderesOnTable[ik].SoldierThinking[0].AStarGreedy[SolderesOnTable[ik].SoldierThinking[0].AStarGreedy.Count - 1].SetRowColumn(0);
                                        //SolderesOnTable[ik].SoldierThinking[0].AStarGreedy[SolderesOnTable[ik].SoldierThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt(iAStarGreedy, ii, jj, a, SolderesOnTable[ik].SoldierThinking[0].TableListSolder[j], Order, false);
                                        //ParameterizedThreadStart start = new ParameterizedThreadStart(SolderesOnTable[ik].SoldierThinking[0].AStarGreedy[SolderesOnTable[ik].SoldierThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt);
                                        if (SolderesOnTable[ik].SoldierThinking[0].AStarGreedy.Count > 0)
                                        {
                                            Task array = new Task(() => SolderesOnTable[ik].SoldierThinking[0].AStarGreedy[SolderesOnTable[ik].SoldierThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt(iAStarGreedy, ii, jj, a, CloneATable(SolderesOnTable[ik].SoldierThinking[0].TableListSolder[j]), Order, false, FOUND));
                                            Object ttttt = new Object(); lock (ttttt) { ThA.Add(array); }
                                            //array.Name = "S" + i.ToString();
                                            array.Start();
                                        }

                                    }
                                }

                            }

                            //Elephant
                        }
                    }
                }
                catch (Exception t) { }
                //Initiatye Variables.
                Order = DummyOrder;
                ChessRules.CurrentOrder = DummyCurrentOrder;


                if (Order * -1 == 1)
                    a = Color.Gray;
                else
                    a = Color.Brown;
                Order *= -1;
                ChessRules.CurrentOrder *= -1;
                //Elephant
                try
                {
                    for (ik = ElefantMidle; ik < ElefantHigh; ik++)
                    {
                        {
                            for (j = 0; j < ElephantOnTable[ik].ElefantThinking[0].TableListElefant.Count; j++)
                            {
                                if (ElephantOnTable[ik].ElefantThinking[0].PenaltyRegardListElefant[j].IsPenaltyAction() != 0)
                                {
                                    //if (Index[1] != -1)
                                    {
                                        // if (ElephantOnTable[ik].ElefantThinking[0].AStarGreedy.Count == 0)
                                        ElephantOnTable[ik].ElefantThinking[0].AStarGreedy.Add(new AllDraw(MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, ref THIS));
                                        ElephantOnTable[ik].ElefantThinking[0].AStarGreedy[ElephantOnTable[ik].ElefantThinking[0].AStarGreedy.Count - 1].TableList.Clear();
                                        ElephantOnTable[ik].ElefantThinking[0].AStarGreedy[ElephantOnTable[ik].ElefantThinking[0].AStarGreedy.Count - 1].TableList.Add(CloneATable(ElephantOnTable[ik].ElefantThinking[0].TableListElefant[j]));
                                        ElephantOnTable[ik].ElefantThinking[0].AStarGreedy[ElephantOnTable[ik].ElefantThinking[0].AStarGreedy.Count - 1].SetRowColumn(0);
                                        //ElephantOnTable[ik].ElefantThinking[0].AStarGreedy[ElephantOnTable[ik].ElefantThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt(iAStarGreedy, ii, jj, a, ElephantOnTable[ik].ElefantThinking[0].TableListElefant[j], Order, false);
                                        //ParameterizedThreadStart start = new ParameterizedThreadStart(ElephantOnTable[ik].ElefantThinking[0].AStarGreedy[ElephantOnTable[ik].ElefantThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt);
                                        if (ElephantOnTable[ik].ElefantThinking[0].AStarGreedy.Count > 0)
                                        {
                                            Task array = new Task(() => ElephantOnTable[ik].ElefantThinking[0].AStarGreedy[ElephantOnTable[ik].ElefantThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt(iAStarGreedy, ii, jj, a, CloneATable(ElephantOnTable[ik].ElefantThinking[0].TableListElefant[j]), Order, false, FOUND));
                                            Object ttttt = new Object(); lock (ttttt) { ThA.Add(array); }
                                            //array.Name = "E" + i.ToString();
                                            array.Start();
                                        }

                                    }
                                }


                            }
                        }
                    }
                }
                catch (Exception t) { }
                //Initiatye Variables.
                Order = DummyOrder;
                ChessRules.CurrentOrder = DummyCurrentOrder;


                if (Order * -1 == 1)
                    a = Color.Gray;
                else
                    a = Color.Brown;
                Order *= -1;
                ChessRules.CurrentOrder *= -1;
                //Hourse.
                try
                {
                    for (ik = HourseMidle; ik < HourseHight; ik++)
                    {
                        {
                            for (j = 0; j < HoursesOnTable[ik].HourseThinking[0].TableListHourse.Count; j++)
                            {

                                if (HoursesOnTable[ik].HourseThinking[0].PenaltyRegardListHourse[j].IsPenaltyAction() != 0)
                                {
                                    //if (Index[2] != -1)
                                    {
                                        // if (HoursesOnTable[ik].HourseThinking[0].AStarGreedy.Count == 0)
                                        HoursesOnTable[ik].HourseThinking[0].AStarGreedy.Add(new AllDraw(MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, ref THIS));
                                        HoursesOnTable[ik].HourseThinking[0].AStarGreedy[HoursesOnTable[ik].HourseThinking[0].AStarGreedy.Count - 1].TableList.Clear(); ;
                                        HoursesOnTable[ik].HourseThinking[0].AStarGreedy[HoursesOnTable[ik].HourseThinking[0].AStarGreedy.Count - 1].TableList.Add(CloneATable(HoursesOnTable[ik].HourseThinking[0].TableListHourse[j]));
                                        HoursesOnTable[ik].HourseThinking[0].AStarGreedy[HoursesOnTable[ik].HourseThinking[0].AStarGreedy.Count - 1].SetRowColumn(0);
                                        //HoursesOnTable[ik].HourseThinking[0].AStarGreedy[HoursesOnTable[ik].HourseThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt(iAStarGreedy, ii, jj, a, HoursesOnTable[ik].HourseThinking[0].TableListHourse[j], Order, false);
                                        //ParameterizedThreadStart start = new ParameterizedThreadStart(HoursesOnTable[ik].HourseThinking[0].AStarGreedy[HoursesOnTable[ik].HourseThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt);
                                        if (HoursesOnTable[ik].HourseThinking[0].AStarGreedy.Count > 0)
                                        {
                                            Task array = new Task(() => HoursesOnTable[ik].HourseThinking[0].AStarGreedy[HoursesOnTable[ik].HourseThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt(iAStarGreedy, ii, jj, a, CloneATable(HoursesOnTable[ik].HourseThinking[0].TableListHourse[j]), Order, false, FOUND));
                                            Object ttttt = new Object(); lock (ttttt) { ThA.Add(array); }
                                            //array.Name = "H" + i.ToString();
                                            array.Start();
                                        }

                                    }
                                }

                            }
                        }
                    }
                }
                catch (Exception t) { }
                //Initiatye Variables.
                Order = DummyOrder;
                ChessRules.CurrentOrder = DummyCurrentOrder;


                if (Order * -1 == 1)
                    a = Color.Gray;
                else
                    a = Color.Brown;
                Order *= -1;
                ChessRules.CurrentOrder *= -1;
                //Bridge.
                try
                {
                    for (ik = BridgeMidle; ik < BridgeHigh; ik++)
                    {
                        {
                            for (j = 0; j < BridgesOnTable[ik].BridgeThinking[0].TableListBridge.Count; j++)
                            {
                                if (BridgesOnTable[ik].BridgeThinking[0].PenaltyRegardListBridge[j].IsPenaltyAction() != 0)
                                {

                                    //if (Index[3] != -1)
                                    {
                                        /// if (BridgesOnTable[ik].BridgeThinking[0].AStarGreedy.Count == 0)
                                        BridgesOnTable[ik].BridgeThinking[0].AStarGreedy.Add(new AllDraw(MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, ref THIS));
                                        BridgesOnTable[ik].BridgeThinking[0].AStarGreedy[BridgesOnTable[ik].BridgeThinking[0].AStarGreedy.Count - 1].TableList.Clear();
                                        BridgesOnTable[ik].BridgeThinking[0].AStarGreedy[BridgesOnTable[ik].BridgeThinking[0].AStarGreedy.Count - 1].TableList.Add(CloneATable(BridgesOnTable[ik].BridgeThinking[0].TableListBridge[j]));
                                        BridgesOnTable[ik].BridgeThinking[0].AStarGreedy[BridgesOnTable[ik].BridgeThinking[0].AStarGreedy.Count - 1].SetRowColumn(0);
                                        //BridgesOnTable[ik].BridgeThinking[0].AStarGreedy[BridgesOnTable[ik].BridgeThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt(iAStarGreedy, ii, jj, a, BridgesOnTable[ik].BridgeThinking[0].TableListBridge[j], Order, false);
                                        //ParameterizedThreadStart start = new ParameterizedThreadStart(BridgesOnTable[ik].BridgeThinking[0].AStarGreedy[BridgesOnTable[ik].BridgeThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt);
                                        if (BridgesOnTable[ik].BridgeThinking[0].AStarGreedy.Count > 0)
                                        {
                                            Task array = new Task(() => BridgesOnTable[ik].BridgeThinking[0].AStarGreedy[BridgesOnTable[ik].BridgeThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt(iAStarGreedy, ii, jj, a, CloneATable(BridgesOnTable[ik].BridgeThinking[0].TableListBridge[j]), Order, false, FOUND));
                                            Object ttttt = new Object(); lock (ttttt) { ThA.Add(array); }
                                            //array.Name = "B" + i.ToString();
                                            array.Start();
                                        }

                                    }
                                }


                            }
                        }
                    }
                }
                catch (Exception t) { }
                //Initiatye Variables.
                Order = DummyOrder;
                ChessRules.CurrentOrder = DummyCurrentOrder;


                if (Order * -1 == 1)
                    a = Color.Gray;
                else
                    a = Color.Brown;
                Order *= -1;
                ChessRules.CurrentOrder *= -1;
                //Minister.
                try
                {
                    for (ik = MinisterMidle; ik < MinisterHigh; ik++)
                    {
                        {
                            for (j = 0; j < MinisterOnTable[ik].MinisterThinking[0].TableListMinister.Count; j++)
                            {

                                if (MinisterOnTable[ik].MinisterThinking[0].PenaltyRegardListMinister[j].IsPenaltyAction() != 0)
                                {
                                    //if (Index[4] != -1)
                                    {
                                        //if (MinisterOnTable[ik].MinisterThinking[0].AStarGreedy.Count == 0)
                                        MinisterOnTable[ik].MinisterThinking[0].AStarGreedy.Add(new AllDraw(MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, ref THIS));
                                        MinisterOnTable[ik].MinisterThinking[0].AStarGreedy[MinisterOnTable[ik].MinisterThinking[0].AStarGreedy.Count - 1].TableList.Clear();
                                        MinisterOnTable[ik].MinisterThinking[0].AStarGreedy[MinisterOnTable[ik].MinisterThinking[0].AStarGreedy.Count - 1].TableList.Add(CloneATable(MinisterOnTable[ik].MinisterThinking[0].TableListMinister[j]));
                                        MinisterOnTable[ik].MinisterThinking[0].AStarGreedy[MinisterOnTable[ik].MinisterThinking[0].AStarGreedy.Count - 1].SetRowColumn(0);
                                        //MinisterOnTable[ik].MinisterThinking[0].AStarGreedy[MinisterOnTable[ik].MinisterThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt(iAStarGreedy, ii, jj, a, MinisterOnTable[ik].MinisterThinking[0].TableListMinister[j], Order, false);
                                        //ParameterizedThreadStart start = new ParameterizedThreadStart(MinisterOnTable[ik].MinisterThinking[0].AStarGreedy[MinisterOnTable[ik].MinisterThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt);
                                        if (MinisterOnTable[ik].MinisterThinking[0].AStarGreedy.Count > 0)
                                        {
                                            Task array = new Task(() => MinisterOnTable[ik].MinisterThinking[0].AStarGreedy[MinisterOnTable[ik].MinisterThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt(iAStarGreedy, ii, jj, a, CloneATable(MinisterOnTable[ik].MinisterThinking[0].TableListMinister[j]), Order, false, FOUND));
                                            Object ttttt = new Object(); lock (ttttt) { ThA.Add(array); }
                                            //array.Name = "M" + i.ToString();
                                            array.Start();
                                        }
                                    }
                                }

                            }
                        }
                    }
                }
                catch (Exception t) { }
                //Initiatye Variables.
                Order = DummyOrder;
                ChessRules.CurrentOrder = DummyCurrentOrder;


                if (Order * -1 == 1)
                    a = Color.Gray;
                else
                    a = Color.Brown;
                Order *= -1;
                ChessRules.CurrentOrder *= -1;
                //King.
                try
                {
                    for (ik = KingMidle; ik < KingHigh; ik++)
                    {
                        {

                            for (j = 0; j < KingOnTable[ik].KingThinking[0].TableListKing.Count; j++)
                            {
                                if (KingOnTable[ik].KingThinking[0].PenaltyRegardListKing[j].IsPenaltyAction() != 0)
                                {
                                    //if (KingOnTable[ik].KingThinking[0].AStarGreedy.Count == 0)
                                    KingOnTable[ik].KingThinking[0].AStarGreedy.Add(new AllDraw(MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, ref THIS));
                                    KingOnTable[ik].KingThinking[0].AStarGreedy[KingOnTable[ik].KingThinking[0].AStarGreedy.Count - 1].TableList.Clear();
                                    KingOnTable[ik].KingThinking[0].AStarGreedy[KingOnTable[ik].KingThinking[0].AStarGreedy.Count - 1].TableList.Add(CloneATable(KingOnTable[ik].KingThinking[0].TableListKing[j]));
                                    KingOnTable[ik].KingThinking[0].AStarGreedy[KingOnTable[ik].KingThinking[0].AStarGreedy.Count - 1].SetRowColumn(0);
                                    //KingOnTable[ik].KingThinking[0].AStarGreedy[KingOnTable[ik].KingThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt(iAStarGreedy, ii, jj, a, KingOnTable[ik].KingThinking[0].TableListKing[j], Order, false);
                                    //ParameterizedThreadStart start = new ParameterizedThreadStart(KingOnTable[ik].KingThinking[0].AStarGreedy[KingOnTable[ik].KingThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt);
                                    if (KingOnTable[ik].KingThinking[0].AStarGreedy.Count > 0)
                                    {
                                        Task array = new Task(() => KingOnTable[ik].KingThinking[0].AStarGreedy[KingOnTable[ik].KingThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt(iAStarGreedy, ii, jj, a, CloneATable(KingOnTable[ik].KingThinking[0].TableListKing[j]), Order, false, FOUND));
                                        Object ttttt = new Object(); lock (ttttt) { ThA.Add(array); }
                                        //array.Name = "K" + i.ToString();
                                        array.Start();
                                    }
                                }

                            }
                        }
                    }
                }
                catch (Exception t) { }
            }
            //For Brown Order Blitz Game Calculate Maximum Table Inclusive AStarGreedy First Game Search.
            else
            {
                try
                {
                    for (ik = 0; ik < SodierMidle; ik++)
                    {
                        {

                            //Soldier.
                            for (j = 0; j < SolderesOnTable[ik].SoldierThinking[0].TableListSolder.Count; j++)
                            {
                                if (SolderesOnTable[ik].SoldierThinking[0].PenaltyRegardListSolder[j].IsPenaltyAction() != 0)
                                {
                                    ///if (Index[0] != -1)
                                    {
                                        // if (SolderesOnTable[ik].SoldierThinking[0].AStarGreedy.Count == 0)
                                        SolderesOnTable[ik].SoldierThinking[0].AStarGreedy.Add(new AllDraw(MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, ref THIS));
                                        SolderesOnTable[ik].SoldierThinking[0].AStarGreedy[SolderesOnTable[ik].SoldierThinking[0].AStarGreedy.Count - 1].TableList.Clear();
                                        SolderesOnTable[ik].SoldierThinking[0].AStarGreedy[SolderesOnTable[ik].SoldierThinking[0].AStarGreedy.Count - 1].TableList.Add(CloneATable(SolderesOnTable[ik].SoldierThinking[0].TableListSolder[j]));
                                        SolderesOnTable[ik].SoldierThinking[0].AStarGreedy[SolderesOnTable[ik].SoldierThinking[0].AStarGreedy.Count - 1].SetRowColumn(0);
                                        //SolderesOnTable[ik].SoldierThinking[0].AStarGreedy[SolderesOnTable[ik].SoldierThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt(iAStarGreedy, ii, jj, a, SolderesOnTable[ik].SoldierThinking[0].TableListSolder[j], Order, false);
                                        //ParameterizedThreadStart start = new ParameterizedThreadStart(SolderesOnTable[ik].SoldierThinking[0].AStarGreedy[SolderesOnTable[ik].SoldierThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt);
                                        if (SolderesOnTable[ik].SoldierThinking[0].AStarGreedy.Count > 0)
                                        {
                                            Task array = new Task(() => SolderesOnTable[ik].SoldierThinking[0].AStarGreedy[SolderesOnTable[ik].SoldierThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt(iAStarGreedy, ii, jj, a, CloneATable(SolderesOnTable[ik].SoldierThinking[0].TableListSolder[j]), Order, false, FOUND));
                                            Object ttttt = new Object(); lock (ttttt) { ThA.Add(array); }
                                            //array.Name = "S" + i.ToString();
                                            array.Start();
                                        }

                                    }
                                }
                            }

                        }
                    }
                }
                catch (Exception t) { }
                //Initiatye Variables.
                Order = DummyOrder;
                ChessRules.CurrentOrder = DummyCurrentOrder;


                if (Order * -1 == 1)
                    a = Color.Gray;
                else
                    a = Color.Brown;
                Order *= -1;
                ChessRules.CurrentOrder *= -1;
                //Elephant
                try
                {
                    for (ik = 0; ik < ElefantMidle; ik++)
                    {
                        {
                            for (j = 0; j < ElephantOnTable[ik].ElefantThinking[0].TableListElefant.Count; j++)
                            {
                                if (ElephantOnTable[ik].ElefantThinking[0].PenaltyRegardListElefant[j].IsPenaltyAction() != 0)
                                {
                                    //if (Index[1] != -1)
                                    {
                                        //if (ElephantOnTable[ik].ElefantThinking[0].AStarGreedy.Count == 0)
                                        ElephantOnTable[ik].ElefantThinking[0].AStarGreedy.Add(new AllDraw(MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, ref THIS));
                                        ElephantOnTable[ik].ElefantThinking[0].AStarGreedy[ElephantOnTable[ik].ElefantThinking[0].AStarGreedy.Count - 1].TableList.Clear();
                                        ElephantOnTable[ik].ElefantThinking[0].AStarGreedy[ElephantOnTable[ik].ElefantThinking[0].AStarGreedy.Count - 1].TableList.Add(CloneATable(ElephantOnTable[ik].ElefantThinking[0].TableListElefant[j]));
                                        ElephantOnTable[ik].ElefantThinking[0].AStarGreedy[ElephantOnTable[ik].ElefantThinking[0].AStarGreedy.Count - 1].SetRowColumn(0);
                                        //ElephantOnTable[ik].ElefantThinking[0].AStarGreedy[ElephantOnTable[ik].ElefantThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt(iAStarGreedy, ii, jj, a, ElephantOnTable[ik].ElefantThinking[0].TableListElefant[j], Order, false);
                                        //ParameterizedThreadStart start = new ParameterizedThreadStart(ElephantOnTable[ik].ElefantThinking[0].AStarGreedy[ElephantOnTable[ik].ElefantThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt);
                                        if (ElephantOnTable[ik].ElefantThinking[0].AStarGreedy.Count > 0)
                                        {
                                            Task array = new Task(() => ElephantOnTable[ik].ElefantThinking[0].AStarGreedy[ElephantOnTable[ik].ElefantThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt(iAStarGreedy, ii, jj, a, CloneATable(ElephantOnTable[ik].ElefantThinking[0].TableListElefant[j]), Order, false, FOUND));
                                            Object ttttt = new Object(); lock (ttttt) { ThA.Add(array); }
                                            //array.Name = "E" + i.ToString();
                                            array.Start();
                                        }

                                    }
                                }


                            }
                        }
                    }
                }
                catch (Exception t) { }

                //Initiatye Variables.
                Order = DummyOrder;
                ChessRules.CurrentOrder = DummyCurrentOrder;


                if (Order * -1 == 1)
                    a = Color.Gray;
                else
                    a = Color.Brown;
                Order *= -1;
                ChessRules.CurrentOrder *= -1;
                //Hourse.
                try
                {
                    for (ik = 0; ik < HourseMidle; ik++)
                    {
                        {
                            for (j = 0; j < HoursesOnTable[ik].HourseThinking[0].TableListHourse.Count; j++)
                            {
                                if (HoursesOnTable[ik].HourseThinking[0].PenaltyRegardListHourse[j].IsPenaltyAction() != 0)
                                {
                                    //if (Index[2] != -1)
                                    {
                                        // if (HoursesOnTable[ik].HourseThinking[0].AStarGreedy.Count == 0)
                                        HoursesOnTable[ik].HourseThinking[0].AStarGreedy.Add(new AllDraw(MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, ref THIS));
                                        HoursesOnTable[ik].HourseThinking[0].AStarGreedy[HoursesOnTable[ik].HourseThinking[0].AStarGreedy.Count - 1].TableList.Clear(); ;
                                        HoursesOnTable[ik].HourseThinking[0].AStarGreedy[HoursesOnTable[ik].HourseThinking[0].AStarGreedy.Count - 1].TableList.Add(CloneATable(HoursesOnTable[ik].HourseThinking[0].TableListHourse[j]));
                                        HoursesOnTable[ik].HourseThinking[0].AStarGreedy[HoursesOnTable[ik].HourseThinking[0].AStarGreedy.Count - 1].SetRowColumn(0);
                                        //HoursesOnTable[ik].HourseThinking[0].AStarGreedy[HoursesOnTable[ik].HourseThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt(iAStarGreedy, ii, jj, a, HoursesOnTable[ik].HourseThinking[0].TableListHourse[j], Order, false);
                                        //ParameterizedThreadStart start = new ParameterizedThreadStart(HoursesOnTable[ik].HourseThinking[0].AStarGreedy[HoursesOnTable[ik].HourseThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt);
                                        if (HoursesOnTable[ik].HourseThinking[0].AStarGreedy.Count > 0)
                                        {
                                            Task array = new Task(() => HoursesOnTable[ik].HourseThinking[0].AStarGreedy[HoursesOnTable[ik].HourseThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt(iAStarGreedy, ii, jj, a, CloneATable(HoursesOnTable[ik].HourseThinking[0].TableListHourse[j]), Order, false, FOUND));
                                            Object ttttt = new Object(); lock (ttttt) { ThA.Add(array); }
                                            //array.Name = "H" + i.ToString();
                                            array.Start();
                                        }

                                    }
                                }



                            }
                        }
                    }
                }
                catch (Exception t) { }
                //Initiatye Variables.
                Order = DummyOrder;
                ChessRules.CurrentOrder = DummyCurrentOrder;


                if (Order * -1 == 1)
                    a = Color.Gray;
                else
                    a = Color.Brown;
                Order *= -1;
                ChessRules.CurrentOrder *= -1;
                //Bridges.
                try
                {
                    for (ik = 0; ik < BridgeMidle; ik++)
                    {
                        {
                            for (j = 0; j < BridgesOnTable[ik].BridgeThinking[0].TableListBridge.Count; j++)
                            {
                                if (BridgesOnTable[ik].BridgeThinking[0].PenaltyRegardListBridge[j].IsPenaltyAction() != 0)
                                {

                                    //if (Index[3] != -1)
                                    {
                                        //  if (BridgesOnTable[ik].BridgeThinking[0].AStarGreedy.Count == 0)
                                        BridgesOnTable[ik].BridgeThinking[0].AStarGreedy.Add(new AllDraw(MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, ref THIS));
                                        BridgesOnTable[ik].BridgeThinking[0].AStarGreedy[BridgesOnTable[ik].BridgeThinking[0].AStarGreedy.Count - 1].TableList.Clear();
                                        BridgesOnTable[ik].BridgeThinking[0].AStarGreedy[BridgesOnTable[ik].BridgeThinking[0].AStarGreedy.Count - 1].TableList.Add(CloneATable(BridgesOnTable[ik].BridgeThinking[0].TableListBridge[j]));
                                        BridgesOnTable[ik].BridgeThinking[0].AStarGreedy[BridgesOnTable[ik].BridgeThinking[0].AStarGreedy.Count - 1].SetRowColumn(0);
                                        //BridgesOnTable[ik].BridgeThinking[0].AStarGreedy[BridgesOnTable[ik].BridgeThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt(iAStarGreedy, ii, jj, a, BridgesOnTable[ik].BridgeThinking[0].TableListBridge[j], Order, false);
                                        //ParameterizedThreadStart start = new ParameterizedThreadStart(BridgesOnTable[ik].BridgeThinking[0].AStarGreedy[BridgesOnTable[ik].BridgeThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt);
                                        if (BridgesOnTable[ik].BridgeThinking[0].AStarGreedy.Count > 0)
                                        {
                                            Task array = new Task(() => BridgesOnTable[ik].BridgeThinking[0].AStarGreedy[BridgesOnTable[ik].BridgeThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt(iAStarGreedy, ii, jj, a, CloneATable(BridgesOnTable[ik].BridgeThinking[0].TableListBridge[j]), Order, false, FOUND));
                                            Object ttttt = new Object(); lock (ttttt) { ThA.Add(array); }
                                            //array.Name = "B" + i.ToString();
                                            array.Start();
                                        }

                                    }
                                }



                            }
                        }
                    }
                }
                catch (Exception t) { }
                //Initiatye Variables.
                Order = DummyOrder;
                ChessRules.CurrentOrder = DummyCurrentOrder;


                if (Order * -1 == 1)
                    a = Color.Gray;
                else
                    a = Color.Brown;
                Order *= -1;
                ChessRules.CurrentOrder *= -1;
                //Minister.

                try
                {
                    for (ik = 0; ik < MinisterMidle; ik++)
                    {
                        {
                            for (j = 0; j < MinisterOnTable[ik].MinisterThinking[0].TableListMinister.Count; j++)
                            {
                                if (MinisterOnTable[ik].MinisterThinking[0].PenaltyRegardListMinister[j].IsPenaltyAction() != 0)
                                {
                                    //if (Index[4] != -1)
                                    {
                                        //  if (MinisterOnTable[ik].MinisterThinking[0].AStarGreedy.Count == 0)
                                        MinisterOnTable[ik].MinisterThinking[0].AStarGreedy.Add(new AllDraw(MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, ref THIS));
                                        MinisterOnTable[ik].MinisterThinking[0].AStarGreedy[MinisterOnTable[ik].MinisterThinking[0].AStarGreedy.Count - 1].TableList.Clear();
                                        MinisterOnTable[ik].MinisterThinking[0].AStarGreedy[MinisterOnTable[ik].MinisterThinking[0].AStarGreedy.Count - 1].TableList.Add(CloneATable(MinisterOnTable[ik].MinisterThinking[0].TableListMinister[j]));
                                        MinisterOnTable[ik].MinisterThinking[0].AStarGreedy[MinisterOnTable[ik].MinisterThinking[0].AStarGreedy.Count - 1].SetRowColumn(0);
                                        //MinisterOnTable[ik].MinisterThinking[0].AStarGreedy[MinisterOnTable[ik].MinisterThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt(iAStarGreedy, ii, jj, a, MinisterOnTable[ik].MinisterThinking[0].TableListMinister[j], Order, false);
                                        //ParameterizedThreadStart start = new ParameterizedThreadStart(MinisterOnTable[ik].MinisterThinking[0].AStarGreedy[MinisterOnTable[ik].MinisterThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt);
                                        if (MinisterOnTable[ik].MinisterThinking[0].AStarGreedy.Count > 0)
                                        {
                                            Task array = new Task(() => MinisterOnTable[ik].MinisterThinking[0].AStarGreedy[MinisterOnTable[ik].MinisterThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt(iAStarGreedy, ii, jj, a, CloneATable(MinisterOnTable[ik].MinisterThinking[0].TableListMinister[j]), Order, false, FOUND));
                                            Object ttttt = new Object(); lock (ttttt) { ThA.Add(array); }
                                            //array.Name = "M" + i.ToString();
                                            array.Start();
                                        }

                                    }
                                }


                            }
                        }
                    }
                }
                catch (Exception t) { }
                //Initiatye Variables.
                Order = DummyOrder;
                ChessRules.CurrentOrder = DummyCurrentOrder;


                if (Order * -1 == 1)
                    a = Color.Gray;
                else
                    a = Color.Brown;
                Order *= -1;
                ChessRules.CurrentOrder *= -1;
                //King.
                try
                {
                    for (ik = 0; ik < KingMidle; ik++)
                    {
                        {
                            for (j = 0; j < KingOnTable[ik].KingThinking[0].TableListKing.Count; j++)
                            {
                                if (KingOnTable[ik].KingThinking[0].PenaltyRegardListKing[j].IsPenaltyAction() != 0)
                                {
                                    //if (Index[5] != -1)
                                    {
                                        // if (KingOnTable[ik].KingThinking[0].AStarGreedy.Count == 0)
                                        KingOnTable[ik].KingThinking[0].AStarGreedy.Add(new AllDraw(MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, ref THIS));
                                        KingOnTable[ik].KingThinking[0].AStarGreedy[KingOnTable[ik].KingThinking[0].AStarGreedy.Count - 1].TableList.Clear();
                                        KingOnTable[ik].KingThinking[0].AStarGreedy[KingOnTable[ik].KingThinking[0].AStarGreedy.Count - 1].TableList.Add(CloneATable(KingOnTable[ik].KingThinking[0].TableListKing[j]));
                                        KingOnTable[ik].KingThinking[0].AStarGreedy[KingOnTable[ik].KingThinking[0].AStarGreedy.Count - 1].SetRowColumn(0);
                                        //KingOnTable[ik].KingThinking[0].AStarGreedy[KingOnTable[ik].KingThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt(iAStarGreedy, ii, jj, a, KingOnTable[ik].KingThinking[0].TableListKing[j], Order, false);
                                        //ParameterizedThreadStart start = new ParameterizedThreadStart(KingOnTable[ik].KingThinking[0].AStarGreedy[KingOnTable[ik].KingThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt);
                                        if (KingOnTable[ik].KingThinking[0].AStarGreedy.Count > 0)
                                        {
                                            Task array = new Task(() => KingOnTable[ik].KingThinking[0].AStarGreedy[KingOnTable[ik].KingThinking[0].AStarGreedy.Count - 1].InitiateAStarGreedyt(iAStarGreedy, ii, jj, a, CloneATable(KingOnTable[ik].KingThinking[0].TableListKing[j]), Order, false, FOUND));                                           //Object ttttt = new Object(); lock(ttttt){ ThA.Add(array);}
                                            Object ttttt = new Object(); lock (ttttt) { ThA.Add(array); }
                                            //array.Name = "K" + i.ToString();
                                            array.Start();
                                        }

                                    }
                                }



                            }
                        }
                    }
                }
                catch (Exception t) { }
                {
                    //if (JI == 0)
                    //if (JI == 1)
                    //if (JI == 2)
                    //if (JI == 3)
                    //if (JI == 4)
                    //if (JI == 5)
                }


            }
        }
        int[,] CloneATable(int[,] Tab)
        {
            int[,] Table = new int[8, 8];
            for (int i = 0; i < 8; i++)
                for (int j = 0; j < 8; j++)
                    Table[i, j] = Tab[i, j];
            return Table;
        }
        int MaxOfThreeHuristic(double _1, double _2, double _3, double _4, double _5, double _6)
        {
            if (_1 > _2)
            {
                if (_1 > _3)
                {
                    if (_1 > _4)
                    {
                        if (_1 > _5)
                        {
                            if (_1 > _6)
                            {
                                return 0;
                            }
                            else
                                return 5;
                        }
                        else
                            if (_5 > _6)
                            {
                                return 4;
                            }
                            else
                                return 5;
                    }
                    else
                        if (_4 > _5)
                        {
                            if (_4 > _6)
                                return 3;
                            else
                                return 5;
                        }
                        else if (_5 > _6)
                            return 4;
                        else
                            return 5;

                }
                else
                    if (_3 > _4)
                    {
                        if (_3 > _5)
                        {
                            if (_3 > _6)
                                return 2;
                            else
                                return 5;
                        }
                        else
                            if (_5 > _6)
                                return 4;
                            else
                                return 5;
                    }
                    else
                        if (_4 > _5)
                        {
                            if (_4 > _6)
                                return 3;
                            else
                                return 5;
                        }
                        else
                            if (_5 > _6)
                                return 4;
                            else
                                return 5;

            }
            else
                if (_2 > _3)
                {
                    if (_2 > _4)
                    {
                        if (_2 > _5)
                        {
                            if (_2 > _6)
                                return 1;
                            else
                                return 5;
                        }
                        else
                            if (_5 > _6)
                                return 4;
                            else
                                return 5;
                    }
                    else
                        if (_4 > _5)
                        {
                            if (_4 > _6)
                                return 3;
                            else
                                return 5;
                        }
                        else
                            if (_5 > _6)
                                return 4;
                            else
                                return 5;
                }
                else
                {
                    if (_3 > _4)
                    {
                        if (_3 > _5)
                        {
                            if (_3 > _6)
                                return 2;
                            else
                                return 5;
                        }
                        else
                            if (_5 > _6)
                                return 4;
                            else
                                return 5;
                    }
                    else
                        if (_4 > _5)
                        {
                            if (_4 > _6)
                                return 3;
                            else
                                return 5;
                        }
                        else
                            if (_5 > _6)
                                return 4;
                            else
                                return 5;
                }
            return -1;
        }
        //best movement indexes founder method.
        List<List<double>> FoundOfBestMovments(int AStarGreedy, ref List<double> i, ref List<double> j, ref List<double> k, AllDraw Dummy, Color a, int Order)
        {
            //initiate local variables.
            List<List<double>> p = new List<List<double>>();

            for (int ii = 0; ii < 6; ii++)
            {
                List<double> pl = new List<double>();
                p.Add(pl);
            }
            Less = Double.MinValue; ;
            List<AllDraw> DummyList = new List<AllDraw>();
            DummyList.Add(Dummy);
            MaxHuristicAStarGreedytBackWard.Clear();
            //found best movment depend of max huristic.
            Dummy.HuristicAStarGreedySearch(0, DummyList, a, Order, false);
            //proccess from a stored global variable decicion making.
            if (MaxHuristicAStarGreedytBackWard[0][1] != -1)//soldier.
            {
                i.Add(MaxHuristicAStarGreedytBackWard[0][2]);
                j.Add(MaxHuristicAStarGreedytBackWard[0][3]);
                k.Add(MaxHuristicAStarGreedytBackWard[0][4]);
                p[0].Add(MaxHuristicAStarGreedytBackWard[0][2]);
            }
            else if (MaxHuristicAStarGreedytBackWard[0][5] != -1)//Elephant
            {
                i.Add(MaxHuristicAStarGreedytBackWard[0][6]);
                j.Add(MaxHuristicAStarGreedytBackWard[0][7]);
                k.Add(MaxHuristicAStarGreedytBackWard[0][8]);
                p[1].Add(MaxHuristicAStarGreedytBackWard[0][6]);
            }
            else if (MaxHuristicAStarGreedytBackWard[0][9] != -1)//Hourse
            {
                i.Add(MaxHuristicAStarGreedytBackWard[0][10]);
                j.Add(MaxHuristicAStarGreedytBackWard[0][11]);
                k.Add(MaxHuristicAStarGreedytBackWard[0][12]);
                p[2].Add(MaxHuristicAStarGreedytBackWard[0][10]);
            }
            else if (MaxHuristicAStarGreedytBackWard[0][13] != -1)//Bridges.
            {
                i.Add(MaxHuristicAStarGreedytBackWard[0][14]);
                j.Add(MaxHuristicAStarGreedytBackWard[0][15]);
                k.Add(MaxHuristicAStarGreedytBackWard[0][16]);
                p[3].Add(MaxHuristicAStarGreedytBackWard[0][14]);
            }
            else if (MaxHuristicAStarGreedytBackWard[0][17] != -1)//Minister
            {
                i.Add(MaxHuristicAStarGreedytBackWard[0][18]);
                j.Add(MaxHuristicAStarGreedytBackWard[0][19]);
                k.Add(MaxHuristicAStarGreedytBackWard[0][20]);
                p[4].Add(MaxHuristicAStarGreedytBackWard[0][18]);
            }
            else if (MaxHuristicAStarGreedytBackWard[0][21] != -1)//King.
            {
                i.Add(MaxHuristicAStarGreedytBackWard[0][22]);
                j.Add(MaxHuristicAStarGreedytBackWard[0][23]);
                k.Add(MaxHuristicAStarGreedytBackWard[0][24]);
                p[5].Add(MaxHuristicAStarGreedytBackWard[0][22]);
            }
            //not found
            return p;
        }
        //Non Used Current Table Found Huristic Method.
        public int[,] HuristicCurrentTable(AllDraw ADra, Color a, int Order)
        {
            //Initiate of Local and Global Varaibles.
            AllDraw.SyntaxToWrite = "";
            int[,] Tab = new int[8, 8];
            List<AllDraw> Ad = new List<AllDraw>();
            Ad.Add(ADra);
            Less = -20000000;

            //Found of Current Table Huristics.
            Tab = this.HuristicAStarGreedySearch(0, Ad, a, Order, true);
            //THIS.SetBoxText("\r\nCurrent Table Syntax:" + AllDraw.SyntaxToWrite);
            //THIS.RefreshBoxText();
            return Tab;

        }
        //Copying of Items of Enemy Non Move and Current Moved.
        public AllDraw CopyRemeiningItems(AllDraw ADummy, int Order)
        {
            //Initiate Local Variables.
            AllDraw Dummy = new AllDraw(MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, ref THIS);
            Dummy.SolderesOnTable = new DrawSoldier[SodierHigh];
            Dummy.ElephantOnTable = new DrawElefant[ElefantHigh];
            Dummy.HoursesOnTable = new DrawHourse[HourseHight];
            Dummy.BridgesOnTable = new DrawBridge[BridgeHigh];
            Dummy.MinisterOnTable = new DrawMinister[MinisterHigh];
            Dummy.KingOnTable = new DrawKing[KingHigh];
            //For All Sodiers Movments.
            for (int i = 0; i < SodierHigh; i++)
            {
                try
                {
                    //Construction of Current Solders. 
                    Dummy.SolderesOnTable[i] = new DrawSoldier(MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, SolderesOnTable[i].Row, SolderesOnTable[i].Column, SolderesOnTable[i].color, SolderesOnTable[i].Table, SolderesOnTable[i].Order, false, SolderesOnTable[i].Current);
                }
                catch (Exception t) { }
            }
            //For All Elephant Objects.
            for (int i = 0; i < ElefantHigh; i++)
            {
                try
                {
                    //Construction of Curren Elephant.
                    Dummy.ElephantOnTable[i] = new DrawElefant(MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, ElephantOnTable[i].Row, ElephantOnTable[i].Column, ElephantOnTable[i].color, ElephantOnTable[i].Table, ElephantOnTable[i].Order, false, ElephantOnTable[i].Current);
                }
                catch (Exception t) { }
            }
            //for All Hourse Objects.
            for (int i = 0; i < HourseHight; i++)
            {
                try
                {
                    //Construction of Hourse Objects.
                    Dummy.HoursesOnTable[i] = new DrawHourse(MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, HoursesOnTable[i].Row, HoursesOnTable[i].Column, HoursesOnTable[i].color, HoursesOnTable[i].Table, HoursesOnTable[i].Order, false, HoursesOnTable[i].Current);
                }
                catch (Exception t) { }
            }
            //For All Bridges Objects.
            for (int i = 0; i < BridgeHigh; i++)
            {
                try
                {
                    //Construction of Bridges Objects.
                    Dummy.BridgesOnTable[i] = new DrawBridge(MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, BridgesOnTable[i].Row, BridgesOnTable[i].Column, BridgesOnTable[i].color, BridgesOnTable[i].Table, BridgesOnTable[i].Order, false, BridgesOnTable[i].Current);
                }
                catch (Exception t) { }
            }
            //For All Minister Objects.
            for (int i = 0; i < MinisterHigh; i++)
            {
                try
                {
                    //Construction of Current Minister.
                    Dummy.MinisterOnTable[i] = new DrawMinister(MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, MinisterOnTable[i].Row, MinisterOnTable[i].Column, MinisterOnTable[i].color, MinisterOnTable[i].Table, MinisterOnTable[i].Order, false, MinisterOnTable[i].Current);
                }
                catch (Exception t) { }
            }
            //For All King Objects.
            for (int i = 0; i < KingHigh; i++)
            {
                try
                {
                    //Construction of Kings Objects.
                    Dummy.KingOnTable[i] = new DrawKing(MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, KingOnTable[i].Row, KingOnTable[i].Column, KingOnTable[i].color, KingOnTable[i].Table, KingOnTable[i].Order, false, KingOnTable[i].Current);
                }
                catch (Exception t) { }
            }
            //Gray Order.
            if (Order == 1)
            {
                //For Gray Soders Objects.
                for (int i = 0; i < SodierMidle; i++)
                {
                    try
                    {
                        //Clone a Movments.
                        ADummy.SolderesOnTable[i].Clone(ref Dummy.SolderesOnTable[i]);
                    }
                    catch (Exception t) { Dummy.SolderesOnTable[i] = null; }
                }
                //For Gray Elephant.
                for (int i = 0; i < ElefantMidle; i++)
                {
                    try
                    {
                        //Clone a  Movments.
                        ADummy.ElephantOnTable[i].Clone(ref Dummy.ElephantOnTable[i]);
                    }
                    catch (Exception t) { Dummy.ElephantOnTable[i] = null; }
                }
                //For Gray Hourses.
                for (int i = 0; i < HourseMidle; i++)
                {
                    try
                    {
                        //Clone a Movments.
                        ADummy.HoursesOnTable[i].Clone(ref Dummy.HoursesOnTable[i]);
                    }
                    catch (Exception t) { Dummy.HoursesOnTable[i] = null; }
                }
                //For Gray Bridges.
                for (int i = 0; i < BridgeMidle; i++)
                {
                    try
                    {
                        //Clone a Movments.
                        ADummy.BridgesOnTable[i].Clone(ref Dummy.BridgesOnTable[i]);
                    }
                    catch (Exception t) { Dummy.BridgesOnTable[i] = null; }
                }
                //For Gray Ministers.
                for (int i = 0; i < MinisterMidle; i++)
                {
                    try
                    {
                        //Clone a Movments.
                        ADummy.MinisterOnTable[i].Clone(ref Dummy.MinisterOnTable[i]);
                    }
                    catch (Exception t) { Dummy.MinisterOnTable[i] = null; }
                }
                //For Gray King.
                for (int i = 0; i < KingMidle; i++)
                {
                    try
                    {
                        //Clone a Movments.
                        ADummy.KingOnTable[i].Clone(ref Dummy.KingOnTable[i]);
                    }
                    catch (Exception t) { Dummy.KingOnTable[i] = null; }
                }
                //For All Solders.
            }
            else//For Order Brown.
            {
                {
                    //For Brown Solders.
                    for (int i = SodierMidle; i < SodierHigh; i++)
                    {
                        try
                        {
                            //Clone a Movments.
                            ADummy.SolderesOnTable[i].Clone(ref Dummy.SolderesOnTable[i]);
                        }
                        catch (Exception t) { Dummy.SolderesOnTable[i] = null; }
                    }
                    //For All Brown Elephants.
                    for (int i = ElefantMidle; i < ElefantHigh; i++)
                    {
                        try
                        {
                            //Clone a Enemy.
                            ADummy.ElephantOnTable[i].Clone(ref Dummy.ElephantOnTable[i]);
                        }
                        catch (Exception t) { Dummy.ElephantOnTable[i] = null; }
                    }
                    //For All Brown Hourses.
                    for (int i = HourseMidle; i < HourseHight; i++)
                    {
                        try
                        {
                            //Clone a Enemy.
                            ADummy.HoursesOnTable[i].Clone(ref Dummy.HoursesOnTable[i]);
                        }
                        catch (Exception t) { Dummy.HoursesOnTable[i] = null; }
                    }
                    //For Brown Bridges. 
                    for (int i = BridgeMidle; i < BridgeHigh; i++)
                    {
                        try
                        {
                            //Clone a Movments.
                            ADummy.BridgesOnTable[i].Clone(ref Dummy.BridgesOnTable[i]);
                        }
                        catch (Exception t) { Dummy.BridgesOnTable[i] = null; }
                    }
                    //For Gray Minsters.
                    for (int i = MinisterMidle; i < MinisterHigh; i++)
                    {
                        try
                        {
                            //Clone a Enemy.
                            ADummy.MinisterOnTable[i].Clone(ref Dummy.MinisterOnTable[i]);
                        }
                        catch (Exception t) { Dummy.MinisterOnTable[i] = null; }
                    }
                    //For Brown Kings.
                    for (int i = KingMidle; i < KingHigh; i++)
                    {
                        try
                        {
                            //Clone a Enemy.
                            ADummy.KingOnTable[i].Clone(ref Dummy.KingOnTable[i]);
                        }
                        catch (Exception t) { Dummy.KingOnTable[i] = null; }
                    }
                }

            }

            //Return Constructed Tables.
            return Dummy;


        }
        //Reconstruction of AllDraw Object.
        public void RecoonstructADraw(ref List<AllDraw> ADrawAll)
        {
            //Recurve Conditions.
            if (ADraw.Count == 0)
                return;
            //Adding Operations.
            ADrawAll.Add(this.ADraw[0]);
            //Recursive Main Method.
            ADraw[0].RecoonstructADraw(ref ADrawAll);
        }
        //Main Initiate Thinking Method.
        public void Initiate(int ii, int jj, Color a, int[,] Table, int Order, bool TB,bool FOUND)
        {
            ThinkingChess.NumbersOfAllNode = 0;
            int[,] TableHuristic = new int[8, 8];
            ThinkingChess.FoundFirstMating = 0;
            ThinkingFinished = false;
            //Monitor Log File Appending ZFirst Line. 
            File.AppendAllText(FormRefrigtz.Root + "\\Database\\Monitor.txt", "\n\t=====================================================================================================================================================================");
            File.AppendAllText(FormRefrigtz.Root + "\\Database\\Monitor.txt", "\n\tMovment Number:" + FormRefrigtz.MovmentsNumber);
            //Initiate Local and Global Variables.            
            ThinkingChess.Sign = 1;
            CurrentHuristic = Double.MinValue; ;
            //SetprogressBarRefregitzValue(//THIS.progressBarVerify, 0);
            //THIS.progressBarVerify.Invalidate();
            //SetprogressBarUpdate(//THIS.progressBarVerify);
            MaxHuristicxT = Double.MinValue;
            DrawBridge.MaxHuristicxB = Double.MinValue;
            DrawElefant.MaxHuristicxE = Double.MinValue;
            DrawHourse.MaxHuristicxH = Double.MinValue;
            DrawKing.MaxHuristicxK = Double.MinValue;
            DrawMinister.MaxHuristicxM = Double.MinValue;
            DrawSoldier.MaxHuristicxS = Double.MinValue;
            MovementsAStarGreedyHuristicFoundT = false;
            DrawTable = false;

            ChessRules.CheckBrownObjectDangourFirstTimesOcured = false;
            ChessRules.CheckGrayObjectDangourFirstTimesOcured = false;
            int Current = ChessRules.CurrentOrder;
            int DummyOrder = Order;

            //If There is Not AStarGreedy Huristic Boolean Chacked.
            if (!AllDraw.AStarGreadyFirstSearch)
            {
                AllDraw.StoreADraw.Clear();
                int[,] Tab = null;
                int[,] TablInit = null;

                ADraw.Clear();
                TableList.Clear();
                TableList.Add(Table);
                SetRowColumn(0);
                TableList.Clear();
                ThinkingChess.NotSolvedKingDanger = false;
                LoopHuristicIndex = 0;
                //For All Pssible One.
                for (int i = 0; i < 1; i++)
                {
                    //If Gray Order.
                    if (Order == 1)
                    {
                        //THIS.SetBoxText("\r\nChess Thinking AStarGreedy " + i.ToString() + " By Bob!");
                        //THIS.RefreshBoxText();
                    }
                    else
                    {
                        //THIS.SetBoxText("\r\nChess Thinking AStarGreedy " + i.ToString() + " By Alice!");
                        //THIS.RefreshBoxText();
                    }
                    //Initaite Local Variables.
                    TablInit = new int[8, 8];
                    if (Order == 1)
                        a = Color.Gray;
                    else
                        a = Color.Brown;
                    int In = 0;
                    //Determine a Random Solders Objects.
                    do
                    {
                        //When Order is Gray Random is on Gray.
                        if (Order == 1)
                            In = (new System.Random()).Next(0, 8);
                        else
                            In = (new System.Random()).Next(8, 16);
                    } while (SolderesOnTable[In] == null);
                    //Initiate a DFept On Movments.
                    this.InitiateForEveryKindThingHome(new AllDraw(MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, ref THIS), (int)SolderesOnTable[In].Row, (int)SolderesOnTable[In].Column, a, Table, Order, false, In);
                    //Initaite a Local Varibales of Huristics.
                    Less = Double.MinValue;
                    //For Greater Than Zero ADraw Count Varibale. 
                    if (ADraw.Count > 0)
                    {
                        //If Gray Order.
                        if (Order == 1)
                        {
                            //THIS.SetBoxText("\r\nHuristic Find Best Movements AStarGreedy " + i.ToString() + " By Bob!");
                            //THIS.RefreshBoxText();
                        }
                        else
                        {
                            //THIS.SetBoxText("\r\nHuristic Find Best Movements AStarGreedy " + i.ToString() + " By Alice!");
                            //THIS.RefreshBoxText();

                        }
                        Order = FormRefrigtz.OrderPlate;
                        ChessRules.CurrentOrder = FormRefrigtz.OrderPlate;
                        Tab = this.ADraw[0].Huristic(ADraw, a, i, Order);
                    }
                    //If Repetedly Movments Occurred.
                    if (ThinkingChess.ExistTableInList(Tab, TableListAction, 0))
                    {
                        //If Gray Order.
                        if (Order == 1)
                        {
                            //THIS.SetBoxText("\r\nGenetic Algorithm Begin AStarGreedy " + i.ToString() + " By Bob!");
                            //THIS.RefreshBoxText();
                        }
                        else
                        {
                            //THIS.SetBoxText("\r\nGenetic Algirithm Begin AStarGreedy " + i.ToString() + " By Alice!");
                            //THIS.RefreshBoxText();

                        }
                        //Genetic Algorithm.
                        ChessGeneticAlgorithm R = (new ChessGeneticAlgorithm(MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged));
                        //Found of Table.
                        Tab = R.GenerateTable(TableListAction, LoopHuristicIndex, Order);
                        //Gray Order.
                        if (Order == 1)
                        {
                            //THIS.SetBoxText("\r\nGenetic Algorithm Finsished AStarGreedy " + i.ToString() + " By Bob!");
                            //THIS.RefreshBoxText();
                        }
                        else
                        {
                            //THIS.SetBoxText("\r\nGenetic Algirithm Finished AStarGreedy " + i.ToString() + " By Alice!");
                            //THIS.RefreshBoxText();

                        }
                    }
                    //If Table Found.
                    if (Tab != null)
                    {
                        //Clone  A Copy.
                        for (int iii = 0; iii < 8; iii++)
                            for (int jjj = 0; jjj < 8; jjj++)
                            {
                                TablInit[iii, jjj] = Tab[iii, jjj];
                            }
                        //Initiate Local Varibales.
                        TableList.Add(TablInit);
                        ClList.Add(CL);
                        RWList.Add(RW);
                        KiList.Add(Ki);
                        AStarGreedy++;

                    }
                }

                //Initaite Global Order Varibales By Local Varibales.
                Order = DummyOrder;
                ChessRules.CurrentOrder = Current;
                DrawTable = true;
                FoundATable = true;
                return;
            }
            else
            {
                //Initiate Local Varibales.
                TableHuristic = null;
                RW1 = -1;
                CL1 = -1;
                Ki1 = -1;
                RW2 = -1;
                CL2 = -1;
                Ki2 = -1;
                RW3 = -1;
                CL3 = -1;
                Ki3 = -1;
                RW4 = -1;
                CL4 = -1;
                Ki4 = -1;
                RW5 = -1;
                CL5 = -1;
                Ki5 = -1;
                RW6 = -1;
                CL6 = -1;
                Ki6 = -1;
                MaxHuristicAStarGreedytBackWard.Clear();
                TableList.Clear();
                int[,] Tab = null;
                int[,] TablInit = null;
                AllDraw.AStarGreedyiLevelMax = 2;
                THISDummy = new FormRefrigtz(true);
                if (!FOUND)
                {
                    THISDummy.accessDraw.TableList.Add(FormRefrigtz.Table);
                    THISDummy.accessDraw.SetRowColumn(0);
                    this.Clone(THISDummy.accessDraw);
                    //THISDummy.Dispose();


                    THISDummy.accessDraw.THIS = this.THIS;
                    AStarGreedyIndexVlue = 0;
                    ThinkingChess.NotSolvedKingDanger = false;
                    LoopHuristicIndex = 0;
                    if (CurrentTable == null)
                        CurrentTable = new int[8, 8];
                    for (int i = 0; i < 8; i++)
                        for (int j = 0; j < 8; j++)
                        {
                            CurrentTable[i, j] = Table[i, j];
                        }
                    Less = Double.MinValue; ;


                    AllDraw Dummy = new AllDraw(MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, ref THIS);
                    THISDummy.accessDraw.ADraw.Clear();
                    THISDummy.accessDraw.ADraw.Add(Dummy);
                }
                else
                {
                    THISDummy.accessDraw.THIS = this.THIS;
                    THISDummy.accessDraw = this;
                }
                // Simulate work.
                   if (FormRefrigtz.Blitz)
                   {
                       MaxAStarGreedy = PlatformHelper.ProcessorCount;
                       AStarGreedyiLevelMax = PlatformHelper.ProcessorCount;
                   }
                   else
                   {
                       MaxAStarGreedy = PlatformHelper.ProcessorCount;
                       AStarGreedyiLevelMax = PlatformHelper.ProcessorCount;
                   }
                 
                /*THIS.Invoke((MethodInvoker)delegate()
                {

                    MaxAStarGreedy = System.Convert.ToInt32(THIS.comboBoxMaxLevel.Text);
                    AStarGreedyiLevelMax = System.Convert.ToInt32(THIS.comboBoxMaxLevel.Text);
                    FormRefrigtz.MaxAStarGreedyHuristicProgress = 6;
                    for (int i = 0; i <= MaxAStarGreedy; i++)
                        FormRefrigtz.MaxAStarGreedyHuristicProgress += FormRefrigtz.MaxAStarGreedyHuristicProgress * 6;
                    //THIS.progressBarVerify.Maximum = 999999999;
                    increasedProgress = (int)((double)999999999 / (double)(FormRefrigtz.MaxAStarGreedyHuristicProgress));
                    AStarGreedytMaxCount = (double)MaxAStarGreedy;
                    //SetprogressBarRefregitzValue(//THIS.progressBarVerify, increasedProgress);
                });
                 */ 

                //Iniatite Dehidspt Movments Of Possible.
                AllDraw DummtTHIS = new AllDraw(MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged, ref THIS);
                ChessRules.CurrentOrder = Current;
                Order = DummyOrder;
                THISDummy.accessDraw = THISDummy.accessDraw.InitiateAStarGreedyt(0, ii, jj, a, CurrentTable, Order, false, FOUND);

                //while (!ThinkingFinished) ;
                //ThinkingFinished = false;
                //SetprogressBarRefregitzValue(//THIS.progressBarVerify, 999999999);
                //THIS.progressBarVerify.Invalidate();
                //SetprogressBarUpdate(//THIS.progressBarVerify);

                //Initaite Local Varibales.
                Tab = new int[8, 8];
                Less = Double.MinValue;
                //MaxHuristicAStarGreedytBackWard.Clear();
                ChessRules.CurrentOrder = Current;
                Order = DummyOrder;
                Thread.Sleep(1000);
                //AStarGreedy Huristic Consideration.
                TableHuristic = THISDummy.accessDraw.HuristicAStarGreedySearch(0, THISDummy.accessDraw.ADraw, a, Order, false);
                if (TableHuristic == null || (!(THIS.TableZero(TableHuristic))))
                {

                    try
                    {
                        bool aa = THISDummy.accessDraw.UsePenaltyRegardMechnisamT;
                        THISDummy.accessDraw.UsePenaltyRegardMechnisamT = false;
                        THISDummy.accessDraw = THISDummy.accessDraw.RemovePenalltyFromFirstBranches();
                        MaxAStarGreedy = 1;
                        AStarGreedyiLevelMax = 1;
                        Less = Double.MinValue; ;
                        TableHuristic = THISDummy.accessDraw.HuristicAStarGreedySearch(0, THISDummy.accessDraw.ADraw, a, Order, false);
                        THISDummy.accessDraw.UsePenaltyRegardMechnisamT = aa;
                    }
                    catch (Exception t)
                    {
                    }
                }
                // THISDummy.accessDraw.ADraw[0].HuristicAStarGreedySearch(0, THISDummy.accessDraw.ADraw, a, ref Less, Order, false);
                 try
                {
                    Tab = new int[8, 8];
                    for (int i = 0; i < 8; i++)
                        for (int j = 0; j < 8; j++)
                            Tab[i, j] = TableHuristic[i, j];
                }
                catch (Exception t)
                {

                }
                TableList.Clear();
                //If Table Found.

                if (Tab != null)
                {
                    //Initiate Local Varibales.
                    //THISDummy.Dispose();
                    TableList.Add(Tab);
                    if (THISDummy.accessDraw.ADraw.Count > 0)
                    {
                        if (Order == 1)
                        {
                            //THIS.SetBoxText("\r\nHuristic Find Best Movements AStarGreedy " + AStarGreedy.ToString() + " By Bob!");
                            //THIS.RefreshBoxText();
                        }
                        else
                        {
                            //THIS.SetBoxText("\r\nHuristic Find Best Movements AStarGreedy " + AStarGreedy.ToString() + " By Alice!");
                            //THIS.RefreshBoxText();

                        }
                        TablInit = new int[8, 8];
                        //Less = Double.MinValue; ;



                        Order = DummyOrder;
                        ChessRules.CurrentOrder = Current;
                        //If There is Reapetedly Movments Number.
                        /*if (ThinkingChess.ExistTableInList(Tab, TableListAction, 0))
                        {
                            //Order Gray.
                            if (Order == 1)
                            {
                                //THIS.SetBoxText("\r\nGenetic Algorithm Begin AStarGreedy 0 By Bob!");
                                //THIS.RefreshBoxText();
                            }
                            else
                            {
                                //THIS.SetBoxText("\r\nGenetic Algirithm Begin AStarGreedy 0 By Alice!");
                                //THIS.RefreshBoxText();

                            }
                            //Genetic Algorithms.
                            ChessGeneticAlgorithm R = (new ChessGeneticAlgorithm(MovementsAStarGreedyHuristicFoundT,IgnoreSelfObjectsT,UsePenaltyRegardMechnisamT,BestMovmentsT,PredictHuristicT,OnlySelfT,AStarGreedyHuristicT,ArrangmentsChanged));
                            //Found Of Tables.
                            Tab = R.GenerateTable(TableListAction, LoopHuristicIndex, Order);
                            //Adding Table To Movments Tables List.
                            if (Tab != null)
                                AllDraw.TableCurrent.Add(Tab);
                            //Order Gray.
                            if (Order == 1)
                            {
                                //THIS.SetBoxText("\r\nGenetic Algorithm Finsished AStarGreedy 0 By Bob!");
                                //THIS.RefreshBoxText();
                            }
                            else
                            {
                                //THIS.SetBoxText("\r\nGenetic Algirithm Finished AStarGreedy 0 By Alice!");
                                //THIS.RefreshBoxText();

                            }
                        }*/
                        //When Table Found.
                        if (Tab != null)
                        {
                            //Clone a Table Copy.
                            for (int iii = 0; iii < 8; iii++)
                                for (int jjj = 0; jjj < 8; jjj++)
                                {
                                    TablInit[iii, jjj] = Tab[iii, jjj];
                                }
                            //Clear Lists.
                            TableList.Clear();
                            TableList.Add(TablInit);
                            AStarGreedy++;

                            //Global Order By Local One.
                            Order = DummyOrder;
                            ChessRules.CurrentOrder = Current;
                            try
                            {
                                //Iniatite of Global Varibales.
                                ChessRules.CurrentOrder = Current;
                                //Genetic for Syntax of Table Found.
                                ChessGeneticAlgorithm RR = new ChessGeneticAlgorithm(MovementsAStarGreedyHuristicFoundT, IgnoreSelfObjectsT, UsePenaltyRegardMechnisamT, BestMovmentsT, PredictHuristicT, OnlySelfT, AStarGreedyHuristicT, ArrangmentsChanged);
                                //Consideration of Autorithy.
                                if (RR.FindGenToModified(AllDraw.TableListAction[AllDraw.TableListAction.Count - 1], Tab, AllDraw.TableListAction, 0, Order, true))
                                {
                                    //Found of Syntax.
                                    bool HitVal = false;
                                    int Hit = AllDraw.TableListAction[AllDraw.TableListAction.Count - 1][RR.CromosomRow, RR.CromosomColumn];
                                    if (Hit != 0)
                                        HitVal = true;
                                    bool Convert = false;
                                    if (Order == 1)
                                    {
                                        if (Tab[RR.CromosomRow, RR.CromosomColumn] == 1)
                                        {
                                            if (RR.CromosomColumn == 7)
                                                Convert = true;
                                        }

                                    }
                                    else
                                    {
                                        if (AllDraw.TableListAction[AllDraw.TableListAction.Count - 1][RR.CromosomRowFirst, RR.CromosomColumnFirst] == -1)
                                        {
                                            if (RR.CromosomColumn == 0)
                                                Convert = true;
                                        }

                                    }
                                }
                            }
                            catch (IndexOutOfRangeException t)
                            {

                            }
                        }
                        else
                        {
                            //Clear AStarGreedy Varibales.
                            AllDraw.StoreADraw.Clear();
                            LevelAStarGreedyFirsDynamic = 1;
                            TableCurrent.Clear();
                            AStarGreedy = 0;
                        }
                    }
                }
                else
                {
                    //Clear AStarGreedy Varibales.
                    AllDraw.StoreADraw.Clear();
                    LevelAStarGreedyFirsDynamic = 1;
                    TableCurrent.Clear();
                    AStarGreedy = 0;
                }
                Order = DummyOrder;
                ChessRules.CurrentOrder = Current;
                //THISDummy.Dispose();
                DrawTable = true;
                FoundATable = true;
                return;
            }

        }
        //Identification of Illegal AStarGreedy First and Common Hurist Movments.
        public bool isEnemyThingsinStable(int[,] TableHuristic, int[,] TableAction, int Order)
        {
            //Iniatiet Local Variables.
            int[,] Cromosom1 = TableHuristic;
            int[,] Cromosom2 = TableAction;
            bool and = true;

            bool Find = false;
            //bool Hit = false;
            int FindNumber = 0;
            int
                  CromosomRowFirst = -1, CromosomColumnFirst = -1,
                  CromosomRow = -1, CromosomColumn = -1;
            //Initiate Local Variables.

            //For All Table Home
            for (int i = 0; i < 8; i++)
            {
                for (int j = 0; j < 8; j++)
                {
                    //Gray Order.
                    if (Order == 1)
                    {
                        //Situation 11.
                        if (and)
                        {
                            //All The Brown Object Ignored.
                            if (Cromosom1[i, j] < 0 && Cromosom2[i, j] < 0)
                                continue;
                        }
                        else///Situation 2.
                        {
                            //All The Brown Ojects Ignored.
                            if (Cromosom1[i, j] < 0 || Cromosom2[i, j] < 0)
                                continue;
                        }
                    }
                    else//Brown Order.
                    {
                        //Situation 1.
                        if (and)
                        {
                            //All The Gray Objects Ignored.
                            if (Cromosom1[i, j] > 0 && Cromosom2[i, j] > 0)
                                continue;

                        }
                        else
                        {
                            //All The Gray Objects Ignored.
                            if (Cromosom1[i, j] > 0 || Cromosom2[i, j] > 0)
                                continue;
                        }
                    }
                    if (!(ArrangmentsChanged))
                    {
                        {
                            if (Order == 1 && j == 6 && i > 0 && i < 7)
                            {
                                if (((Cromosom2[i, j + 1] > 0) || (Cromosom2[i + 1, j + 1] > 0 && Cromosom1[i + 1, j + 1] < 0) || (Cromosom2[i - 1, j + 1] > 0 && Cromosom1[i - 1, j + 1] < 0) && Cromosom1[i, j] == 1))
                                {
                                    CromosomRowFirst = i;
                                    CromosomColumnFirst = j;
                                    if (Cromosom2[i, j + 1] > 0)
                                    {
                                        CromosomRow = i;
                                        CromosomColumn = j + 1;
                                    }
                                    else if (Cromosom2[i + 1, j + 1] > 0 && Cromosom1[i + 1, j + 1] < 0)
                                    {
                                        CromosomRow = i + 1;
                                        CromosomColumn = j + 1;
                                    }
                                    else if (Cromosom2[i - 1, j + 1] > 0 && Cromosom1[i - 1, j + 1] < 0)
                                    {
                                        CromosomRow = i - 1;
                                        CromosomColumn = j + 1;
                                    }
                                    Find = true;
                                    FindNumber++;
                                    AllDraw.SodierConversionOcuured = true;

                                }

                            }
                            else
                                if (Order == -1 && j == 1 && i > 0 && i < 7)
                                {
                                    if (((Cromosom2[i, j - 1] < 0) || (Cromosom2[i + 1, j - 1] < 0 && Cromosom1[i + 1, j - 1] > 0) || (Cromosom2[i - 1, j - 1] < 0 && Cromosom1[i - 1, j - 1] < 0) && Cromosom1[i, j] == -1))
                                    {
                                        CromosomRowFirst = i;
                                        CromosomColumnFirst = j;
                                        if (Cromosom2[i, j - 1] > 0)
                                        {
                                            CromosomRow = i;
                                            CromosomColumn = j - 1;
                                        }
                                        else if (Cromosom2[i + 1, j - 1] > 0 && Cromosom1[i + 1, j - 1] < 0)
                                        {
                                            CromosomRow = i + 1;
                                            CromosomColumn = j - 1;
                                        }
                                        else if (Cromosom2[i - 1, j - 1] > 0 && Cromosom1[i - 1, j - 1] < 0)
                                        {
                                            CromosomRow = i - 1;
                                            CromosomColumn = j - 1;
                                        }
                                        FindNumber++;
                                        AllDraw.SodierConversionOcuured = true;
                                    }
                                }

                            //Bridges King Validity Condition.
                            if (Order == 1 && j == 0)
                            {
                                //Small Gray Bridges King.
                                if (i == 6 && Cromosom2[i, j] == 6 && Cromosom2[i - 1, j] == 4 && Cromosom1[i, j] != 6 && Cromosom1[i - 1, j] != 4)
                                {
                                    CromosomRowFirst = i - 3;
                                    CromosomColumnFirst = j;
                                    CromosomRow = i;
                                    CromosomColumn = j;
                                    Find = true;
                                    FindNumber++;
                                    ChessRules.SmallKingBridgeGray = true;
                                    BridgesKing = true;
                                }
                                else //Big Briges King Gray.
                                    if (i == 2 && Cromosom2[i, j] == 6 && Cromosom2[i + 1, j] == 4 && Cromosom1[i, j] != 6 && Cromosom1[i + 1, j] != 4)
                                    {
                                        CromosomRowFirst = i + 3;
                                        CromosomColumnFirst = j;
                                        CromosomRow = i;
                                        CromosomColumn = j;
                                        Find = true;
                                        FindNumber++;
                                        ChessRules.BigKingBridgeGray = true;
                                        BridgesKing = true;
                                    }

                            }
                            else if (j == 7)
                            {
                                //Small Bridges King Brown.
                                if (i == 6 && Cromosom2[i, j] == -6 && Cromosom2[i - 1, j] == -4 && Cromosom1[i, j] != -6 && Cromosom1[i - 1, j] != -4)
                                {
                                    CromosomRowFirst = i - 3;
                                    CromosomColumnFirst = j;
                                    CromosomRow = i;
                                    CromosomColumn = j;
                                    Find = true;
                                    FindNumber++;
                                    ChessRules.SmallKingBridgeBrown = true;
                                    BridgesKing = true;
                                }
                                else//Big Bridges King Brown.
                                    if (i == 2 && Cromosom2[i, j] == -6 && Cromosom2[i + 1, j] == -4 && Cromosom1[i, j] != -6 && Cromosom1[i + 1, j] != -4)
                                    {
                                        CromosomRowFirst = i + 3;
                                        CromosomColumnFirst = j;
                                        CromosomRow = i;
                                        CromosomColumn = j;
                                        Find = true;
                                        FindNumber++;
                                        ChessRules.BigKingBridgeBrown = true;
                                        BridgesKing = true;
                                    }

                            }

                        }
                    }
                    else
                    {
                        {
                            if (Order == 1 && j == 1 && i > 0 && i < 7)
                            {
                                if (((Cromosom2[i, j - 1] > 0) || (Cromosom2[i + 1, j - 1] > 0 && Cromosom1[i + 1, j - 1] < 0) || (Cromosom2[i - 1, j - 1] > 0 && Cromosom1[i - 1, j - 1] < 0) && Cromosom1[i, j] == 1))
                                {
                                    CromosomRowFirst = i;
                                    CromosomColumnFirst = j;
                                    if (Cromosom2[i, j - 1] > 0)
                                    {
                                        CromosomRow = i;
                                        CromosomColumn = j - 1;
                                    }
                                    else if (Cromosom2[i + 1, j - 1] > 0 && Cromosom1[i + 1, j - 1] < 0)
                                    {
                                        CromosomRow = i + 1;
                                        CromosomColumn = j - 1;
                                    }
                                    else if (Cromosom2[i - 1, j - 1] > 0 && Cromosom1[i - 1, j - 1] < 0)
                                    {
                                        CromosomRow = i - 1;
                                        CromosomColumn = j - 1;
                                    }
                                    FindNumber++;
                                    AllDraw.SodierConversionOcuured = true;

                                }

                            }
                            else
                                if (Order == -1 && j == 6 && i > 0 && i < 7)
                                {
                                    if (((Cromosom2[i, j + 1] < 0) || (Cromosom2[i + 1, j + 1] < 0 && Cromosom1[i + 1, j + 1] > 0) || (Cromosom2[i - 1, j + 1] < 0 && Cromosom1[i - 1, j + 1] < 0) && Cromosom1[i, j] == -1))
                                    {
                                        CromosomRowFirst = i;
                                        CromosomColumnFirst = j;
                                        if (Cromosom2[i, j + 1] > 0)
                                        {
                                            CromosomRow = i;
                                            CromosomColumn = j + 1;
                                        }
                                        else if (Cromosom2[i + 1, j + 1] > 0 && Cromosom1[i + 1, j + 1] < 0)
                                        {
                                            CromosomRow = i + 1;
                                            CromosomColumn = j + 1;
                                        }
                                        else if (Cromosom2[i - 1, j + 1] > 0 && Cromosom1[i - 1, j + 1] < 0)
                                        {
                                            CromosomRow = i - 1;
                                            CromosomColumn = j + 1;
                                        }
                                        Find = true;
                                        FindNumber++;
                                        AllDraw.SodierConversionOcuured = true;
                                    }
                                }

                            //Bridges King Validity Condition.
                            if (Order == 1 && j == 7)
                            {
                                //Small Gray Bridges King.
                                if (i == 6 && Cromosom2[i, j] == 6 && Cromosom2[i - 1, j] == 4 && Cromosom1[i, j] != 6 && Cromosom1[i - 1, j] != 4)
                                {
                                    CromosomRowFirst = i - 3;
                                    CromosomColumnFirst = j;
                                    CromosomRow = i;
                                    CromosomColumn = j;
                                    Find = true;
                                    FindNumber++;
                                    ChessRules.SmallKingBridgeGray = true;
                                    BridgesKing = true;
                                }
                                else //Big Briges King Gray.
                                    if (i == 2 && Cromosom2[i, j] == 6 && Cromosom2[i + 1, j] == 4 && Cromosom1[i, j] != 6 && Cromosom1[i + 1, j] != 4)
                                    {
                                        CromosomRowFirst = i + 3;
                                        CromosomColumnFirst = j;
                                        CromosomRow = i;
                                        CromosomColumn = j;
                                        Find = true;
                                        FindNumber++;
                                        ChessRules.BigKingBridgeGray = true;
                                        BridgesKing = true;
                                    }

                            }
                            else if (j == 0)
                            {
                                //Small Bridges King Brown.
                                if (i == 6 && Cromosom2[i, j] == -6 && Cromosom2[i - 1, j] == -4 && Cromosom1[i, j] != -6 && Cromosom1[i - 1, j] != -4)
                                {
                                    CromosomRowFirst = i - 3;
                                    CromosomColumnFirst = j;
                                    CromosomRow = i;
                                    CromosomColumn = j;
                                    Find = true;
                                    FindNumber++;
                                    ChessRules.SmallKingBridgeBrown = true;
                                    BridgesKing = true;
                                }
                                else//Big Bridges King Brown.
                                    if (i == 2 && Cromosom2[i, j] == -6 && Cromosom2[i + 1, j] == -4 && Cromosom1[i, j] != -6 && Cromosom1[i + 1, j] != -4)
                                    {
                                        CromosomRowFirst = i + 3;
                                        CromosomColumnFirst = j;
                                        CromosomRow = i;
                                        CromosomColumn = j;
                                        Find = true;
                                        FindNumber++;
                                        ChessRules.BigKingBridgeBrown = true;
                                        BridgesKing = true;
                                    }

                            }

                        }
                    }

                    //When To Same Location Tbles are Different in Gen.
                    if (Cromosom1[i, j] != Cromosom2[i, j])
                    {
                        //When Cromosom 2 is Empty.
                        if (Cromosom2[i, j] == 0)
                        {
                            //Initiate Location of Table.
                            continue;
                        }
                        else
                        {
                            //Situation 1.0
                            if (and)
                            {
                                //When Cromosom1 Current Location is Empty.
                                if (Cromosom1[i, j] == 0)
                                {
                                    //Initiate Location of Gen.
                                    CromosomRow = i;
                                    CromosomColumn = j;
                                    Find = true;
                                    FindNumber++;
                                    continue;
                                }
                            }
                        }
                        //Store Location of Gen and Calculate Gen Numbers.
                        CromosomRow = i;
                        CromosomColumn = j;
                        Find = true;
                        FindNumber++;
                    }
                }
            }
            //If Gen Foundation is Valid. 
            if (((FindNumber == 1 || FindNumber == 2) && Find) || BridgesKing || AllDraw.SodierConversionOcuured)
                return Find;
            //Gen Not Found.
            return false;
        }
    }
}
//End of Documentation.
