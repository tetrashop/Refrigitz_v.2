/***********************************************************************************************
 * Main class of Form Inherited of Form Main in the C#.*****************************************
 * Ramin Edjlal*******************************************************************************RS*****0.12**4**Managements and Cuation Programing**(+)
 * Mouse Event Handling Error*****************************************************************RS*****0.12**4**Managements and Cuation Programing**(+)
 * Some Soldiers Loos Location  And Virutuallization at Click*********************************RS*****0.12**4**Managements and Cuation Programing**(+)
 * Some Codes Lines Frizes********************************************************************RS*****0.12**4**Managements and Cuation Programing**(+)
 * Hit things Abnormal behaviour**************************************************************RS*****0.12**4**Managements and Cuation Programing**(+)
 * Virtualization Things Error****************************************************************RS*****0.12**4**Managements and Cuation Programing**(+)
 * No Reason Logically For Equality of 'SoldierP' and 'Soldier'*******************************RS*****0.12**4**Managements and Cuation Programing**(+)
 * Problem of Sameness of Hit Enemys Solved.No Reason For Equality of 'Soldier' and 'SoldierP'RS--************(-+)
 * No Problem For Hiting**********************************************************************RS*****0.12**4**Managements and Cuation Programing**(+)
 * Castle of Gray Color Conversion to Kings Brown********************************************CU*****0.88**1**Risk Control************************(*)QC-OK.
 * Castle Conversion To King Brown Abnormally no Reasonably**********************************CU*****0.88**1**Risk Control************************(*)
 * Color Conversion In Virtualization Hit Enemy***********************************************RS*****0.12**4**Managements and Cuation Programing**(+)
 * Need To Find Enemy Detection on Current OrderPlate*****************************************RS*****0.12**4**Managements and Cuation Programing**(+)
 * CheckMate an Check Dosn't Work*******************************************************************CU*****0.88**1**Risk Control************************(*)QC-OK.
 * No Movments By Computer********************************************************************RS*****0.12**4**Managements and Cuation Programing**(+)
 * Illegal Virtualization. The Thinking By 'Alice' (My Computer) ChessRules Misleading********RS*****0.12**4**Managements and Cuation Programing**(+)
 * permutative Constant Heuristic Results******************************************************RS*****0.12**4**Managements and Cuation Programing**(+)
 * In Existence of Adding Suported Heuristic Constant Heuristic Result Detection****************RS*****0.12**4**Managements and Cuation Programing**(+)
 * OrderPlate Not Configured******************************************************************RS*****0.12**4**Managements and Cuation Programing**(+)
 * Non Color Hourse Hit Assignment Misleading(Abnormal)***************************************RS*****0.12**4**Managements and Cuation Programing**(+)
 * Undetected Error Table Content Malfunction*************************************************RS*****0.12**4**Managements and Cuation Programing**(+)
 * MalFunction Movments Greate than 5 by 'Alice'.*********************************************RS*****0.12**4**Managements and Cuation Programing**(+)
 * 'Check' Second Time 'Alice' MalFanction*****************************************************RS*****0.12**4**Managements and Cuation Programing**(+)
 * 'Check' 'Alice' Mechnisam Failure***********************************************************RS*****0.12**4**Managements and Cuation Programing**(+)
 '* CheckMate' of Unsatisfied in 'Alice'***********************************************************CU*****0.88**1**Risk Control************************(*)QC-OK.
 * CheckMate Dosn't Recognized.********************************************************************RS*****0.12**4**Managements and Cuation Programing**(+)
 * Virtualization Filed (Not Responding) at Indpencdency State********************************RS*****0.12**4**Managements and Cuation Programing**(+)
 * Unable To Draw Refrigtz.Timer  Content at Tow Picture Box*******************************************RS*****0.12**4**Managements and Cuation Programing**(+)
 * Refrigtz.Timer Working Hardly.**********************************************************************RS*****0.12**4**Managements and Cuation Programing**(+)
 * Dead lock In Drawing Images.***************************************************************RS*****0.12**4**Managements and Cuation Programing**(+)
 * Misleading Thread OrderPlate And Time Sharing**********************************************RS*****0.12**4**Managements and Cuation Programing**(+)
 * Thinkings Taking a lot of Time.************************************************************RS*****0.12**4**Managements and Cuation Programing**(+)
 * AntiVirus Protextion and Existance Caused to Reduce Speed of Thinking and lead to Lose.****RS*****0.12**4**Managements and Cuation Programing**(+)
 * No Programatically Reason For Speed Reduction.*********************************************RS*****0.12**4**Managements and Cuation Programing**(+) 
 * Mybe Windows Filrewall Has no been correctly Arranges to reduce speed.*********************RS*****0.12**4**Managements and Cuation Programing**(+)
 * Method on Leave not Work.******************************************************************CU*****0.88**1**Risk Control************************(*)QC-OK.
 * OrderPlate Reader Table MalFunction.*******************************************************RS*****0.12**4**Managements and Cuation Programing**(+)
 * Wrong Sysntax To Read.*********************************************************************CU*****0.88**1**Risk Control************************(*)QC-OK.
 * Some Tables of Hitting Tow Person Are Missing.*********************************************__**************(_)
 * Some Syntaxes at Table Read Are Missing.***************************************************__**************(_)
 * Chess Refregitz Sometimes Not Responding due to Cpu Power Non Ability.*********************CU*****0.88**1**Risk Control************************(*)QC-OK.
 * Chess Refregitz Sometimes stop working.****************************************************CU*****0.88**1**Risk Control************************(*)QC-OK.
 * 1395/1/16**********************************************************************************CU*****0.88**1**Risk Control************************(*)QC-OK.
 * OrderPlate MalFunction.********************************************************************RS*****0.12**4**Managements and Cuation Programing**{+}
 * Virtualization Error.No Reason For MalFunctionla Operation of Program at Sysntax and Orde.*CU*****0.88**1**Risk Control************************{*}QC-OK.
 * Cause Sensitive Problems of 'Check' And 'CheckMate By 'Alice' is borring at StateCP.*************CU*****0.88**1**Risk Control************************{*}QC-OK.
 * Table Content Misleading.******************************************************************CU*****0.88**1**Risk Control************************(*)QC-OK.
 * Documentation Faulting On Removing Detials.************************************************CU*****0.88**1**Risk Control************************(*)QC-OK.
 * Loading Games  to Continue failed Unreasonly.**********************************************CU*****0.88**1**Risk Control************************<*>QC-OK.
 * "Thread is dead.The state can not be accessed.".*******************************************CU*****0.88**1**Risk Control************************{*}QC-OK.
 * Illegal Syntax Mechanisam Detection By Genetic Algorithm.**********************************CU*****0.88**1**Risk Control************************<*>QC-Ok.
 * 'MaxCurrentMovmentsNumber' Changes Illegal to Reduced.*************************************CU*****0.88**1**Risk Control************************{*}QC-OK.
 * Arranagment Up-Down Changes caused to Born of Some Objects UnSupported Attractively.*******CU*****0.88**1**Risk Control************************(*)QC-OK.
 * Table TableListAction Genetic Algorithm MalFunctionally Illegal Data.**********************CU*****0.88**1**Risk Control************************(*)QC-OK.
 * Castle King Insertion Overllaping Previous Enemy Movments of Person Movments.*************CU*****0.88**1**Risk Control************************(*)QC-OK.
 * Statisticer Loader and Acter Castle King Overview Failed.*********************************CU*****0.88**1**Risk Control************************(*)QC-OK.
 * Castle King Continue With Illegal Movments at Statisticer.********************************CU*****0.88**1**Risk Control************************(*)QC-OK.
 * Calling of All Events From Pressing a Single Button.Mal Function of Database Leading.******CU*****0.88**1**Risk Control************************<*>
 * ***********************************************************************************************************
 * ***********************************************************************************************************
 */


using Chess;
using System;
using System.Data.OleDb;
using System.Diagnostics;
using System.Drawing;
using System.IO;
using System.Media;
using System.Threading;
using System.Threading.Tasks;

[assembly: CLSCompliant(true)]


namespace RefrigtzW
{
    [Serializable]
    //Constructor
    public class FormRefrigtz
    {
        bool FOUND = false;
        int AllDrawKind = 0;
        public AllDraw Draw;
        readonly String path3 = "temp";
        public static String AllDrawReplacement = "";
        bool NotFoundBegin = false;
        public static String AllDrawKindString = "";
        bool Deeperthandeeper = false;

        //Initiate Global Variable.
        //public bool DisableTemporarlyTimerUpdate = false;
        public static double MaxHeuristicx = Double.MinValue;
        public static bool MovementsAStarGreedyHeuristicFound = false;
        public static bool IInoreSelfObjects = false;
        public static bool UsePenaltyRegardMechnisam = true;
        public static bool BestMovments = false;
        public static bool PredictHeuristic = true;
        public static bool OnlySelf = false;
        public static bool AStarGreedyHeuristic = false;
        bool IsPenaltyRegardCanceled = false;
        WebApplicationRefregitzTow._Default ttt = null;
        public static bool LoadPlaceHolder = true;
        public bool PlaceHolderBreak = false;
        public static bool ThinkingA = false;
        public static bool ReadF = false;
        public static OleDbConnection bookConn = null;
        public static OleDbCommand oleDbCmd = new OleDbCommand();
        public static OleDbCommand oleDbCmdUser = new OleDbCommand();
        //#pragma warning disable CS0414 // The field 'FormRefrigtz.BobWithStockfishFinished' is assigned but its value is never used
#pragma warning disable CS0414 // The field 'FormRefrigtz.BobWithStockfishFinished' is assigned but its value is never used
        bool BobWithStockfishFinished = false;
#pragma warning restore CS0414 // The field 'FormRefrigtz.BobWithStockfishFinished' is assigned but its value is never used
        //#pragma warning restore CS0414 // The field 'FormRefrigtz.BobWithStockfishFinished' is assigned but its value is never used
        bool Stockfish = false;
        //#pragma warning disable CS0414 // The field 'FormRefrigtz.RefregitzisCurrent' is assigned but its value is never used
#pragma warning disable CS0414 // The field 'FormRefrigtz.RefregitzisCurrent' is assigned but its value is never used
        bool RefregitzisCurrent = true;
#pragma warning restore CS0414 // The field 'FormRefrigtz.RefregitzisCurrent' is assigned but its value is never used
        //#pragma warning restore CS0414 // The field 'FormRefrigtz.RefregitzisCurrent' is assigned but its value is never used
        bool SettingPRFALSE = false;
        public static bool ProfesionalWithComputer = false;
        public bool TimersSet = true;
        public static bool GameStarted = false;
        public static bool ArrangmentsChanged = true;
        public static int MaxCurrentMovmentsNumber = 1;
        public static bool ErrorTrueMonitorFalse = true;
        //#pragma warning disable CS0414 // The field 'FormRefrigtz.tM' is assigned but its value is never used
#pragma warning disable CS0414 // The field 'FormRefrigtz.tM' is assigned but its value is never used
        Thread tM = null;
#pragma warning restore CS0414 // The field 'FormRefrigtz.tM' is assigned but its value is never used
        //#pragma warning restore CS0414 // The field 'FormRefrigtz.tM' is assigned but its value is never used
        bool Clicked = true;
        public static int MaxAStarGreedyHeuristicProgress = 0;
        public static String Root = System.Web.HttpRuntime.AppDomainAppPath;
        public bool MouseClicked = false;
        public static bool Blitz = false;
        //#pragma warning disable CS0414 // The field 'FormRefrigtz.LoadAG' is assigned but its value is never used
#pragma warning disable CS0414 // The field 'FormRefrigtz.LoadAG' is assigned but its value is never used
        static bool LoadAG = false;
#pragma warning restore CS0414 // The field 'FormRefrigtz.LoadAG' is assigned but its value is never used
        //#pragma warning restore CS0414 // The field 'FormRefrigtz.LoadAG' is assigned but its value is never used
        //#pragma warning disable CS0414 // The field 'FormRefrigtz._1' is assigned but its value is never used
#pragma warning disable CS0414 // The field 'FormRefrigtz._1' is assigned but its value is never used
        static bool _1 = false;
#pragma warning restore CS0414 // The field 'FormRefrigtz._1' is assigned but its value is never used
        //#pragma warning restore CS0414 // The field 'FormRefrigtz._1' is assigned but its value is never used
        //#pragma warning disable CS0414 // The field 'FormRefrigtz._2' is assigned but its value is never used
#pragma warning disable CS0414 // The field 'FormRefrigtz._2' is assigned but its value is never used
        static bool _2 = false;
#pragma warning restore CS0414 // The field 'FormRefrigtz._2' is assigned but its value is never used
        //#pragma warning restore CS0414 // The field 'FormRefrigtz._2' is assigned but its value is never used
        //#pragma warning disable CS0414 // The field 'FormRefrigtz._3' is assigned but its value is never used
#pragma warning disable CS0414 // The field 'FormRefrigtz._3' is assigned but its value is never used
        static bool _3 = false;
#pragma warning restore CS0414 // The field 'FormRefrigtz._3' is assigned but its value is never used
        //#pragma warning restore CS0414 // The field 'FormRefrigtz._3' is assigned but its value is never used
        //#pragma warning disable CS0414 // The field 'FormRefrigtz._4' is assigned but its value is never used
#pragma warning disable CS0414 // The field 'FormRefrigtz._4' is assigned but its value is never used
        static bool _4 = false;
#pragma warning restore CS0414 // The field 'FormRefrigtz._4' is assigned but its value is never used
        //#pragma warning restore CS0414 // The field 'FormRefrigtz._4' is assigned but its value is never used
        //#pragma warning disable CS0414 // The field 'FormRefrigtz.Hideag' is assigned but its value is never used
#pragma warning disable CS0414 // The field 'FormRefrigtz.Hideag' is assigned but its value is never used
        static bool Hideag = false;
#pragma warning restore CS0414 // The field 'FormRefrigtz.Hideag' is assigned but its value is never used
        //#pragma warning restore CS0414 // The field 'FormRefrigtz.Hideag' is assigned but its value is never used
        //#pragma warning disable CS0414 // The field 'FormRefrigtz.exit' is assigned but its value is never used
#pragma warning disable CS0414 // The field 'FormRefrigtz.exit' is assigned but its value is never used
        bool exit = false;
#pragma warning restore CS0414 // The field 'FormRefrigtz.exit' is assigned but its value is never used
        //#pragma warning restore CS0414 // The field 'FormRefrigtz.exit' is assigned but its value is never used
        bool AllDrawLoad = false;
        //#pragma warning disable CS0414 // The field 'FormRefrigtz.AllOperate' is assigned but its value is never used
#pragma warning disable CS0414 // The field 'FormRefrigtz.AllOperate' is assigned but its value is never used
        Thread AllOperate = null;
#pragma warning restore CS0414 // The field 'FormRefrigtz.AllOperate' is assigned but its value is never used
        //#pragma warning restore CS0414 // The field 'FormRefrigtz.AllOperate' is assigned but its value is never used
        //#pragma warning disable CS0414 // The field 'FormRefrigtz.Paused' is assigned but its value is never used
#pragma warning disable CS0414 // The field 'FormRefrigtz.Paused' is assigned but its value is never used
        static bool Paused = false;
#pragma warning restore CS0414 // The field 'FormRefrigtz.Paused' is assigned but its value is never used
        //#pragma warning restore CS0414 // The field 'FormRefrigtz.Paused' is assigned but its value is never used
        //#pragma warning disable CS0414 // The field 'FormRefrigtz.UpdateConfigurationTableVal' is assigned but its value is never used
#pragma warning disable CS0414 // The field 'FormRefrigtz.UpdateConfigurationTableVal' is assigned but its value is never used
        static bool UpdateConfigurationTableVal = false;
#pragma warning restore CS0414 // The field 'FormRefrigtz.UpdateConfigurationTableVal' is assigned but its value is never used
        //#pragma warning restore CS0414 // The field 'FormRefrigtz.UpdateConfigurationTableVal' is assigned but its value is never used
        //#pragma warning disable CS0414 // The field 'FormRefrigtz.NewTable' is assigned but its value is never used
#pragma warning disable CS0414 // The field 'FormRefrigtz.NewTable' is assigned but its value is never used
        static bool NewTable = false;
#pragma warning restore CS0414 // The field 'FormRefrigtz.NewTable' is assigned but its value is never used
        //#pragma warning restore CS0414 // The field 'FormRefrigtz.NewTable' is assigned but its value is never used
        //#pragma warning disable CS0414 // The field 'FormRefrigtz.TimerImage' is assigned but its value is never used
#pragma warning disable CS0414 // The field 'FormRefrigtz.TimerImage' is assigned but its value is never used
        Image TimerImage = null;
#pragma warning restore CS0414 // The field 'FormRefrigtz.TimerImage' is assigned but its value is never used
        //#pragma warning restore CS0414 // The field 'FormRefrigtz.TimerImage' is assigned but its value is never used
        //#pragma warning disable CS0414 // The field 'FormRefrigtz.g1' is assigned but its value is never used
#pragma warning disable CS0414 // The field 'FormRefrigtz.g1' is assigned but its value is never used
        Graphics g1 = null;
#pragma warning restore CS0414 // The field 'FormRefrigtz.g1' is assigned but its value is never used
        //#pragma warning restore CS0414 // The field 'FormRefrigtz.g1' is assigned but its value is never used
        //#pragma warning disable CS0414 // The field 'FormRefrigtz.TimerImage1' is assigned but its value is never used
#pragma warning disable CS0414 // The field 'FormRefrigtz.TimerImage1' is assigned but its value is never used
        Image TimerImage1 = null;
#pragma warning restore CS0414 // The field 'FormRefrigtz.TimerImage1' is assigned but its value is never used
        //#pragma warning restore CS0414 // The field 'FormRefrigtz.TimerImage1' is assigned but its value is never used
        //#pragma warning disable CS0414 // The field 'FormRefrigtz.g2' is assigned but its value is never used
#pragma warning disable CS0414 // The field 'FormRefrigtz.g2' is assigned but its value is never used
        Graphics g2 = null;
#pragma warning restore CS0414 // The field 'FormRefrigtz.g2' is assigned but its value is never used
        //#pragma warning restore CS0414 // The field 'FormRefrigtz.g2' is assigned but its value is never used
        //#pragma warning disable CS0414 // The field 'FormRefrigtz.g' is assigned but its value is never used
#pragma warning disable CS0414 // The field 'FormRefrigtz.g' is assigned but its value is never used
        Graphics g = null;
#pragma warning restore CS0414 // The field 'FormRefrigtz.g' is assigned but its value is never used
        //#pragma warning restore CS0414 // The field 'FormRefrigtz.g' is assigned but its value is never used
        //#pragma warning disable CS0414 // The field 'FormRefrigtz.ChessTable' is assigned but its value is never used
#pragma warning disable CS0414 // The field 'FormRefrigtz.ChessTable' is assigned but its value is never used
        Image ChessTable = null;
#pragma warning restore CS0414 // The field 'FormRefrigtz.ChessTable' is assigned but its value is never used
        //#pragma warning restore CS0414 // The field 'FormRefrigtz.ChessTable' is assigned but its value is never used
        public static int LastRowQ = -1;
        public static int LastColumn = -1;
        Thread t1 = null;
        //#pragma warning disable CS0414 // The field 'FormRefrigtz.t2' is assigned but its value is never used
#pragma warning disable CS0414 // The field 'FormRefrigtz.t2' is assigned but its value is never used
        Thread t2 = null;
#pragma warning restore CS0414 // The field 'FormRefrigtz.t2' is assigned but its value is never used
        //#pragma warning restore CS0414 // The field 'FormRefrigtz.t2' is assigned but its value is never used
        //#pragma warning disable CS0414 // The field 'FormRefrigtz.t3' is assigned but its value is never used
#pragma warning disable CS0414 // The field 'FormRefrigtz.t3' is assigned but its value is never used
        Thread t3 = null;
#pragma warning restore CS0414 // The field 'FormRefrigtz.t3' is assigned but its value is never used
        //#pragma warning restore CS0414 // The field 'FormRefrigtz.t3' is assigned but its value is never used
        //#pragma warning disable CS0414 // The field 'FormRefrigtz.t4' is assigned but its value is never used
#pragma warning disable CS0414 // The field 'FormRefrigtz.t4' is assigned but its value is never used
        Thread t4 = null;
#pragma warning restore CS0414 // The field 'FormRefrigtz.t4' is assigned but its value is never used
        //#pragma warning restore CS0414 // The field 'FormRefrigtz.t4' is assigned but its value is never used
        Thread TTimerSet;
        public static bool LoadedTable = false;
        //#pragma warning disable CS0414 // The field 'FormRefrigtz.GrayWinner' is assigned but its value is never used
#pragma warning disable CS0414 // The field 'FormRefrigtz.GrayWinner' is assigned but its value is never used
        bool GrayWinner = false;
#pragma warning restore CS0414 // The field 'FormRefrigtz.GrayWinner' is assigned but its value is never used
        //#pragma warning restore CS0414 // The field 'FormRefrigtz.GrayWinner' is assigned but its value is never used
        //#pragma warning disable CS0414 // The field 'FormRefrigtz.BrownWiner' is assigned but its value is never used
#pragma warning disable CS0414 // The field 'FormRefrigtz.BrownWiner' is assigned but its value is never used
        bool BrownWiner = false;
#pragma warning restore CS0414 // The field 'FormRefrigtz.BrownWiner' is assigned but its value is never used
        //#pragma warning restore CS0414 // The field 'FormRefrigtz.BrownWiner' is assigned but its value is never used
        public Refrigtz.Timer TimerText = null;
        public Refrigtz.Timer GrayTimer = null;
        public Refrigtz.Timer BrownTimer = null;
        public static int MovmentsNumber = 0;
        public static bool EndOfGame = false;
        //#pragma warning disable CS0414 // The field 'FormRefrigtz.Maximize' is assigned but its value is never used
#pragma warning disable CS0414 // The field 'FormRefrigtz.Maximize' is assigned but its value is never used
        bool Maximize = false;
#pragma warning restore CS0414 // The field 'FormRefrigtz.Maximize' is assigned but its value is never used
        //#pragma warning restore CS0414 // The field 'FormRefrigtz.Maximize' is assigned but its value is never used
        //#pragma warning disable CS0414 // The field 'FormRefrigtz.RowS' is assigned but its value is never used
        //#pragma warning disable CS0414 // The field 'FormRefrigtz.ColS' is assigned but its value is never used
        //#pragma warning disable CS0414 // The field 'FormRefrigtz.ColP' is assigned but its value is never used
        //#pragma warning disable CS0414 // The field 'FormRefrigtz.RowP' is assigned but its value is never used
#pragma warning disable CS0414 // The field 'FormRefrigtz.ColP' is assigned but its value is never used
#pragma warning disable CS0414 // The field 'FormRefrigtz.RowP' is assigned but its value is never used
#pragma warning disable CS0414 // The field 'FormRefrigtz.RowS' is assigned but its value is never used
#pragma warning disable CS0414 // The field 'FormRefrigtz.ColS' is assigned but its value is never used
        static int RowP = 0, ColP = 0, RowS = 0, ColS = 0;
#pragma warning restore CS0414 // The field 'FormRefrigtz.ColS' is assigned but its value is never used
#pragma warning restore CS0414 // The field 'FormRefrigtz.RowS' is assigned but its value is never used
#pragma warning restore CS0414 // The field 'FormRefrigtz.RowP' is assigned but its value is never used
#pragma warning restore CS0414 // The field 'FormRefrigtz.ColP' is assigned but its value is never used
        //#pragma warning restore CS0414 // The field 'FormRefrigtz.RowP' is assigned but its value is never used
        //#pragma warning restore CS0414 // The field 'FormRefrigtz.ColP' is assigned but its value is never used
        //#pragma warning restore CS0414 // The field 'FormRefrigtz.ColS' is assigned but its value is never used
        //#pragma warning restore CS0414 // The field 'FormRefrigtz.RowS' is assigned but its value is never used
        bool BobSection = true;
        bool AliceSection = false;
        public static bool Person = true;
        //#pragma warning disable CS0414 // The field 'FormRefrigtz.CurrentKind' is assigned but its value is never used
#pragma warning disable CS0414 // The field 'FormRefrigtz.CurrentKind' is assigned but its value is never used
        static int CurrentKind = 0;
#pragma warning restore CS0414 // The field 'FormRefrigtz.CurrentKind' is assigned but its value is never used
        //#pragma warning restore CS0414 // The field 'FormRefrigtz.CurrentKind' is assigned but its value is never used
        public static bool StateCC = false;//Computer With Computer
        public static bool StateCP = false;//Person With Computer
        public static bool StateGe = false;//For Genetic Games.
        public static int OrderPlate = 1;
        // int AllDraw.MouseClick;
        float RowClickP = -1, ColumnClickP = -1;
        //#pragma warning disable CS0414 // The field 'FormRefrigtz.RowClick' is assigned but its value is never used
        //#pragma warning disable CS0414 // The field 'FormRefrigtz.ColumnClick' is assigned but its value is never used
#pragma warning disable CS0414 // The field 'FormRefrigtz.RowClick' is assigned but its value is never used
#pragma warning disable CS0414 // The field 'FormRefrigtz.ColumnClick' is assigned but its value is never used
        int RowClick = -1, ColumnClick = -1;
#pragma warning restore CS0414 // The field 'FormRefrigtz.ColumnClick' is assigned but its value is never used
#pragma warning restore CS0414 // The field 'FormRefrigtz.RowClick' is assigned but its value is never used
        //#pragma warning restore CS0414 // The field 'FormRefrigtz.ColumnClick' is assigned but its value is never used
        //#pragma warning restore CS0414 // The field 'FormRefrigtz.RowClick' is assigned but its value is never used
        //#pragma warning disable CS0414 // The field 'FormRefrigtz.ColumnRealeasedP' is assigned but its value is never used
        //#pragma warning disable CS0414 // The field 'FormRefrigtz.RowRealesedP' is assigned but its value is never used
#pragma warning disable CS0414 // The field 'FormRefrigtz.RowRealesedP' is assigned but its value is never used
#pragma warning disable CS0414 // The field 'FormRefrigtz.ColumnRealeasedP' is assigned but its value is never used
        float RowRealesedP = -1, ColumnRealeasedP = -1;
#pragma warning restore CS0414 // The field 'FormRefrigtz.ColumnRealeasedP' is assigned but its value is never used
#pragma warning restore CS0414 // The field 'FormRefrigtz.RowRealesedP' is assigned but its value is never used
        //#pragma warning restore CS0414 // The field 'FormRefrigtz.RowRealesedP' is assigned but its value is never used
        //#pragma warning restore CS0414 // The field 'FormRefrigtz.ColumnRealeasedP' is assigned but its value is never used
        //#pragma warning disable CS0414 // The field 'FormRefrigtz.RowRealesed' is assigned but its value is never used
        //#pragma warning disable CS0414 // The field 'FormRefrigtz.ColumnRealeased' is assigned but its value is never used
#pragma warning disable CS0414 // The field 'FormRefrigtz.ColumnRealeased' is assigned but its value is never used
#pragma warning disable CS0414 // The field 'FormRefrigtz.RowRealesed' is assigned but its value is never used
        float RowRealesed = -1, ColumnRealeased = -1;
#pragma warning restore CS0414 // The field 'FormRefrigtz.RowRealesed' is assigned but its value is never used
#pragma warning restore CS0414 // The field 'FormRefrigtz.ColumnRealeased' is assigned but its value is never used
        //#pragma warning restore CS0414 // The field 'FormRefrigtz.ColumnRealeased' is assigned but its value is never used
        //#pragma warning restore CS0414 // The field 'FormRefrigtz.RowRealesed' is assigned but its value is never used
        public static int[,] Table = new int[8, 8];
        FormRefrigtz THIs = null;
        String connParam = "Provider=Microsoft.ACE.OLEDB.12.0;Data Source=" + Root + "Database\\CurrentBank.accdb;;Persist Security Info=False; Jet OLEDB:Database Password='!HN#BGHHN&N$G$V4'";
        //Error Handling.
        static void Log(Exception ex)
        {
            try
            {
                Object a = new Object();
                lock (a)
                {
                    string stackTrace = ex.ToString();
                    File.AppendAllText(Root + "\\ErrorProgramRun.txt", stackTrace + ": On" + DateTime.Now.ToString()); // path of file where stack trace will be stored.
                }
            }
            catch (Exception t) { Log(t); }
        }
        //Constructor No2
        public FormRefrigtz(bool AllDra)
        {

            AllDrawLoad = AllDra;

            if (!AllDrawLoad)
            {

                t1 = new Thread(new ThreadStart(AliceWithPerson));

            }


            THIs = this;
            Draw = new AllDraw(OrderPlate, MovementsAStarGreedyHeuristicFound, IInoreSelfObjects, UsePenaltyRegardMechnisam, BestMovments, PredictHeuristic, OnlySelf, AStarGreedyHeuristic, ArrangmentsChanged);

            if (!AllDrawLoad)
            {
                BrownTimer = new Refrigtz.Timer(false);
                GrayTimer = new Refrigtz.Timer(false);
                TimerText = new Refrigtz.Timer(true);

                BrownTimer.TimerInitiate();
                GrayTimer.TimerInitiate();
                TTimerSet = new Thread(new ThreadStart(SetTimer));
                TTimerSet.Start();

                TimerText.TimerInitiate();

                TimerText.StartTime();
            }

            if (!AllDrawLoad)
            {
                for (int i = 0; i < 8; i++)
                    for (int j = 0; j < 8; j++)
                    {
                        Table[i, j] = 0;
                    }

                for (int i = 0; i < 8; i++)
                    Table[i, 1] = 1;

                for (int i = 8; i < 16; i++)
                    Table[i - 8, 6] = -1;
                Table[2, 0] = 2;
                Table[5, 0] = 2;
                Table[2, 7] = -2;
                Table[5, 7] = -2;

                Table[1, 0] = 3;
                Table[6, 0] = 3;
                Table[1, 7] = -3;
                Table[6, 7] = -3;

                Table[0, 0] = 4;
                Table[0, 0] = 4;
                Table[0, 7] = -4;
                Table[7, 7] = -4;

                Table[3, 0] = 6;
                Table[3, 7] = -6;

                Table[4, 0] = 5;
                Table[0, 0] = -5;
            }
            for (int i = 0; i < 8; i++)
                for (int j = 0; j < 8; j++)
                {
                    AllDraw.TableVeryfy[i, j] = Table[i, j];
                    AllDraw.TableVeryfyConst[i, j] = Table[i, j];
                }
            if (!AllDrawLoad)
            {
                AllDraw.TableListAction.Add(Table);
            }
            Draw.TableList.Clear();
            Draw.TableList.Add(CloneATable(Table));
            Draw.SetRowColumn(0);
            /*for (int i = 0; i < 8; i++)
            {
                Draw.SolderesOnTable[i] = new DrawSoldier(0,MovementsAStarGreedyHeuristicFound,IInoreSelfObjects,UsePenaltyRegardMechnisam,BestMovments,PredictHeuristic,OnlySelf,AStarGreedyHeuristic,ArrangmentsChanged,i, 1, Color.Gray, CloneATable(Table), 1, false, i);
            }
            for (int i = 8; i < 16; i++)
            {
                Draw.SolderesOnTable[i] = new DrawSoldier(0,MovementsAStarGreedyHeuristicFound,IInoreSelfObjects,UsePenaltyRegardMechnisam,BestMovments,PredictHeuristic,OnlySelf,AStarGreedyHeuristic,ArrangmentsChanged,i - 8, 6, Color.Brown, CloneATable(Table), -1, false, i);
            }
            Draw.ElephantOnTable[0] = new DrawElefant(0,MovementsAStarGreedyHeuristicFound,IInoreSelfObjects,UsePenaltyRegardMechnisam,BestMovments,PredictHeuristic,OnlySelf,AStarGreedyHeuristic,ArrangmentsChanged,2, 0, Color.Gray, CloneATable(Table), 1, false, 0);
            Draw.ElephantOnTable[1] = new DrawElefant(0,MovementsAStarGreedyHeuristicFound,IInoreSelfObjects,UsePenaltyRegardMechnisam,BestMovments,PredictHeuristic,OnlySelf,AStarGreedyHeuristic,ArrangmentsChanged,5, 0, Color.Gray, CloneATable(Table), 1, false, 1);
            Draw.ElephantOnTable[2] = new DrawElefant(0,MovementsAStarGreedyHeuristicFound,IInoreSelfObjects,UsePenaltyRegardMechnisam,BestMovments,PredictHeuristic,OnlySelf,AStarGreedyHeuristic,ArrangmentsChanged,2, 7, Color.Brown, CloneATable(Table), -1, false, 2);
            Draw.ElephantOnTable[3] = new DrawElefant(0,MovementsAStarGreedyHeuristicFound,IInoreSelfObjects,UsePenaltyRegardMechnisam,BestMovments,PredictHeuristic,OnlySelf,AStarGreedyHeuristic,ArrangmentsChanged,5, 7, Color.Brown, CloneATable(Table), -1, false, 3);

            Draw.HoursesOnTable[0] = new DrawHourse(0,MovementsAStarGreedyHeuristicFound,IInoreSelfObjects,UsePenaltyRegardMechnisam,BestMovments,PredictHeuristic,OnlySelf,AStarGreedyHeuristic,ArrangmentsChanged,1, 0, Color.Gray, CloneATable(Table), 1, false, 0);
            Draw.HoursesOnTable[1] = new DrawHourse(0,MovementsAStarGreedyHeuristicFound,IInoreSelfObjects,UsePenaltyRegardMechnisam,BestMovments,PredictHeuristic,OnlySelf,AStarGreedyHeuristic,ArrangmentsChanged,6, 0, Color.Gray, CloneATable(Table), 1, false, 1);
            Draw.HoursesOnTable[2] = new DrawHourse(0,MovementsAStarGreedyHeuristicFound,IInoreSelfObjects,UsePenaltyRegardMechnisam,BestMovments,PredictHeuristic,OnlySelf,AStarGreedyHeuristic,ArrangmentsChanged,1, 7, Color.Brown, CloneATable(Table), -1, false, 2);
            Draw.HoursesOnTable[3] = new DrawHourse(0,MovementsAStarGreedyHeuristicFound,IInoreSelfObjects,UsePenaltyRegardMechnisam,BestMovments,PredictHeuristic,OnlySelf,AStarGreedyHeuristic,ArrangmentsChanged,6, 7, Color.Brown, CloneATable(Table), -1, false, 3);

            Draw.CastlesOnTable[0] = new DrawCastle(0,MovementsAStarGreedyHeuristicFound,IInoreSelfObjects,UsePenaltyRegardMechnisam,BestMovments,PredictHeuristic,OnlySelf,AStarGreedyHeuristic,ArrangmentsChanged,0, 0, Color.Gray, CloneATable(Table), 1, false, 0);
            Draw.CastlesOnTable[1] = new DrawCastle(0,MovementsAStarGreedyHeuristicFound,IInoreSelfObjects,UsePenaltyRegardMechnisam,BestMovments,PredictHeuristic,OnlySelf,AStarGreedyHeuristic,ArrangmentsChanged,7, 0, Color.Gray, CloneATable(Table), 1, false, 1);
            Draw.CastlesOnTable[2] = new DrawCastle(0,MovementsAStarGreedyHeuristicFound,IInoreSelfObjects,UsePenaltyRegardMechnisam,BestMovments,PredictHeuristic,OnlySelf,AStarGreedyHeuristic,ArrangmentsChanged,0, 7, Color.Brown, CloneATable(Table), -1, false, 2);
            Draw.CastlesOnTable[3] = new DrawCastle(0,MovementsAStarGreedyHeuristicFound,IInoreSelfObjects,UsePenaltyRegardMechnisam,BestMovments,PredictHeuristic,OnlySelf,AStarGreedyHeuristic,ArrangmentsChanged,7, 7, Color.Brown, CloneATable(Table), -1, false, 3);

            Draw.if (KingOnTable==null||KingOnTable[i] == null)[0] = new DrawKing(0,MovementsAStarGreedyHeuristicFound,IInoreSelfObjects,UsePenaltyRegardMechnisam,BestMovments,PredictHeuristic,OnlySelf,AStarGreedyHeuristic,ArrangmentsChanged,3, 0, Color.Gray, CloneATable(Table), 1, false, 0);
            Draw.if (KingOnTable==null||KingOnTable[i] == null)[1] = new DrawKing(0,MovementsAStarGreedyHeuristicFound,IInoreSelfObjects,UsePenaltyRegardMechnisam,BestMovments,PredictHeuristic,OnlySelf,AStarGreedyHeuristic,ArrangmentsChanged,3, 7, Color.Brown, CloneATable(Table), -1, false, 1);

            Draw.MinisterOnTable[0] = new DrawMinister(0,MovementsAStarGreedyHeuristicFound,IInoreSelfObjects,UsePenaltyRegardMechnisam,BestMovments,PredictHeuristic,OnlySelf,AStarGreedyHeuristic,ArrangmentsChanged,4, 0, Color.Gray, CloneATable(Table), 1, false, 0);
            Draw.MinisterOnTable[1] = new DrawMinister(0,MovementsAStarGreedyHeuristicFound,IInoreSelfObjects,UsePenaltyRegardMechnisam,BestMovments,PredictHeuristic,OnlySelf,AStarGreedyHeuristic,ArrangmentsChanged,4, 7, Color.Brown, CloneATable(Table), -1, false, 1);
            */

            AllDraw.TableListAction.Add(Table);
            if (WebApplicationRefregitzTow._Default.First && MovmentsNumber == 0)
            {
                for (int i = 0; i < 8; i++)
                    for (int j = 0; j < 8; j++)
                        Table[i, j] *= -1;
            }
            RefrigtzW.ThinkingRefrigtzW.LearniningTable = new RefrigtzW.NetworkQuantumLearningKrinskyAtamata(8, 8, 8);
            Draw.TableList.Clear();
            Draw.TableList.Add(CloneATable(Table));
            Draw.SetRowColumn(0);
            //TakeRoot.CalculateRootGray(Draw);
        }
        //Acccess Point
        public AllDraw AccessDraw
        {
            get { return Draw; }
            set { Draw = value; }

        }
        //Syncronization Between Class Dlls.
        private void SetTimer()
        {
            do
            {
                //while (!StateCC && !StateCP && !StateGe)

                Refrigtz.Timer.AStarGreadyFirstSearch = AllDraw.AStarGreadyFirstSearch;
                Refrigtz.Timer.AStarGreedytiLevelMax = AllDraw.AStarGreedyiLevelMax;
                Refrigtz.Timer.UseDoubleTime = AllDraw.UseDoubleTime;
                Refrigtz.Timer.StoreAllDrawCount = AllDraw.StoreADraw.Count;
            }
            while (true);

        }

        //Boolean Setting of Illustration at Slected Object Rules.
        bool[,] VeryFye(int[,] Table, int Order, Color a)
        {
            int Cdummy = ChessRules.CurrentOrder;
            if (OrderPlate == 1)
                ChessRules.CurrentOrder = 1;
            else
                ChessRules.CurrentOrder = -1;
            bool[,] Tab = new bool[8, 8];
            for (int i = 0; i < 8; i++)
                for (int j = 0; j < 8; j++)
                {
                    if ((new ChessRules(0, MovementsAStarGreedyHeuristicFound, IInoreSelfObjects, UsePenaltyRegardMechnisam, BestMovments, PredictHeuristic, OnlySelf, AStarGreedyHeuristic, ArrangmentsChanged, Table[(int)RowClickP, (int)ColumnClickP], CloneATable(Table), Order, (int)RowClickP, (int)ColumnClickP)).Rules((int)RowClickP, (int)ColumnClickP, i, j, a, Table[(int)RowClickP, (int)ColumnClickP]))
                    {
                        Tab[i, j] = true;
                    }
                }
            ChessRules.CurrentOrder = Cdummy;
            return Tab;
        }
        //Load Refregitz Form.
        //Reading Table Database.
        int[,] ReadTable(int Movment, ref int MoveNumber)
        {

            ChessRules.CastleActBrown = false;
            //bool OneIncreament = false;
            int[,] Tab = Table;
            int Move = 0;
            AllDraw.TableListAction.Clear();
            do
            {
                Again:
                try
                {

                    bookConn = new OleDbConnection(connParam);
                    bookConn.Open();
                    oleDbCmd.Connection = bookConn;


                    String TableName = Move.ToString();
                    String Zero = "Table";
                    for (int i = 0; i < 8 - TableName.Length; i++)
                        Zero += "0";
                    TableName = Zero + TableName;

                    oleDbCmd.CommandText = "Select * From " + TableName;
                    OleDbDataReader dr = null;
                    dr = oleDbCmd.ExecuteReader();
                    int ii = 0;
                    while (dr.Read())
                    {
                        Tab[0, ii] = System.Convert.ToInt32(dr["a"]);
                        Tab[1, ii] = System.Convert.ToInt32(dr["b"]);
                        Tab[2, ii] = System.Convert.ToInt32(dr["c"]);
                        Tab[3, ii] = System.Convert.ToInt32(dr["d"]);
                        Tab[4, ii] = System.Convert.ToInt32(dr["e"]);
                        Tab[5, ii] = System.Convert.ToInt32(dr["f"]);
                        Tab[6, ii] = System.Convert.ToInt32(dr["g"]);
                        Tab[7, ii] = System.Convert.ToInt32(dr["h"]);
                        ii++;
                    }
                    int[,] TableA = new int[8, 8];
                    for (int i = 0; i < 8; i++)
                        for (int j = 0; j < 8; j++)
                            TableA[i, j] = Tab[i, j];
                    MaxCurrentMovmentsNumber++;
                    AllDraw.TableListAction.Add(TableA);

                    if (AllDraw.TableListAction.Count > 1)
                    {
                        ChessGeneticAlgorithm R = new ChessGeneticAlgorithm(MovementsAStarGreedyHeuristicFound, IInoreSelfObjects, UsePenaltyRegardMechnisam, BestMovments, PredictHeuristic, OnlySelf, AStarGreedyHeuristic, ArrangmentsChanged);
                        if (R.FindGenToModified(AllDraw.TableListAction[AllDraw.TableListAction.Count - 2], AllDraw.TableListAction[AllDraw.TableListAction.Count - 1], AllDraw.TableListAction, 0, OrderPlate, true))
                        {
                            bool HitVal = false;
                            int Hit = AllDraw.TableListAction[AllDraw.TableListAction.Count - 2][R.CromosomRow, R.CromosomColumn];
                            if (Hit != 0)
                                HitVal = true;
                            bool Convert = false;
                            if (OrderPlate == 1)
                            {
                                if (AllDraw.TableListAction[AllDraw.TableListAction.Count - 1][R.CromosomRow, R.CromosomColumn] == 1)
                                {
                                    if (R.CromosomColumn == 7)
                                        Convert = true;
                                }
                                if ((ChessRules.SmallKingCastleGray || ChessRules.BigKingCastleGray) && (!ChessRules.CastleActGray))
                                    ChessRules.CastleActGray = true;
                                AllDraw.SyntaxToWrite = (new ChessRules(0, MovementsAStarGreedyHeuristicFound, IInoreSelfObjects, UsePenaltyRegardMechnisam, BestMovments, PredictHeuristic, OnlySelf, AStarGreedyHeuristic, ArrangmentsChanged, OrderPlate)).CreateStatistic(ArrangmentsChanged, TableA, MoveNumber + 1, AllDraw.TableListAction[AllDraw.TableListAction.Count - 2][R.CromosomRowFirst, R.CromosomColumnFirst], R.CromosomColumn, R.CromosomRow, HitVal, Hit, ChessRules.CastleActGray, Convert);
                            }
                            else
                            {
                                if (AllDraw.TableListAction[AllDraw.TableListAction.Count - 1][R.CromosomRow, R.CromosomColumn] == -1)
                                {
                                    if (R.CromosomColumn == 0)
                                        Convert = true;
                                }
                                if ((ChessRules.SmallKingCastleBrown || ChessRules.BigKingCastleBrown) && (!ChessRules.CastleActBrown))
                                    ChessRules.CastleActBrown = true;

                                AllDraw.SyntaxToWrite = (new ChessRules(0, MovementsAStarGreedyHeuristicFound, IInoreSelfObjects, UsePenaltyRegardMechnisam, BestMovments, PredictHeuristic, OnlySelf, AStarGreedyHeuristic, ArrangmentsChanged, OrderPlate)).CreateStatistic(ArrangmentsChanged, TableA, MoveNumber + 1, AllDraw.TableListAction[AllDraw.TableListAction.Count - 2][R.CromosomRowFirst, R.CromosomColumnFirst], R.CromosomColumn, R.CromosomRow, HitVal, Hit, ChessRules.CastleActBrown, Convert);
                            }

                        }
                    }


                    //Move++;
                    //if (Move > 2)
                    //GameStarted = true;
                    //if (Move > 1)
                    //MoveNumber++;

                    for (int i = 0; i < 8; i++)
                        for (int j = 0; j < 8; j++)
                            TableA[i, j] = Tab[i, j];


                    bookConn.Close();
                    bookConn.Dispose();
                    oleDbCmd.Dispose();

                    if (Move > 0)
                        OrderPlate *= -1;
                    if ((new ChessRules(0, MovementsAStarGreedyHeuristicFound, IInoreSelfObjects, UsePenaltyRegardMechnisam, BestMovments, PredictHeuristic, OnlySelf, AStarGreedyHeuristic, ArrangmentsChanged, 1, TableA, OrderPlate, -1, -1).CheckMate(TableA, OrderPlate)))
                    {
                        int iii = 0;
                        do { iii++; } while (System.IO.File.Exists(Root + "\\Database\\Games\\CurrentBank" + iii.ToString() + ".accdb"));
                        System.IO.File.Copy(Root + "\\Database\\CurrentBank.accdb", "Database\\Games\\CurrentBank" + iii.ToString() + ".accdb");
                        System.IO.File.Delete(Root + "\\Database\\CurrentBank.accdb");
                        break;

                    }
                }
                catch (Exception t)
                {
                    if (Stockfish)
                    {
                        goto Again;
                    }
                    Log(t);
                    try
                    {



                        bookConn.Close();
                        bookConn.Dispose();
                        oleDbCmd.Dispose();
                        bookConn = new OleDbConnection(connParam);

                        bookConn.Open();
                        oleDbCmd = new OleDbCommand();
                        oleDbCmd.Connection = bookConn;

                        String TableName = (Move).ToString();
                        String Zero = "Table";
                        for (int i = 0; i < 8 - TableName.Length; i++)
                            Zero += "0";
                        TableName = Zero + TableName;

                        oleDbCmd.CommandText = "Select * From " + TableName;
                        OleDbDataReader dr = null;
                        dr = oleDbCmd.ExecuteReader();
                        int ii = 0;
                        while (dr.Read())
                        {
                            Tab[0, ii] = System.Convert.ToInt32(dr["a"]);
                            Tab[1, ii] = System.Convert.ToInt32(dr["b"]);
                            Tab[2, ii] = System.Convert.ToInt32(dr["c"]);
                            Tab[3, ii] = System.Convert.ToInt32(dr["d"]);
                            Tab[4, ii] = System.Convert.ToInt32(dr["e"]);
                            Tab[5, ii] = System.Convert.ToInt32(dr["f"]);
                            Tab[6, ii] = System.Convert.ToInt32(dr["g"]);
                            Tab[7, ii] = System.Convert.ToInt32(dr["h"]);
                            ii++;
                        }
                        int[,] TableA = new int[8, 8];
                        for (int i = 0; i < 8; i++)
                            for (int j = 0; j < 8; j++)
                                TableA[i, j] = Tab[i, j];

                        Draw.TableList.Clear();
                        Draw.TableList.Add(CloneATable(TableA));
                        Draw.SetRowColumn(0);
                        AllDraw.TableListAction.Add(TableA);
                        if (AllDraw.TableListAction.Count >= 1)
                        {
                            ChessGeneticAlgorithm R = new ChessGeneticAlgorithm(MovementsAStarGreedyHeuristicFound, IInoreSelfObjects, UsePenaltyRegardMechnisam, BestMovments, PredictHeuristic, OnlySelf, AStarGreedyHeuristic, ArrangmentsChanged);
                            if (R.FindGenToModified(AllDraw.TableListAction[AllDraw.TableListAction.Count - 2], AllDraw.TableListAction[AllDraw.TableListAction.Count - 1], AllDraw.TableListAction, 0, OrderPlate, true))
                            {
                                bool HitVal = false;
                                int Hit = AllDraw.TableListAction[AllDraw.TableListAction.Count - 2][R.CromosomRow, R.CromosomColumn];
                                if (Hit != 0)
                                    HitVal = true;
                                bool Convert = false;
                                if (OrderPlate == 1)
                                {
                                    if (AllDraw.TableListAction[AllDraw.TableListAction.Count - 1][R.CromosomRow, R.CromosomColumn] == 1)
                                    {
                                        if (R.CromosomColumn == 7)
                                            Convert = true;
                                    }
                                    AllDraw.SyntaxToWrite = (new ChessRules(0, MovementsAStarGreedyHeuristicFound, IInoreSelfObjects, UsePenaltyRegardMechnisam, BestMovments, PredictHeuristic, OnlySelf, AStarGreedyHeuristic, ArrangmentsChanged, OrderPlate)).CreateStatistic(ArrangmentsChanged, TableA, MoveNumber + 1, AllDraw.TableListAction[AllDraw.TableListAction.Count - 2][R.CromosomRowFirst, R.CromosomColumnFirst], R.CromosomColumn, R.CromosomRow, HitVal, Hit, ChessRules.CastleActGray, Convert);
                                }
                                else
                                {
                                    if (AllDraw.TableListAction[AllDraw.TableListAction.Count - 2][R.CromosomRowFirst, R.CromosomColumnFirst] == -1)
                                    {
                                        if (R.CromosomColumn == 0)
                                            Convert = true;
                                    }
                                    AllDraw.SyntaxToWrite = (new ChessRules(0, MovementsAStarGreedyHeuristicFound, IInoreSelfObjects, UsePenaltyRegardMechnisam, BestMovments, PredictHeuristic, OnlySelf, AStarGreedyHeuristic, ArrangmentsChanged, OrderPlate)).CreateStatistic(ArrangmentsChanged, TableA, MoveNumber, AllDraw.TableListAction[AllDraw.TableListAction.Count - 2][R.CromosomRowFirst, R.CromosomColumnFirst], R.CromosomColumn, R.CromosomRow, HitVal, Hit, ChessRules.CastleActBrown, Convert);
                                }

                            }
                        }


                        for (int i = 0; i < 8; i++)
                            for (int j = 0; j < 8; j++)
                                TableA[i, j] = Tab[i, j];


                        if ((new ChessRules(0, MovementsAStarGreedyHeuristicFound, IInoreSelfObjects, UsePenaltyRegardMechnisam, BestMovments, PredictHeuristic, OnlySelf, AStarGreedyHeuristic, ArrangmentsChanged, 1, TableA, OrderPlate, -1, -1).CheckMate(TableA, OrderPlate)))
                        {
                            int iii = 0;
                            do { iii++; } while (System.IO.File.Exists(Root + "\\Database\\Games\\CurrentBank" + iii.ToString() + ".accdb"));
                            System.IO.File.Copy(Root + "\\Database\\CurrentBank.accdb", Root + "\\Database\\Games\\CurrentBank" + iii.ToString() + ".accdb");
                            System.IO.File.Delete(Root + "\\Database\\CurrentBank.accdb");
                            break;

                        }
                        bookConn.Close();
                        bookConn.Dispose();
                        oleDbCmd.Dispose();
                        if (Move > 0)
                            OrderPlate *= -1;
                    }
                    catch (Exception tt)
                    {
                        Log(tt);
                        break;
                    }
                }
                Move++;
                if (Move > 2)
                    GameStarted = true;
                if (Move > 1)
                    MoveNumber++;


            } while (true);
            ReadF = true;
            return Tab;


        }
        //Verify Accuarance of Table Games Methos.
        bool VerifyTable(String FileName, int Movment, ref int MoveNumber)
        {
            bool PreviouseCheck = false;
            FileName = System.IO.Path.GetDirectoryName(Environment.GetCommandLineArgs()[0]) + "/CurrentBank.accdb";
            int[,] Tab = Table;
            int Move = 1;
            int Order = 1;
            bool TowCheckFromOneKind = false;
            do
            {
                if (Move > 5000)
                    break;
                try
                {
                    if (Move % 2 == 1)
                        Order = 1;
                    else
                        Order = -1;


                    bookConn = new OleDbConnection(connParam);
                    oleDbCmd = new OleDbCommand();
                    bookConn.Open();
                    oleDbCmd.Connection = bookConn;
                    String TableName = Move.ToString();
                    String Zero = "Table";
                    for (int i = 0; i < 8 - TableName.Length; i++)
                        Zero += "0";
                    TableName = Zero + TableName;

                    oleDbCmd.CommandText = "Select * From " + TableName;
                    OleDbDataReader dr = null;
                    try
                    {
                        dr = oleDbCmd.ExecuteReader();
                    }
                    catch (Exception t)
                    {
                        Log(t);
                        Move++;
                        break;
                    }
                    int ii = 0;
                    while (dr.Read())
                    {
                        Tab[0, ii] = System.Convert.ToInt32(dr["a"]);
                        Tab[1, ii] = System.Convert.ToInt32(dr["b"]);
                        Tab[2, ii] = System.Convert.ToInt32(dr["c"]);
                        Tab[3, ii] = System.Convert.ToInt32(dr["d"]);
                        Tab[4, ii] = System.Convert.ToInt32(dr["e"]);
                        Tab[5, ii] = System.Convert.ToInt32(dr["f"]);
                        Tab[6, ii] = System.Convert.ToInt32(dr["g"]);
                        Tab[7, ii] = System.Convert.ToInt32(dr["h"]);
                        ii++;
                    }
                    int[,] TableA = new int[8, 8];
                    for (int i = 0; i < 8; i++)
                        for (int j = 0; j < 8; j++)
                            TableA[i, j] = Tab[i, j];
                    Draw.TableList.Clear();
                    Draw.TableList.Add(CloneATable(TableA));
                    Draw.SetRowColumn(0);
                    if (!Draw.IsEnemyThingsinStable(TableA, AllDraw.TableVeryfy, Order))
                    {
                        Tab = null;
                        Tab[0, 0] = -1;
                    }
                    else
                    {
                        for (int i = 0; i < 8; i++)
                            for (int j = 0; j < 8; j++)
                                AllDraw.TableVeryfy[i, j] = Tab[i, j];

                    }


                    bookConn.Close();
                    oleDbCmd.Dispose();
                    bookConn.Dispose();
                    Move++;
                    if (Move > 1)
                        MoveNumber++;
                    for (int i = 0; i < 8; i++)
                        for (int j = 0; j < 8; j++)
                            TableA[i, j] = Tab[i, j];

                    ChessRules A = new ChessRules(0, MovementsAStarGreedyHeuristicFound, IInoreSelfObjects, UsePenaltyRegardMechnisam, BestMovments, PredictHeuristic, OnlySelf, AStarGreedyHeuristic, ArrangmentsChanged, 1, TableA, OrderPlate, -1, -1);
                    if (A.CheckMate(TableA, OrderPlate))
                    {

                        int iii = 0;
                        do { iii++; } while (System.IO.File.Exists(Root + "\\Database\\Games\\CurrentBank" + iii.ToString() + ".accdb"));
                        System.IO.File.Copy(Root + "\\Database\\CurrentBank.accdb", Root + "\\Database\\Games\\CurrentBank" + iii.ToString() + ".accdb");
                        System.IO.File.Delete(Root + "\\Database\\CurrentBank.accdb");
                        break;

                    }
                    if (A.CheckGray && TowCheckFromOneKind)
                    {
                        Tab = null;
                        Tab[0, 0] = -1;

                    }
                    else
                        if (Order == 1 && A.CheckGray)
                        TowCheckFromOneKind = true;
                    else
                        TowCheckFromOneKind = false;

                    if (A.CheckGray && TowCheckFromOneKind)
                    {
                        Tab = null;
                        Tab[0, 0] = -1;

                    }
                    else
                        if (Order == 1 && A.CheckGray)
                        TowCheckFromOneKind = true;
                    else
                        TowCheckFromOneKind = false;

                    if (A.CheckBrown || A.CheckGray)
                    {
                        if (PreviouseCheck)
                            return false;
                        else
                            PreviouseCheck = true;
                    }
                    else
                        PreviouseCheck = false;
                }
                catch (Exception t)
                {
                    Log(t);
                    bookConn.Close();
                    oleDbCmd.Dispose();
                    bookConn.Dispose();


                    do
                    {
                        try
                        {

                            Move++;



                            bookConn = new OleDbConnection(connParam);
                            bookConn.Open();
                            oleDbCmd.Connection = bookConn;
                            String TableName = (Move).ToString();
                            String Zero = "Table";
                            for (int i = 0; i < 8 - TableName.Length; i++)
                                Zero += "0";
                            TableName = Zero + TableName;

                            oleDbCmd.CommandText = "Drop Table " + TableName;
                            OleDbDataReader dr = null;
                            dr = oleDbCmd.ExecuteReader();
                            bookConn.Close();
                            oleDbCmd.Dispose();
                            bookConn.Dispose();
                            //return true;

                        }
                        catch (Exception tt)
                        {
                            Log(tt);
                            bookConn.Close();
                            oleDbCmd.Dispose();
                            bookConn.Dispose();
                            return false;
                        }
                    } while (true);
                }
                if (Move > 1)
                {
                    OrderPlate *= -1;
                    ChessRules.CurrentOrder = OrderPlate;
                }


            } while (true);
            bookConn.Close();
            oleDbCmd.Dispose();
            bookConn.Dispose();

            return true;


        }
        //Read Specific Table Number.
        int[,] ReadTableMovmentNumber()
        {
            int[,] Tab = Table;
            int Move = MovmentsNumber;
            AllDraw.TableListAction.Clear();

            try
            {
                if (Move > 1)
                {
                    if (MovmentsNumber % 2 == 0)
                        OrderPlate = 1;
                    else
                        OrderPlate = -1;
                    ChessRules.CurrentOrder = OrderPlate;
                }

                bookConn = new OleDbConnection(connParam);
                bookConn.Open();
                oleDbCmd.Connection = bookConn;
                String TableName = Move.ToString();
                String Zero = "Table";
                for (int i = 0; i < 8 - TableName.Length; i++)
                    Zero += "0";
                TableName = Zero + TableName;

                oleDbCmd.CommandText = "Select * From " + TableName;
                OleDbDataReader dr = null;
                dr = oleDbCmd.ExecuteReader();
                int ii = 0;
                while (dr.Read())
                {
                    Tab[0, ii] = System.Convert.ToInt32(dr["a"]);
                    Tab[1, ii] = System.Convert.ToInt32(dr["b"]);
                    Tab[2, ii] = System.Convert.ToInt32(dr["c"]);
                    Tab[3, ii] = System.Convert.ToInt32(dr["d"]);
                    Tab[4, ii] = System.Convert.ToInt32(dr["e"]);
                    Tab[5, ii] = System.Convert.ToInt32(dr["f"]);
                    Tab[6, ii] = System.Convert.ToInt32(dr["g"]);
                    Tab[7, ii] = System.Convert.ToInt32(dr["h"]);
                    ii++;
                }
                int[,] TableA = new int[8, 8];
                for (int i = 0; i < 8; i++)
                    for (int j = 0; j < 8; j++)
                        TableA[i, j] = Tab[i, j];

                AllDraw.TableListAction.Add(TableA);
                if (AllDraw.TableListAction.Count >= 1)
                {
                    ChessGeneticAlgorithm R = new ChessGeneticAlgorithm(MovementsAStarGreedyHeuristicFound, IInoreSelfObjects, UsePenaltyRegardMechnisam, BestMovments, PredictHeuristic, OnlySelf, AStarGreedyHeuristic, ArrangmentsChanged);
                    if (R.FindGenToModified(AllDraw.TableListAction[AllDraw.TableListAction.Count - 2], AllDraw.TableListAction[AllDraw.TableListAction.Count - 1], AllDraw.TableListAction, 0, OrderPlate, true))
                    {
                        bool HitVal = false;
                        int Hit = AllDraw.TableListAction[AllDraw.TableListAction.Count - 2][R.CromosomRow, R.CromosomColumn];
                        if (Hit != 0)
                            HitVal = true;
                        bool Convert = false;
                        if (OrderPlate == 1)
                        {
                            if (AllDraw.TableListAction[AllDraw.TableListAction.Count - 1][R.CromosomRow, R.CromosomColumn] == 1)
                            {
                                if (R.CromosomColumn == 7)
                                    Convert = true;
                            }
                            AllDraw.SyntaxToWrite = (new ChessRules(0, MovementsAStarGreedyHeuristicFound, IInoreSelfObjects, UsePenaltyRegardMechnisam, BestMovments, PredictHeuristic, OnlySelf, AStarGreedyHeuristic, ArrangmentsChanged, OrderPlate)).CreateStatistic(ArrangmentsChanged, TableA, MovmentsNumber, AllDraw.TableListAction[AllDraw.TableListAction.Count - 2][R.CromosomRowFirst, R.CromosomColumnFirst], R.CromosomColumn, R.CromosomRow, HitVal, Hit, ChessRules.CastleActGray, Convert);
                        }
                        else
                        {
                            if (AllDraw.TableListAction[AllDraw.TableListAction.Count - 1][R.CromosomRowFirst, R.CromosomColumnFirst] == -1)
                            {
                                if (R.CromosomColumn == 0)
                                    Convert = true;
                            }
                            AllDraw.SyntaxToWrite = (new ChessRules(0, MovementsAStarGreedyHeuristicFound, IInoreSelfObjects, UsePenaltyRegardMechnisam, BestMovments, PredictHeuristic, OnlySelf, AStarGreedyHeuristic, ArrangmentsChanged, OrderPlate)).CreateStatistic(ArrangmentsChanged, TableA, MovmentsNumber, AllDraw.TableListAction[AllDraw.TableListAction.Count - 2][R.CromosomRowFirst, R.CromosomColumnFirst], R.CromosomColumn, R.CromosomRow, HitVal, Hit, ChessRules.CastleActBrown, Convert);
                        }
                        //SetBoxStatistic(AllDraw.SyntaxToWrite);
                        //RefreshBoxStatistic();
                    }
                }


                bookConn.Close();
                oleDbCmd.Dispose();
                bookConn.Dispose();
                Move++;

                if ((new ChessRules(0, MovementsAStarGreedyHeuristicFound, IInoreSelfObjects, UsePenaltyRegardMechnisam, BestMovments, PredictHeuristic, OnlySelf, AStarGreedyHeuristic, ArrangmentsChanged, 1, CloneATable(Tab), OrderPlate, -1, -1).CheckMate(CloneATable(Tab), OrderPlate)))
                {
                    int iii = 0;
                    do { iii++; } while (System.IO.File.Exists(Root + "\\Database\\Games\\CurrentBank" + iii.ToString() + ".accdb"));
                    System.IO.File.Copy(Root + "\\Database\\CurrentBank.accdb", Root + "\\Database\\Games\\CurrentBank" + iii.ToString() + ".accdb");
                    System.IO.File.Delete(Root + "\\Database\\CurrentBank.accdb");
                    return TableA;

                }
            }
            catch (Exception t)
            {
                Log(t);
                try
                {
                    bookConn.Close();
                    oleDbCmd.Dispose();
                    bookConn.Dispose();

                    Move++;


                    bookConn = new OleDbConnection(connParam);
                    bookConn.Open();
                    oleDbCmd.Connection = bookConn;
                    String TableName = (Move).ToString();
                    String Zero = "Table";
                    for (int i = 0; i < 8 - TableName.Length; i++)
                        Zero += "0";
                    TableName = Zero + TableName;

                    oleDbCmd.CommandText = "Select * From " + TableName;
                    OleDbDataReader dr = null;
                    dr = oleDbCmd.ExecuteReader();
                    int ii = 0;
                    while (dr.Read())
                    {
                        Tab[0, ii] = System.Convert.ToInt32(dr["a"]);
                        Tab[1, ii] = System.Convert.ToInt32(dr["b"]);
                        Tab[2, ii] = System.Convert.ToInt32(dr["c"]);
                        Tab[3, ii] = System.Convert.ToInt32(dr["d"]);
                        Tab[4, ii] = System.Convert.ToInt32(dr["e"]);
                        Tab[5, ii] = System.Convert.ToInt32(dr["f"]);
                        Tab[6, ii] = System.Convert.ToInt32(dr["g"]);
                        Tab[7, ii] = System.Convert.ToInt32(dr["h"]);
                        ii++;
                    }
                    int[,] TableA = new int[8, 8];
                    for (int i = 0; i < 8; i++)
                        for (int j = 0; j < 8; j++)
                            TableA[i, j] = Tab[i, j];

                    AllDraw.TableListAction.Add(TableA);
                    if (AllDraw.TableListAction.Count >= 1)
                    {
                        ChessGeneticAlgorithm R = new ChessGeneticAlgorithm(MovementsAStarGreedyHeuristicFound, IInoreSelfObjects, UsePenaltyRegardMechnisam, BestMovments, PredictHeuristic, OnlySelf, AStarGreedyHeuristic, ArrangmentsChanged);
                        if (R.FindGenToModified(AllDraw.TableListAction[AllDraw.TableListAction.Count - 2], AllDraw.TableListAction[AllDraw.TableListAction.Count - 1], AllDraw.TableListAction, 0, OrderPlate, true))
                        {
                            bool HitVal = false;
                            int Hit = AllDraw.TableListAction[AllDraw.TableListAction.Count - 2][R.CromosomRow, R.CromosomColumn];
                            if (Hit != 0)
                                HitVal = true;
                            bool Convert = false;
                            if (OrderPlate == 1)
                            {
                                if (AllDraw.TableListAction[AllDraw.TableListAction.Count - 1][R.CromosomRow, R.CromosomColumn] == 1)
                                {
                                    if (R.CromosomColumn == 7)
                                        Convert = true;
                                }
                                AllDraw.SyntaxToWrite = (new ChessRules(0, MovementsAStarGreedyHeuristicFound, IInoreSelfObjects, UsePenaltyRegardMechnisam, BestMovments, PredictHeuristic, OnlySelf, AStarGreedyHeuristic, ArrangmentsChanged, OrderPlate)).CreateStatistic(ArrangmentsChanged, TableA, MovmentsNumber, AllDraw.TableListAction[AllDraw.TableListAction.Count - 2][R.CromosomRowFirst, R.CromosomColumnFirst], R.CromosomColumn, R.CromosomRow, HitVal, Hit, ChessRules.CastleActGray, Convert);
                            }
                            else
                            {
                                if (AllDraw.TableListAction[AllDraw.TableListAction.Count - 2][R.CromosomRowFirst, R.CromosomColumnFirst] == -1)
                                {
                                    if (R.CromosomColumn == 0)
                                        Convert = true;
                                }
                                AllDraw.SyntaxToWrite = (new ChessRules(0, MovementsAStarGreedyHeuristicFound, IInoreSelfObjects, UsePenaltyRegardMechnisam, BestMovments, PredictHeuristic, OnlySelf, AStarGreedyHeuristic, ArrangmentsChanged, OrderPlate)).CreateStatistic(ArrangmentsChanged, TableA, MovmentsNumber, AllDraw.TableListAction[AllDraw.TableListAction.Count - 2][R.CromosomRowFirst, R.CromosomColumnFirst], R.CromosomColumn, R.CromosomRow, HitVal, Hit, ChessRules.CastleActBrown, Convert);
                            }
                            //SetBoxStatistic(AllDraw.SyntaxToWrite);
                            //RefreshBoxStatistic();
                        }
                    }

                    bookConn.Close();
                    oleDbCmd.Dispose();
                    bookConn.Dispose();
                    if ((new ChessRules(0, MovementsAStarGreedyHeuristicFound, IInoreSelfObjects, UsePenaltyRegardMechnisam, BestMovments, PredictHeuristic, OnlySelf, AStarGreedyHeuristic, ArrangmentsChanged, 1, CloneATable(Tab), OrderPlate, -1, -1).CheckMate(CloneATable(Tab), OrderPlate)))
                    {
                        int iii = 0;
                        do { iii++; } while (System.IO.File.Exists("Database\\Games\\CurrentBank" + iii.ToString() + ".accdb"));
                        System.IO.File.Copy("Database\\CurrentBank.accdb", Root + "\\Database\\Games\\CurrentBank" + iii.ToString() + ".accdb");
                        System.IO.File.Delete("Database\\CurrentBank.accdb");
                        return TableA; ;

                    }

                }
                catch (Exception tt)
                {
                    Log(tt);
                    bookConn.Close();
                    oleDbCmd.Dispose();
                    bookConn.Dispose();
                    return null;
                }
            }



            return Tab;


        }
        //Creation of New Tables at DatabaseMethod.
        String CreatTable()
        {
            Begin12:
            try
            {


                bookConn = new OleDbConnection(connParam);
                bookConn.Open();
                oleDbCmd.Connection = bookConn;
                String TableName = MovmentsNumber.ToString();
                String Zero = "Table";
                for (int i = 0; i < 8 - TableName.Length; i++)
                    Zero += "0";
                TableName = Zero + TableName;

                oleDbCmd.CommandText = "Create Table " + TableName + " (a Number NOT NULL,b Number NOT NULL,c Number NOT NULL,d Number NOT NULL,e Number NOT NULL,f Number NOT NULL,g Number NOT NULL,h Number NOT NULL)";
                int temp = 0;
                temp = oleDbCmd.ExecuteNonQuery();
                bookConn.Close();
                oleDbCmd.Dispose();
                bookConn.Dispose();
                return TableName;
            }
            catch (Exception t)
            {
                Log(t);


                bookConn = new OleDbConnection(connParam);
                bookConn.Open();
                oleDbCmd.Connection = bookConn;
                String TableName = MovmentsNumber.ToString();
                String Zero = "Table";
                for (int i = 0; i < 8 - TableName.Length; i++)
                    Zero += "0";
                TableName = Zero + TableName;

                oleDbCmd.CommandText = "Drop Table " + TableName;
                int temp = 0;
                temp = oleDbCmd.ExecuteNonQuery();
                bookConn.Close();
                oleDbCmd.Dispose();
                bookConn.Dispose();
                goto Begin12;

            }
        }
        //Creatiopn of Configuration Table
        public void CreateConfigurationTable()
        {
            Begin12:
            if (bookConn == null)
            {

                bookConn = new OleDbConnection(connParam);
                bookConn.Open();
                oleDbCmd.Connection = bookConn;
            }

            if (!AllDrawLoad)
            {
                try
                {

                    oleDbCmd.CommandText = "Create Table Configuration (ArrangmentsChanged Number NOT NULL,GrayTimer Number NOT NULL,BrownTimer Number NOT NULL,BobSection Number NOT NULL,AliceSection Number NOT NULL,StateCP Number NOT NULL,StateCC Number NOT NULL,StateGe Number NOT NULL,Blitz Number NOT NULL,Person Number NOT NULL,SettingPRFALSE Number NOT NULL,Colleralation Number NOT NULL)";
                    int temp = 0;
                    temp = oleDbCmd.ExecuteNonQuery();

                    oleDbCmd.CommandText = "Insert into Configuration (ArrangmentsChanged,GrayTimer,BrownTimer,BobSection,AliceSection,StateCP,StateCC,StateGe,Blitz,Person,SettingPRFALSE,Colleralation) values(" + System.Convert.ToInt32(ArrangmentsChanged).ToString() + "," + GrayTimer.Times.ToString() + "," + BrownTimer.Times.ToString() + "," + System.Convert.ToInt32(BobSection).ToString() + "," + System.Convert.ToInt32(AliceSection).ToString() + "," + System.Convert.ToInt32(StateCP).ToString() + "," + System.Convert.ToInt32(StateCC).ToString() + "," + System.Convert.ToInt32(StateGe).ToString() + "," + System.Convert.ToInt32(Blitz).ToString() + "," + System.Convert.ToInt32(Person).ToString() + "," + System.Convert.ToInt32(SettingPRFALSE).ToString() + "," + ThinkingRefrigtzW.Colleralation.ToString() + ")";

                    temp = oleDbCmd.ExecuteNonQuery();

                }
                catch (Exception t)
                {
                    Log(t);
                    bookConn.Close();
                    oleDbCmd.Dispose();
                    bookConn.Dispose();
                    goto Begin12;

                }
            }
        }
        void UpdateTable(int[,] Tabl, String TableName)
        {
            try
            {
                oleDbCmd.CommandText = "Drop Table " + TableName;
                int temp = 0;
                temp = oleDbCmd.ExecuteNonQuery();
                InsertTableAtDataBase(Tabl);

            }
            catch (Exception t)
            {
                Log(t);
            }
        }


        //Reading of Configuration Table Method.
        void ReadConfigurationTable()
        {

            if (!AllDrawLoad)
            {
                Begin12:
                try
                {

                    oleDbCmd.CommandText = "Select * from Configuration";
                    OleDbDataReader dr = null;
                    dr = oleDbCmd.ExecuteReader();
                    if (dr.Read())
                    {
                        ArrangmentsChanged = System.Convert.ToBoolean(dr["ArrangmentsChanged"]);
                        GrayTimer.Times = System.Convert.ToInt64(dr["GrayTimer"]);
                        BrownTimer.Times = System.Convert.ToInt64(dr["BrownTimer"]);
                        BobSection = System.Convert.ToBoolean(dr["BobSection"]);
                        AliceSection = System.Convert.ToBoolean(dr["AliceSection"]);
                        StateCP = System.Convert.ToBoolean(dr["StateCP"]);
                        StateCC = System.Convert.ToBoolean(dr["StateCC"]);
                        StateGe = System.Convert.ToBoolean(dr["StateGe"]);
                        Blitz = System.Convert.ToBoolean(dr["Blitz"]);
                        Person = System.Convert.ToBoolean(dr["Person"]);
                        SettingPRFALSE = System.Convert.ToBoolean(dr["SettingPRFALSE"]);
                        ThinkingRefrigtzW.Colleralation = System.Convert.ToInt32(dr["Colleralation"]);
                    }

                }
                catch (Exception t)
                {
                    Log(t);
                    try
                    {
                        oleDbCmd.CommandText = "Drop Table Configuration";
                        int temp = 0;
                        temp = oleDbCmd.ExecuteNonQuery();
                    }
                    catch (Exception tt)
                    {
                        Log(tt);
                        CreateConfigurationTable();

                    }
                    goto Begin12;

                }
            }
        }
        //Updating of Configuration Method.
        void UpdateConfigurationTable()
        {

            //if (UpdateConfigurationTableVal)
            {

                Begin12:
                try
                {
                    TimersSet = false;

                    oleDbCmd.CommandText = "Update Configuration Set ArrangmentsChanged=" + System.Convert.ToString(System.Convert.ToInt32(ArrangmentsChanged)) + ",GrayTimer=" + GrayTimer.Times.ToString() + ",BrownTimer=" + BrownTimer.Times.ToString() + ",BobSection = " + System.Convert.ToUInt32(BobSection).ToString() + ",AliceSection =" + System.Convert.ToUInt32(AliceSection).ToString() + ",StateCP = " + System.Convert.ToUInt32(StateCP).ToString() + ",StateCC = " + System.Convert.ToUInt32(StateCC).ToString() + ",StateGe=" + System.Convert.ToUInt32(StateGe).ToString() + ",Blitz=" + System.Convert.ToUInt32(Blitz).ToString() + ",Person=" + System.Convert.ToUInt32(Person).ToString() + ",SettingPRFALSE=" + System.Convert.ToUInt32(SettingPRFALSE).ToString() + ",Colleralation='" + ThinkingRefrigtzW.Colleralation.ToString() + "'";

                    int temp = oleDbCmd.ExecuteNonQuery();
                    TimersSet = true;
                }
                catch (Exception t)
                {
                    //TimersSet = true;
                    Log(t);
                    try
                    {
                        oleDbCmd.CommandText = "Drop Table Configuration";
                        int temp = 0;
                        temp = oleDbCmd.ExecuteNonQuery();
                        goto Begin12;
                    }
                    catch (Exception tt)
                    {
                        Log(tt);

                    }

                }
            }
        }
        public void InsertTableAtDataBase(int[,] Table)
        {


            //TimersSet = false;
            int[,] Tab = new int[8, 8];
            for (int i = 0; i < 8; i++)
                for (int j = 0; j < 8; j++)
                    Tab[i, j] = Table[i, j];
            String TableName = CreatTable();
            for (int i = 0; i < 8; i++)
            {
                bookConn = new OleDbConnection(connParam);
                oleDbCmd = new OleDbCommand();
                bookConn.Open();
                oleDbCmd.Connection = bookConn;

                oleDbCmd.CommandText = "insert into " + TableName + "(a,b,c,d,e,f,g,h)  values (" + Tab[0, i].ToString() + "," + Tab[1, i].ToString() + "," + Tab[2, i].ToString() + "," + Tab[3, i].ToString() + "," + Tab[4, i].ToString() + "," + Tab[5, i].ToString() + "," + Tab[6, i].ToString() + "," + Tab[7, i].ToString() + ")";
                int temp = 0;
                temp = oleDbCmd.ExecuteNonQuery();

                bookConn.Close();
                bookConn.Dispose();
                oleDbCmd.Dispose();

            }

            MaxCurrentMovmentsNumber++;

            //bookConn.Close();
            //oleDbCmd.Dispose();
            //bookConn.Dispose();
            if (MovmentsNumber > 1)
                GameStarted = true;
            //RefrigtzW.ChessRules.CastleActBrown = false;
            //RefrigtzW.ChessRules.CastleActGray = false;
            //TimersSet = true;
        }

        //Inserting of New Tabler at Database.
        public AllDraw RootFound()
        {
            try
            {
                if (Draw != null)
                {
                    while (Draw.AStarGreedyString != null)
                    {
                        Draw = Draw.AStarGreedyString;
                    }
                }

            }
            catch (Exception t) { Log(t); }
            return Draw;
        }
        void L()
        {
            do
            {
                ArrangmentsChanged = true;

            } while (true);
        }
        public void Load()
        {
            //var parallelOptions = new ParallelOptions();
            //parallelOptionsMaxDegreeOfParallelism =System.Threading.PlatformHelper.ProcessorCount; //PlatformHelper.ProcessorCount;

            MovmentsNumber = 0;

            ttt = new WebApplicationRefregitzTow._Default();
            //ttt.Iniziate();
            //GC.Collect();
            //GC.WaitForPendingFinalizers();
            Thread tSPHT = new Thread(new ThreadStart(L));
            tSPHT.Start();
            Thread tS = new Thread(new ThreadStart(SetRefregitzDLL));
            tS.Start();


            ThinkingA = true;

            bookConn = new OleDbConnection(connParam);
            oleDbCmd = new OleDbCommand();
            bookConn.Open();
            oleDbCmd.Connection = bookConn;

            ReadConfigurationTable();

            bookConn.Close();
            bookConn.Dispose();
            oleDbCmd.Dispose();

            Table = ReadTable(0, ref MovmentsNumber);

            int[,] TableA = new int[8, 8];
            for (int i = 0; i < 8; i++)
                for (int j = 0; j < 8; j++)
                    TableA[i, j] = Table[i, j];

            Object O = new Object();
            lock (O)
            {
                {
                    RefrigtzW.AllDraw.OrderPlateDraw = -1;
                    RefrigtzW.AllDraw.TableListAction.Add(CloneATable(Table));
                    RefrigtzW.ThinkingRefrigtzW.TableInitiation = CloneATable(Table);
                    if (DrawManagement())
                    {
                        //Load AllDraw.asd
                        bool LoadTree = true;
                        TakeRoot y = new TakeRoot();
                        bool DrawDrawen = y.Load(FOUND, false, this, ref LoadTree, false, false, UsePenaltyRegardMechnisam, false, false, false, AStarGreedyHeuristic, true);
                        if (!DrawDrawen)
                        {
                            Draw = new RefrigtzW.AllDraw(OrderPlate, false, false, UsePenaltyRegardMechnisam, false, false, false, AStarGreedyHeuristic, true);
                            Draw.TableList.Clear();
                            Draw.TableList.Add(CloneATable(Table));
                            Draw.SetRowColumn(0);
                            RefrigtzW.AllDraw.DepthIterative = 0;
                            bool Store = Deeperthandeeper;
                            Deeperthandeeper = false;
                            OrderPlate = 1;
                            AllDraw.OrderPlate = OrderPlate;
                            int Ord = OrderPlate;
                            Color aa = Color.Gray;
                            if (Ord == -1)
                                aa = Color.Brown;
                            bool B = AllDraw.Blitz;
                            AllDraw.Blitz = false;
                            RefrigtzW.AllDraw.MaxAStarGreedy = 2; //PlatformHelper.ProcessorCount;

                            if (Draw.IsAtLeastAllObjectIsNull())
                            {
                                Draw.TableList.Clear();
                                Draw.TableList.Add(CloneATable(RefrigtzW.AllDraw.TableListAction[RefrigtzW.AllDraw.TableListAction.Count - 2]));
                                Draw.SetRowColumn(0);
                                Draw.IsCurrentDraw = true;
                            }
                            Draw.InitiateAStarGreedyt(RefrigtzW.AllDraw.MaxAStarGreedy, 0, 0, aa, CloneATable(RefrigtzW.AllDraw.TableListAction[RefrigtzW.AllDraw.TableListAction.Count - 1]), Ord, false, FOUND, 0);
                            AllDraw.Blitz = B;
                            Deeperthandeeper = Store;

                        }
                        else
                        {
                            FOUND = false;
                            Draw = y.t;
                            Draw.HarasAlphaBeta(0, 0, -1);
                            Thread arr = new Thread(new ThreadStart(SetDrawFound));
                            arr.Start();
                            arr.Join();
                        }
                    }
                }
            }


            //GC.Collect();
            //GC.WaitForPendingFinalizers();
            LoadPlaceHolder = true;
            // ttt.LoadPlaceHolder(); 

            do
            {
                AllDraw.Root = Root;
                AllDraw.OrderPlate = OrderPlate;
                AllDraw.Blitz = Blitz;
                AllDraw.StateCP = true;
                AllDraw.MovmentsNumber = MovmentsNumber;
                AllDraw.EndOfGame = EndOfGame;
                AllDraw.THIScomboBoxMaxLevelText = PlatformHelper.ProcessorCount.ToString();
                //LoadPlaceHolder = false;
                if (OrderPlate == 1)
                {

                    File.AppendAllText(Root + "\\Database\\Monitor.txt", "\n\t=====================================================================================================================================================================");
                    File.AppendAllText(Root + "\\Database\\Monitor.txt", "\n\tMovment Number:" + MovmentsNumber);

                    WebApplicationRefregitzTow._Default.No = 0;
                    ThinkingA = false;
                    WebApplicationRefregitzTow.Controls_CBC.MouseClicked = 0;
                    WebApplicationRefregitzTow.Controls_CBC.Found = false;
                    WebApplicationRefregitzTow.Controls_CBC.CurrentClickedNumber = 0;
                    while (!(ThinkingA))
                    {
                        //LoadPlaceHolder = false;
                        //PlaceHolderBreak=true;
                        //Thread tSPHT = new Thread(new ThreadStart(SetLoadPlaceHoldertrue));
                        //tSPHT.Start();
                        //ttt.LoadPlaceHolder();
                    }

                    int[,] Tab = new int[8, 8];
                    for (int i = 0; i < 8; i++)
                        for (int j = 0; j < 8; j++)
                            Tab[i, j] = Table[i, j];
                    OrderPlate *= -1;
                    ChessRules.CurrentOrder *= -1;
                    //RefrigtzW.FormRefrigtz.MovmentsNumber++; 


                    InsertTableAtDataBase(Tab);



                    //ttt.AddBPOP();
                    //LoadPlaceHolder = true;
                    using (SoundPlayer soundClick = new SoundPlayer(Root + "\\Music\\Click6.wav"))
                    {
                        soundClick.Play();
                        soundClick.Dispose();
                    }
                    //LoadPlaceHolder = true; 
                    //PlaceHolderBreak = true;
                    //Thread tSPHTT = new Thread(new ThreadStart(SetLoadPlaceHoldertrue));
                    //tSPHTT.Start();


                }
                else
                {
                    LoadPlaceHolder = false;

                    ThinkingA = true;
                    t1 = new Thread(new ThreadStart(AliceWithPerson));
                    //Thread tSPHT = new Thread(new ThreadStart(SetLoadPlaceHoldertrue));
                    //PlaceHolderBreak = false;
                    //tSPHT.Start();
                    t1.Start();

                    t1.Join();
                    if (IsPenaltyRegardCanceled)
                    {
                        SettingPRFALSE = true;
                        UsePenaltyRegardMechnisam = false;
                        //UpdateConfigurationTable();
                        t1 = new Thread(new ThreadStart(AliceWithPerson));
                        //Thread tSPHT = new Thread(new ThreadStart(SetLoadPlaceHoldertrue));
                        //PlaceHolderBreak = false;
                        //tSPHT.Start();
                        t1.Start();
                        t1.Join();
                        SettingPRFALSE = false;
                        UsePenaltyRegardMechnisam = true;
                        //UpdateConfigurationTable();
                        IsPenaltyRegardCanceled = false;

                    }
                    else
                    {
                        //tSPHT.Abort();
                        // LoadPlaceHolder = true;
                        //OrderPlate = OrderPlate * -1;
                        // ChessRules.CurrentOrder = OrderPlate;
                        //t1.Abort();
                        //  while (ThinkingA)
                        //{
                        //  
                        //}
                        LoadPlaceHolder = true;
                        FormRefrigtz.ThinkingA = false;
                        //Thread tSPHT = new Thread(new ThreadStart(SetLoadPlaceHoldertrue));
                        //PlaceHolderBreak = false;
                        //tSPHT.Start();
                        //System.Web.HttpContext.Current.Response.AppendHeader("Refresh", 30 + "; URL=~/Default.aspx");   
                        //ttt.LoadPlaceHolder();
                        ttt = new WebApplicationRefregitzTow._Default();
                    }
                }
                SetDrawFound();
            } while (true);
        }
        //Inserting of New Tabler at Database.

        void Wait()
        {
            do
            {

            } while (Clicked);
        }
        int[,] CloneATable(int[,] Tab)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object O = new Object();
            lock (O)
            {
                //Create and new an Object.
                int[,] Table = new int[8, 8];
                //Assigne Parameter To New Objects.
                for (var i = 0; i < 8; i++)
                    for (var j = 0; j < 8; j++)
                        Table[i, j] = Tab[i, j];
                //Return New Object.
                ////{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("CloneATable:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                return Table;
            }

        }
        bool[,] CloneATable(bool[,] Tab)
        {
            //long Time = TimeElapced.TimeNow();Spaces++;
            Object O = new Object();
            lock (O)
            {
                //Create and new an Object.
                bool[,] Table = new bool[8, 8];
                //Assigne Parameter To New Objects.
                for (var i = 0; i < 8; i++)
                    for (var j = 0; j < 8; j++)
                        Table[i, j] = Tab[i, j];
                //Return New Object.
                ////{ //AllDraw.OutPut.Append("\r\n");for (int l = 0; l < Spaces; l++) //AllDraw.OutPut.Append(Space);  //AllDraw.OutPut.Append("CloneATable:" + (TimeElapced.TimeNow() - Time).ToString());}Spaces--;
                return Table;
            }

        }
        //All Operation of Thinking Handling.

        //The State of Alice with Person Thinking.
        void AliceWithPerson()
        {

            ThinkingRefrigtzW.ThinkingRun = true;

            try
            {
                Begin1:
                bool StoreStateCC = StateCC;
                bool StoreStateCP = StateCP;
                bool StoreStateGe = StateGe;
                StateCC = false;
                StateCP = false;
                StateGe = false;

                MovmentsNumber++;

                ////SetBoxText("\r\nMovments Number " + MovmentsNumber.ToString() + " is Brown OrderPlate!");
                ////RefreshBoxText();();

                ////SetBoxText("\r\nThinking Begin!");
                ////RefreshBoxText();();
                Color a = Color.Gray;
                if (OrderPlate == -1)
                    a = Color.Brown;
                int LeafAStarGrteedy = 0;
                bool FOUND = false;
                AllDraw THIS = null;
                Draw.FoundOfCurrentTableNode(CloneATable(Table), OrderPlate, ref THIS, ref FOUND);
                if (FOUND)
                {

                    Draw = THIS;

                }
                else
                {
                    RefrigtzW.AllDraw.TableListAction.Add(Table);
                    OrderPlate = OrderPlate * -1;
                    Draw = new AllDraw(OrderPlate, MovementsAStarGreedyHeuristicFound, IInoreSelfObjects, UsePenaltyRegardMechnisam, BestMovments, PredictHeuristic, OnlySelf, AStarGreedyHeuristic, ArrangmentsChanged);
                    Draw.TableList.Clear();
                    Draw.TableList.Add(CloneATable(Table));
                    Draw.SetRowColumn(0);
                    RefrigtzW.AllDraw.DepthIterative = 0;
                }
                Table = Draw.Initiate(1, 4, a, CloneATable(Table), OrderPlate, false, false, LeafAStarGrteedy);
                //this.//SetBoxText("\r\nThinking Finished!");
                try
                {

                    if (!TableZero(Table))
                    {
                        SettingPRFALSE = true;
                        UpdateConfigurationTable();
                        System.IO.File.AppendAllText("CheckSum.btt", "\n\tInstallation Begine On " + DateTime.Now.ToString());
                        String FolderLocation = Root;
                        int exitCode = 0;

                        // Prepare the process to run
                        ProcessStartInfo start = new ProcessStartInfo();
                        // Prepare the process to run
                        // Enter in the command line arguments, everything you would enter after the executable name itself
                        start.Arguments = "";
                        // Enter the executable to run, including the complete path
                        start.FileName = "\"" + FolderLocation + "\\" + "LoadRP.exe" + "\"";
                        // Do you want to show a console window?
                        start.WindowStyle = ProcessWindowStyle.Normal;
                        start.CreateNoWindow = true;
                        start.UseShellExecute = true;

                        // Run the external process & wait for it to finish
                        using (Process proc = Process.Start(start))
                        {
                            proc.WaitForExit(20000);
                            // Retrieve the app's exit code
                            exitCode = proc.ExitCode;
                        }

                    }

                }
                catch (Exception t)
                {
                    Log(t);
                    goto Begin1;
                }

                //Draw.SetRowColumn(0);
                int[,] TableCon = new int[8, 8];
                for (int i = 0; i < 8; i++)
                    for (int j = 0; j < 8; j++)
                        TableCon[i, j] = Table[i, j];
                AllDraw.TableListAction.Add(TableCon);
                int[,] Tab = new int[8, 8];
                for (int i = 0; i < 8; i++)
                    for (int j = 0; j < 8; j++)
                        Tab[i, j] = Table[i, j];
                //RefrigtzW.FormRefrigtz.MovmentsNumber++; 

                InsertTableAtDataBase(Tab);

                if (AllDraw.TableListAction.Count > 1)

                {
                    ChessGeneticAlgorithm R = new ChessGeneticAlgorithm(MovementsAStarGreedyHeuristicFound, IInoreSelfObjects, UsePenaltyRegardMechnisam, BestMovments, PredictHeuristic, OnlySelf, AStarGreedyHeuristic, ArrangmentsChanged);
                    if (R.FindGenToModified(AllDraw.TableListAction[AllDraw.TableListAction.Count - 2], AllDraw.TableListAction[AllDraw.TableListAction.Count - 1], AllDraw.TableListAction, 0, OrderPlate, true))
                    {
                        bool HitVal = false;
                        int Hit = AllDraw.TableListAction[AllDraw.TableListAction.Count - 2][R.CromosomRow, R.CromosomColumn];
                        if (Hit != 0)
                            HitVal = true;
                        bool Convert = false;
                        if (OrderPlate == 1)
                        {
                            if (AllDraw.TableListAction[AllDraw.TableListAction.Count - 1][R.CromosomRow, R.CromosomColumn] == 1)
                            {
                                if (R.CromosomColumn == 7)
                                    Convert = true;
                            }
                            if ((ChessRules.SmallKingCastleGray || ChessRules.BigKingCastleGray) && (!ChessRules.CastleActGray))
                                ChessRules.CastleActGray = true;
                            AllDraw.SyntaxToWrite = (new ChessRules(0, MovementsAStarGreedyHeuristicFound, IInoreSelfObjects, UsePenaltyRegardMechnisam, BestMovments, PredictHeuristic, OnlySelf, AStarGreedyHeuristic, ArrangmentsChanged, OrderPlate)).CreateStatistic(ArrangmentsChanged, CloneATable(Table), MovmentsNumber + 1, AllDraw.TableListAction[AllDraw.TableListAction.Count - 2][R.CromosomRowFirst, R.CromosomColumnFirst], R.CromosomColumn, R.CromosomRow, HitVal, Hit, ChessRules.CastleActGray, Convert);
                        }
                        else
                        {
                            if (AllDraw.TableListAction[AllDraw.TableListAction.Count - 1][R.CromosomRow, R.CromosomColumn] == -1)
                            {
                                if (R.CromosomColumn == 0)
                                    Convert = true;
                            }
                            if ((ChessRules.SmallKingCastleBrown || ChessRules.BigKingCastleBrown) && (!ChessRules.CastleActBrown))
                                ChessRules.CastleActBrown = true;

                            AllDraw.SyntaxToWrite = (new ChessRules(0, MovementsAStarGreedyHeuristicFound, IInoreSelfObjects, UsePenaltyRegardMechnisam, BestMovments, PredictHeuristic, OnlySelf, AStarGreedyHeuristic, ArrangmentsChanged, OrderPlate)).CreateStatistic(ArrangmentsChanged, CloneATable(Table), MovmentsNumber + 1, AllDraw.TableListAction[AllDraw.TableListAction.Count - 2][R.CromosomRowFirst, R.CromosomColumnFirst], R.CromosomColumn, R.CromosomRow, HitVal, Hit, ChessRules.CastleActBrown, Convert);
                        }
                        //SetBoxStatistic(AllDraw.SyntaxToWrite);
                        //RefreshBoxStatistic();
                    }
                }
                FOUND = false;
                Draw.FoundOfCurrentTableNode(CloneATable(Table), OrderPlate, ref THIS, ref FOUND);
                if (FOUND)
                {

                    Draw = THIS;

                }
                else
                {
                    RefrigtzW.AllDraw.TableListAction.Add(Table);
                    OrderPlate = OrderPlate * -1;
                    Draw = new AllDraw(OrderPlate, MovementsAStarGreedyHeuristicFound, IInoreSelfObjects, UsePenaltyRegardMechnisam, BestMovments, PredictHeuristic, OnlySelf, AStarGreedyHeuristic, ArrangmentsChanged);
                    Draw.TableList.Clear();
                    Draw.TableList.Add(CloneATable(Table));
                    Draw.SetRowColumn(0);
                    RefrigtzW.AllDraw.DepthIterative = 0;
                }
                OrderPlate = OrderPlate * -1;
                ChessRules.CurrentOrder = OrderPlate;

                BrownTimer.StopTime();
                GrayTimer.StartTime();
                using (SoundPlayer soundClick = new SoundPlayer(Root + "\\Music\\Click6.wav"))
                {
                    soundClick.Play();
                    soundClick.Dispose();
                }


                Person = true;
                StateCC = StoreStateCC;
                StateCP = StoreStateCP;
                StateGe = StoreStateGe;
                ThinkingRefrigtzW.ThinkingRun = false;
                if (SettingPRFALSE)
                {
                    SettingPRFALSE = false;
                    UpdateConfigurationTable();
                }
            }
            catch (Exception t)
            {
                Log(t);
                //this.//SetBoxText("\r\nError!");
            }
        }
        //The State of Bob with Person Thinking.
        public bool TableZero(int[,] Ta)
        {
            bool NotZerro = false;
            for (int i = 0; i < 8; i++)
                for (int j = 0; j < 8; j++)
                    if (Ta[i, j] != 0)
                        NotZerro = true;
            return NotZerro;
        }
        //Alice Section of Computer by Computer Thinking.
        //Bob Section of Computer By Computer Thinking.
        void SetRefregitzDLL()
        {
            do
            {
                Object o = new Object();
                lock (o)
                {
                    if (AllDraw.ActionStringReady)
                    {
                        SetBoxText(AllDraw.ActionString.ToString());
                        AllDraw.ActionString.Clear();
                        AllDraw.ActionStringReady = false;
                    }
                    if (AllDraw.OutPut.ToString() != "")
                    {
                        SetBoxText(AllDraw.OutPut.ToString());
                        AllDraw.OutPut.Clear();

                    }

                }

            } while (true);
        }
        //Deligation of Control Threading.
        delegate void SetTextBoxTextCallback(String state);

        public void SetBoxText(String state)
        {
            // InvokeRequired required compares the thread ID of the
            // calling thread to the thread ID of the creating thread.
            // If these threads are different, it returns true.
            try
            {
                String A = TimerText.ReturnTime();
                if (OrderPlate == -1)
                    A = TimerText.ReturnTime();

                File.AppendAllText(Root + "\\Database\\Monitor.txt", "\n\t" + state + " At Time " + A);


            }
            catch (Exception t) { Log(t); }
        }
        public void SetDrawFounding(ref bool FOUNDI, ref RefrigtzW.AllDraw THISI, bool FirstI)
        {

            Object OO = new Object();
            lock (OO)
            {
                if (Draw == null)
                    return;

                RefrigtzW.AllDraw.StoreInitMaxAStarGreedy = Draw.CurrentMaxLevel;

                int Dummy = OrderPlate;
                RefrigtzW.AllDraw THISB = Draw.AStarGreedyString;
                RefrigtzW.AllDraw THISStore = Draw;
                //while (Draw.AStarGreedyString != null)
                bool FOUND = false;
                RefrigtzW.AllDraw THIS = null;
                bool First = false;

                Object O = new Object();
                lock (O)
                {
                    FOUND = false;
                    THIS = null;
                    Color a = Color.Brown;
                    //if (First)
                    //else
                    int Ord = OrderPlate;
                    AllDraw.OrderPlate = Ord;
                    var output = Task.Factory.StartNew(() => Draw.FoundOfCurrentTableNode(CloneATable(Table), Ord, ref THIS, ref FOUND));
                    output.Wait();
                    output.Dispose();
                    if (FOUND)
                    {
                        Draw = THIS;

                        bool LoadTree = true;
                        Ord = OrderPlate;
                        //if (MovmentsNumber > 1)
                        (new TakeRoot()).Save(FOUND, false, this, ref LoadTree, false, false, UsePenaltyRegardMechnisam, false, false, false, AStarGreedyHeuristic, true);
                        Draw.IsCurrentDraw = true;

                    }
                    else
                    {
                        bool Store = Deeperthandeeper;
                        Deeperthandeeper = false;

                        Color aa = Color.Gray;
                        if (Ord == -1)
                            aa = Color.Brown;
                        bool B = AllDraw.Blitz;
                        AllDraw.Blitz = false;
                        RefrigtzW.AllDraw.MaxAStarGreedy = PlatformHelper.ProcessorCount * 2;
                        FOUND = false;
                        AllDraw thiB = Draw.AStarGreedyString;
                        if (Draw.IsAtLeastAllObjectIsNull())
                        {
                            Draw.TableList.Clear();
                            Draw.TableList.Add(CloneATable(RefrigtzW.AllDraw.TableListAction[RefrigtzW.AllDraw.TableListAction.Count - 1]));
                            Draw.SetRowColumn(0);
                            Draw.IsCurrentDraw = true;
                        }
                        Draw.AStarGreedyString = thiB;

                        output = Task.Factory.StartNew(() => Draw.InitiateAStarGreedyt(RefrigtzW.AllDraw.MaxAStarGreedy, 0, 0, aa, CloneATable(RefrigtzW.AllDraw.TableListAction[RefrigtzW.AllDraw.TableListAction.Count - 1]), Ord, false, FOUND, 0));
                        output.Wait();
                        output.Dispose();
                        AllDraw.Blitz = B;
                        Deeperthandeeper = Store;
                        //while (Draw.AStarGreedyString != null)
                        FOUND = false;

                        output = Task.Factory.StartNew(() => Draw.FoundOfCurrentTableNode(CloneATable(RefrigtzW.AllDraw.TableListAction[RefrigtzW.AllDraw.TableListAction.Count - 1]), Ord, ref THIS, ref FOUND));
                        output.Wait();
                        output.Dispose();
                        if (FOUND)
                        {
                            Draw = THIS;


                            bool LoadTree = true;
                            (new TakeRoot()).Save(FOUND, false, this, ref LoadTree, false, false, UsePenaltyRegardMechnisam, false, false, false, AStarGreedyHeuristic, true);
                            AllDraw.OrderPlate = Ord;

                        }
                        else
                        {
                            Draw = THISStore;
                            if (MovmentsNumber == 1)
                                NotFoundBegin = true;
                            bool LoadTree = true;

                            Draw.TableList.Clear();
                            Draw.TableList.Add(CloneATable(Table));
                            Draw.SetRowColumn(0);
                            Draw.IsCurrentDraw = true;
                            Draw.AStarGreedyString = THISB;
                            RefrigtzW.ChessRules.CurrentOrder = OrderPlate;
                            RefrigtzW.AllDraw.DepthIterative = 0;
                            (new TakeRoot()).Save(FOUND, false, this, ref LoadTree, false, false, UsePenaltyRegardMechnisam, false, false, false, AStarGreedyHeuristic, true);

                        }
                    }
                }
                if (RefrigtzW.AllDraw.FirstTraversalTree)
                    FOUND = false;
                FOUNDI = FOUND;
                THISI = THIS;
                FirstI = First;
                DrawManagement();
            }
        }
        bool DrawManagement()
        {
            Object OO = new Object();
            lock (OO)
            {
                SetAllDrawKind();
                //Set Configuration To True for some unknown reason!.

                SetAllDrawKindString();
                bool Found = false;
                String P = System.Web.HttpRuntime.AppDomainAppPath + path3 + "\\";
                AllDrawReplacement = P + AllDrawKindString;
                Logger y = new Logger(AllDrawReplacement);

                String PP = System.Web.HttpRuntime.AppDomainAppPath;
                AllDrawKindString = PP + AllDrawKindString;
                y = new Logger(AllDrawKindString);

                if (File.Exists(AllDrawReplacement))
                {
                    if (AllDraw.HarasAct)
                        File.Delete(AllDrawReplacement);
                }
                if (File.Exists(AllDrawKindString))
                {
                    if (AllDraw.HarasAct)
                        File.Delete(AllDrawKindString);

                }
                AllDraw.HarasAct = false;
                if (!NotFoundBegin)
                {
                    if (File.Exists(AllDrawKindString))
                    {
                        if (File.Exists(AllDrawReplacement))
                        {
                            if (((new System.IO.FileInfo(AllDrawKindString).Length) < (new System.IO.FileInfo(AllDrawReplacement)).Length))
                            {
                                File.Delete(AllDrawKindString);
                                File.Copy(AllDrawReplacement, AllDrawKindString);
                                Found = true;
                            }
                            else if (((new System.IO.FileInfo(AllDrawKindString).Length) > (new System.IO.FileInfo(AllDrawReplacement)).Length))
                            {
                                if (File.Exists(AllDrawReplacement))
                                    File.Delete(AllDrawReplacement);
                                File.Copy(AllDrawKindString, AllDrawReplacement);
                                Found = true;
                            }
                        }
                        else
                        {
                            if (!Directory.Exists(Path.GetFullPath(path3)))
                                Directory.CreateDirectory(Path.GetFullPath(path3));
                            File.Copy(AllDrawKindString, AllDrawReplacement);
                            Found = true;
                        }
                        Found = true;
                    }
                    else if (File.Exists(AllDrawReplacement))
                    {
                        File.Copy(AllDrawReplacement, AllDrawKindString);
                        Found = true;
                    }
                }
                else
                {
                    if (File.Exists(AllDrawKindString))
                        File.Delete(AllDrawKindString);
                    if (File.Exists(AllDrawReplacement))
                        File.Delete(AllDrawReplacement);
                    NotFoundBegin = false;
                }
                return Found;
            }
        }
        void SetAllDrawKindString()
        {
            Object O = new Object();
            lock (O)
            {
                if (AllDrawKind == 4)
                    AllDrawKindString = "AllDrawBT.asd";
                else
                if (AllDrawKind == 3)
                    AllDrawKindString = "AllDrawFFST.asd";
                else
                if (AllDrawKind == 2)
                    AllDrawKindString = "AllDrawFTSF.asd";
                else
                if (AllDrawKind == 1)
                    AllDrawKindString = "AllDrawFFSF.asd";
            }
        }
        void SetAllDrawKind()
        {
            Object O = new Object();
            lock (O)
            {
                if (UsePenaltyRegardMechnisam && AStarGreedyHeuristic)
                    AllDrawKind = 4;
                else
          if ((!UsePenaltyRegardMechnisam) && AStarGreedyHeuristic)
                    AllDrawKind = 3;
                if (UsePenaltyRegardMechnisam && (!AStarGreedyHeuristic))
                    AllDrawKind = 2;
                if ((!UsePenaltyRegardMechnisam) && (!AStarGreedyHeuristic))
                    AllDrawKind = 1;
            }
        }
        void SetDrawFound()
        {
            Object O = new Object();
            lock (O)
            {
                FOUND = false;
                RefrigtzW.AllDraw THIS = null;
                SetDrawFounding(ref FOUND, ref THIS, false);
            }
        }
    }


}

//End of Documentation.




